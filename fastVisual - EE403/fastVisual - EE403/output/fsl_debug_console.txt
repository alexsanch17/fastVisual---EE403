; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_debug_console.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_debug_console.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_debug_console.crf SRC\System\utilities\fsl_debug_console.c]
                          THUMB

                          AREA ||i.DbgConsole_ConvertRadixNumToString||, CODE, READONLY, ALIGN=1

                  DbgConsole_ConvertRadixNumToString PROC
;;;533     */
;;;534    static int32_t DbgConsole_ConvertRadixNumToString(char *numstr, void *nump, int32_t neg, int32_t radix, bool use_caps)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;535    {
000004  4607              MOV      r7,r0
000006  468c              MOV      r12,r1
000008  4691              MOV      r9,r2
;;;536    #if PRINTF_ADVANCED_ENABLE
;;;537        int64_t a;
;;;538        int64_t b;
;;;539        int64_t c;
;;;540    
;;;541        uint64_t ua;
;;;542        uint64_t ub;
;;;543        uint64_t uc;
;;;544    #else
;;;545        int32_t a;
;;;546        int32_t b;
;;;547        int32_t c;
;;;548    
;;;549        uint32_t ua;
;;;550        uint32_t ub;
;;;551        uint32_t uc;
;;;552    #endif /* PRINTF_ADVANCED_ENABLE */
;;;553    
;;;554        int32_t nlen;
;;;555        char *nstrp;
;;;556    
;;;557        nlen = 0;
00000a  2000              MOVS     r0,#0
;;;558        nstrp = numstr;
00000c  4639              MOV      r1,r7
;;;559        *nstrp++ = '\0';
00000e  4683              MOV      r11,r0
000010  f801bb01          STRB     r11,[r1],#1
;;;560    
;;;561        if (neg)
000014  f1b90f00          CMP      r9,#0
000018  d01e              BEQ      |L1.88|
;;;562        {
;;;563    #if PRINTF_ADVANCED_ENABLE
;;;564            a = *(int64_t *)nump;
;;;565    #else
;;;566            a = *(int32_t *)nump;
00001a  f8dc4000          LDR      r4,[r12,#0]
;;;567    #endif /* PRINTF_ADVANCED_ENABLE */
;;;568            if (a == 0)
00001e  b934              CBNZ     r4,|L1.46|
;;;569            {
;;;570                *nstrp = '0';
000020  f04f0b30          MOV      r11,#0x30
000024  f881b000          STRB     r11,[r1,#0]
;;;571                ++nlen;
000028  1c40              ADDS     r0,r0,#1
                  |L1.42|
;;;572                return nlen;
;;;573            }
;;;574            while (a != 0)
;;;575            {
;;;576    #if PRINTF_ADVANCED_ENABLE
;;;577                b = (int64_t)a / (int64_t)radix;
;;;578                c = (int64_t)a - ((int64_t)b * (int64_t)radix);
;;;579                if (c < 0)
;;;580                {
;;;581                    uc = (uint64_t)c;
;;;582                    c = (int64_t)(~uc) + 1 + '0';
;;;583                }
;;;584    #else
;;;585                b = a / radix;
;;;586                c = a - (b * radix);
;;;587                if (c < 0)
;;;588                {
;;;589                    uc = (uint32_t)c;
;;;590                    c = (uint32_t)(~uc) + 1 + '0';
;;;591                }
;;;592    #endif /* PRINTF_ADVANCED_ENABLE */
;;;593                else
;;;594                {
;;;595                    c = c + '0';
;;;596                }
;;;597                a = b;
;;;598                *nstrp++ = (char)c;
;;;599                ++nlen;
;;;600            }
;;;601        }
;;;602        else
;;;603        {
;;;604    #if PRINTF_ADVANCED_ENABLE
;;;605            ua = *(uint64_t *)nump;
;;;606    #else
;;;607            ua = *(uint32_t *)nump;
;;;608    #endif /* PRINTF_ADVANCED_ENABLE */
;;;609            if (ua == 0)
;;;610            {
;;;611                *nstrp = '0';
;;;612                ++nlen;
;;;613                return nlen;
;;;614            }
;;;615            while (ua != 0)
;;;616            {
;;;617    #if PRINTF_ADVANCED_ENABLE
;;;618                ub = (uint64_t)ua / (uint64_t)radix;
;;;619                uc = (uint64_t)ua - ((uint64_t)ub * (uint64_t)radix);
;;;620    #else
;;;621                ub = ua / (uint32_t)radix;
;;;622                uc = ua - (ub * (uint32_t)radix);
;;;623    #endif /* PRINTF_ADVANCED_ENABLE */
;;;624    
;;;625                if (uc < 10)
;;;626                {
;;;627                    uc = uc + '0';
;;;628                }
;;;629                else
;;;630                {
;;;631                    uc = uc - 10 + (use_caps ? 'A' : 'a');
;;;632                }
;;;633                ua = ub;
;;;634                *nstrp++ = (char)uc;
;;;635                ++nlen;
;;;636            }
;;;637        }
;;;638        return nlen;
;;;639    }
00002a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.46|
00002e  e010              B        |L1.82|
                  |L1.48|
000030  fb94f8f3          SDIV     r8,r4,r3              ;585
000034  fb084513          MLS      r5,r8,r3,r4           ;586
000038  2d00              CMP      r5,#0                 ;587
00003a  da05              BGE      |L1.72|
00003c  462a              MOV      r2,r5                 ;589
00003e  ea6f0b02          MVN      r11,r2                ;590
000042  f10b0531          ADD      r5,r11,#0x31          ;590
000046  e000              B        |L1.74|
                  |L1.72|
000048  3530              ADDS     r5,r5,#0x30           ;595
                  |L1.74|
00004a  4644              MOV      r4,r8                 ;597
00004c  f8015b01          STRB     r5,[r1],#1            ;598
000050  1c40              ADDS     r0,r0,#1              ;599
                  |L1.82|
000052  2c00              CMP      r4,#0                 ;574
000054  d1ec              BNE      |L1.48|
000056  e025              B        |L1.164|
                  |L1.88|
000058  f8dc6000          LDR      r6,[r12,#0]           ;607
00005c  b92e              CBNZ     r6,|L1.106|
00005e  f04f0b30          MOV      r11,#0x30             ;611
000062  f881b000          STRB     r11,[r1,#0]           ;611
000066  1c40              ADDS     r0,r0,#1              ;612
000068  e7df              B        |L1.42|
                  |L1.106|
00006a  e019              B        |L1.160|
                  |L1.108|
00006c  fbb6faf3          UDIV     r10,r6,r3             ;621
000070  fb0a6213          MLS      r2,r10,r3,r6          ;622
000074  2a0a              CMP      r2,#0xa               ;625
000076  d201              BCS      |L1.124|
000078  3230              ADDS     r2,r2,#0x30           ;627
00007a  e00d              B        |L1.152|
                  |L1.124|
00007c  f1a20b0a          SUB      r11,r2,#0xa           ;631
000080  f8dde024          LDR      lr,[sp,#0x24]         ;631
000084  f1be0f00          CMP      lr,#0                 ;631
000088  d002              BEQ      |L1.144|
00008a  f04f0e41          MOV      lr,#0x41              ;631
00008e  e001              B        |L1.148|
                  |L1.144|
000090  f04f0e61          MOV      lr,#0x61              ;631
                  |L1.148|
000094  eb0b020e          ADD      r2,r11,lr             ;631
                  |L1.152|
000098  4656              MOV      r6,r10                ;633
00009a  f8012b01          STRB     r2,[r1],#1            ;634
00009e  1c40              ADDS     r0,r0,#1              ;635
                  |L1.160|
0000a0  2e00              CMP      r6,#0                 ;615
0000a2  d1e3              BNE      |L1.108|
                  |L1.164|
0000a4  bf00              NOP                            ;638
0000a6  e7c0              B        |L1.42|
;;;640    
                          ENDP


                          AREA ||i.DbgConsole_Deinit||, CODE, READONLY, ALIGN=2

                  DbgConsole_Deinit PROC
;;;328    /* See fsl_debug_console.h for documentation of this function. */
;;;329    status_t DbgConsole_Deinit(void)
000000  b510              PUSH     {r4,lr}
;;;330    {
;;;331        if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000002  480e              LDR      r0,|L2.60|
000004  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
000006  b908              CBNZ     r0,|L2.12|
;;;332        {
;;;333            return kStatus_Success;
000008  2000              MOVS     r0,#0
                  |L2.10|
;;;334        }
;;;335    
;;;336        switch (s_debugConsole.type)
;;;337        {
;;;338    #if defined(FSL_FEATURE_SOC_UART_COUNT) && (FSL_FEATURE_SOC_UART_COUNT > 0)
;;;339            case DEBUG_CONSOLE_DEVICE_TYPE_UART:
;;;340                /* Disable UART module. */
;;;341                UART_Deinit(s_debugConsole.base);
;;;342                break;
;;;343    #endif /* FSL_FEATURE_SOC_UART_COUNT */
;;;344    #if defined(FSL_FEATURE_SOC_LPSCI_COUNT) && (FSL_FEATURE_SOC_LPSCI_COUNT > 0)
;;;345            case DEBUG_CONSOLE_DEVICE_TYPE_LPSCI:
;;;346                /* Disable LPSCI module. */
;;;347                LPSCI_Deinit(s_debugConsole.base);
;;;348                break;
;;;349    #endif /* FSL_FEATURE_SOC_LPSCI_COUNT */
;;;350    #if defined(FSL_FEATURE_SOC_LPUART_COUNT) && (FSL_FEATURE_SOC_LPUART_COUNT > 0)
;;;351            case DEBUG_CONSOLE_DEVICE_TYPE_LPUART:
;;;352                /* Disable LPUART module. */
;;;353                LPUART_Deinit(s_debugConsole.base);
;;;354                break;
;;;355    #endif /* FSL_FEATURE_SOC_LPUART_COUNT */
;;;356    #if defined(FSL_FEATURE_SOC_USB_COUNT) && (FSL_FEATURE_SOC_USB_COUNT > 0) && defined(BOARD_USE_VIRTUALCOM)
;;;357            case DEBUG_CONSOLE_DEVICE_TYPE_USBCDC:
;;;358                /* Disable USBCDC module. */
;;;359                USB_VcomDeinit(s_debugConsole.base);
;;;360                break;
;;;361    #endif /* FSL_FEATURE_SOC_USB_COUNT && BOARD_USE_VIRTUALCOM*/
;;;362    #if defined(FSL_FEATURE_SOC_FLEXCOMM_COUNT) && (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 0)
;;;363            case DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM:
;;;364            {
;;;365                USART_Deinit((USART_Type*)s_debugConsole.base);
;;;366            }
;;;367            break;
;;;368    #endif /* FSL_FEATURE_SOC_FLEXCOMM_COUNT*/
;;;369            default:
;;;370                s_debugConsole.type = DEBUG_CONSOLE_DEVICE_TYPE_NONE;
;;;371                break;
;;;372        }
;;;373    
;;;374        /* Device identified is invalid, return invalid device error code. */
;;;375        if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
;;;376        {
;;;377            return kStatus_InvalidArgument;
;;;378        }
;;;379    
;;;380        s_debugConsole.type = DEBUG_CONSOLE_DEVICE_TYPE_NONE;
;;;381        return kStatus_Success;
;;;382    }
00000a  bd10              POP      {r4,pc}
                  |L2.12|
00000c  480b              LDR      r0,|L2.60|
00000e  7800              LDRB     r0,[r0,#0]            ;336  ; s_debugConsole
000010  2805              CMP      r0,#5                 ;336
000012  d104              BNE      |L2.30|
000014  4909              LDR      r1,|L2.60|
000016  6848              LDR      r0,[r1,#4]            ;365  ; s_debugConsole
000018  f7fffffe          BL       USART_Deinit
00001c  e003              B        |L2.38|
                  |L2.30|
00001e  2000              MOVS     r0,#0                 ;370
000020  4906              LDR      r1,|L2.60|
000022  7008              STRB     r0,[r1,#0]            ;370
000024  bf00              NOP                            ;371
                  |L2.38|
000026  bf00              NOP                            ;367
000028  4804              LDR      r0,|L2.60|
00002a  7800              LDRB     r0,[r0,#0]            ;375  ; s_debugConsole
00002c  b908              CBNZ     r0,|L2.50|
00002e  2004              MOVS     r0,#4                 ;377
000030  e7eb              B        |L2.10|
                  |L2.50|
000032  2000              MOVS     r0,#0                 ;380
000034  4901              LDR      r1,|L2.60|
000036  7008              STRB     r0,[r1,#0]            ;380
000038  bf00              NOP                            ;381
00003a  e7e6              B        |L2.10|
;;;383    
                          ENDP

                  |L2.60|
                          DCD      s_debugConsole

                          AREA ||i.DbgConsole_Getchar||, CODE, READONLY, ALIGN=2

                  DbgConsole_Getchar PROC
;;;466    /* See fsl_debug_console.h for documentation of this function. */
;;;467    int DbgConsole_Getchar(void)
000000  b508              PUSH     {r3,lr}
;;;468    {
;;;469        char ch;
;;;470        /* Do nothing if the debug UART is not initialized. */
;;;471        if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000002  4807              LDR      r0,|L3.32|
000004  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
000006  b910              CBNZ     r0,|L3.14|
;;;472        {
;;;473            return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L3.12|
;;;474        }
;;;475        s_debugConsole.ops.rx_union.GetChar(s_debugConsole.base, (uint8_t *)(&ch), 1);
;;;476    
;;;477        return ch;
;;;478    }
00000c  bd08              POP      {r3,pc}
                  |L3.14|
00000e  4904              LDR      r1,|L3.32|
000010  6848              LDR      r0,[r1,#4]            ;475  ; s_debugConsole
000012  2201              MOVS     r2,#1                 ;475
000014  68cb              LDR      r3,[r1,#0xc]          ;475
000016  4669              MOV      r1,sp                 ;475
000018  4798              BLX      r3                    ;475
00001a  f89d0000          LDRB     r0,[sp,#0]            ;477
00001e  e7f5              B        |L3.12|
;;;479    
                          ENDP

                  |L3.32|
                          DCD      s_debugConsole

                          AREA ||i.DbgConsole_Init||, CODE, READONLY, ALIGN=2

                  DbgConsole_Init PROC
;;;228    /* See fsl_debug_console.h for documentation of this function. */
;;;229    status_t DbgConsole_Init(uint32_t baseAddr, uint32_t baudRate, uint8_t device, uint32_t clkSrcFreq)
000000  b5fe              PUSH     {r1-r7,lr}
;;;230    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
000008  461f              MOV      r7,r3
;;;231        if (s_debugConsole.type != DEBUG_CONSOLE_DEVICE_TYPE_NONE)
00000a  4810              LDR      r0,|L4.76|
00000c  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
00000e  b108              CBZ      r0,|L4.20|
;;;232        {
;;;233            return kStatus_Fail;
000010  2001              MOVS     r0,#1
                  |L4.18|
;;;234        }
;;;235    
;;;236        /* Set debug console to initialized to avoid duplicated initialized operation. */
;;;237        s_debugConsole.type = device;
;;;238    
;;;239        /* Switch between different device. */
;;;240        switch (device)
;;;241        {
;;;242    #if defined(FSL_FEATURE_SOC_UART_COUNT) && (FSL_FEATURE_SOC_UART_COUNT > 0)
;;;243            case DEBUG_CONSOLE_DEVICE_TYPE_UART:
;;;244            {
;;;245                uart_config_t uart_config;
;;;246                s_debugConsole.base = (UART_Type *)baseAddr;
;;;247                UART_GetDefaultConfig(&uart_config);
;;;248                uart_config.baudRate_Bps = baudRate;
;;;249                /* Enable clock and initial UART module follow user configure structure. */
;;;250                UART_Init(s_debugConsole.base, &uart_config, clkSrcFreq);
;;;251                UART_EnableTx(s_debugConsole.base, true);
;;;252                UART_EnableRx(s_debugConsole.base, true);
;;;253                /* Set the function pointer for send and receive for this kind of device. */
;;;254                s_debugConsole.ops.tx_union.UART_PutChar = UART_WriteBlocking;
;;;255                s_debugConsole.ops.rx_union.UART_GetChar = UART_ReadBlocking;
;;;256            }
;;;257            break;
;;;258    #endif /* FSL_FEATURE_SOC_UART_COUNT */
;;;259    #if defined(FSL_FEATURE_SOC_LPSCI_COUNT) && (FSL_FEATURE_SOC_LPSCI_COUNT > 0)
;;;260            case DEBUG_CONSOLE_DEVICE_TYPE_LPSCI:
;;;261            {
;;;262                lpsci_config_t lpsci_config;
;;;263                s_debugConsole.base = (UART0_Type *)baseAddr;
;;;264                LPSCI_GetDefaultConfig(&lpsci_config);
;;;265                lpsci_config.baudRate_Bps = baudRate;
;;;266                /* Enable clock and initial UART module follow user configure structure. */
;;;267                LPSCI_Init(s_debugConsole.base, &lpsci_config, clkSrcFreq);
;;;268                LPSCI_EnableTx(s_debugConsole.base, true);
;;;269                LPSCI_EnableRx(s_debugConsole.base, true);
;;;270                /* Set the function pointer for send and receive for this kind of device. */
;;;271                s_debugConsole.ops.tx_union.LPSCI_PutChar = LPSCI_WriteBlocking;
;;;272                s_debugConsole.ops.rx_union.LPSCI_GetChar = LPSCI_ReadBlocking;
;;;273            }
;;;274            break;
;;;275    #endif /* FSL_FEATURE_SOC_LPSCI_COUNT */
;;;276    #if defined(FSL_FEATURE_SOC_LPUART_COUNT) && (FSL_FEATURE_SOC_LPUART_COUNT > 0)
;;;277            case DEBUG_CONSOLE_DEVICE_TYPE_LPUART:
;;;278            {
;;;279                lpuart_config_t lpuart_config;
;;;280                s_debugConsole.base = (LPUART_Type *)baseAddr;
;;;281                LPUART_GetDefaultConfig(&lpuart_config);
;;;282                lpuart_config.baudRate_Bps = baudRate;
;;;283                /* Enable clock and initial UART module follow user configure structure. */
;;;284                LPUART_Init(s_debugConsole.base, &lpuart_config, clkSrcFreq);
;;;285                LPUART_EnableTx(s_debugConsole.base, true);
;;;286                LPUART_EnableRx(s_debugConsole.base, true);
;;;287                /* Set the function pointer for send and receive for this kind of device. */
;;;288                s_debugConsole.ops.tx_union.LPUART_PutChar = LPUART_WriteBlocking;
;;;289                s_debugConsole.ops.rx_union.LPUART_GetChar = LPUART_ReadBlocking;
;;;290            }
;;;291            break;
;;;292    #endif /* FSL_FEATURE_SOC_LPUART_COUNT */
;;;293    #if defined(FSL_FEATURE_SOC_USB_COUNT) && (FSL_FEATURE_SOC_USB_COUNT > 0) && defined(BOARD_USE_VIRTUALCOM)
;;;294            case DEBUG_CONSOLE_DEVICE_TYPE_USBCDC:
;;;295            {
;;;296                s_debugConsole.base = USB_VcomInit();
;;;297                s_debugConsole.ops.tx_union.USB_PutChar = USB_VcomWriteBlocking;
;;;298                s_debugConsole.ops.rx_union.USB_GetChar = USB_VcomReadBlocking;
;;;299            }
;;;300            break;
;;;301    #endif /* FSL_FEATURE_SOC_USB_COUNT && BOARD_USE_VIRTUALCOM*/
;;;302    #if defined(FSL_FEATURE_SOC_FLEXCOMM_COUNT) && (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 0)
;;;303            case DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM:
;;;304            {
;;;305                usart_config_t usart_config;
;;;306                s_debugConsole.base = (USART_Type *)baseAddr;
;;;307                USART_GetDefaultConfig(&usart_config);
;;;308                usart_config.baudRate_Bps = baudRate;
;;;309                /* Enable clock and initial UART module follow user configure structure. */
;;;310                USART_Init(s_debugConsole.base, &usart_config, clkSrcFreq);
;;;311                /* Set the function pointer for send and receive for this kind of device. */
;;;312                s_debugConsole.ops.tx_union.USART_PutChar = USART_WriteBlocking;
;;;313                s_debugConsole.ops.rx_union.USART_GetChar = USART_ReadBlocking;
;;;314            }
;;;315            break;
;;;316    #endif  /* FSL_FEATURE_SOC_FLEXCOMM_COUNT*/
;;;317            /* If new device is required as the low level device for debug console,
;;;318             * Add the case branch and add the preprocessor macro to judge whether
;;;319             * this kind of device exist in this SOC. */
;;;320            default:
;;;321                /* Device identified is invalid, return invalid device error code. */
;;;322                return kStatus_InvalidArgument;
;;;323        }
;;;324    
;;;325        return kStatus_Success;
;;;326    }
000012  bdfe              POP      {r1-r7,pc}
                  |L4.20|
000014  480d              LDR      r0,|L4.76|
000016  7004              STRB     r4,[r0,#0]            ;237
000018  2c05              CMP      r4,#5                 ;240
00001a  d111              BNE      |L4.64|
00001c  6045              STR      r5,[r0,#4]            ;306  ; s_debugConsole
00001e  4668              MOV      r0,sp                 ;307
000020  f7fffffe          BL       USART_GetDefaultConfig
000024  9600              STR      r6,[sp,#0]            ;308
000026  4909              LDR      r1,|L4.76|
000028  463a              MOV      r2,r7                 ;310
00002a  6848              LDR      r0,[r1,#4]            ;310  ; s_debugConsole
00002c  4669              MOV      r1,sp                 ;310
00002e  f7fffffe          BL       USART_Init
000032  4807              LDR      r0,|L4.80|
000034  4905              LDR      r1,|L4.76|
000036  6088              STR      r0,[r1,#8]            ;312  ; s_debugConsole
000038  4906              LDR      r1,|L4.84|
00003a  4804              LDR      r0,|L4.76|
00003c  60c1              STR      r1,[r0,#0xc]          ;313
00003e  e001              B        |L4.68|
                  |L4.64|
000040  2004              MOVS     r0,#4                 ;322
000042  e7e6              B        |L4.18|
                  |L4.68|
000044  bf00              NOP                            ;315
000046  2000              MOVS     r0,#0                 ;325
000048  e7e3              B        |L4.18|
;;;327    
                          ENDP

00004a  0000              DCW      0x0000
                  |L4.76|
                          DCD      s_debugConsole
                  |L4.80|
                          DCD      USART_WriteBlocking
                  |L4.84|
                          DCD      USART_ReadBlocking

                          AREA ||i.DbgConsole_Printf||, CODE, READONLY, ALIGN=2

                  DbgConsole_Printf PROC
;;;385    /* See fsl_debug_console.h for documentation of this function. */
;;;386    int DbgConsole_Printf(const char *fmt_s, ...)
000000  b40f              PUSH     {r0-r3}
;;;387    {
000002  b538              PUSH     {r3-r5,lr}
;;;388        va_list ap;
;;;389        int result;
;;;390    
;;;391        /* Do nothing if the debug UART is not initialized. */
;;;392        if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000004  4809              LDR      r0,|L5.44|
000006  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
000008  b920              CBNZ     r0,|L5.20|
;;;393        {
;;;394            return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L5.14|
;;;395        }
;;;396        va_start(ap, fmt_s);
;;;397        result = DbgConsole_PrintfFormattedData(DbgConsole_Putchar, fmt_s, ap);
;;;398        va_end(ap);
;;;399    
;;;400        return result;
;;;401    }
00000e  bc38              POP      {r3-r5}
000010  f85dfb14          LDR      pc,[sp],#0x14
                  |L5.20|
000014  a805              ADD      r0,sp,#0x14           ;396
000016  9000              STR      r0,[sp,#0]            ;396
000018  4805              LDR      r0,|L5.48|
00001a  9a00              LDR      r2,[sp,#0]            ;397
00001c  9904              LDR      r1,[sp,#0x10]         ;397
00001e  f7fffffe          BL       DbgConsole_PrintfFormattedData
000022  4604              MOV      r4,r0                 ;397
000024  2000              MOVS     r0,#0                 ;398
000026  9000              STR      r0,[sp,#0]            ;398
000028  4620              MOV      r0,r4                 ;400
00002a  e7f0              B        |L5.14|
;;;402    
                          ENDP

                  |L5.44|
                          DCD      s_debugConsole
                  |L5.48|
                          DCD      DbgConsole_Putchar

                          AREA ||i.DbgConsole_PrintfFormattedData||, CODE, READONLY, ALIGN=1

                  DbgConsole_PrintfFormattedData PROC
;;;764     */
;;;765    static int DbgConsole_PrintfFormattedData(PUTCHAR_FUNC func_ptr, const char *fmt, va_list ap)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;766    {
000004  b092              SUB      sp,sp,#0x48
000006  4606              MOV      r6,r0
000008  468b              MOV      r11,r1
;;;767        /* va_list ap; */
;;;768        char *p;
;;;769        int32_t c;
;;;770    
;;;771        char vstr[33];
;;;772        char *vstrp = NULL;
00000a  f04f0800          MOV      r8,#0
;;;773        int32_t vlen = 0;
00000e  46c1              MOV      r9,r8
;;;774    
;;;775        int32_t done;
;;;776        int32_t count = 0;
000010  2000              MOVS     r0,#0
000012  9007              STR      r0,[sp,#0x1c]
;;;777    
;;;778        uint32_t field_width;
;;;779        uint32_t precision_width;
;;;780        char *sval;
;;;781        int32_t cval;
;;;782        bool use_caps;
;;;783        uint8_t radix = 0;
000014  9003              STR      r0,[sp,#0xc]
;;;784    
;;;785    #if PRINTF_ADVANCED_ENABLE
;;;786        uint32_t flags_used;
;;;787        int32_t schar, dschar;
;;;788        int64_t ival;
;;;789        uint64_t uval = 0;
;;;790    #else
;;;791        int32_t ival;
;;;792        uint32_t uval = 0;
000016  9001              STR      r0,[sp,#4]
;;;793    #endif /* PRINTF_ADVANCED_ENABLE */
;;;794    
;;;795    #if PRINTF_FLOAT_ENABLE
;;;796        double fval;
;;;797    #endif /* PRINTF_FLOAT_ENABLE */
;;;798    
;;;799        /* Start parsing apart the format string and display appropriate formats and data. */
;;;800        for (p = (char *)fmt; (c = *p) != 0; p++)
000018  465d              MOV      r5,r11
00001a  e106              B        |L6.554|
                  |L6.28|
;;;801        {
;;;802            /*
;;;803             * All formats begin with a '%' marker.  Special chars like
;;;804             * '\n' or '\t' are normally converted to the appropriate
;;;805             * character by the __compiler__.  Thus, no need for this
;;;806             * routine to account for the '\' character.
;;;807             */
;;;808            if (c != '%')
00001c  2c25              CMP      r4,#0x25
00001e  d005              BEQ      |L6.44|
;;;809            {
;;;810                func_ptr(c);
000020  4620              MOV      r0,r4
000022  47b0              BLX      r6
;;;811                count++;
000024  9807              LDR      r0,[sp,#0x1c]
000026  1c40              ADDS     r0,r0,#1
000028  9007              STR      r0,[sp,#0x1c]
;;;812                /* By using 'continue', the next iteration of the loop is used, skipping the code that follows. */
;;;813                continue;
00002a  e0fd              B        |L6.552|
                  |L6.44|
;;;814            }
;;;815    
;;;816            use_caps = true;
00002c  f04f0a01          MOV      r10,#1
;;;817    
;;;818    #if PRINTF_ADVANCED_ENABLE
;;;819            /* First check for specification modifier flags. */
;;;820            flags_used = 0;
;;;821            done = false;
;;;822            while (!done)
;;;823            {
;;;824                switch (*++p)
;;;825                {
;;;826                    case '-':
;;;827                        flags_used |= kPRINTF_Minus;
;;;828                        break;
;;;829                    case '+':
;;;830                        flags_used |= kPRINTF_Plus;
;;;831                        break;
;;;832                    case ' ':
;;;833                        flags_used |= kPRINTF_Space;
;;;834                        break;
;;;835                    case '0':
;;;836                        flags_used |= kPRINTF_Zero;
;;;837                        break;
;;;838                    case '#':
;;;839                        flags_used |= kPRINTF_Pound;
;;;840                        break;
;;;841                    default:
;;;842                        /* We've gone one char too far. */
;;;843                        --p;
;;;844                        done = true;
;;;845                        break;
;;;846                }
;;;847            }
;;;848    #endif /* PRINTF_ADVANCED_ENABLE */
;;;849    
;;;850            /* Next check for minimum field width. */
;;;851            field_width = 0;
000030  2000              MOVS     r0,#0
000032  9006              STR      r0,[sp,#0x18]
;;;852            done = false;
000034  9008              STR      r0,[sp,#0x20]
;;;853            while (!done)
000036  e012              B        |L6.94|
                  |L6.56|
;;;854            {
;;;855                c = *++p;
000038  1c68              ADDS     r0,r5,#1
00003a  4605              MOV      r5,r0
00003c  7804              LDRB     r4,[r0,#0]
;;;856                if ((c >= '0') && (c <= '9'))
00003e  2c30              CMP      r4,#0x30
000040  db0a              BLT      |L6.88|
000042  2c39              CMP      r4,#0x39
000044  dc08              BGT      |L6.88|
;;;857                {
;;;858                    field_width = (field_width * 10) + (c - '0');
000046  f1a40030          SUB      r0,r4,#0x30
00004a  9906              LDR      r1,[sp,#0x18]
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  eb000041          ADD      r0,r0,r1,LSL #1
000054  9006              STR      r0,[sp,#0x18]
000056  e002              B        |L6.94|
                  |L6.88|
;;;859                }
;;;860                else
;;;861                {
;;;862                    /* We've gone one char too far. */
;;;863                    --p;
000058  1e6d              SUBS     r5,r5,#1
;;;864                    done = true;
00005a  2001              MOVS     r0,#1
00005c  9008              STR      r0,[sp,#0x20]
                  |L6.94|
00005e  9808              LDR      r0,[sp,#0x20]         ;853
000060  2800              CMP      r0,#0                 ;853
000062  d0e9              BEQ      |L6.56|
;;;865                }
;;;866            }
;;;867            /* Next check for the width and precision field separator. */
;;;868            precision_width = 6;
000064  2006              MOVS     r0,#6
000066  9005              STR      r0,[sp,#0x14]
;;;869            if (*++p == '.')
000068  1c68              ADDS     r0,r5,#1
00006a  4605              MOV      r5,r0
00006c  7800              LDRB     r0,[r0,#0]
00006e  282e              CMP      r0,#0x2e
000070  d11a              BNE      |L6.168|
;;;870            {
;;;871                /* Must get precision field width, if present. */
;;;872                precision_width = 0;
000072  2000              MOVS     r0,#0
000074  9005              STR      r0,[sp,#0x14]
;;;873                done = false;
000076  9008              STR      r0,[sp,#0x20]
;;;874                while (!done)
000078  e012              B        |L6.160|
                  |L6.122|
;;;875                {
;;;876                    c = *++p;
00007a  1c68              ADDS     r0,r5,#1
00007c  4605              MOV      r5,r0
00007e  7804              LDRB     r4,[r0,#0]
;;;877                    if ((c >= '0') && (c <= '9'))
000080  2c30              CMP      r4,#0x30
000082  db0a              BLT      |L6.154|
000084  2c39              CMP      r4,#0x39
000086  dc08              BGT      |L6.154|
;;;878                    {
;;;879                        precision_width = (precision_width * 10) + (c - '0');
000088  f1a40030          SUB      r0,r4,#0x30
00008c  9905              LDR      r1,[sp,#0x14]
00008e  eb010181          ADD      r1,r1,r1,LSL #2
000092  eb000041          ADD      r0,r0,r1,LSL #1
000096  9005              STR      r0,[sp,#0x14]
000098  e002              B        |L6.160|
                  |L6.154|
;;;880                    }
;;;881                    else
;;;882                    {
;;;883                        /* We've gone one char too far. */
;;;884                        --p;
00009a  1e6d              SUBS     r5,r5,#1
;;;885                        done = true;
00009c  2001              MOVS     r0,#1
00009e  9008              STR      r0,[sp,#0x20]
                  |L6.160|
0000a0  9808              LDR      r0,[sp,#0x20]         ;874
0000a2  2800              CMP      r0,#0                 ;874
0000a4  d0e9              BEQ      |L6.122|
0000a6  e000              B        |L6.170|
                  |L6.168|
;;;886                    }
;;;887                }
;;;888            }
;;;889            else
;;;890            {
;;;891                /* We've gone one char too far. */
;;;892                --p;
0000a8  1e6d              SUBS     r5,r5,#1
                  |L6.170|
;;;893            }
;;;894    #if PRINTF_ADVANCED_ENABLE
;;;895            /*
;;;896             * Check for the length modifier.
;;;897             */
;;;898            switch (/* c = */ *++p)
;;;899            {
;;;900                case 'h':
;;;901                    if (*++p != 'h')
;;;902                    {
;;;903                        flags_used |= kPRINTF_LengthShortInt;
;;;904                        --p;
;;;905                    }
;;;906                    else
;;;907                    {
;;;908                        flags_used |= kPRINTF_LengthChar;
;;;909                    }
;;;910                    break;
;;;911                case 'l':
;;;912                    if (*++p != 'l')
;;;913                    {
;;;914                        flags_used |= kPRINTF_LengthLongInt;
;;;915                        --p;
;;;916                    }
;;;917                    else
;;;918                    {
;;;919                        flags_used |= kPRINTF_LengthLongLongInt;
;;;920                    }
;;;921                    break;
;;;922                default:
;;;923                    /* we've gone one char too far */
;;;924                    --p;
;;;925                    break;
;;;926            }
;;;927    #endif /* PRINTF_ADVANCED_ENABLE */
;;;928            /* Now we're ready to examine the format. */
;;;929            c = *++p;
0000aa  1c68              ADDS     r0,r5,#1
0000ac  4605              MOV      r5,r0
0000ae  7804              LDRB     r4,[r0,#0]
;;;930            {
;;;931                if ((c == 'd') || (c == 'i') || (c == 'f') || (c == 'F') || (c == 'x') || (c == 'X') || (c == 'o') ||
0000b0  2c64              CMP      r4,#0x64
0000b2  d011              BEQ      |L6.216|
0000b4  2c69              CMP      r4,#0x69
0000b6  d00f              BEQ      |L6.216|
0000b8  2c66              CMP      r4,#0x66
0000ba  d00d              BEQ      |L6.216|
0000bc  2c46              CMP      r4,#0x46
0000be  d00b              BEQ      |L6.216|
0000c0  2c78              CMP      r4,#0x78
0000c2  d009              BEQ      |L6.216|
0000c4  2c58              CMP      r4,#0x58
0000c6  d007              BEQ      |L6.216|
0000c8  2c6f              CMP      r4,#0x6f
0000ca  d005              BEQ      |L6.216|
;;;932                    (c == 'b') || (c == 'p') || (c == 'u'))
0000cc  2c62              CMP      r4,#0x62
0000ce  d003              BEQ      |L6.216|
0000d0  2c70              CMP      r4,#0x70
0000d2  d001              BEQ      |L6.216|
0000d4  2c75              CMP      r4,#0x75
0000d6  d177              BNE      |L6.456|
                  |L6.216|
;;;933                {
;;;934                    if ((c == 'd') || (c == 'i'))
0000d8  2c64              CMP      r4,#0x64
0000da  d001              BEQ      |L6.224|
0000dc  2c69              CMP      r4,#0x69
0000de  d111              BNE      |L6.260|
                  |L6.224|
;;;935                    {
;;;936    #if PRINTF_ADVANCED_ENABLE
;;;937                        if (flags_used & kPRINTF_LengthLongLongInt)
;;;938                        {
;;;939                            ival = (int64_t)va_arg(ap, int64_t);
;;;940                        }
;;;941                        else
;;;942    #endif /* PRINTF_ADVANCED_ENABLE */
;;;943                        {
;;;944                            ival = (int32_t)va_arg(ap, int32_t);
0000e0  9814              LDR      r0,[sp,#0x50]
0000e2  6800              LDR      r0,[r0,#0]
0000e4  9002              STR      r0,[sp,#8]
0000e6  9814              LDR      r0,[sp,#0x50]
0000e8  1d00              ADDS     r0,r0,#4
0000ea  9014              STR      r0,[sp,#0x50]
;;;945                        }
;;;946                        vlen = DbgConsole_ConvertRadixNumToString(vstr, &ival, true, 10, use_caps);
0000ec  230a              MOVS     r3,#0xa
0000ee  2201              MOVS     r2,#1
0000f0  a902              ADD      r1,sp,#8
0000f2  a809              ADD      r0,sp,#0x24
0000f4  f8cda000          STR      r10,[sp,#0]
0000f8  f7fffffe          BL       DbgConsole_ConvertRadixNumToString
0000fc  4681              MOV      r9,r0
;;;947                        vstrp = &vstr[vlen];
0000fe  a809              ADD      r0,sp,#0x24
000100  eb000809          ADD      r8,r0,r9
                  |L6.260|
;;;948    #if PRINTF_ADVANCED_ENABLE
;;;949                        if (ival < 0)
;;;950                        {
;;;951                            schar = '-';
;;;952                            ++vlen;
;;;953                        }
;;;954                        else
;;;955                        {
;;;956                            if (flags_used & kPRINTF_Plus)
;;;957                            {
;;;958                                schar = '+';
;;;959                                ++vlen;
;;;960                            }
;;;961                            else
;;;962                            {
;;;963                                if (flags_used & kPRINTF_Space)
;;;964                                {
;;;965                                    schar = ' ';
;;;966                                    ++vlen;
;;;967                                }
;;;968                                else
;;;969                                {
;;;970                                    schar = 0;
;;;971                                }
;;;972                            }
;;;973                        }
;;;974                        dschar = false;
;;;975                        /* Do the ZERO pad. */
;;;976                        if (flags_used & kPRINTF_Zero)
;;;977                        {
;;;978                            if (schar)
;;;979                            {
;;;980                                func_ptr(schar);
;;;981                                count++;
;;;982                            }
;;;983                            dschar = true;
;;;984    
;;;985                            DbgConsole_PrintfPaddingCharacter('0', vlen, field_width, &count, func_ptr);
;;;986                            vlen = field_width;
;;;987                        }
;;;988                        else
;;;989                        {
;;;990                            if (!(flags_used & kPRINTF_Minus))
;;;991                            {
;;;992                                DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
;;;993                                if (schar)
;;;994                                {
;;;995                                    func_ptr(schar);
;;;996                                    count++;
;;;997                                }
;;;998                                dschar = true;
;;;999                            }
;;;1000                       }
;;;1001                       /* The string was built in reverse order, now display in correct order. */
;;;1002                       if ((!dschar) && schar)
;;;1003                       {
;;;1004                           func_ptr(schar);
;;;1005                           count++;
;;;1006                       }
;;;1007   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1008                   }
;;;1009   
;;;1010   #if PRINTF_FLOAT_ENABLE
;;;1011                   if ((c == 'f') || (c == 'F'))
;;;1012                   {
;;;1013                       fval = (double)va_arg(ap, double);
;;;1014                       vlen = DbgConsole_ConvertFloatRadixNumToString(vstr, &fval, 10, precision_width);
;;;1015                       vstrp = &vstr[vlen];
;;;1016   
;;;1017   #if PRINTF_ADVANCED_ENABLE
;;;1018                       if (fval < 0)
;;;1019                       {
;;;1020                           schar = '-';
;;;1021                           ++vlen;
;;;1022                       }
;;;1023                       else
;;;1024                       {
;;;1025                           if (flags_used & kPRINTF_Plus)
;;;1026                           {
;;;1027                               schar = '+';
;;;1028                               ++vlen;
;;;1029                           }
;;;1030                           else
;;;1031                           {
;;;1032                               if (flags_used & kPRINTF_Space)
;;;1033                               {
;;;1034                                   schar = ' ';
;;;1035                                   ++vlen;
;;;1036                               }
;;;1037                               else
;;;1038                               {
;;;1039                                   schar = 0;
;;;1040                               }
;;;1041                           }
;;;1042                       }
;;;1043                       dschar = false;
;;;1044                       if (flags_used & kPRINTF_Zero)
;;;1045                       {
;;;1046                           if (schar)
;;;1047                           {
;;;1048                               func_ptr(schar);
;;;1049                               count++;
;;;1050                           }
;;;1051                           dschar = true;
;;;1052                           DbgConsole_PrintfPaddingCharacter('0', vlen, field_width, &count, func_ptr);
;;;1053                           vlen = field_width;
;;;1054                       }
;;;1055                       else
;;;1056                       {
;;;1057                           if (!(flags_used & kPRINTF_Minus))
;;;1058                           {
;;;1059                               DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
;;;1060                               if (schar)
;;;1061                               {
;;;1062                                   func_ptr(schar);
;;;1063                                   count++;
;;;1064                               }
;;;1065                               dschar = true;
;;;1066                           }
;;;1067                       }
;;;1068                       if ((!dschar) && schar)
;;;1069                       {
;;;1070                           func_ptr(schar);
;;;1071                           count++;
;;;1072                       }
;;;1073   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1074                   }
;;;1075   #endif /* PRINTF_FLOAT_ENABLE */
;;;1076                   if ((c == 'X') || (c == 'x'))
000104  2c58              CMP      r4,#0x58
000106  d001              BEQ      |L6.268|
000108  2c78              CMP      r4,#0x78
00010a  d115              BNE      |L6.312|
                  |L6.268|
;;;1077                   {
;;;1078                       if (c == 'x')
00010c  2c78              CMP      r4,#0x78
00010e  d101              BNE      |L6.276|
;;;1079                       {
;;;1080                           use_caps = false;
000110  f04f0a00          MOV      r10,#0
                  |L6.276|
;;;1081                       }
;;;1082   #if PRINTF_ADVANCED_ENABLE
;;;1083                       if (flags_used & kPRINTF_LengthLongLongInt)
;;;1084                       {
;;;1085                           uval = (uint64_t)va_arg(ap, uint64_t);
;;;1086                       }
;;;1087                       else
;;;1088   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1089                       {
;;;1090                           uval = (uint32_t)va_arg(ap, uint32_t);
000114  9814              LDR      r0,[sp,#0x50]
000116  6800              LDR      r0,[r0,#0]
000118  9001              STR      r0,[sp,#4]
00011a  9814              LDR      r0,[sp,#0x50]
00011c  1d00              ADDS     r0,r0,#4
00011e  9014              STR      r0,[sp,#0x50]
;;;1091                       }
;;;1092                       vlen = DbgConsole_ConvertRadixNumToString(vstr, &uval, false, 16, use_caps);
000120  2310              MOVS     r3,#0x10
000122  2200              MOVS     r2,#0
000124  a901              ADD      r1,sp,#4
000126  a809              ADD      r0,sp,#0x24
000128  f8cda000          STR      r10,[sp,#0]
00012c  f7fffffe          BL       DbgConsole_ConvertRadixNumToString
000130  4681              MOV      r9,r0
;;;1093                       vstrp = &vstr[vlen];
000132  a809              ADD      r0,sp,#0x24
000134  eb000809          ADD      r8,r0,r9
                  |L6.312|
;;;1094   
;;;1095   #if PRINTF_ADVANCED_ENABLE
;;;1096                       dschar = false;
;;;1097                       if (flags_used & kPRINTF_Zero)
;;;1098                       {
;;;1099                           if (flags_used & kPRINTF_Pound)
;;;1100                           {
;;;1101                               func_ptr('0');
;;;1102                               func_ptr((use_caps ? 'X' : 'x'));
;;;1103                               count += 2;
;;;1104                               /*vlen += 2;*/
;;;1105                               dschar = true;
;;;1106                           }
;;;1107                           DbgConsole_PrintfPaddingCharacter('0', vlen, field_width, &count, func_ptr);
;;;1108                           vlen = field_width;
;;;1109                       }
;;;1110                       else
;;;1111                       {
;;;1112                           if (!(flags_used & kPRINTF_Minus))
;;;1113                           {
;;;1114                               if (flags_used & kPRINTF_Pound)
;;;1115                               {
;;;1116                                   vlen += 2;
;;;1117                               }
;;;1118                               DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
;;;1119                               if (flags_used & kPRINTF_Pound)
;;;1120                               {
;;;1121                                   func_ptr('0');
;;;1122                                   func_ptr(use_caps ? 'X' : 'x');
;;;1123                                   count += 2;
;;;1124   
;;;1125                                   dschar = true;
;;;1126                               }
;;;1127                           }
;;;1128                       }
;;;1129   
;;;1130                       if ((flags_used & kPRINTF_Pound) && (!dschar))
;;;1131                       {
;;;1132                           func_ptr('0');
;;;1133                           func_ptr(use_caps ? 'X' : 'x');
;;;1134                           count += 2;
;;;1135                           vlen += 2;
;;;1136                       }
;;;1137   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1138                   }
;;;1139                   if ((c == 'o') || (c == 'b') || (c == 'p') || (c == 'u'))
000138  2c6f              CMP      r4,#0x6f
00013a  d005              BEQ      |L6.328|
00013c  2c62              CMP      r4,#0x62
00013e  d003              BEQ      |L6.328|
000140  2c70              CMP      r4,#0x70
000142  d001              BEQ      |L6.328|
000144  2c75              CMP      r4,#0x75
000146  d128              BNE      |L6.410|
                  |L6.328|
;;;1140                   {
;;;1141   #if PRINTF_ADVANCED_ENABLE
;;;1142                       if (flags_used & kPRINTF_LengthLongLongInt)
;;;1143                       {
;;;1144                           uval = (uint64_t)va_arg(ap, uint64_t);
;;;1145                       }
;;;1146                       else
;;;1147   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1148                       {
;;;1149                           uval = (uint32_t)va_arg(ap, uint32_t);
000148  9814              LDR      r0,[sp,#0x50]
00014a  6800              LDR      r0,[r0,#0]
00014c  9001              STR      r0,[sp,#4]
00014e  9814              LDR      r0,[sp,#0x50]
000150  1d00              ADDS     r0,r0,#4
000152  9014              STR      r0,[sp,#0x50]
;;;1150                       }
;;;1151                       switch (c)
000154  2c62              CMP      r4,#0x62
000156  d009              BEQ      |L6.364|
000158  2c6f              CMP      r4,#0x6f
00015a  d004              BEQ      |L6.358|
00015c  2c70              CMP      r4,#0x70
00015e  d008              BEQ      |L6.370|
000160  2c75              CMP      r4,#0x75
000162  d10c              BNE      |L6.382|
000164  e008              B        |L6.376|
                  |L6.358|
;;;1152                       {
;;;1153                           case 'o':
;;;1154                               radix = 8;
000166  2008              MOVS     r0,#8
000168  9003              STR      r0,[sp,#0xc]
;;;1155                               break;
00016a  e009              B        |L6.384|
                  |L6.364|
;;;1156                           case 'b':
;;;1157                               radix = 2;
00016c  2002              MOVS     r0,#2
00016e  9003              STR      r0,[sp,#0xc]
;;;1158                               break;
000170  e006              B        |L6.384|
                  |L6.370|
;;;1159                           case 'p':
;;;1160                               radix = 16;
000172  2010              MOVS     r0,#0x10
000174  9003              STR      r0,[sp,#0xc]
;;;1161                               break;
000176  e003              B        |L6.384|
                  |L6.376|
;;;1162                           case 'u':
;;;1163                               radix = 10;
000178  200a              MOVS     r0,#0xa
00017a  9003              STR      r0,[sp,#0xc]
;;;1164                               break;
00017c  e000              B        |L6.384|
                  |L6.382|
;;;1165                           default:
;;;1166                               break;
00017e  bf00              NOP      
                  |L6.384|
000180  bf00              NOP                            ;1155
;;;1167                       }
;;;1168                       vlen = DbgConsole_ConvertRadixNumToString(vstr, &uval, false, radix, use_caps);
000182  f8cda000          STR      r10,[sp,#0]
000186  2200              MOVS     r2,#0
000188  a901              ADD      r1,sp,#4
00018a  a809              ADD      r0,sp,#0x24
00018c  9b03              LDR      r3,[sp,#0xc]
00018e  f7fffffe          BL       DbgConsole_ConvertRadixNumToString
000192  4681              MOV      r9,r0
;;;1169                       vstrp = &vstr[vlen];
000194  a809              ADD      r0,sp,#0x24
000196  eb000809          ADD      r8,r0,r9
                  |L6.410|
;;;1170   #if PRINTF_ADVANCED_ENABLE
;;;1171                       if (flags_used & kPRINTF_Zero)
;;;1172                       {
;;;1173                           DbgConsole_PrintfPaddingCharacter('0', vlen, field_width, &count, func_ptr);
;;;1174                           vlen = field_width;
;;;1175                       }
;;;1176                       else
;;;1177                       {
;;;1178                           if (!(flags_used & kPRINTF_Minus))
;;;1179                           {
;;;1180                               DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
;;;1181                           }
;;;1182                       }
;;;1183   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1184                   }
;;;1185   #if !PRINTF_ADVANCED_ENABLE
;;;1186                   DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
00019a  ab07              ADD      r3,sp,#0x1c
00019c  9600              STR      r6,[sp,#0]
00019e  4649              MOV      r1,r9
0001a0  2020              MOVS     r0,#0x20
0001a2  9a06              LDR      r2,[sp,#0x18]
0001a4  f7fffffe          BL       DbgConsole_PrintfPaddingCharacter
;;;1187   #endif /* !PRINTF_ADVANCED_ENABLE */
;;;1188                   if (vstrp != NULL)
0001a8  f1b80f00          CMP      r8,#0
0001ac  d03b              BEQ      |L6.550|
;;;1189                   {
;;;1190                       while (*vstrp)
0001ae  e005              B        |L6.444|
                  |L6.432|
;;;1191                       {
;;;1192                           func_ptr(*vstrp--);
0001b0  f8180901          LDRB     r0,[r8],#-1
0001b4  47b0              BLX      r6
;;;1193                           count++;
0001b6  9807              LDR      r0,[sp,#0x1c]
0001b8  1c40              ADDS     r0,r0,#1
0001ba  9007              STR      r0,[sp,#0x1c]
                  |L6.444|
0001bc  f8980000          LDRB     r0,[r8,#0]            ;1190
0001c0  2800              CMP      r0,#0                 ;1190
0001c2  d1f5              BNE      |L6.432|
0001c4  e02f              B        |L6.550|
0001c6  e7ff              B        |L6.456|
                  |L6.456|
;;;1194                       }
;;;1195                   }
;;;1196   #if PRINTF_ADVANCED_ENABLE
;;;1197                   if (flags_used & kPRINTF_Minus)
;;;1198                   {
;;;1199                       DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
;;;1200                   }
;;;1201   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1202               }
;;;1203               else if (c == 'c')
0001c8  2c63              CMP      r4,#0x63
0001ca  d10b              BNE      |L6.484|
;;;1204               {
;;;1205                   cval = (char)va_arg(ap, uint32_t);
0001cc  9814              LDR      r0,[sp,#0x50]
0001ce  f8101b04          LDRB     r1,[r0],#4
0001d2  9014              STR      r0,[sp,#0x50]
0001d4  b2c8              UXTB     r0,r1
0001d6  9004              STR      r0,[sp,#0x10]
;;;1206                   func_ptr(cval);
0001d8  9804              LDR      r0,[sp,#0x10]
0001da  47b0              BLX      r6
;;;1207                   count++;
0001dc  9807              LDR      r0,[sp,#0x1c]
0001de  1c40              ADDS     r0,r0,#1
0001e0  9007              STR      r0,[sp,#0x1c]
0001e2  e020              B        |L6.550|
                  |L6.484|
;;;1208               }
;;;1209               else if (c == 's')
0001e4  2c73              CMP      r4,#0x73
0001e6  d119              BNE      |L6.540|
;;;1210               {
;;;1211                   sval = (char *)va_arg(ap, char *);
0001e8  9814              LDR      r0,[sp,#0x50]
0001ea  c880              LDM      r0!,{r7}
0001ec  9014              STR      r0,[sp,#0x50]
;;;1212                   if (sval)
0001ee  b1d7              CBZ      r7,|L6.550|
;;;1213                   {
;;;1214                       vlen = strlen(sval);
0001f0  4638              MOV      r0,r7
0001f2  f7fffffe          BL       strlen
0001f6  4681              MOV      r9,r0
;;;1215   #if PRINTF_ADVANCED_ENABLE
;;;1216                       if (!(flags_used & kPRINTF_Minus))
;;;1217   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1218                       {
;;;1219                           DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
0001f8  ab07              ADD      r3,sp,#0x1c
0001fa  9600              STR      r6,[sp,#0]
0001fc  4649              MOV      r1,r9
0001fe  2020              MOVS     r0,#0x20
000200  9a06              LDR      r2,[sp,#0x18]
000202  f7fffffe          BL       DbgConsole_PrintfPaddingCharacter
;;;1220                       }
;;;1221                       while (*sval)
000206  e005              B        |L6.532|
                  |L6.520|
;;;1222                       {
;;;1223                           func_ptr(*sval++);
000208  f8170b01          LDRB     r0,[r7],#1
00020c  47b0              BLX      r6
;;;1224                           count++;
00020e  9807              LDR      r0,[sp,#0x1c]
000210  1c40              ADDS     r0,r0,#1
000212  9007              STR      r0,[sp,#0x1c]
                  |L6.532|
000214  7838              LDRB     r0,[r7,#0]            ;1221
000216  2800              CMP      r0,#0                 ;1221
000218  d1f6              BNE      |L6.520|
00021a  e004              B        |L6.550|
                  |L6.540|
;;;1225                       }
;;;1226   #if PRINTF_ADVANCED_ENABLE
;;;1227                       if (flags_used & kPRINTF_Minus)
;;;1228                       {
;;;1229                           DbgConsole_PrintfPaddingCharacter(' ', vlen, field_width, &count, func_ptr);
;;;1230                       }
;;;1231   #endif /* PRINTF_ADVANCED_ENABLE */
;;;1232                   }
;;;1233               }
;;;1234               else
;;;1235               {
;;;1236                   func_ptr(c);
00021c  4620              MOV      r0,r4
00021e  47b0              BLX      r6
;;;1237                   count++;
000220  9807              LDR      r0,[sp,#0x1c]
000222  1c40              ADDS     r0,r0,#1
000224  9007              STR      r0,[sp,#0x1c]
                  |L6.550|
000226  bf00              NOP                            ;813
                  |L6.552|
000228  1c6d              ADDS     r5,r5,#1              ;800
                  |L6.554|
00022a  7828              LDRB     r0,[r5,#0]            ;800
00022c  1e04              SUBS     r4,r0,#0              ;800
00022e  f47faef5          BNE      |L6.28|
;;;1238               }
;;;1239           }
;;;1240       }
;;;1241       return count;
000232  9807              LDR      r0,[sp,#0x1c]
;;;1242   }
000234  b015              ADD      sp,sp,#0x54
000236  e8bd8ff0          POP      {r4-r11,pc}
;;;1243   
                          ENDP


                          AREA ||i.DbgConsole_PrintfPaddingCharacter||, CODE, READONLY, ALIGN=1

                  DbgConsole_PrintfPaddingCharacter PROC
;;;510     */
;;;511    static void DbgConsole_PrintfPaddingCharacter(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;512        char c, int32_t curlen, int32_t width, int32_t *count, PUTCHAR_FUNC func_ptr)
;;;513    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;514        int32_t i;
;;;515    
;;;516        for (i = curlen; i < width; i++)
000010  462f              MOV      r7,r5
000012  e005              B        |L7.32|
                  |L7.20|
;;;517        {
;;;518            func_ptr(c);
000014  4640              MOV      r0,r8
000016  47c8              BLX      r9
;;;519            (*count)++;
000018  6820              LDR      r0,[r4,#0]
00001a  1c40              ADDS     r0,r0,#1
00001c  6020              STR      r0,[r4,#0]
00001e  1c7f              ADDS     r7,r7,#1              ;516
                  |L7.32|
000020  42b7              CMP      r7,r6                 ;516
000022  dbf7              BLT      |L7.20|
;;;520        }
;;;521    }
000024  e8bd87f0          POP      {r4-r10,pc}
;;;522    
                          ENDP


                          AREA ||i.DbgConsole_Putchar||, CODE, READONLY, ALIGN=2

                  DbgConsole_Putchar PROC
;;;403    /* See fsl_debug_console.h for documentation of this function. */
;;;404    int DbgConsole_Putchar(int ch)
000000  b501              PUSH     {r0,lr}
;;;405    {
;;;406        /* Do nothing if the debug UART is not initialized. */
;;;407        if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000002  4807              LDR      r0,|L8.32|
000004  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
000006  b910              CBNZ     r0,|L8.14|
;;;408        {
;;;409            return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L8.12|
;;;410        }
;;;411        s_debugConsole.ops.tx_union.PutChar(s_debugConsole.base, (uint8_t *)(&ch), 1);
;;;412    
;;;413        return 1;
;;;414    }
00000c  bd08              POP      {r3,pc}
                  |L8.14|
00000e  4904              LDR      r1,|L8.32|
000010  6848              LDR      r0,[r1,#4]            ;411  ; s_debugConsole
000012  2201              MOVS     r2,#1                 ;411
000014  688b              LDR      r3,[r1,#8]            ;411  ; s_debugConsole
000016  4669              MOV      r1,sp                 ;411
000018  4798              BLX      r3                    ;411
00001a  2001              MOVS     r0,#1                 ;413
00001c  e7f6              B        |L8.12|
;;;415    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      s_debugConsole

                          AREA ||i.DbgConsole_ScanIgnoreWhiteSpace||, CODE, READONLY, ALIGN=1

                  DbgConsole_ScanIgnoreWhiteSpace PROC
;;;486     */
;;;487    static uint32_t DbgConsole_ScanIgnoreWhiteSpace(const char **s)
000000  4602              MOV      r2,r0
;;;488    {
;;;489        uint8_t count = 0;
000002  2000              MOVS     r0,#0
;;;490        uint8_t c;
;;;491    
;;;492        c = **s;
000004  6813              LDR      r3,[r2,#0]
000006  7819              LDRB     r1,[r3,#0]
;;;493        while ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\v') || (c == '\f'))
000008  e006              B        |L9.24|
                  |L9.10|
;;;494        {
;;;495            count++;
00000a  1c43              ADDS     r3,r0,#1
00000c  b2d8              UXTB     r0,r3
;;;496            (*s)++;
00000e  6813              LDR      r3,[r2,#0]
000010  1c5b              ADDS     r3,r3,#1
000012  6013              STR      r3,[r2,#0]
;;;497            c = **s;
000014  6813              LDR      r3,[r2,#0]
000016  7819              LDRB     r1,[r3,#0]
                  |L9.24|
000018  2920              CMP      r1,#0x20              ;493
00001a  d0f6              BEQ      |L9.10|
00001c  2909              CMP      r1,#9                 ;493
00001e  d0f4              BEQ      |L9.10|
000020  290a              CMP      r1,#0xa               ;493
000022  d0f2              BEQ      |L9.10|
000024  290d              CMP      r1,#0xd               ;493
000026  d0f0              BEQ      |L9.10|
000028  290b              CMP      r1,#0xb               ;493
00002a  d0ee              BEQ      |L9.10|
00002c  290c              CMP      r1,#0xc               ;493
00002e  d0ec              BEQ      |L9.10|
;;;498        }
;;;499        return count;
;;;500    }
000030  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.DbgConsole_Scanf||, CODE, READONLY, ALIGN=2

                  DbgConsole_Scanf PROC
;;;416    /* See fsl_debug_console.h for documentation of this function. */
;;;417    int DbgConsole_Scanf(char *fmt_ptr, ...)
000000  b40f              PUSH     {r0-r3}
;;;418    {
000002  b530              PUSH     {r4,r5,lr}
000004  b087              SUB      sp,sp,#0x1c
;;;419        /* Plus one to store end of string char */
;;;420        char temp_buf[IO_MAXLINE + 1];
;;;421        va_list ap;
;;;422        int32_t i;
;;;423        char result;
;;;424    
;;;425        /* Do nothing if the debug UART is not initialized. */
;;;426        if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000006  481c              LDR      r0,|L10.120|
000008  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
00000a  b928              CBNZ     r0,|L10.24|
;;;427        {
;;;428            return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L10.16|
;;;429        }
;;;430        va_start(ap, fmt_ptr);
;;;431        temp_buf[0] = '\0';
;;;432    
;;;433        for (i = 0; i < IO_MAXLINE; i++)
;;;434        {
;;;435            temp_buf[i] = result = DbgConsole_Getchar();
;;;436    
;;;437            if ((result == '\r') || (result == '\n'))
;;;438            {
;;;439                /* End of Line. */
;;;440                if (i == 0)
;;;441                {
;;;442                    temp_buf[i] = '\0';
;;;443                    i = -1;
;;;444                }
;;;445                else
;;;446                {
;;;447                    break;
;;;448                }
;;;449            }
;;;450        }
;;;451    
;;;452        if ((i == IO_MAXLINE))
;;;453        {
;;;454            temp_buf[i] = '\0';
;;;455        }
;;;456        else
;;;457        {
;;;458            temp_buf[i + 1] = '\0';
;;;459        }
;;;460        result = DbgConsole_ScanfFormattedData(temp_buf, fmt_ptr, ap);
;;;461        va_end(ap);
;;;462    
;;;463        return result;
;;;464    }
000010  b007              ADD      sp,sp,#0x1c
000012  bc30              POP      {r4,r5}
000014  f85dfb14          LDR      pc,[sp],#0x14
                  |L10.24|
000018  a80b              ADD      r0,sp,#0x2c           ;430
00001a  9000              STR      r0,[sp,#0]            ;430
00001c  2000              MOVS     r0,#0                 ;431
00001e  f88d0004          STRB     r0,[sp,#4]            ;431
000022  2400              MOVS     r4,#0                 ;433
000024  e010              B        |L10.72|
                  |L10.38|
000026  f7fffffe          BL       DbgConsole_Getchar
00002a  b2c5              UXTB     r5,r0                 ;435
00002c  a801              ADD      r0,sp,#4              ;435
00002e  5505              STRB     r5,[r0,r4]            ;435
000030  2d0d              CMP      r5,#0xd               ;437
000032  d001              BEQ      |L10.56|
000034  2d0a              CMP      r5,#0xa               ;437
000036  d106              BNE      |L10.70|
                  |L10.56|
000038  b924              CBNZ     r4,|L10.68|
00003a  2000              MOVS     r0,#0                 ;442
00003c  a901              ADD      r1,sp,#4              ;442
00003e  5508              STRB     r0,[r1,r4]            ;442
000040  1e44              SUBS     r4,r0,#1              ;443
000042  e000              B        |L10.70|
                  |L10.68|
000044  e002              B        |L10.76|
                  |L10.70|
000046  1c64              ADDS     r4,r4,#1              ;433
                  |L10.72|
000048  2c14              CMP      r4,#0x14              ;433
00004a  d3ec              BCC      |L10.38|
                  |L10.76|
00004c  bf00              NOP                            ;447
00004e  2c14              CMP      r4,#0x14              ;452
000050  d103              BNE      |L10.90|
000052  2000              MOVS     r0,#0                 ;454
000054  a901              ADD      r1,sp,#4              ;454
000056  5508              STRB     r0,[r1,r4]            ;454
000058  e003              B        |L10.98|
                  |L10.90|
00005a  2100              MOVS     r1,#0                 ;458
00005c  aa01              ADD      r2,sp,#4              ;458
00005e  1c60              ADDS     r0,r4,#1              ;458
000060  5411              STRB     r1,[r2,r0]            ;458
                  |L10.98|
000062  a801              ADD      r0,sp,#4              ;460
000064  9a00              LDR      r2,[sp,#0]            ;460
000066  990a              LDR      r1,[sp,#0x28]         ;460
000068  f7fffffe          BL       DbgConsole_ScanfFormattedData
00006c  b2c5              UXTB     r5,r0                 ;460
00006e  2000              MOVS     r0,#0                 ;461
000070  9000              STR      r0,[sp,#0]            ;461
000072  4628              MOV      r0,r5                 ;463
000074  e7cc              B        |L10.16|
;;;465    
                          ENDP

000076  0000              DCW      0x0000
                  |L10.120|
                          DCD      s_debugConsole

                          AREA ||i.DbgConsole_ScanfFormattedData||, CODE, READONLY, ALIGN=1

                  DbgConsole_ScanfFormattedData PROC
;;;1254    */
;;;1255   static int DbgConsole_ScanfFormattedData(const char *line_ptr, char *format, va_list args_ptr)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1256   {
000004  b084              SUB      sp,sp,#0x10
;;;1257       uint8_t base;
;;;1258       int8_t neg;
;;;1259       /* Identifier for the format string. */
;;;1260       char *c = format;
000006  9805              LDR      r0,[sp,#0x14]
000008  9002              STR      r0,[sp,#8]
;;;1261       char temp;
;;;1262       char *buf;
;;;1263       /* Flag telling the conversion specification. */
;;;1264       uint32_t flag = 0;
00000a  2400              MOVS     r4,#0
;;;1265       /* Filed width for the matching input streams. */
;;;1266       uint32_t field_width;
;;;1267       /* How many arguments are assigned except the suppress. */
;;;1268       uint32_t nassigned = 0;
00000c  46a2              MOV      r10,r4
;;;1269       /* How many characters are read from the input streams. */
;;;1270       uint32_t n_decode = 0;
00000e  2600              MOVS     r6,#0
;;;1271   
;;;1272       int32_t val;
;;;1273   
;;;1274       const char *s;
;;;1275       /* Identifier for the input string. */
;;;1276       const char *p = line_ptr;
000010  9804              LDR      r0,[sp,#0x10]
000012  9000              STR      r0,[sp,#0]
;;;1277   
;;;1278       /* Return EOF error before any conversion. */
;;;1279       if (*p == '\0')
000014  9800              LDR      r0,[sp,#0]
000016  7800              LDRB     r0,[r0,#0]
000018  b918              CBNZ     r0,|L11.34|
;;;1280       {
;;;1281           return -1;
00001a  1e60              SUBS     r0,r4,#1
                  |L11.28|
;;;1282       }
;;;1283   
;;;1284       /* Decode directives. */
;;;1285       while ((*c) && (*p))
;;;1286       {
;;;1287           /* Ignore all white-spaces in the format strings. */
;;;1288           if (DbgConsole_ScanIgnoreWhiteSpace((const char **)&c))
;;;1289           {
;;;1290               n_decode += DbgConsole_ScanIgnoreWhiteSpace(&p);
;;;1291           }
;;;1292           else if ((*c != '%') || ((*c == '%') && (*(c + 1) == '%')))
;;;1293           {
;;;1294               /* Ordinary characters. */
;;;1295               c++;
;;;1296               if (*p == *c)
;;;1297               {
;;;1298                   n_decode++;
;;;1299                   p++;
;;;1300                   c++;
;;;1301               }
;;;1302               else
;;;1303               {
;;;1304                   /* Match failure. Misalignment with C99, the unmatched characters need to be pushed back to stream.
;;;1305                    * However, it is deserted now. */
;;;1306                   break;
;;;1307               }
;;;1308           }
;;;1309           else
;;;1310           {
;;;1311               /* convernsion specification */
;;;1312               c++;
;;;1313               /* Reset. */
;;;1314               flag = 0;
;;;1315               field_width = 0;
;;;1316               base = 0;
;;;1317   
;;;1318               /* Loop to get full conversion specification. */
;;;1319               while ((*c) && (!(flag & kSCANF_DestMask)))
;;;1320               {
;;;1321                   switch (*c)
;;;1322                   {
;;;1323   #if SCANF_ADVANCED_ENABLE
;;;1324                       case '*':
;;;1325                           if (flag & kSCANF_Suppress)
;;;1326                           {
;;;1327                               /* Match failure. */
;;;1328                               return nassigned;
;;;1329                           }
;;;1330                           flag |= kSCANF_Suppress;
;;;1331                           c++;
;;;1332                           break;
;;;1333                       case 'h':
;;;1334                           if (flag & kSCANF_LengthMask)
;;;1335                           {
;;;1336                               /* Match failure. */
;;;1337                               return nassigned;
;;;1338                           }
;;;1339   
;;;1340                           if (c[1] == 'h')
;;;1341                           {
;;;1342                               flag |= kSCANF_LengthChar;
;;;1343                               c++;
;;;1344                           }
;;;1345                           else
;;;1346                           {
;;;1347                               flag |= kSCANF_LengthShortInt;
;;;1348                           }
;;;1349                           c++;
;;;1350                           break;
;;;1351                       case 'l':
;;;1352                           if (flag & kSCANF_LengthMask)
;;;1353                           {
;;;1354                               /* Match failure. */
;;;1355                               return nassigned;
;;;1356                           }
;;;1357   
;;;1358                           if (c[1] == 'l')
;;;1359                           {
;;;1360                               flag |= kSCANF_LengthLongLongInt;
;;;1361                               c++;
;;;1362                           }
;;;1363                           else
;;;1364                           {
;;;1365                               flag |= kSCANF_LengthLongInt;
;;;1366                           }
;;;1367                           c++;
;;;1368                           break;
;;;1369   #endif /* SCANF_ADVANCED_ENABLE */
;;;1370   #if SCANF_FLOAT_ENABLE
;;;1371                       case 'L':
;;;1372                           if (flag & kSCANF_LengthMask)
;;;1373                           {
;;;1374                               /* Match failure. */
;;;1375                               return nassigned;
;;;1376                           }
;;;1377                           flag |= kSCANF_LengthLongLongDouble;
;;;1378                           c++;
;;;1379                           break;
;;;1380   #endif /* SCANF_FLOAT_ENABLE */
;;;1381                       case '0':
;;;1382                       case '1':
;;;1383                       case '2':
;;;1384                       case '3':
;;;1385                       case '4':
;;;1386                       case '5':
;;;1387                       case '6':
;;;1388                       case '7':
;;;1389                       case '8':
;;;1390                       case '9':
;;;1391                           if (field_width)
;;;1392                           {
;;;1393                               /* Match failure. */
;;;1394                               return nassigned;
;;;1395                           }
;;;1396                           do
;;;1397                           {
;;;1398                               field_width = field_width * 10 + *c - '0';
;;;1399                               c++;
;;;1400                           } while ((*c >= '0') && (*c <= '9'));
;;;1401                           break;
;;;1402                       case 'd':
;;;1403                           base = 10;
;;;1404                           flag |= kSCANF_TypeSinged;
;;;1405                           flag |= kSCANF_DestInt;
;;;1406                           c++;
;;;1407                           break;
;;;1408                       case 'u':
;;;1409                           base = 10;
;;;1410                           flag |= kSCANF_DestInt;
;;;1411                           c++;
;;;1412                           break;
;;;1413                       case 'o':
;;;1414                           base = 8;
;;;1415                           flag |= kSCANF_DestInt;
;;;1416                           c++;
;;;1417                           break;
;;;1418                       case 'x':
;;;1419                       case 'X':
;;;1420                           base = 16;
;;;1421                           flag |= kSCANF_DestInt;
;;;1422                           c++;
;;;1423                           break;
;;;1424                       case 'i':
;;;1425                           base = 0;
;;;1426                           flag |= kSCANF_DestInt;
;;;1427                           c++;
;;;1428                           break;
;;;1429   #if SCANF_FLOAT_ENABLE
;;;1430                       case 'a':
;;;1431                       case 'A':
;;;1432                       case 'e':
;;;1433                       case 'E':
;;;1434                       case 'f':
;;;1435                       case 'F':
;;;1436                       case 'g':
;;;1437                       case 'G':
;;;1438                           flag |= kSCANF_DestFloat;
;;;1439                           c++;
;;;1440                           break;
;;;1441   #endif /* SCANF_FLOAT_ENABLE */
;;;1442                       case 'c':
;;;1443                           flag |= kSCANF_DestChar;
;;;1444                           if (!field_width)
;;;1445                           {
;;;1446                               field_width = 1;
;;;1447                           }
;;;1448                           c++;
;;;1449                           break;
;;;1450                       case 's':
;;;1451                           flag |= kSCANF_DestString;
;;;1452                           c++;
;;;1453                           break;
;;;1454                       default:
;;;1455                           return nassigned;
;;;1456                   }
;;;1457               }
;;;1458   
;;;1459               if (!(flag & kSCANF_DestMask))
;;;1460               {
;;;1461                   /* Format strings are exhausted. */
;;;1462                   return nassigned;
;;;1463               }
;;;1464   
;;;1465               if (!field_width)
;;;1466               {
;;;1467                   /* Large than length of a line. */
;;;1468                   field_width = 99;
;;;1469               }
;;;1470   
;;;1471               /* Matching strings in input streams and assign to argument. */
;;;1472               switch (flag & kSCANF_DestMask)
;;;1473               {
;;;1474                   case kSCANF_DestChar:
;;;1475                       s = (const char *)p;
;;;1476                       buf = va_arg(args_ptr, char *);
;;;1477                       while ((field_width--) && (*p))
;;;1478                       {
;;;1479                           if (!(flag & kSCANF_Suppress))
;;;1480                           {
;;;1481                               *buf++ = *p++;
;;;1482                           }
;;;1483                           else
;;;1484                           {
;;;1485                               p++;
;;;1486                           }
;;;1487                           n_decode++;
;;;1488                       }
;;;1489   
;;;1490                       if ((!(flag & kSCANF_Suppress)) && (s != p))
;;;1491                       {
;;;1492                           nassigned++;
;;;1493                       }
;;;1494                       break;
;;;1495                   case kSCANF_DestString:
;;;1496                       n_decode += DbgConsole_ScanIgnoreWhiteSpace(&p);
;;;1497                       s = p;
;;;1498                       buf = va_arg(args_ptr, char *);
;;;1499                       while ((field_width--) && (*p != '\0') && (*p != ' ') && (*p != '\t') && (*p != '\n') &&
;;;1500                              (*p != '\r') && (*p != '\v') && (*p != '\f'))
;;;1501                       {
;;;1502                           if (flag & kSCANF_Suppress)
;;;1503                           {
;;;1504                               p++;
;;;1505                           }
;;;1506                           else
;;;1507                           {
;;;1508                               *buf++ = *p++;
;;;1509                           }
;;;1510                           n_decode++;
;;;1511                       }
;;;1512   
;;;1513                       if ((!(flag & kSCANF_Suppress)) && (s != p))
;;;1514                       {
;;;1515                           /* Add NULL to end of string. */
;;;1516                           *buf = '\0';
;;;1517                           nassigned++;
;;;1518                       }
;;;1519                       break;
;;;1520                   case kSCANF_DestInt:
;;;1521                       n_decode += DbgConsole_ScanIgnoreWhiteSpace(&p);
;;;1522                       s = p;
;;;1523                       val = 0;
;;;1524                       if ((base == 0) || (base == 16))
;;;1525                       {
;;;1526                           if ((s[0] == '0') && ((s[1] == 'x') || (s[1] == 'X')))
;;;1527                           {
;;;1528                               base = 16;
;;;1529                               if (field_width >= 1)
;;;1530                               {
;;;1531                                   p += 2;
;;;1532                                   n_decode += 2;
;;;1533                                   field_width -= 2;
;;;1534                               }
;;;1535                           }
;;;1536                       }
;;;1537   
;;;1538                       if (base == 0)
;;;1539                       {
;;;1540                           if (s[0] == '0')
;;;1541                           {
;;;1542                               base = 8;
;;;1543                           }
;;;1544                           else
;;;1545                           {
;;;1546                               base = 10;
;;;1547                           }
;;;1548                       }
;;;1549   
;;;1550                       neg = 1;
;;;1551                       switch (*p)
;;;1552                       {
;;;1553                           case '-':
;;;1554                               neg = -1;
;;;1555                               n_decode++;
;;;1556                               p++;
;;;1557                               field_width--;
;;;1558                               break;
;;;1559                           case '+':
;;;1560                               neg = 1;
;;;1561                               n_decode++;
;;;1562                               p++;
;;;1563                               field_width--;
;;;1564                               break;
;;;1565                           default:
;;;1566                               break;
;;;1567                       }
;;;1568   
;;;1569                       while ((*p) && (field_width--))
;;;1570                       {
;;;1571                           if ((*p <= '9') && (*p >= '0'))
;;;1572                           {
;;;1573                               temp = *p - '0';
;;;1574                           }
;;;1575                           else if ((*p <= 'f') && (*p >= 'a'))
;;;1576                           {
;;;1577                               temp = *p - 'a' + 10;
;;;1578                           }
;;;1579                           else if ((*p <= 'F') && (*p >= 'A'))
;;;1580                           {
;;;1581                               temp = *p - 'A' + 10;
;;;1582                           }
;;;1583                           else
;;;1584                           {
;;;1585                               temp = base;
;;;1586                           }
;;;1587   
;;;1588                           if (temp >= base)
;;;1589                           {
;;;1590                               break;
;;;1591                           }
;;;1592                           else
;;;1593                           {
;;;1594                               val = base * val + temp;
;;;1595                           }
;;;1596                           p++;
;;;1597                           n_decode++;
;;;1598                       }
;;;1599                       val *= neg;
;;;1600                       if (!(flag & kSCANF_Suppress))
;;;1601                       {
;;;1602   #if SCANF_ADVANCED_ENABLE
;;;1603                           switch (flag & kSCANF_LengthMask)
;;;1604                           {
;;;1605                               case kSCANF_LengthChar:
;;;1606                                   if (flag & kSCANF_TypeSinged)
;;;1607                                   {
;;;1608                                       *va_arg(args_ptr, signed char *) = (signed char)val;
;;;1609                                   }
;;;1610                                   else
;;;1611                                   {
;;;1612                                       *va_arg(args_ptr, unsigned char *) = (unsigned char)val;
;;;1613                                   }
;;;1614                                   break;
;;;1615                               case kSCANF_LengthShortInt:
;;;1616                                   if (flag & kSCANF_TypeSinged)
;;;1617                                   {
;;;1618                                       *va_arg(args_ptr, signed short *) = (signed short)val;
;;;1619                                   }
;;;1620                                   else
;;;1621                                   {
;;;1622                                       *va_arg(args_ptr, unsigned short *) = (unsigned short)val;
;;;1623                                   }
;;;1624                                   break;
;;;1625                               case kSCANF_LengthLongInt:
;;;1626                                   if (flag & kSCANF_TypeSinged)
;;;1627                                   {
;;;1628                                       *va_arg(args_ptr, signed long int *) = (signed long int)val;
;;;1629                                   }
;;;1630                                   else
;;;1631                                   {
;;;1632                                       *va_arg(args_ptr, unsigned long int *) = (unsigned long int)val;
;;;1633                                   }
;;;1634                                   break;
;;;1635                               case kSCANF_LengthLongLongInt:
;;;1636                                   if (flag & kSCANF_TypeSinged)
;;;1637                                   {
;;;1638                                       *va_arg(args_ptr, signed long long int *) = (signed long long int)val;
;;;1639                                   }
;;;1640                                   else
;;;1641                                   {
;;;1642                                       *va_arg(args_ptr, unsigned long long int *) = (unsigned long long int)val;
;;;1643                                   }
;;;1644                                   break;
;;;1645                               default:
;;;1646                                   /* The default type is the type int. */
;;;1647                                   if (flag & kSCANF_TypeSinged)
;;;1648                                   {
;;;1649                                       *va_arg(args_ptr, signed int *) = (signed int)val;
;;;1650                                   }
;;;1651                                   else
;;;1652                                   {
;;;1653                                       *va_arg(args_ptr, unsigned int *) = (unsigned int)val;
;;;1654                                   }
;;;1655                                   break;
;;;1656                           }
;;;1657   #else
;;;1658                           /* The default type is the type int. */
;;;1659                           if (flag & kSCANF_TypeSinged)
;;;1660                           {
;;;1661                               *va_arg(args_ptr, signed int *) = (signed int)val;
;;;1662                           }
;;;1663                           else
;;;1664                           {
;;;1665                               *va_arg(args_ptr, unsigned int *) = (unsigned int)val;
;;;1666                           }
;;;1667   #endif /* SCANF_ADVANCED_ENABLE */
;;;1668                           nassigned++;
;;;1669                       }
;;;1670                       break;
;;;1671   #if SCANF_FLOAT_ENABLE
;;;1672                   case kSCANF_DestFloat:
;;;1673                       n_decode += DbgConsole_ScanIgnoreWhiteSpace(&p);
;;;1674                       fnum = strtod(p, (char **)&s);
;;;1675   
;;;1676                       if ((fnum >= HUGE_VAL) || (fnum <= -HUGE_VAL))
;;;1677                       {
;;;1678                           break;
;;;1679                       }
;;;1680   
;;;1681                       n_decode += (int)(s) - (int)(p);
;;;1682                       p = s;
;;;1683                       if (!(flag & kSCANF_Suppress))
;;;1684                       {
;;;1685                           if (flag & kSCANF_LengthLongLongDouble)
;;;1686                           {
;;;1687                               *va_arg(args_ptr, double *) = fnum;
;;;1688                           }
;;;1689                           else
;;;1690                           {
;;;1691                               *va_arg(args_ptr, float *) = (float)fnum;
;;;1692                           }
;;;1693                           nassigned++;
;;;1694                       }
;;;1695                       break;
;;;1696   #endif /* SCANF_FLOAT_ENABLE */
;;;1697                   default:
;;;1698                       return nassigned;
;;;1699               }
;;;1700           }
;;;1701       }
;;;1702       return nassigned;
;;;1703   }
00001c  b007              ADD      sp,sp,#0x1c
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.34|
000022  e1cc              B        |L11.958|
                  |L11.36|
000024  a802              ADD      r0,sp,#8              ;1288
000026  f7fffffe          BL       DbgConsole_ScanIgnoreWhiteSpace
00002a  b120              CBZ      r0,|L11.54|
00002c  4668              MOV      r0,sp                 ;1290
00002e  f7fffffe          BL       DbgConsole_ScanIgnoreWhiteSpace
000032  4406              ADD      r6,r6,r0              ;1290
000034  e1c3              B        |L11.958|
                  |L11.54|
000036  9802              LDR      r0,[sp,#8]            ;1292
000038  7800              LDRB     r0,[r0,#0]            ;1292
00003a  2825              CMP      r0,#0x25              ;1292
00003c  d107              BNE      |L11.78|
00003e  9802              LDR      r0,[sp,#8]            ;1292
000040  7800              LDRB     r0,[r0,#0]            ;1292
000042  2825              CMP      r0,#0x25              ;1292
000044  d115              BNE      |L11.114|
000046  9802              LDR      r0,[sp,#8]            ;1292
000048  7840              LDRB     r0,[r0,#1]            ;1292
00004a  2825              CMP      r0,#0x25              ;1292
00004c  d111              BNE      |L11.114|
                  |L11.78|
00004e  9802              LDR      r0,[sp,#8]            ;1295
000050  1c40              ADDS     r0,r0,#1              ;1295
000052  9002              STR      r0,[sp,#8]            ;1295
000054  9800              LDR      r0,[sp,#0]            ;1296
000056  7800              LDRB     r0,[r0,#0]            ;1296
000058  9902              LDR      r1,[sp,#8]            ;1296
00005a  7809              LDRB     r1,[r1,#0]            ;1296
00005c  4288              CMP      r0,r1                 ;1296
00005e  d107              BNE      |L11.112|
000060  1c76              ADDS     r6,r6,#1              ;1298
000062  9800              LDR      r0,[sp,#0]            ;1299
000064  1c40              ADDS     r0,r0,#1              ;1299
000066  9000              STR      r0,[sp,#0]            ;1299
000068  9802              LDR      r0,[sp,#8]            ;1300
00006a  1c40              ADDS     r0,r0,#1              ;1300
00006c  9002              STR      r0,[sp,#8]            ;1300
00006e  e1a6              B        |L11.958|
                  |L11.112|
000070  e1ad              B        |L11.974|
                  |L11.114|
000072  9802              LDR      r0,[sp,#8]            ;1312
000074  1c40              ADDS     r0,r0,#1              ;1312
000076  9002              STR      r0,[sp,#8]            ;1312
000078  2400              MOVS     r4,#0                 ;1314
00007a  2500              MOVS     r5,#0                 ;1315
00007c  2700              MOVS     r7,#0                 ;1316
00007e  e07a              B        |L11.374|
                  |L11.128|
000080  9802              LDR      r0,[sp,#8]            ;1321
000082  7800              LDRB     r0,[r0,#0]            ;1321
000084  2839              CMP      r0,#0x39              ;1321
000086  d027              BEQ      |L11.216|
000088  dc0a              BGT      |L11.160|
00008a  f1a00030          SUB      r0,r0,#0x30           ;1321
00008e  2809              CMP      r0,#9                 ;1321
000090  d26e              BCS      |L11.368|
000092  e8dff000          TBB      [pc,r0]               ;1321
000096  1819              DCB      0x18,0x19
000098  1a1b1c1d          DCB      0x1a,0x1b,0x1c,0x1d
00009c  1e1f2000          DCB      0x1e,0x1f,0x20,0x00
                  |L11.160|
0000a0  286f              CMP      r0,#0x6f              ;1321
0000a2  d041              BEQ      |L11.296|
0000a4  dc08              BGT      |L11.184|
0000a6  2858              CMP      r0,#0x58              ;1321
0000a8  d046              BEQ      |L11.312|
0000aa  2863              CMP      r0,#0x63              ;1321
0000ac  d052              BEQ      |L11.340|
0000ae  2864              CMP      r0,#0x64              ;1321
0000b0  d02a              BEQ      |L11.264|
0000b2  2869              CMP      r0,#0x69              ;1321
0000b4  d15c              BNE      |L11.368|
0000b6  e046              B        |L11.326|
                  |L11.184|
0000b8  2873              CMP      r0,#0x73              ;1321
0000ba  d053              BEQ      |L11.356|
0000bc  2875              CMP      r0,#0x75              ;1321
0000be  d02c              BEQ      |L11.282|
0000c0  2878              CMP      r0,#0x78              ;1321
0000c2  d155              BNE      |L11.368|
0000c4  e037              B        |L11.310|
0000c6  bf00              NOP                            ;1382
0000c8  bf00              NOP                            ;1383
0000ca  bf00              NOP                            ;1384
0000cc  bf00              NOP                            ;1385
0000ce  bf00              NOP                            ;1386
0000d0  bf00              NOP                            ;1387
0000d2  bf00              NOP                            ;1388
0000d4  bf00              NOP                            ;1389
0000d6  bf00              NOP                            ;1390
                  |L11.216|
0000d8  b10d              CBZ      r5,|L11.222|
0000da  4650              MOV      r0,r10                ;1394
0000dc  e79e              B        |L11.28|
                  |L11.222|
0000de  bf00              NOP                            ;1396
                  |L11.224|
0000e0  9802              LDR      r0,[sp,#8]            ;1398
0000e2  7800              LDRB     r0,[r0,#0]            ;1398
0000e4  eb050185          ADD      r1,r5,r5,LSL #2       ;1398
0000e8  eb000041          ADD      r0,r0,r1,LSL #1       ;1398
0000ec  f1a00530          SUB      r5,r0,#0x30           ;1398
0000f0  9802              LDR      r0,[sp,#8]            ;1399
0000f2  1c40              ADDS     r0,r0,#1              ;1399
0000f4  9002              STR      r0,[sp,#8]            ;1399
0000f6  9802              LDR      r0,[sp,#8]            ;1400
0000f8  7800              LDRB     r0,[r0,#0]            ;1400
0000fa  2830              CMP      r0,#0x30              ;1400
0000fc  db03              BLT      |L11.262|
0000fe  9802              LDR      r0,[sp,#8]            ;1400
000100  7800              LDRB     r0,[r0,#0]            ;1400
000102  2839              CMP      r0,#0x39              ;1400
000104  ddec              BLE      |L11.224|
                  |L11.262|
000106  e035              B        |L11.372|
                  |L11.264|
000108  270a              MOVS     r7,#0xa               ;1403
00010a  f4445400          ORR      r4,r4,#0x2000         ;1404
00010e  f0440420          ORR      r4,r4,#0x20           ;1405
000112  9802              LDR      r0,[sp,#8]            ;1406
000114  1c40              ADDS     r0,r0,#1              ;1406
000116  9002              STR      r0,[sp,#8]            ;1406
000118  e02c              B        |L11.372|
                  |L11.282|
00011a  270a              MOVS     r7,#0xa               ;1409
00011c  f0440420          ORR      r4,r4,#0x20           ;1410
000120  9802              LDR      r0,[sp,#8]            ;1411
000122  1c40              ADDS     r0,r0,#1              ;1411
000124  9002              STR      r0,[sp,#8]            ;1411
000126  e025              B        |L11.372|
                  |L11.296|
000128  2708              MOVS     r7,#8                 ;1414
00012a  f0440420          ORR      r4,r4,#0x20           ;1415
00012e  9802              LDR      r0,[sp,#8]            ;1416
000130  1c40              ADDS     r0,r0,#1              ;1416
000132  9002              STR      r0,[sp,#8]            ;1416
000134  e01e              B        |L11.372|
                  |L11.310|
000136  bf00              NOP                            ;1419
                  |L11.312|
000138  2710              MOVS     r7,#0x10              ;1420
00013a  f0440420          ORR      r4,r4,#0x20           ;1421
00013e  9802              LDR      r0,[sp,#8]            ;1422
000140  1c40              ADDS     r0,r0,#1              ;1422
000142  9002              STR      r0,[sp,#8]            ;1422
000144  e016              B        |L11.372|
                  |L11.326|
000146  2700              MOVS     r7,#0                 ;1425
000148  f0440420          ORR      r4,r4,#0x20           ;1426
00014c  9802              LDR      r0,[sp,#8]            ;1427
00014e  1c40              ADDS     r0,r0,#1              ;1427
000150  9002              STR      r0,[sp,#8]            ;1427
000152  e00f              B        |L11.372|
                  |L11.340|
000154  f0440404          ORR      r4,r4,#4              ;1443
000158  b905              CBNZ     r5,|L11.348|
00015a  2501              MOVS     r5,#1                 ;1446
                  |L11.348|
00015c  9802              LDR      r0,[sp,#8]            ;1448
00015e  1c40              ADDS     r0,r0,#1              ;1448
000160  9002              STR      r0,[sp,#8]            ;1448
000162  e007              B        |L11.372|
                  |L11.356|
000164  f0440408          ORR      r4,r4,#8              ;1451
000168  9802              LDR      r0,[sp,#8]            ;1452
00016a  1c40              ADDS     r0,r0,#1              ;1452
00016c  9002              STR      r0,[sp,#8]            ;1452
00016e  e001              B        |L11.372|
                  |L11.368|
000170  4650              MOV      r0,r10                ;1455
000172  e753              B        |L11.28|
                  |L11.372|
000174  bf00              NOP                            ;1401
                  |L11.374|
000176  9802              LDR      r0,[sp,#8]            ;1319
000178  7800              LDRB     r0,[r0,#0]            ;1319
00017a  b120              CBZ      r0,|L11.390|
00017c  f004007c          AND      r0,r4,#0x7c           ;1319
000180  2800              CMP      r0,#0                 ;1319
000182  f43faf7d          BEQ      |L11.128|
                  |L11.390|
000186  f004007c          AND      r0,r4,#0x7c           ;1459
00018a  b908              CBNZ     r0,|L11.400|
00018c  4650              MOV      r0,r10                ;1462
00018e  e745              B        |L11.28|
                  |L11.400|
000190  b905              CBNZ     r5,|L11.404|
000192  2563              MOVS     r5,#0x63              ;1468
                  |L11.404|
000194  f004007c          AND      r0,r4,#0x7c           ;1472
000198  2804              CMP      r0,#4                 ;1472
00019a  d004              BEQ      |L11.422|
00019c  2808              CMP      r0,#8                 ;1472
00019e  d029              BEQ      |L11.500|
0001a0  2820              CMP      r0,#0x20              ;1472
0001a2  d17c              BNE      |L11.670|
0001a4  e06b              B        |L11.638|
                  |L11.422|
0001a6  f8dd8000          LDR      r8,[sp,#0]            ;1475
0001aa  9806              LDR      r0,[sp,#0x18]         ;1476
0001ac  f8509b04          LDR      r9,[r0],#4            ;1476
0001b0  9006              STR      r0,[sp,#0x18]         ;1476
0001b2  e00e              B        |L11.466|
                  |L11.436|
0001b4  f0040002          AND      r0,r4,#2              ;1479
0001b8  b938              CBNZ     r0,|L11.458|
0001ba  9800              LDR      r0,[sp,#0]            ;1481
0001bc  7800              LDRB     r0,[r0,#0]            ;1481
0001be  f8090b01          STRB     r0,[r9],#1            ;1481
0001c2  9800              LDR      r0,[sp,#0]            ;1481
0001c4  1c40              ADDS     r0,r0,#1              ;1481
0001c6  9000              STR      r0,[sp,#0]            ;1481
0001c8  e002              B        |L11.464|
                  |L11.458|
0001ca  9800              LDR      r0,[sp,#0]            ;1485
0001cc  1c40              ADDS     r0,r0,#1              ;1485
0001ce  9000              STR      r0,[sp,#0]            ;1485
                  |L11.464|
0001d0  1c76              ADDS     r6,r6,#1              ;1487
                  |L11.466|
0001d2  1e28              SUBS     r0,r5,#0              ;1477
0001d4  f1a50501          SUB      r5,r5,#1              ;1477
0001d8  d003              BEQ      |L11.482|
0001da  9800              LDR      r0,[sp,#0]            ;1477
0001dc  7800              LDRB     r0,[r0,#0]            ;1477
0001de  2800              CMP      r0,#0                 ;1477
0001e0  d1e8              BNE      |L11.436|
                  |L11.482|
0001e2  f0040002          AND      r0,r4,#2              ;1490
0001e6  b920              CBNZ     r0,|L11.498|
0001e8  9800              LDR      r0,[sp,#0]            ;1490
0001ea  4580              CMP      r8,r0                 ;1490
0001ec  d001              BEQ      |L11.498|
0001ee  f10a0a01          ADD      r10,r10,#1            ;1492
                  |L11.498|
0001f2  e0e3              B        |L11.956|
                  |L11.500|
0001f4  4668              MOV      r0,sp                 ;1496
0001f6  f7fffffe          BL       DbgConsole_ScanIgnoreWhiteSpace
0001fa  4406              ADD      r6,r6,r0              ;1496
0001fc  f8dd8000          LDR      r8,[sp,#0]            ;1497
000200  9806              LDR      r0,[sp,#0x18]         ;1498
000202  f8509b04          LDR      r9,[r0],#4            ;1498
000206  9006              STR      r0,[sp,#0x18]         ;1498
000208  e00e              B        |L11.552|
                  |L11.522|
00020a  f0040002          AND      r0,r4,#2              ;1502
00020e  b118              CBZ      r0,|L11.536|
000210  9800              LDR      r0,[sp,#0]            ;1504
000212  1c40              ADDS     r0,r0,#1              ;1504
000214  9000              STR      r0,[sp,#0]            ;1504
000216  e006              B        |L11.550|
                  |L11.536|
000218  9800              LDR      r0,[sp,#0]            ;1508
00021a  7800              LDRB     r0,[r0,#0]            ;1508
00021c  f8090b01          STRB     r0,[r9],#1            ;1508
000220  9800              LDR      r0,[sp,#0]            ;1508
000222  1c40              ADDS     r0,r0,#1              ;1508
000224  9000              STR      r0,[sp,#0]            ;1508
                  |L11.550|
000226  1c76              ADDS     r6,r6,#1              ;1510
                  |L11.552|
000228  1e28              SUBS     r0,r5,#0              ;1499
00022a  f1a50501          SUB      r5,r5,#1              ;1499
00022e  d01a              BEQ      |L11.614|
000230  9800              LDR      r0,[sp,#0]            ;1499
000232  7800              LDRB     r0,[r0,#0]            ;1499
000234  b1b8              CBZ      r0,|L11.614|
000236  9800              LDR      r0,[sp,#0]            ;1499
000238  7800              LDRB     r0,[r0,#0]            ;1499
00023a  2820              CMP      r0,#0x20              ;1499
00023c  d013              BEQ      |L11.614|
00023e  9800              LDR      r0,[sp,#0]            ;1499
000240  7800              LDRB     r0,[r0,#0]            ;1499
000242  2809              CMP      r0,#9                 ;1499
000244  d00f              BEQ      |L11.614|
000246  9800              LDR      r0,[sp,#0]            ;1499
000248  7800              LDRB     r0,[r0,#0]            ;1499
00024a  280a              CMP      r0,#0xa               ;1499
00024c  d00b              BEQ      |L11.614|
00024e  9800              LDR      r0,[sp,#0]            ;1500
000250  7800              LDRB     r0,[r0,#0]            ;1500
000252  280d              CMP      r0,#0xd               ;1500
000254  d007              BEQ      |L11.614|
000256  9800              LDR      r0,[sp,#0]            ;1500
000258  7800              LDRB     r0,[r0,#0]            ;1500
00025a  280b              CMP      r0,#0xb               ;1500
00025c  d003              BEQ      |L11.614|
00025e  9800              LDR      r0,[sp,#0]            ;1500
000260  7800              LDRB     r0,[r0,#0]            ;1500
000262  280c              CMP      r0,#0xc               ;1500
000264  d1d1              BNE      |L11.522|
                  |L11.614|
000266  f0040002          AND      r0,r4,#2              ;1513
00026a  b938              CBNZ     r0,|L11.636|
00026c  9800              LDR      r0,[sp,#0]            ;1513
00026e  4580              CMP      r8,r0                 ;1513
000270  d004              BEQ      |L11.636|
000272  2000              MOVS     r0,#0                 ;1516
000274  f8890000          STRB     r0,[r9,#0]            ;1516
000278  f10a0a01          ADD      r10,r10,#1            ;1517
                  |L11.636|
00027c  e09e              B        |L11.956|
                  |L11.638|
00027e  4668              MOV      r0,sp                 ;1521
000280  f7fffffe          BL       DbgConsole_ScanIgnoreWhiteSpace
000284  4406              ADD      r6,r6,r0              ;1521
000286  f8dd8000          LDR      r8,[sp,#0]            ;1522
00028a  f04f0b00          MOV      r11,#0                ;1523
00028e  b10f              CBZ      r7,|L11.660|
000290  2f10              CMP      r7,#0x10              ;1524
000292  d114              BNE      |L11.702|
                  |L11.660|
000294  f8980000          LDRB     r0,[r8,#0]            ;1526
000298  2830              CMP      r0,#0x30              ;1526
00029a  d110              BNE      |L11.702|
00029c  e000              B        |L11.672|
                  |L11.670|
00029e  e08b              B        |L11.952|
                  |L11.672|
0002a0  f8980001          LDRB     r0,[r8,#1]            ;1526
0002a4  2878              CMP      r0,#0x78              ;1526
0002a6  d003              BEQ      |L11.688|
0002a8  f8980001          LDRB     r0,[r8,#1]            ;1526
0002ac  2858              CMP      r0,#0x58              ;1526
0002ae  d106              BNE      |L11.702|
                  |L11.688|
0002b0  2710              MOVS     r7,#0x10              ;1528
0002b2  b125              CBZ      r5,|L11.702|
0002b4  9800              LDR      r0,[sp,#0]            ;1531
0002b6  1c80              ADDS     r0,r0,#2              ;1531
0002b8  9000              STR      r0,[sp,#0]            ;1531
0002ba  1cb6              ADDS     r6,r6,#2              ;1532
0002bc  1ead              SUBS     r5,r5,#2              ;1533
                  |L11.702|
0002be  b937              CBNZ     r7,|L11.718|
0002c0  f8980000          LDRB     r0,[r8,#0]            ;1540
0002c4  2830              CMP      r0,#0x30              ;1540
0002c6  d101              BNE      |L11.716|
0002c8  2708              MOVS     r7,#8                 ;1542
0002ca  e000              B        |L11.718|
                  |L11.716|
0002cc  270a              MOVS     r7,#0xa               ;1546
                  |L11.718|
0002ce  2001              MOVS     r0,#1                 ;1550
0002d0  9003              STR      r0,[sp,#0xc]          ;1550
0002d2  9800              LDR      r0,[sp,#0]            ;1551
0002d4  7800              LDRB     r0,[r0,#0]            ;1551
0002d6  282b              CMP      r0,#0x2b              ;1551
0002d8  d00a              BEQ      |L11.752|
0002da  282d              CMP      r0,#0x2d              ;1551
0002dc  d110              BNE      |L11.768|
0002de  f04f30ff          MOV      r0,#0xffffffff        ;1554
0002e2  9003              STR      r0,[sp,#0xc]          ;1554
0002e4  1c76              ADDS     r6,r6,#1              ;1555
0002e6  9800              LDR      r0,[sp,#0]            ;1556
0002e8  1c40              ADDS     r0,r0,#1              ;1556
0002ea  9000              STR      r0,[sp,#0]            ;1556
0002ec  1e6d              SUBS     r5,r5,#1              ;1557
0002ee  e008              B        |L11.770|
                  |L11.752|
0002f0  2001              MOVS     r0,#1                 ;1560
0002f2  9003              STR      r0,[sp,#0xc]          ;1560
0002f4  1c76              ADDS     r6,r6,#1              ;1561
0002f6  9800              LDR      r0,[sp,#0]            ;1562
0002f8  1c40              ADDS     r0,r0,#1              ;1562
0002fa  9000              STR      r0,[sp,#0]            ;1562
0002fc  1e6d              SUBS     r5,r5,#1              ;1563
0002fe  e000              B        |L11.770|
                  |L11.768|
000300  bf00              NOP                            ;1566
                  |L11.770|
000302  bf00              NOP                            ;1558
000304  e035              B        |L11.882|
                  |L11.774|
000306  9800              LDR      r0,[sp,#0]            ;1571
000308  7800              LDRB     r0,[r0,#0]            ;1571
00030a  2839              CMP      r0,#0x39              ;1571
00030c  dc09              BGT      |L11.802|
00030e  9800              LDR      r0,[sp,#0]            ;1571
000310  7800              LDRB     r0,[r0,#0]            ;1571
000312  2830              CMP      r0,#0x30              ;1571
000314  db05              BLT      |L11.802|
000316  9800              LDR      r0,[sp,#0]            ;1573
000318  7800              LDRB     r0,[r0,#0]            ;1573
00031a  3830              SUBS     r0,r0,#0x30           ;1573
00031c  b2c0              UXTB     r0,r0                 ;1573
00031e  9001              STR      r0,[sp,#4]            ;1573
000320  e01c              B        |L11.860|
                  |L11.802|
000322  9800              LDR      r0,[sp,#0]            ;1575
000324  7800              LDRB     r0,[r0,#0]            ;1575
000326  2866              CMP      r0,#0x66              ;1575
000328  dc09              BGT      |L11.830|
00032a  9800              LDR      r0,[sp,#0]            ;1575
00032c  7800              LDRB     r0,[r0,#0]            ;1575
00032e  2861              CMP      r0,#0x61              ;1575
000330  db05              BLT      |L11.830|
000332  9800              LDR      r0,[sp,#0]            ;1577
000334  7800              LDRB     r0,[r0,#0]            ;1577
000336  3857              SUBS     r0,r0,#0x57           ;1577
000338  b2c0              UXTB     r0,r0                 ;1577
00033a  9001              STR      r0,[sp,#4]            ;1577
00033c  e00e              B        |L11.860|
                  |L11.830|
00033e  9800              LDR      r0,[sp,#0]            ;1579
000340  7800              LDRB     r0,[r0,#0]            ;1579
000342  2846              CMP      r0,#0x46              ;1579
000344  dc09              BGT      |L11.858|
000346  9800              LDR      r0,[sp,#0]            ;1579
000348  7800              LDRB     r0,[r0,#0]            ;1579
00034a  2841              CMP      r0,#0x41              ;1579
00034c  db05              BLT      |L11.858|
00034e  9800              LDR      r0,[sp,#0]            ;1581
000350  7800              LDRB     r0,[r0,#0]            ;1581
000352  3837              SUBS     r0,r0,#0x37           ;1581
000354  b2c0              UXTB     r0,r0                 ;1581
000356  9001              STR      r0,[sp,#4]            ;1581
000358  e000              B        |L11.860|
                  |L11.858|
00035a  9701              STR      r7,[sp,#4]            ;1585
                  |L11.860|
00035c  9801              LDR      r0,[sp,#4]            ;1588
00035e  42b8              CMP      r0,r7                 ;1588
000360  db00              BLT      |L11.868|
000362  e00d              B        |L11.896|
                  |L11.868|
000364  9801              LDR      r0,[sp,#4]            ;1594
000366  fb0b0b07          MLA      r11,r11,r7,r0         ;1594
00036a  9800              LDR      r0,[sp,#0]            ;1596
00036c  1c40              ADDS     r0,r0,#1              ;1596
00036e  9000              STR      r0,[sp,#0]            ;1596
000370  1c76              ADDS     r6,r6,#1              ;1597
                  |L11.882|
000372  9800              LDR      r0,[sp,#0]            ;1569
000374  7800              LDRB     r0,[r0,#0]            ;1569
000376  b118              CBZ      r0,|L11.896|
000378  1e28              SUBS     r0,r5,#0              ;1569
00037a  f1a50501          SUB      r5,r5,#1              ;1569
00037e  d1c2              BNE      |L11.774|
                  |L11.896|
000380  bf00              NOP                            ;1590
000382  9803              LDR      r0,[sp,#0xc]          ;1599
000384  fb0bfb00          MUL      r11,r11,r0            ;1599
000388  f0040002          AND      r0,r4,#2              ;1600
00038c  b998              CBNZ     r0,|L11.950|
00038e  f4045000          AND      r0,r4,#0x2000         ;1659
000392  b138              CBZ      r0,|L11.932|
000394  9806              LDR      r0,[sp,#0x18]         ;1661
000396  6800              LDR      r0,[r0,#0]            ;1661
000398  f8c0b000          STR      r11,[r0,#0]           ;1661
00039c  9806              LDR      r0,[sp,#0x18]         ;1661
00039e  1d00              ADDS     r0,r0,#4              ;1661
0003a0  9006              STR      r0,[sp,#0x18]         ;1661
0003a2  e006              B        |L11.946|
                  |L11.932|
0003a4  9806              LDR      r0,[sp,#0x18]         ;1665
0003a6  6800              LDR      r0,[r0,#0]            ;1665
0003a8  f8c0b000          STR      r11,[r0,#0]           ;1665
0003ac  9806              LDR      r0,[sp,#0x18]         ;1665
0003ae  1d00              ADDS     r0,r0,#4              ;1665
0003b0  9006              STR      r0,[sp,#0x18]         ;1665
                  |L11.946|
0003b2  f10a0a01          ADD      r10,r10,#1            ;1668
                  |L11.950|
0003b6  e001              B        |L11.956|
                  |L11.952|
0003b8  4650              MOV      r0,r10                ;1698
0003ba  e62f              B        |L11.28|
                  |L11.956|
0003bc  bf00              NOP                            ;1494
                  |L11.958|
0003be  9802              LDR      r0,[sp,#8]            ;1285
0003c0  7800              LDRB     r0,[r0,#0]            ;1285
0003c2  b120              CBZ      r0,|L11.974|
0003c4  9800              LDR      r0,[sp,#0]            ;1285
0003c6  7800              LDRB     r0,[r0,#0]            ;1285
0003c8  2800              CMP      r0,#0                 ;1285
0003ca  f47fae2b          BNE      |L11.36|
                  |L11.974|
0003ce  bf00              NOP                            ;1306
0003d0  4650              MOV      r0,r10                ;1702
0003d2  e623              B        |L11.28|
;;;1704   #endif /* SDK_DEBUGCONSOLE */
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;1876   #pragma weak fgetc
;;;1877   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1878   {
000002  4604              MOV      r4,r0
;;;1879       char ch;
;;;1880       /* Do nothing if the debug UART is not initialized. */
;;;1881       if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000004  4807              LDR      r0,|L12.36|
000006  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
000008  b910              CBNZ     r0,|L12.16|
;;;1882       {
;;;1883           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L12.14|
;;;1884       }
;;;1885   
;;;1886       /* Receive data. */
;;;1887       s_debugConsole.ops.rx_union.GetChar(s_debugConsole.base, (uint8_t *)(&ch), 1);
;;;1888       return ch;
;;;1889   }
00000e  bd38              POP      {r3-r5,pc}
                  |L12.16|
000010  4904              LDR      r1,|L12.36|
000012  6848              LDR      r0,[r1,#4]            ;1887  ; s_debugConsole
000014  2201              MOVS     r2,#1                 ;1887
000016  68cb              LDR      r3,[r1,#0xc]          ;1887
000018  4669              MOV      r1,sp                 ;1887
00001a  4798              BLX      r3                    ;1887
00001c  f89d0000          LDRB     r0,[sp,#0]            ;1888
000020  e7f5              B        |L12.14|
;;;1890   #endif /* __ICCARM__ */
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      s_debugConsole

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;1862   #pragma weak fputc
;;;1863   int fputc(int ch, FILE *f)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;1864   {
000002  460c              MOV      r4,r1
;;;1865       /* Do nothing if the debug UART is not initialized. */
;;;1866       if (s_debugConsole.type == DEBUG_CONSOLE_DEVICE_TYPE_NONE)
000004  4806              LDR      r0,|L13.32|
000006  7800              LDRB     r0,[r0,#0]  ; s_debugConsole
000008  b910              CBNZ     r0,|L13.16|
;;;1867       {
;;;1868           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L13.14|
;;;1869       }
;;;1870   
;;;1871       /* Send data. */
;;;1872       s_debugConsole.ops.tx_union.PutChar(s_debugConsole.base, (uint8_t *)(&ch), 1);
;;;1873       return 1;
;;;1874   }
00000e  bd1c              POP      {r2-r4,pc}
                  |L13.16|
000010  4903              LDR      r1,|L13.32|
000012  6848              LDR      r0,[r1,#4]            ;1872  ; s_debugConsole
000014  2201              MOVS     r2,#1                 ;1872
000016  688b              LDR      r3,[r1,#8]            ;1872  ; s_debugConsole
000018  4669              MOV      r1,sp                 ;1872
00001a  4798              BLX      r3                    ;1872
00001c  2001              MOVS     r0,#1                 ;1873
00001e  e7f6              B        |L13.14|
;;;1875   
                          ENDP

                  |L13.32|
                          DCD      s_debugConsole

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_debugConsole
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\System\\utilities\\fsl_debug_console.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_fsl_debug_console_c_eb138075____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_fsl_debug_console_c_eb138075____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_fsl_debug_console_c_eb138075____REVSH|
#line 402
|__asm___19_fsl_debug_console_c_eb138075____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_fsl_debug_console_c_eb138075____RRX|
#line 587
|__asm___19_fsl_debug_console_c_eb138075____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
