; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_sdif.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_sdif.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_sdif.crf SRC\Drivers\fsl_sdif.c]
                          THUMB

                          AREA ||i.SDIF_AbortReadData||, CODE, READONLY, ALIGN=1

                  SDIF_AbortReadData PROC
;;;790    
;;;791    bool SDIF_AbortReadData(SDIF_Type *base, uint32_t timeout)
000000  4602              MOV      r2,r0
;;;792    {
;;;793        /* assert this bit to reset the data machine to abort the read data */
;;;794        base->CTRL |= SDIF_CTRL_ABORT_READ_DATA_MASK;
000002  6810              LDR      r0,[r2,#0]
000004  f4407080          ORR      r0,r0,#0x100
000008  6010              STR      r0,[r2,#0]
;;;795        /* polling the bit self clear */
;;;796        while (base->CTRL & SDIF_CTRL_ABORT_READ_DATA_MASK == SDIF_CTRL_ABORT_READ_DATA_MASK)
00000a  e002              B        |L1.18|
                  |L1.12|
;;;797        {
;;;798            if (!timeout)
00000c  b901              CBNZ     r1,|L1.16|
;;;799            {
;;;800                break;
00000e  e005              B        |L1.28|
                  |L1.16|
;;;801            }
;;;802            timeout--;
000010  1e49              SUBS     r1,r1,#1
                  |L1.18|
000012  6810              LDR      r0,[r2,#0]            ;796
000014  f0000001          AND      r0,r0,#1              ;796
000018  2800              CMP      r0,#0                 ;796
00001a  d1f7              BNE      |L1.12|
                  |L1.28|
00001c  bf00              NOP                            ;800
;;;803        }
;;;804    
;;;805        return base->CTRL & SDIF_CTRL_ABORT_READ_DATA_MASK ? false : true;
00001e  6810              LDR      r0,[r2,#0]
000020  2301              MOVS     r3,#1
000022  ea232010          BIC      r0,r3,r0,LSR #8
;;;806    }
000026  4770              BX       lr
;;;807    
                          ENDP


                          AREA ||i.SDIF_ClearInternalDMAStatus||, CODE, READONLY, ALIGN=1

                  SDIF_ClearInternalDMAStatus PROC
;;;683     */
;;;684    static inline void SDIF_ClearInternalDMAStatus(SDIF_Type *base, uint32_t mask)
000000  f8d0208c          LDR      r2,[r0,#0x8c]
;;;685    {
;;;686        base->IDSTS &= mask;
000004  400a              ANDS     r2,r2,r1
000006  f8c0208c          STR      r2,[r0,#0x8c]
;;;687    }
00000a  4770              BX       lr
;;;688    
                          ENDP


                          AREA ||i.SDIF_ClearInterruptStatus||, CODE, READONLY, ALIGN=1

                  SDIF_ClearInterruptStatus PROC
;;;630     */
;;;631    static inline void SDIF_ClearInterruptStatus(SDIF_Type *base, uint32_t mask)
000000  6c42              LDR      r2,[r0,#0x44]
;;;632    {
;;;633        base->RINTSTS &= mask;
000002  400a              ANDS     r2,r2,r1
000004  6442              STR      r2,[r0,#0x44]
;;;634    }
000006  4770              BX       lr
;;;635    
                          ENDP


                          AREA ||i.SDIF_ConfigClockDelay||, CODE, READONLY, ALIGN=2

                  SDIF_ConfigClockDelay PROC
;;;681    
;;;682    void SDIF_ConfigClockDelay(uint32_t target_HZ, uint32_t divider)
000000  4a0f              LDR      r2,|L4.64|
;;;683    {
;;;684        /*config the clock delay and pharse shift
;;;685         *should config the clk_in_drv,
;;;686         *clk_in_sample to meet the min hold and
;;;687         *setup time
;;;688         */
;;;689        if (target_HZ <= kSDIF_Freq400KHZ)
000002  4290              CMP      r0,r2
000004  d803              BHI      |L4.14|
;;;690        {
;;;691            /*min hold time:5ns
;;;692            * min setup time: 5ns
;;;693            * delay = (x+1)*250ps
;;;694            */
;;;695            SYSCON->SDIOCLKCTRL = SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_MASK |
000006  4a0f              LDR      r2,|L4.68|
000008  4b0f              LDR      r3,|L4.72|
00000a  601a              STR      r2,[r3,#0]
00000c  e017              B        |L4.62|
                  |L4.14|
;;;696                                  SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY(SDIF_INDENTIFICATION_MODE_SAMPLE_DELAY) |
;;;697                                  SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_MASK |
;;;698                                  SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY(SDIF_INDENTIFICATION_MODE_DRV_DELAY);
;;;699        }
;;;700        else if (target_HZ >= kSDIF_Freq50MHZ)
00000e  4a0f              LDR      r2,|L4.76|
000010  4290              CMP      r0,r2
000012  d30a              BCC      |L4.42|
;;;701        {
;;;702            /*
;;;703            * user need to pay attention to this parameter
;;;704            * can be change the setting for you card and board
;;;705            * min hold time:2ns
;;;706            * min setup time: 6ns
;;;707            * delay = (x+1)*250ps
;;;708            */
;;;709            SYSCON->SDIOCLKCTRL = SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_MASK |
000014  4a0e              LDR      r2,|L4.80|
000016  4b0c              LDR      r3,|L4.72|
000018  601a              STR      r2,[r3,#0]
;;;710                                  SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY(SDIF_HIGHSPEED_50MHZ_SAMPLE_DELAY) |
;;;711                                  SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_MASK |
;;;712                                  SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY(SDIF_HIGHSPEED_50MHZ_DRV_DELAY);
;;;713            /* means the input clock = 2 * card clock,
;;;714            * can use clock pharse shift tech
;;;715            */
;;;716            if (divider == 1U)
00001a  2901              CMP      r1,#1
00001c  d10f              BNE      |L4.62|
;;;717            {
;;;718                SYSCON->SDIOCLKCTRL |= SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_MASK |
00001e  461a              MOV      r2,r3
000020  6812              LDR      r2,[r2,#0]
000022  f0420286          ORR      r2,r2,#0x86
000026  601a              STR      r2,[r3,#0]
000028  e009              B        |L4.62|
                  |L4.42|
;;;719                                       SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE(kSDIF_ClcokPharseShift90) |
;;;720                                       SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE(kSDIF_ClcokPharseShift180);
;;;721            }
;;;722        }
;;;723        else
;;;724        {
;;;725            /*
;;;726            * user need to pay attention to this parameter
;;;727            * can be change the setting for you card and board
;;;728            * min hold time:5ns
;;;729            * min setup time: 5ns
;;;730            * delay = (x+1)*250ps
;;;731            */
;;;732            SYSCON->SDIOCLKCTRL = SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_MASK |
00002a  4a0a              LDR      r2,|L4.84|
00002c  4b06              LDR      r3,|L4.72|
00002e  601a              STR      r2,[r3,#0]
;;;733                                  SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY(SDIF_HIGHSPEED_25MHZ_SAMPLE_DELAY) |
;;;734                                  SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_MASK |
;;;735                                  SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY(SDIF_HIGHSPEED_25MHZ_DRV_DELAY);
;;;736            /* means the input clock = 2 * card clock,
;;;737            * can use clock pharse shift tech
;;;738            */
;;;739            if (divider == 1U)
000030  2901              CMP      r1,#1
000032  d104              BNE      |L4.62|
;;;740            {
;;;741                SYSCON->SDIOCLKCTRL |= SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_MASK |
000034  461a              MOV      r2,r3
000036  6812              LDR      r2,[r2,#0]
000038  f0420285          ORR      r2,r2,#0x85
00003c  601a              STR      r2,[r3,#0]
                  |L4.62|
;;;742                                       SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE(kSDIF_ClcokPharseShift90) |
;;;743                                       SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE(kSDIF_ClcokPharseShift90);
;;;744            }
;;;745        }
;;;746    }
00003e  4770              BX       lr
;;;747    
                          ENDP

                  |L4.64|
                          DCD      0x00061a80
                  |L4.68|
                          DCD      0x97970000
                  |L4.72|
                          DCD      0x40000460
                  |L4.76|
                          DCD      0x02faf080
                  |L4.80|
                          DCD      0x9f9f0000
                  |L4.84|
                          DCD      0x90900000

                          AREA ||i.SDIF_Deinit||, CODE, READONLY, ALIGN=2

                  SDIF_Deinit PROC
;;;1273   
;;;1274   void SDIF_Deinit(SDIF_Type *base)
000000  b510              PUSH     {r4,lr}
;;;1275   {
000002  4604              MOV      r4,r0
;;;1276       /* disable clock here*/
;;;1277       CLOCK_DisableClock(kCLOCK_Sdio);
000004  f2402003          MOV      r0,#0x203
000008  0a01              LSRS     r1,r0,#8
00000a  2903              CMP      r1,#3
00000c  d205              BCS      |L5.26|
00000e  2201              MOVS     r2,#1
000010  4082              LSLS     r2,r2,r0
000012  4b0b              LDR      r3,|L5.64|
000014  f8432021          STR      r2,[r3,r1,LSL #2]
000018  e006              B        |L5.40|
                  |L5.26|
00001a  2201              MOVS     r2,#1
00001c  4082              LSLS     r2,r2,r0
00001e  4b09              LDR      r3,|L5.68|
000020  619a              STR      r2,[r3,#0x18]
000022  2200              MOVS     r2,#0
000024  031b              LSLS     r3,r3,#12
000026  64da              STR      r2,[r3,#0x4c]
                  |L5.40|
000028  bf00              NOP      
;;;1278       /* disable the SDIOCLKCTRL */
;;;1279       SYSCON->SDIOCLKCTRL &= ~(SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_MASK |
00002a  4807              LDR      r0,|L5.72|
00002c  6800              LDR      r0,[r0,#0]
00002e  4907              LDR      r1,|L5.76|
000030  4008              ANDS     r0,r0,r1
000032  4905              LDR      r1,|L5.72|
000034  6008              STR      r0,[r1,#0]
;;;1280                                SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_MASK | SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_MASK);
;;;1281       RESET_PeripheralReset(kSDIO_RST_SHIFT_RSTn);
000036  4806              LDR      r0,|L5.80|
000038  f7fffffe          BL       RESET_PeripheralReset
;;;1282   }
00003c  bd10              POP      {r4,pc}
;;;1283   
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x40000240
                  |L5.68|
                          DCD      0x40040000
                  |L5.72|
                          DCD      0x40000460
                  |L5.76|
                          DCD      0x7f7fff7f
                  |L5.80|
                          DCD      0x00020003

                          AREA ||i.SDIF_EnableCardClock||, CODE, READONLY, ALIGN=1

                  SDIF_EnableCardClock PROC
;;;472     */
;;;473    static inline void SDIF_EnableCardClock(SDIF_Type *base, bool enable)
000000  b121              CBZ      r1,|L6.12|
;;;474    {
;;;475        if (enable)
;;;476        {
;;;477            base->CLKENA |= SDIF_CLKENA_CCLK_ENABLE_MASK;
000002  6902              LDR      r2,[r0,#0x10]
000004  f0420201          ORR      r2,r2,#1
000008  6102              STR      r2,[r0,#0x10]
00000a  e003              B        |L6.20|
                  |L6.12|
;;;478        }
;;;479        else
;;;480        {
;;;481            base->CLKENA &= ~SDIF_CLKENA_CCLK_ENABLE_MASK;
00000c  6902              LDR      r2,[r0,#0x10]
00000e  f0220201          BIC      r2,r2,#1
000012  6102              STR      r2,[r0,#0x10]
                  |L6.20|
;;;482        }
;;;483    }
000014  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.SDIF_GetCapability||, CODE, READONLY, ALIGN=2

                  SDIF_GetCapability PROC
;;;1119   
;;;1120   void SDIF_GetCapability(SDIF_Type *base, sdif_capability_t *capability)
000000  b570              PUSH     {r4-r6,lr}
;;;1121   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1122       assert(NULL != capability);
000006  b104              CBZ      r4,|L7.10|
000008  e005              B        |L7.22|
                  |L7.10|
00000a  f2404262          MOV      r2,#0x462
00000e  a108              ADR      r1,|L7.48|
000010  a00d              ADR      r0,|L7.72|
000012  f7fffffe          BL       __aeabi_assert
                  |L7.22|
;;;1123   
;;;1124       capability->sdVersion = SDIF_SUPPORT_SD_VERSION;
000016  2020              MOVS     r0,#0x20
000018  6020              STR      r0,[r4,#0]
;;;1125       capability->mmcVersion = SDIF_SUPPORT_MMC_VERSION;
00001a  2044              MOVS     r0,#0x44
00001c  6060              STR      r0,[r4,#4]
;;;1126       capability->maxBlockLength = SDIF_BLKSIZ_BLOCK_SIZE_MASK;
00001e  f64f70ff          MOV      r0,#0xffff
000022  60a0              STR      r0,[r4,#8]
;;;1127       /* set the max block count = max byte conut / max block size */
;;;1128       capability->maxBlockCount = SDIF_BYTCNT_BYTE_COUNT_MASK / SDIF_BLKSIZ_BLOCK_SIZE_MASK;
000024  1c80              ADDS     r0,r0,#2
000026  60e0              STR      r0,[r4,#0xc]
;;;1129       capability->flags = kSDIF_SupportHighSpeedFlag | kSDIF_SupportDmaFlag | kSDIF_SupportSuspendResumeFlag |
000028  203f              MOVS     r0,#0x3f
00002a  6120              STR      r0,[r4,#0x10]
;;;1130                           kSDIF_SupportV330Flag | kSDIF_Support4BitFlag | kSDIF_Support8BitFlag;
;;;1131   }
00002c  bd70              POP      {r4-r6,pc}
;;;1132   
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
000030  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000034  44726976
000038  6572735c
00003c  66736c5f
000040  73646966
000044  2e6300  
000047  00                DCB      0
                  |L7.72|
000048  4e554c4c          DCB      "NULL != capability",0
00004c  20213d20
000050  63617061
000054  62696c69
000058  747900  
00005b  00                DCB      0

                          AREA ||i.SDIF_GetInstance||, CODE, READONLY, ALIGN=2

                  SDIF_GetInstance PROC
;;;171     ******************************************************************************/
;;;172    static uint32_t SDIF_GetInstance(SDIF_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;173    {
000002  4605              MOV      r5,r0
;;;174        uint8_t instance = 0U;
000004  2400              MOVS     r4,#0
;;;175    
;;;176        while ((instance < FSL_FEATURE_SOC_SDIF_COUNT) && (s_sdifBase[instance] != base))
000006  e001              B        |L8.12|
                  |L8.8|
;;;177        {
;;;178            instance++;
000008  1c60              ADDS     r0,r4,#1
00000a  b2c4              UXTB     r4,r0
                  |L8.12|
00000c  2c01              CMP      r4,#1                 ;176
00000e  da04              BGE      |L8.26|
000010  4807              LDR      r0,|L8.48|
000012  f8500024          LDR      r0,[r0,r4,LSL #2]     ;176
000016  42a8              CMP      r0,r5                 ;176
000018  d1f6              BNE      |L8.8|
                  |L8.26|
;;;179        }
;;;180    
;;;181        assert(instance < FSL_FEATURE_SOC_SDIF_COUNT);
00001a  2c01              CMP      r4,#1
00001c  da00              BGE      |L8.32|
00001e  e004              B        |L8.42|
                  |L8.32|
000020  22b5              MOVS     r2,#0xb5
000022  a104              ADR      r1,|L8.52|
000024  a009              ADR      r0,|L8.76|
000026  f7fffffe          BL       __aeabi_assert
                  |L8.42|
;;;182    
;;;183        return instance;
00002a  4620              MOV      r0,r4
;;;184    }
00002c  bd70              POP      {r4-r6,pc}
;;;185    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      s_sdifBase
                  |L8.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  73646966
000048  2e6300  
00004b  00                DCB      0
                  |L8.76|
00004c  696e7374          DCB      "instance < FSL_FEATURE_SOC_SDIF_COUNT",0
000050  616e6365
000054  203c2046
000058  534c5f46
00005c  45415455
000060  52455f53
000064  4f435f53
000068  4449465f
00006c  434f554e
000070  5400    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.SDIF_GetInterruptStatus||, CODE, READONLY, ALIGN=1

                  SDIF_GetInterruptStatus PROC
;;;620     */
;;;621    static inline uint32_t SDIF_GetInterruptStatus(SDIF_Type *base)
000000  4601              MOV      r1,r0
;;;622    {
;;;623        return base->MINTSTS;
000002  6c08              LDR      r0,[r1,#0x40]
;;;624    }
000004  4770              BX       lr
;;;625    
                          ENDP


                          AREA ||i.SDIF_Init||, CODE, READONLY, ALIGN=2

                  SDIF_Init PROC
;;;950    
;;;951    void SDIF_Init(SDIF_Type *base, sdif_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;952    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;953        assert(NULL != config);
000006  b105              CBZ      r5,|L10.10|
000008  e005              B        |L10.22|
                  |L10.10|
00000a  f24032b9          MOV      r2,#0x3b9
00000e  a11f              ADR      r1,|L10.140|
000010  a024              ADR      r0,|L10.164|
000012  f7fffffe          BL       __aeabi_assert
                  |L10.22|
;;;954    
;;;955        uint32_t timeout;
;;;956    
;;;957        /* enable SDIF clock */
;;;958        CLOCK_EnableClock(kCLOCK_Sdio);
000016  f2402003          MOV      r0,#0x203
00001a  0a01              LSRS     r1,r0,#8
00001c  2903              CMP      r1,#3
00001e  d205              BCS      |L10.44|
000020  2201              MOVS     r2,#1
000022  4082              LSLS     r2,r2,r0
000024  4b23              LDR      r3,|L10.180|
000026  f8432021          STR      r2,[r3,r1,LSL #2]
00002a  e005              B        |L10.56|
                  |L10.44|
00002c  2201              MOVS     r2,#1
00002e  0793              LSLS     r3,r2,#30
000030  64da              STR      r2,[r3,#0x4c]
000032  4082              LSLS     r2,r2,r0
000034  4b20              LDR      r3,|L10.184|
000036  615a              STR      r2,[r3,#0x14]
                  |L10.56|
000038  bf00              NOP      
;;;959    
;;;960        /* do software reset */
;;;961        base->BMOD |= SDIF_BMOD_SWR_MASK;
00003a  f8d40080          LDR      r0,[r4,#0x80]
00003e  f0400001          ORR      r0,r0,#1
000042  f8c40080          STR      r0,[r4,#0x80]
;;;962    
;;;963        /* reset all */
;;;964        SDIF_Reset(base, kSDIF_ResetAll, SDIF_TIMEOUT_VALUE);
000046  f64f72ff          MOV      r2,#0xffff
00004a  2107              MOVS     r1,#7
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       SDIF_Reset
;;;965    
;;;966        /*config timeout register */
;;;967        timeout = base->TMOUT;
000052  6966              LDR      r6,[r4,#0x14]
;;;968        timeout &= ~(SDIF_TMOUT_RESPONSE_TIMEOUT_MASK | SDIF_TMOUT_DATA_TIMEOUT_MASK);
000054  2600              MOVS     r6,#0
;;;969        timeout |= SDIF_TMOUT_RESPONSE_TIMEOUT(config->responseTimeout) | SDIF_TMOUT_DATA_TIMEOUT(config->dataTimeout);
000056  7828              LDRB     r0,[r5,#0]
000058  68e9              LDR      r1,[r5,#0xc]
00005a  f361201f          BFI      r0,r1,#8,#24
00005e  4306              ORRS     r6,r6,r0
;;;970    
;;;971        base->TMOUT = timeout;
000060  6166              STR      r6,[r4,#0x14]
;;;972    
;;;973        /* config the card detect debounce clock count */
;;;974        base->DEBNCE = SDIF_DEBNCE_DEBOUNCE_COUNT(config->cardDetDebounce_Clock);
000062  6868              LDR      r0,[r5,#4]
000064  f020407f          BIC      r0,r0,#0xff000000
000068  6660              STR      r0,[r4,#0x64]
;;;975    
;;;976        /*config the watermark/burst transfer value */
;;;977        base->FIFOTH =
00006a  4814              LDR      r0,|L10.188|
00006c  64e0              STR      r0,[r4,#0x4c]
;;;978            SDIF_FIFOTH_TX_WMARK(SDIF_TX_WATERMARK) | SDIF_FIFOTH_RX_WMARK(SDIF_RX_WATERMARK) | SDIF_FIFOTH_DMA_MTS(1U);
;;;979    
;;;980        /* enable the interrupt status  */
;;;981        SDIF_EnableInterrupt(base, kSDIF_AllInterruptStatus);
00006e  4814              LDR      r0,|L10.192|
000070  6a61              LDR      r1,[r4,#0x24]
000072  4301              ORRS     r1,r1,r0
000074  6261              STR      r1,[r4,#0x24]
000076  bf00              NOP      
;;;982    
;;;983        /* clear all interrupt/DMA status */
;;;984        SDIF_ClearInterruptStatus(base, kSDIF_AllInterruptStatus);
000078  4601              MOV      r1,r0
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       SDIF_ClearInterruptStatus
;;;985        SDIF_ClearInternalDMAStatus(base, kSDIF_DMAAllStatus);
000080  f2403137          MOV      r1,#0x337
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       SDIF_ClearInternalDMAStatus
;;;986    }
00008a  bd70              POP      {r4-r6,pc}
;;;987    
                          ENDP

                  |L10.140|
00008c  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000090  44726976
000094  6572735c
000098  66736c5f
00009c  73646966
0000a0  2e6300  
0000a3  00                DCB      0
                  |L10.164|
0000a4  4e554c4c          DCB      "NULL != config",0
0000a8  20213d20
0000ac  636f6e66
0000b0  696700  
0000b3  00                DCB      0
                  |L10.180|
                          DCD      0x40000220
                  |L10.184|
                          DCD      0x40040000
                  |L10.188|
                          DCD      0x100f0010
                  |L10.192|
                          DCD      0x0001ffff

                          AREA ||i.SDIF_InternalDMAConfig||, CODE, READONLY, ALIGN=2

                  SDIF_InternalDMAConfig PROC
;;;807    
;;;808    status_t SDIF_InternalDMAConfig(SDIF_Type *base, sdif_dma_config_t *config, const uint32_t *data, uint32_t dataSize)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;809    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  461d              MOV      r5,r3
;;;810        assert(NULL != config);
00000c  b107              CBZ      r7,|L11.16|
00000e  e005              B        |L11.28|
                  |L11.16|
000010  f240322a          MOV      r2,#0x32a
000014  a17a              ADR      r1,|L11.512|
000016  a080              ADR      r0,|L11.536|
000018  f7fffffe          BL       __aeabi_assert
                  |L11.28|
;;;811        assert(NULL != data);
00001c  9805              LDR      r0,[sp,#0x14]
00001e  b100              CBZ      r0,|L11.34|
000020  e005              B        |L11.46|
                  |L11.34|
000022  f240322b          MOV      r2,#0x32b
000026  a176              ADR      r1,|L11.512|
000028  a07f              ADR      r0,|L11.552|
00002a  f7fffffe          BL       __aeabi_assert
                  |L11.46|
;;;812    
;;;813        uint32_t dmaEntry = 0U, i, dmaBufferSize = 0U, dmaBuffer1Size = 0U;
00002e  2000              MOVS     r0,#0
000030  9002              STR      r0,[sp,#8]
000032  4681              MOV      r9,r0
000034  9001              STR      r0,[sp,#4]
;;;814        uint32_t *tempDMADesBuffer = config->dmaDesBufferStartAddr;
000036  f8d7a004          LDR      r10,[r7,#4]
;;;815        const uint32_t *dataBuffer = data;
00003a  f8ddb014          LDR      r11,[sp,#0x14]
;;;816        sdif_dma_descriptor_t *descriptorPoniter = NULL;
00003e  2400              MOVS     r4,#0
;;;817        uint32_t maxDMABuffer = FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE * (config->mode);
000040  7878              LDRB     r0,[r7,#1]
000042  0300              LSLS     r0,r0,#12
000044  9000              STR      r0,[sp,#0]
;;;818    
;;;819        /* check the dma descriptor buffer length , it is user's responsibility to make sure the DMA descriptor table
;;;820        size is bigger enough to hold the transfer descriptor */
;;;821        if (config->dmaDesBufferLen * sizeof(uint32_t) < sizeof(sdif_dma_descriptor_t))
000046  2110              MOVS     r1,#0x10
000048  68b8              LDR      r0,[r7,#8]
00004a  ebb10f80          CMP      r1,r0,LSL #2
00004e  d904              BLS      |L11.90|
;;;822        {
;;;823            return kStatus_SDIF_DescriptorBufferLenError;
000050  f241700c          MOV      r0,#0x170c
                  |L11.84|
;;;824        }
;;;825    
;;;826        /* check the read/write data size,must be a multiple of 4 */
;;;827        if (dataSize % sizeof(uint32_t) != 0U)
;;;828        {
;;;829            dataSize += sizeof(uint32_t) - (dataSize % sizeof(uint32_t));
;;;830        }
;;;831    
;;;832        /*config the bus mode*/
;;;833        if (config->enableFixBurstLen)
;;;834        {
;;;835            base->BMOD |= SDIF_BMOD_FB_MASK;
;;;836        }
;;;837    
;;;838        /* calucate the dma descriptor entry due to DMA buffer size limit */
;;;839        /* if datasize smaller than one descriptor buffer size */
;;;840        if (dataSize > maxDMABuffer)
;;;841        {
;;;842            dmaEntry = dataSize / maxDMABuffer + (dataSize % maxDMABuffer ? 1U : 0U);
;;;843        }
;;;844        else /* need one dma descriptor */
;;;845        {
;;;846            dmaEntry = 1U;
;;;847        }
;;;848    
;;;849        /* check the DMA descriptor buffer len one more time,it is user's responsibility to make sure the DMA descriptor
;;;850        table
;;;851        size is bigger enough to hold the transfer descriptor */
;;;852        if (config->dmaDesBufferLen * sizeof(uint32_t) < (dmaEntry * sizeof(sdif_dma_descriptor_t) + config->dmaDesSkipLen))
;;;853        {
;;;854            return kStatus_SDIF_DescriptorBufferLenError;
;;;855        }
;;;856    
;;;857        switch (config->mode)
;;;858        {
;;;859            case kSDIF_DualDMAMode:
;;;860                base->BMOD |= SDIF_BMOD_DSL(config->dmaDesSkipLen); /* config the distance between the DMA descriptor */
;;;861                for (i = 0U; i < dmaEntry; i++)
;;;862                {
;;;863                    if (dataSize > FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE)
;;;864                    {
;;;865                        dmaBufferSize = FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE;
;;;866                        dataSize -= dmaBufferSize;
;;;867                        dmaBuffer1Size = dataSize > FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE ?
;;;868                                             FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE :
;;;869                                             dataSize;
;;;870                        dataSize -= dmaBuffer1Size;
;;;871                    }
;;;872                    else
;;;873                    {
;;;874                        dmaBufferSize = dataSize;
;;;875                        dmaBuffer1Size = 0U;
;;;876                    }
;;;877    
;;;878                    descriptorPoniter = (sdif_dma_descriptor_t *)tempDMADesBuffer;
;;;879                    if (i == 0U)
;;;880                    {
;;;881                        descriptorPoniter->dmaDesAttribute = kSDIF_DMADescriptorDataBufferStart;
;;;882                    }
;;;883                    descriptorPoniter->dmaDesAttribute |= kSDIF_DMADescriptorOwnByDMA | kSDIF_DisableCompleteInterrupt;
;;;884                    descriptorPoniter->dmaDataBufferSize =
;;;885                        SDIF_DMA_DESCRIPTOR_BUFFER1_SIZE(dmaBufferSize) | SDIF_DMA_DESCRIPTOR_BUFFER2_SIZE(dmaBuffer1Size);
;;;886    
;;;887                    descriptorPoniter->dmaDataBufferAddr0 = dataBuffer;
;;;888                    descriptorPoniter->dmaDataBufferAddr1 = dataBuffer + dmaBufferSize / sizeof(uint32_t);
;;;889                    dataBuffer += (dmaBufferSize + dmaBuffer1Size) / sizeof(uint32_t);
;;;890    
;;;891                    /* descriptor skip length */
;;;892                    tempDMADesBuffer += config->dmaDesSkipLen + sizeof(sdif_dma_descriptor_t) / sizeof(uint32_t);
;;;893                }
;;;894                /* enable the completion interrupt when reach the last descriptor */
;;;895                descriptorPoniter->dmaDesAttribute &= ~kSDIF_DisableCompleteInterrupt;
;;;896                descriptorPoniter->dmaDesAttribute |= kSDIF_DMADescriptorDataBufferEnd | kSDIF_DMADescriptorEnd;
;;;897                break;
;;;898    
;;;899            case kSDIF_ChainDMAMode:
;;;900                for (i = 0U; i < dmaEntry; i++)
;;;901                {
;;;902                    if (dataSize > FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE)
;;;903                    {
;;;904                        dmaBufferSize = FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE;
;;;905                        dataSize -= FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE;
;;;906                    }
;;;907                    else
;;;908                    {
;;;909                        dmaBufferSize = dataSize;
;;;910                    }
;;;911    
;;;912                    descriptorPoniter = (sdif_dma_descriptor_t *)tempDMADesBuffer;
;;;913                    if (i == 0U)
;;;914                    {
;;;915                        descriptorPoniter->dmaDesAttribute = kSDIF_DMADescriptorDataBufferStart;
;;;916                    }
;;;917                    descriptorPoniter->dmaDesAttribute |=
;;;918                        kSDIF_DMADescriptorOwnByDMA | kSDIF_DMASecondAddrChained | kSDIF_DisableCompleteInterrupt;
;;;919                    descriptorPoniter->dmaDataBufferSize =
;;;920                        SDIF_DMA_DESCRIPTOR_BUFFER1_SIZE(dmaBufferSize); /* use only buffer 1 for data buffer*/
;;;921                    descriptorPoniter->dmaDataBufferAddr0 = dataBuffer;
;;;922                    dataBuffer += dmaBufferSize / sizeof(uint32_t);
;;;923                    tempDMADesBuffer +=
;;;924                        sizeof(sdif_dma_descriptor_t) / sizeof(uint32_t); /* calucate the next descriptor address */
;;;925                    /* this descriptor buffer2 pointer to the next descriptor address */
;;;926                    descriptorPoniter->dmaDataBufferAddr1 = tempDMADesBuffer;
;;;927                }
;;;928                /* enable the completion interrupt when reach the last descriptor */
;;;929                descriptorPoniter->dmaDesAttribute &= ~kSDIF_DisableCompleteInterrupt;
;;;930                descriptorPoniter->dmaDesAttribute |= kSDIF_DMADescriptorDataBufferEnd;
;;;931                break;
;;;932    
;;;933            default:
;;;934                break;
;;;935        }
;;;936    
;;;937        /* use internal DMA interface */
;;;938        base->CTRL |= SDIF_CTRL_USE_INTERNAL_DMAC_MASK;
;;;939        /* enable the internal SD/MMC DMA */
;;;940        base->BMOD |= SDIF_BMOD_DE_MASK;
;;;941        /* enable DMA status check */
;;;942        base->IDINTEN |= kSDIF_DMAAllStatus;
;;;943        /* clear write/read FIFO request interrupt in DMA mode, DMA will handle the data transfer*/
;;;944        SDIF_DisableInterrupt(base, kSDIF_WriteFIFORequest | kSDIF_ReadFIFORequest | kSDIF_DataTransferOver);
;;;945        /* load DMA descriptor buffer address */
;;;946        base->DBADDR = (uint32_t)config->dmaDesBufferStartAddr;
;;;947    
;;;948        return kStatus_Success;
;;;949    }
000054  b007              ADD      sp,sp,#0x1c
000056  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.90|
00005a  f0050003          AND      r0,r5,#3              ;827
00005e  b120              CBZ      r0,|L11.106|
000060  f0050003          AND      r0,r5,#3              ;829
000064  f1c00004          RSB      r0,r0,#4              ;829
000068  4405              ADD      r5,r5,r0              ;829
                  |L11.106|
00006a  7838              LDRB     r0,[r7,#0]            ;833
00006c  b128              CBZ      r0,|L11.122|
00006e  f8d60080          LDR      r0,[r6,#0x80]         ;835
000072  f0400002          ORR      r0,r0,#2              ;835
000076  f8c60080          STR      r0,[r6,#0x80]         ;835
                  |L11.122|
00007a  9800              LDR      r0,[sp,#0]            ;840
00007c  4285              CMP      r5,r0                 ;840
00007e  d90d              BLS      |L11.156|
000080  9800              LDR      r0,[sp,#0]            ;842
000082  fbb5f1f0          UDIV     r1,r5,r0              ;842
000086  fbb5f2f0          UDIV     r2,r5,r0              ;842
00008a  fb005012          MLS      r0,r0,r2,r5           ;842
00008e  b108              CBZ      r0,|L11.148|
000090  2001              MOVS     r0,#1                 ;842
000092  e000              B        |L11.150|
                  |L11.148|
000094  2000              MOVS     r0,#0                 ;842
                  |L11.150|
000096  4408              ADD      r0,r0,r1              ;842
000098  9002              STR      r0,[sp,#8]            ;842
00009a  e001              B        |L11.160|
                  |L11.156|
00009c  2001              MOVS     r0,#1                 ;846
00009e  9002              STR      r0,[sp,#8]            ;846
                  |L11.160|
0000a0  78b9              LDRB     r1,[r7,#2]            ;852
0000a2  9802              LDR      r0,[sp,#8]            ;852
0000a4  eb011100          ADD      r1,r1,r0,LSL #4       ;852
0000a8  68b8              LDR      r0,[r7,#8]            ;852
0000aa  ebb10f80          CMP      r1,r0,LSL #2          ;852
0000ae  d902              BLS      |L11.182|
0000b0  f241700c          MOV      r0,#0x170c            ;854
0000b4  e7ce              B        |L11.84|
                  |L11.182|
0000b6  7878              LDRB     r0,[r7,#1]            ;857
0000b8  2801              CMP      r0,#1                 ;857
0000ba  d050              BEQ      |L11.350|
0000bc  2802              CMP      r0,#2                 ;857
0000be  d17d              BNE      |L11.444|
0000c0  f8d60080          LDR      r0,[r6,#0x80]         ;860
0000c4  78b9              LDRB     r1,[r7,#2]            ;860
0000c6  227c              MOVS     r2,#0x7c              ;860
0000c8  ea020181          AND      r1,r2,r1,LSL #2       ;860
0000cc  4308              ORRS     r0,r0,r1              ;860
0000ce  f8c60080          STR      r0,[r6,#0x80]         ;860
0000d2  f04f0800          MOV      r8,#0                 ;861
0000d6  e036              B        |L11.326|
                  |L11.216|
0000d8  f5b55f80          CMP      r5,#0x1000            ;863
0000dc  d90d              BLS      |L11.250|
0000de  f44f5980          MOV      r9,#0x1000            ;865
0000e2  eba50509          SUB      r5,r5,r9              ;866
0000e6  f5b55f80          CMP      r5,#0x1000            ;867
0000ea  d901              BLS      |L11.240|
0000ec  4648              MOV      r0,r9                 ;868
0000ee  e000              B        |L11.242|
                  |L11.240|
0000f0  4628              MOV      r0,r5                 ;869
                  |L11.242|
0000f2  9001              STR      r0,[sp,#4]            ;869
0000f4  9801              LDR      r0,[sp,#4]            ;870
0000f6  1a2d              SUBS     r5,r5,r0              ;870
0000f8  e002              B        |L11.256|
                  |L11.250|
0000fa  46a9              MOV      r9,r5                 ;874
0000fc  2000              MOVS     r0,#0                 ;875
0000fe  9001              STR      r0,[sp,#4]            ;875
                  |L11.256|
000100  4654              MOV      r4,r10                ;878
000102  f1b80f00          CMP      r8,#0                 ;879
000106  d101              BNE      |L11.268|
000108  2008              MOVS     r0,#8                 ;881
00010a  6020              STR      r0,[r4,#0]            ;881
                  |L11.268|
00010c  494a              LDR      r1,|L11.568|
00010e  6820              LDR      r0,[r4,#0]            ;883
000110  4308              ORRS     r0,r0,r1              ;883
000112  6020              STR      r0,[r4,#0]            ;883
000114  9801              LDR      r0,[sp,#4]            ;884
000116  f3c0010c          UBFX     r1,r0,#0,#13          ;884
00011a  4648              MOV      r0,r9                 ;884
00011c  f361305f          BFI      r0,r1,#13,#19         ;884
000120  6060              STR      r0,[r4,#4]            ;884
000122  f8c4b008          STR      r11,[r4,#8]           ;887
000126  ea4f0099          LSR      r0,r9,#2              ;888
00012a  eb0b0080          ADD      r0,r11,r0,LSL #2      ;888
00012e  60e0              STR      r0,[r4,#0xc]          ;888
000130  9801              LDR      r0,[sp,#4]            ;889
000132  4448              ADD      r0,r0,r9              ;889
000134  0880              LSRS     r0,r0,#2              ;889
000136  eb0b0b80          ADD      r11,r11,r0,LSL #2     ;889
00013a  78b8              LDRB     r0,[r7,#2]            ;892
00013c  1d00              ADDS     r0,r0,#4              ;892
00013e  eb0a0a80          ADD      r10,r10,r0,LSL #2     ;892
000142  f1080801          ADD      r8,r8,#1              ;861
                  |L11.326|
000146  9802              LDR      r0,[sp,#8]            ;861
000148  4580              CMP      r8,r0                 ;861
00014a  d3c5              BCC      |L11.216|
00014c  6820              LDR      r0,[r4,#0]            ;895
00014e  f0200002          BIC      r0,r0,#2              ;895
000152  6020              STR      r0,[r4,#0]            ;895
000154  6820              LDR      r0,[r4,#0]            ;896
000156  f0400024          ORR      r0,r0,#0x24           ;896
00015a  6020              STR      r0,[r4,#0]            ;896
00015c  e034              B        |L11.456|
                  |L11.350|
00015e  f04f0800          MOV      r8,#0                 ;900
000162  e022              B        |L11.426|
                  |L11.356|
000164  f5b55f80          CMP      r5,#0x1000            ;902
000168  d904              BLS      |L11.372|
00016a  f44f5980          MOV      r9,#0x1000            ;904
00016e  f5a55580          SUB      r5,r5,#0x1000         ;905
000172  e000              B        |L11.374|
                  |L11.372|
000174  46a9              MOV      r9,r5                 ;909
                  |L11.374|
000176  4654              MOV      r4,r10                ;912
000178  f1b80f00          CMP      r8,#0                 ;913
00017c  d101              BNE      |L11.386|
00017e  2008              MOVS     r0,#8                 ;915
000180  6020              STR      r0,[r4,#0]            ;915
                  |L11.386|
000182  492d              LDR      r1,|L11.568|
000184  3110              ADDS     r1,r1,#0x10           ;917
000186  6820              LDR      r0,[r4,#0]            ;917
000188  4308              ORRS     r0,r0,r1              ;917
00018a  6020              STR      r0,[r4,#0]            ;917
00018c  f3c9000c          UBFX     r0,r9,#0,#13          ;919
000190  6060              STR      r0,[r4,#4]            ;919
000192  f8c4b008          STR      r11,[r4,#8]           ;921
000196  ea4f0099          LSR      r0,r9,#2              ;922
00019a  eb0b0b80          ADD      r11,r11,r0,LSL #2     ;922
00019e  f10a0a10          ADD      r10,r10,#0x10         ;923
0001a2  f8c4a00c          STR      r10,[r4,#0xc]         ;926
0001a6  f1080801          ADD      r8,r8,#1              ;900
                  |L11.426|
0001aa  9802              LDR      r0,[sp,#8]            ;900
0001ac  4580              CMP      r8,r0                 ;900
0001ae  d3d9              BCC      |L11.356|
0001b0  6820              LDR      r0,[r4,#0]            ;929
0001b2  f0200002          BIC      r0,r0,#2              ;929
0001b6  6020              STR      r0,[r4,#0]            ;929
0001b8  6820              LDR      r0,[r4,#0]            ;930
0001ba  e000              B        |L11.446|
                  |L11.444|
0001bc  e003              B        |L11.454|
                  |L11.446|
0001be  f0400004          ORR      r0,r0,#4              ;930
0001c2  6020              STR      r0,[r4,#0]            ;930
0001c4  e000              B        |L11.456|
                  |L11.454|
0001c6  bf00              NOP                            ;934
                  |L11.456|
0001c8  bf00              NOP                            ;897
0001ca  3614              ADDS     r6,r6,#0x14           ;938
0001cc  f8560c14          LDR      r0,[r6,#-0x14]        ;938
0001d0  f0407000          ORR      r0,r0,#0x2000000      ;938
0001d4  f8460c14          STR      r0,[r6,#-0x14]        ;938
0001d8  6ef0              LDR      r0,[r6,#0x6c]         ;940
0001da  f0400080          ORR      r0,r0,#0x80           ;940
0001de  66f0              STR      r0,[r6,#0x6c]         ;940
0001e0  6ff0              LDR      r0,[r6,#0x7c]         ;942
0001e2  f2403137          MOV      r1,#0x337             ;942
0001e6  4308              ORRS     r0,r0,r1              ;942
0001e8  67f0              STR      r0,[r6,#0x7c]         ;942
0001ea  2038              MOVS     r0,#0x38              ;944
0001ec  6931              LDR      r1,[r6,#0x10]         ;944
0001ee  4381              BICS     r1,r1,r0              ;944
0001f0  6131              STR      r1,[r6,#0x10]         ;944
0001f2  bf00              NOP                            ;944
0001f4  6878              LDR      r0,[r7,#4]            ;946
0001f6  6770              STR      r0,[r6,#0x74]         ;946
0001f8  3e14              SUBS     r6,r6,#0x14           ;946
0001fa  2000              MOVS     r0,#0                 ;948
0001fc  e72a              B        |L11.84|
;;;950    
                          ENDP

0001fe  0000              DCW      0x0000
                  |L11.512|
000200  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000204  44726976
000208  6572735c
00020c  66736c5f
000210  73646966
000214  2e6300  
000217  00                DCB      0
                  |L11.536|
000218  4e554c4c          DCB      "NULL != config",0
00021c  20213d20
000220  636f6e66
000224  696700  
000227  00                DCB      0
                  |L11.552|
000228  4e554c4c          DCB      "NULL != data",0
00022c  20213d20
000230  64617461
000234  00      
000235  00                DCB      0
000236  00                DCB      0
000237  00                DCB      0
                  |L11.568|
                          DCD      0x80000002

                          AREA ||i.SDIF_ReadCommandResponse||, CODE, READONLY, ALIGN=1

                  SDIF_ReadCommandResponse PROC
;;;261    
;;;262    static status_t SDIF_ReadCommandResponse(SDIF_Type *base, sdif_command_t *command)
000000  4602              MOV      r2,r0
;;;263    {
;;;264        /* check if command exsit,if not, do not read the response */
;;;265        if (NULL != command)
000002  b1f9              CBZ      r1,|L12.68|
;;;266        {
;;;267            /* read reponse */
;;;268            command->response[0U] = base->RESP[0U];
000004  6b10              LDR      r0,[r2,#0x30]
000006  6088              STR      r0,[r1,#8]
;;;269            if (command->responseType == kCARD_ResponseTypeR2)
000008  69c8              LDR      r0,[r1,#0x1c]
00000a  2803              CMP      r0,#3
00000c  d105              BNE      |L12.26|
;;;270            {
;;;271                command->response[1U] = base->RESP[1U];
00000e  6b53              LDR      r3,[r2,#0x34]
000010  60cb              STR      r3,[r1,#0xc]
;;;272                command->response[2U] = base->RESP[2U];
000012  6b93              LDR      r3,[r2,#0x38]
000014  610b              STR      r3,[r1,#0x10]
;;;273                command->response[3U] = base->RESP[3U];
000016  6bd3              LDR      r3,[r2,#0x3c]
000018  614b              STR      r3,[r1,#0x14]
                  |L12.26|
;;;274            }
;;;275    
;;;276            if ((command->responseErrorFlags != 0U) &&
00001a  6a48              LDR      r0,[r1,#0x24]
00001c  b190              CBZ      r0,|L12.68|
;;;277                ((command->responseType == kCARD_ResponseTypeR1) || (command->responseType == kCARD_ResponseTypeR1b) ||
00001e  69c8              LDR      r0,[r1,#0x1c]
000020  2801              CMP      r0,#1
000022  d008              BEQ      |L12.54|
000024  69c8              LDR      r0,[r1,#0x1c]
000026  2802              CMP      r0,#2
000028  d005              BEQ      |L12.54|
;;;278                 (command->responseType == kCARD_ResponseTypeR6) || (command->responseType == kCARD_ResponseTypeR5)))
00002a  69c8              LDR      r0,[r1,#0x1c]
00002c  2808              CMP      r0,#8
00002e  d002              BEQ      |L12.54|
000030  69c8              LDR      r0,[r1,#0x1c]
000032  2806              CMP      r0,#6
000034  d106              BNE      |L12.68|
                  |L12.54|
;;;279            {
;;;280                if (((command->responseErrorFlags) & (command->response[0U])) != 0U)
000036  688b              LDR      r3,[r1,#8]
000038  6a48              LDR      r0,[r1,#0x24]
00003a  4018              ANDS     r0,r0,r3
00003c  b110              CBZ      r0,|L12.68|
;;;281                {
;;;282                    return kStatus_SDIF_ResponseError;
00003e  f2417016          MOV      r0,#0x1716
                  |L12.66|
;;;283                }
;;;284            }
;;;285        }
;;;286    
;;;287        return kStatus_Success;
;;;288    }
000042  4770              BX       lr
                  |L12.68|
000044  2000              MOVS     r0,#0                 ;287
000046  e7fc              B        |L12.66|
;;;289    
                          ENDP


                          AREA ||i.SDIF_ReadDataPort||, CODE, READONLY, ALIGN=1

                  SDIF_ReadDataPort PROC
;;;363    
;;;364    static uint32_t SDIF_ReadDataPort(SDIF_Type *base, sdif_data_t *data, uint32_t transferredWords)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;365    {
000004  4607              MOV      r7,r0
000006  4613              MOV      r3,r2
;;;366        uint32_t i;
;;;367        uint32_t totalWords;
;;;368        uint32_t wordsCanBeRead; /* The words can be read at this time. */
;;;369        uint32_t readWatermark = ((base->FIFOTH & SDIF_FIFOTH_RX_WMARK_MASK) >> SDIF_FIFOTH_RX_WMARK_SHIFT);
000008  6cf8              LDR      r0,[r7,#0x4c]
00000a  f3c0460b          UBFX     r6,r0,#16,#12
;;;370    
;;;371        if (data->blockSize % sizeof(uint32_t) != 0U)
00000e  7908              LDRB     r0,[r1,#4]
000010  f0000003          AND      r0,r0,#3
000014  b140              CBZ      r0,|L13.40|
;;;372        {
;;;373            data->blockSize +=
000016  f891c004          LDRB     r12,[r1,#4]
00001a  f00c0c03          AND      r12,r12,#3
00001e  f1cc0c04          RSB      r12,r12,#4
000022  6848              LDR      r0,[r1,#4]
000024  4460              ADD      r0,r0,r12
000026  6048              STR      r0,[r1,#4]
                  |L13.40|
;;;374                sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
;;;375        }
;;;376    
;;;377        totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
000028  e9d1c001          LDRD     r12,r0,[r1,#4]
00002c  fb00f00c          MUL      r0,r0,r12
000030  0882              LSRS     r2,r0,#2
;;;378    
;;;379        /* If watermark level is equal or bigger than totalWords, transfers totalWords data. */
;;;380        if (readWatermark >= totalWords)
000032  4296              CMP      r6,r2
000034  d301              BCC      |L13.58|
;;;381        {
;;;382            wordsCanBeRead = totalWords;
000036  4615              MOV      r5,r2
000038  e007              B        |L13.74|
                  |L13.58|
;;;383        }
;;;384        /* If watermark level is less than totalWords and left words to be sent is equal or bigger than readWatermark,
;;;385        transfers watermark level words. */
;;;386        else if ((readWatermark < totalWords) && ((totalWords - transferredWords) >= readWatermark))
00003a  4296              CMP      r6,r2
00003c  d204              BCS      |L13.72|
00003e  1ad0              SUBS     r0,r2,r3
000040  42b0              CMP      r0,r6
000042  d301              BCC      |L13.72|
;;;387        {
;;;388            wordsCanBeRead = readWatermark;
000044  4635              MOV      r5,r6
000046  e000              B        |L13.74|
                  |L13.72|
;;;389        }
;;;390        /* If watermark level is less than totalWords and left words to be sent is less than readWatermark, transfers left
;;;391        words. */
;;;392        else
;;;393        {
;;;394            wordsCanBeRead = (totalWords - transferredWords);
000048  1ad5              SUBS     r5,r2,r3
                  |L13.74|
;;;395        }
;;;396    
;;;397        i = 0U;
00004a  2400              MOVS     r4,#0
;;;398        while (i < wordsCanBeRead)
00004c  e00a              B        |L13.100|
                  |L13.78|
;;;399        {
;;;400            data->rxData[transferredWords++] = base->FIFO[i];
00004e  f5077000          ADD      r0,r7,#0x200
000052  f8508024          LDR      r8,[r0,r4,LSL #2]
000056  4618              MOV      r0,r3
000058  1c5b              ADDS     r3,r3,#1
00005a  f8d1900c          LDR      r9,[r1,#0xc]
00005e  f8498020          STR      r8,[r9,r0,LSL #2]
;;;401            i++;
000062  1c64              ADDS     r4,r4,#1
                  |L13.100|
000064  42ac              CMP      r4,r5                 ;398
000066  d3f2              BCC      |L13.78|
;;;402        }
;;;403    
;;;404        return transferredWords;
000068  4618              MOV      r0,r3
;;;405    }
00006a  e8bd83f0          POP      {r4-r9,pc}
;;;406    
                          ENDP


                          AREA ||i.SDIF_ReadDataPortBlocking||, CODE, READONLY, ALIGN=1

                  SDIF_ReadDataPortBlocking PROC
;;;449    
;;;450    static status_t SDIF_ReadDataPortBlocking(SDIF_Type *base, sdif_data_t *data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;451    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;452        uint32_t totalWords;
;;;453        uint32_t transferredWords = 0U;
000008  f04f0800          MOV      r8,#0
;;;454        status_t error = kStatus_Success;
00000c  2600              MOVS     r6,#0
;;;455        uint32_t status;
;;;456        bool transferOver = false;
00000e  46b2              MOV      r10,r6
;;;457    
;;;458        if (data->blockSize % sizeof(uint32_t) != 0U)
000010  7920              LDRB     r0,[r4,#4]
000012  f0000003          AND      r0,r0,#3
000016  b138              CBZ      r0,|L14.40|
;;;459        {
;;;460            data->blockSize +=
000018  7921              LDRB     r1,[r4,#4]
00001a  f0010103          AND      r1,r1,#3
00001e  f1c10104          RSB      r1,r1,#4
000022  6860              LDR      r0,[r4,#4]
000024  4408              ADD      r0,r0,r1
000026  6060              STR      r0,[r4,#4]
                  |L14.40|
;;;461                sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
;;;462        }
;;;463    
;;;464        totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
000028  e9d41001          LDRD     r1,r0,[r4,#4]
00002c  4348              MULS     r0,r1,r0
00002e  0887              LSRS     r7,r0,#2
;;;465    
;;;466        while ((transferredWords < totalWords) && (error == kStatus_Success))
000030  e022              B        |L14.120|
                  |L14.50|
;;;467        {
;;;468            /* wait data transfer complete or reach RX watermark */
;;;469            do
000032  bf00              NOP      
                  |L14.52|
;;;470            {
;;;471                status = SDIF_GetInterruptStatus(base);
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       SDIF_GetInterruptStatus
00003a  4605              MOV      r5,r0
;;;472                if (status & kSDIF_DataTransferError)
00003c  f64a2080          MOV      r0,#0xaa80
000040  4028              ANDS     r0,r0,r5
000042  b110              CBZ      r0,|L14.74|
;;;473                {
;;;474                    if (!(data->enableIgnoreError))
000044  78a0              LDRB     r0,[r4,#2]
000046  b900              CBNZ     r0,|L14.74|
;;;475                    {
;;;476                        error = kStatus_Fail;
000048  2601              MOVS     r6,#1
                  |L14.74|
;;;477                    }
;;;478                }
;;;479            } while (((status & (kSDIF_DataTransferOver | kSDIF_ReadFIFORequest)) == 0U) && (!transferOver));
00004a  f0050028          AND      r0,r5,#0x28
00004e  b910              CBNZ     r0,|L14.86|
000050  f1ba0f00          CMP      r10,#0
000054  d0ee              BEQ      |L14.52|
                  |L14.86|
;;;480    
;;;481            if ((status & kSDIF_DataTransferOver) == kSDIF_DataTransferOver)
000056  f0050008          AND      r0,r5,#8
00005a  2808              CMP      r0,#8
00005c  d101              BNE      |L14.98|
;;;482            {
;;;483                transferOver = true;
00005e  f04f0a01          MOV      r10,#1
                  |L14.98|
;;;484            }
;;;485    
;;;486            if (error == kStatus_Success)
000062  b92e              CBNZ     r6,|L14.112|
;;;487            {
;;;488                transferredWords = SDIF_ReadDataPort(base, data, transferredWords);
000064  4642              MOV      r2,r8
000066  4621              MOV      r1,r4
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       SDIF_ReadDataPort
00006e  4680              MOV      r8,r0
                  |L14.112|
;;;489            }
;;;490    
;;;491            /* clear interrupt status */
;;;492            SDIF_ClearInterruptStatus(base, status);
000070  4629              MOV      r1,r5
000072  4648              MOV      r0,r9
000074  f7fffffe          BL       SDIF_ClearInterruptStatus
                  |L14.120|
000078  45b8              CMP      r8,r7                 ;466
00007a  d201              BCS      |L14.128|
00007c  2e00              CMP      r6,#0                 ;466
00007e  d0d8              BEQ      |L14.50|
                  |L14.128|
;;;493        }
;;;494    
;;;495        return error;
000080  4630              MOV      r0,r6
;;;496    }
000082  e8bd87f0          POP      {r4-r10,pc}
;;;497    
                          ENDP


                          AREA ||i.SDIF_ReleaseDMADescriptor||, CODE, READONLY, ALIGN=2

                  SDIF_ReleaseDMADescriptor PROC
;;;311    
;;;312    status_t SDIF_ReleaseDMADescriptor(SDIF_Type *base, sdif_dma_config_t *dmaConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;313    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;314        assert(NULL != dmaConfig);
000008  b105              CBZ      r5,|L15.12|
00000a  e005              B        |L15.24|
                  |L15.12|
00000c  f44f729d          MOV      r2,#0x13a
000010  a127              ADR      r1,|L15.176|
000012  a02d              ADR      r0,|L15.200|
000014  f7fffffe          BL       __aeabi_assert
                  |L15.24|
;;;315        assert(NULL != dmaConfig->dmaDesBufferStartAddr);
000018  6868              LDR      r0,[r5,#4]
00001a  b100              CBZ      r0,|L15.30|
00001c  e005              B        |L15.42|
                  |L15.30|
00001e  f240123b          MOV      r2,#0x13b
000022  a123              ADR      r1,|L15.176|
000024  a02d              ADR      r0,|L15.220|
000026  f7fffffe          BL       __aeabi_assert
                  |L15.42|
;;;316    
;;;317        sdif_dma_descriptor_t *dmaDesAddr;
;;;318        uint32_t *tempDMADesBuffer = dmaConfig->dmaDesBufferStartAddr;
00002a  686e              LDR      r6,[r5,#4]
;;;319        uint32_t dmaDesBufferSize = 0U;
00002c  2700              MOVS     r7,#0
;;;320    
;;;321        dmaDesAddr = (sdif_dma_descriptor_t *)tempDMADesBuffer;
00002e  4634              MOV      r4,r6
;;;322    
;;;323        /* chain descriptor mode */
;;;324        if (dmaConfig->mode == kSDIF_ChainDMAMode)
000030  7868              LDRB     r0,[r5,#1]
000032  2801              CMP      r0,#1
000034  d11b              BNE      |L15.110|
;;;325        {
;;;326            while (((dmaDesAddr->dmaDesAttribute & kSDIF_DMADescriptorDataBufferEnd) != kSDIF_DMADescriptorDataBufferEnd) &&
000036  e005              B        |L15.68|
                  |L15.56|
;;;327                   (dmaDesBufferSize < dmaConfig->dmaDesBufferLen * sizeof(uint32_t)))
;;;328            {
;;;329                /* set the OWN bit */
;;;330                dmaDesAddr->dmaDesAttribute |= kSDIF_DMADescriptorOwnByDMA;
000038  6820              LDR      r0,[r4,#0]
00003a  f0404000          ORR      r0,r0,#0x80000000
00003e  6020              STR      r0,[r4,#0]
;;;331                dmaDesAddr++;
000040  3410              ADDS     r4,r4,#0x10
;;;332                dmaDesBufferSize += sizeof(sdif_dma_descriptor_t);
000042  3710              ADDS     r7,r7,#0x10
                  |L15.68|
000044  7820              LDRB     r0,[r4,#0]            ;326
000046  f0000004          AND      r0,r0,#4              ;326
00004a  2804              CMP      r0,#4                 ;326
00004c  d003              BEQ      |L15.86|
00004e  68a8              LDR      r0,[r5,#8]            ;327
000050  ebb70f80          CMP      r7,r0,LSL #2          ;327
000054  d3f0              BCC      |L15.56|
                  |L15.86|
;;;333            }
;;;334            /* if access dma des address overflow, return fail */
;;;335            if (dmaDesBufferSize > dmaConfig->dmaDesBufferLen * sizeof(uint32_t))
000056  68a8              LDR      r0,[r5,#8]
000058  ebb70f80          CMP      r7,r0,LSL #2
00005c  d902              BLS      |L15.100|
;;;336            {
;;;337                return kStatus_Fail;
00005e  2001              MOVS     r0,#1
                  |L15.96|
;;;338            }
;;;339            dmaDesAddr->dmaDesAttribute |= kSDIF_DMADescriptorOwnByDMA;
;;;340        }
;;;341        /* dual descriptor mode */
;;;342        else
;;;343        {
;;;344            while (((dmaDesAddr->dmaDesAttribute & kSDIF_DMADescriptorEnd) != kSDIF_DMADescriptorEnd) &&
;;;345                   (dmaDesBufferSize < dmaConfig->dmaDesBufferLen * sizeof(uint32_t)))
;;;346            {
;;;347                dmaDesAddr = (sdif_dma_descriptor_t *)tempDMADesBuffer;
;;;348                dmaDesAddr->dmaDesAttribute |= kSDIF_DMADescriptorOwnByDMA;
;;;349                tempDMADesBuffer += dmaConfig->dmaDesSkipLen;
;;;350            }
;;;351            /* if access dma des address overflow, return fail */
;;;352            if (dmaDesBufferSize > dmaConfig->dmaDesBufferLen * sizeof(uint32_t))
;;;353            {
;;;354                return kStatus_Fail;
;;;355            }
;;;356            dmaDesAddr->dmaDesAttribute |= kSDIF_DMADescriptorOwnByDMA;
;;;357        }
;;;358        /* reload DMA descriptor */
;;;359        base->PLDMND = SDIF_POLL_DEMAND_VALUE;
;;;360    
;;;361        return kStatus_Success;
;;;362    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L15.100|
000064  6820              LDR      r0,[r4,#0]            ;339
000066  f0404000          ORR      r0,r0,#0x80000000     ;339
00006a  6020              STR      r0,[r4,#0]            ;339
00006c  e01b              B        |L15.166|
                  |L15.110|
00006e  e007              B        |L15.128|
                  |L15.112|
000070  4634              MOV      r4,r6                 ;347
000072  6820              LDR      r0,[r4,#0]            ;348
000074  f0404000          ORR      r0,r0,#0x80000000     ;348
000078  6020              STR      r0,[r4,#0]            ;348
00007a  78a8              LDRB     r0,[r5,#2]            ;349
00007c  eb060680          ADD      r6,r6,r0,LSL #2       ;349
                  |L15.128|
000080  7820              LDRB     r0,[r4,#0]            ;344
000082  f0000020          AND      r0,r0,#0x20           ;344
000086  2820              CMP      r0,#0x20              ;344
000088  d003              BEQ      |L15.146|
00008a  68a8              LDR      r0,[r5,#8]            ;345
00008c  ebb70f80          CMP      r7,r0,LSL #2          ;345
000090  d3ee              BCC      |L15.112|
                  |L15.146|
000092  68a8              LDR      r0,[r5,#8]            ;352
000094  ebb70f80          CMP      r7,r0,LSL #2          ;352
000098  d901              BLS      |L15.158|
00009a  2001              MOVS     r0,#1                 ;354
00009c  e7e0              B        |L15.96|
                  |L15.158|
00009e  6820              LDR      r0,[r4,#0]            ;356
0000a0  f0404000          ORR      r0,r0,#0x80000000     ;356
0000a4  6020              STR      r0,[r4,#0]            ;356
                  |L15.166|
0000a6  20ff              MOVS     r0,#0xff              ;359
0000a8  f8c80084          STR      r0,[r8,#0x84]         ;359
0000ac  2000              MOVS     r0,#0                 ;361
0000ae  e7d7              B        |L15.96|
;;;363    
                          ENDP

                  |L15.176|
0000b0  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
0000b4  44726976
0000b8  6572735c
0000bc  66736c5f
0000c0  73646966
0000c4  2e6300  
0000c7  00                DCB      0
                  |L15.200|
0000c8  4e554c4c          DCB      "NULL != dmaConfig",0
0000cc  20213d20
0000d0  646d6143
0000d4  6f6e6669
0000d8  6700    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L15.220|
0000dc  4e554c4c          DCB      "NULL != dmaConfig->dmaDesBufferStartAddr",0
0000e0  20213d20
0000e4  646d6143
0000e8  6f6e6669
0000ec  672d3e64
0000f0  6d614465
0000f4  73427566
0000f8  66657253
0000fc  74617274
000100  41646472
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.SDIF_Reset||, CODE, READONLY, ALIGN=1

                  SDIF_Reset PROC
;;;552    
;;;553    bool SDIF_Reset(SDIF_Type *base, uint32_t mask, uint32_t timeout)
000000  4603              MOV      r3,r0
;;;554    {
;;;555        base->CTRL |= mask;
000002  6818              LDR      r0,[r3,#0]
000004  4308              ORRS     r0,r0,r1
000006  6018              STR      r0,[r3,#0]
;;;556    
;;;557        /* check software DMA reset here for DMA reset also need to check this bit */
;;;558        while ((base->CTRL & mask) != 0U)
000008  e002              B        |L16.16|
                  |L16.10|
;;;559        {
;;;560            if (!timeout)
00000a  b902              CBNZ     r2,|L16.14|
;;;561            {
;;;562                break;
00000c  e004              B        |L16.24|
                  |L16.14|
;;;563            }
;;;564            timeout--;
00000e  1e52              SUBS     r2,r2,#1
                  |L16.16|
000010  6818              LDR      r0,[r3,#0]            ;558
000012  4008              ANDS     r0,r0,r1              ;558
000014  2800              CMP      r0,#0                 ;558
000016  d1f8              BNE      |L16.10|
                  |L16.24|
000018  bf00              NOP                            ;562
;;;565        }
;;;566    
;;;567        return timeout ? true : false;
00001a  b10a              CBZ      r2,|L16.32|
00001c  2001              MOVS     r0,#1
                  |L16.30|
;;;568    }
00001e  4770              BX       lr
                  |L16.32|
000020  2000              MOVS     r0,#0                 ;567
000022  e7fc              B        |L16.30|
;;;569    
                          ENDP


                          AREA ||i.SDIF_SendCardActive||, CODE, READONLY, ALIGN=1

                  SDIF_SendCardActive PROC
;;;643    
;;;644    bool SDIF_SendCardActive(SDIF_Type *base, uint32_t timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;645    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;646        bool enINT = false;
000008  2600              MOVS     r6,#0
;;;647        sdif_command_t command;
;;;648    
;;;649        memset(&command, 0U, sizeof(sdif_command_t));
00000a  2128              MOVS     r1,#0x28
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;650    
;;;651        /* add for confict with interrupt mode,close the interrupt temporary */
;;;652        if ((base->CTRL & SDIF_CTRL_INT_ENABLE_MASK) == SDIF_CTRL_INT_ENABLE_MASK)
000012  6820              LDR      r0,[r4,#0]
000014  f0000010          AND      r0,r0,#0x10
000018  2810              CMP      r0,#0x10
00001a  d104              BNE      |L17.38|
;;;653        {
;;;654            enINT = true;
00001c  2601              MOVS     r6,#1
;;;655            base->CTRL &= ~SDIF_CTRL_INT_ENABLE_MASK;
00001e  6820              LDR      r0,[r4,#0]
000020  f0200010          BIC      r0,r0,#0x10
000024  6020              STR      r0,[r4,#0]
                  |L17.38|
;;;656        }
;;;657    
;;;658        command.flags = SDIF_CMD_SEND_INITIALIZATION_MASK;
000026  f44f4000          MOV      r0,#0x8000
00002a  9008              STR      r0,[sp,#0x20]
;;;659    
;;;660        if (SDIF_SendCommand(base, &command, timeout) == kStatus_Fail)
00002c  462a              MOV      r2,r5
00002e  4669              MOV      r1,sp
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       SDIF_SendCommand
000036  2801              CMP      r0,#1
000038  d102              BNE      |L17.64|
;;;661        {
;;;662            return false;
00003a  2000              MOVS     r0,#0
                  |L17.60|
;;;663        }
;;;664    
;;;665        /* wait command done */
;;;666        while ((SDIF_GetInterruptStatus(base) & kSDIF_CommandDone) != kSDIF_CommandDone)
;;;667        {
;;;668        }
;;;669    
;;;670        /* clear status */
;;;671        SDIF_ClearInterruptStatus(base, kSDIF_CommandDone);
;;;672    
;;;673        /* add for confict with interrupt mode */
;;;674        if (enINT)
;;;675        {
;;;676            base->CTRL |= SDIF_CTRL_INT_ENABLE_MASK;
;;;677        }
;;;678    
;;;679        return true;
;;;680    }
00003c  b00a              ADD      sp,sp,#0x28
00003e  bd70              POP      {r4-r6,pc}
                  |L17.64|
000040  bf00              NOP                            ;666
                  |L17.66|
000042  4620              MOV      r0,r4                 ;666
000044  f7fffffe          BL       SDIF_GetInterruptStatus
000048  f0000004          AND      r0,r0,#4              ;666
00004c  2804              CMP      r0,#4                 ;666
00004e  d1f8              BNE      |L17.66|
000050  2104              MOVS     r1,#4                 ;671
000052  4620              MOV      r0,r4                 ;671
000054  f7fffffe          BL       SDIF_ClearInterruptStatus
000058  b11e              CBZ      r6,|L17.98|
00005a  6820              LDR      r0,[r4,#0]            ;676
00005c  f0400010          ORR      r0,r0,#0x10           ;676
000060  6020              STR      r0,[r4,#0]            ;676
                  |L17.98|
000062  2001              MOVS     r0,#1                 ;679
000064  e7ea              B        |L17.60|
;;;681    
                          ENDP


                          AREA ||i.SDIF_SendCommand||, CODE, READONLY, ALIGN=2

                  SDIF_SendCommand PROC
;;;622    
;;;623    status_t SDIF_SendCommand(SDIF_Type *base, sdif_command_t *cmd, uint32_t timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;624    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;625        assert(NULL != cmd);
000008  b104              CBZ      r4,|L18.12|
00000a  e005              B        |L18.24|
                  |L18.12|
00000c  f2402271          MOV      r2,#0x271
000010  a10f              ADR      r1,|L18.80|
000012  a015              ADR      r0,|L18.104|
000014  f7fffffe          BL       __aeabi_assert
                  |L18.24|
;;;626    
;;;627        base->CMDARG = cmd->argument;
000018  6860              LDR      r0,[r4,#4]
00001a  62a8              STR      r0,[r5,#0x28]
;;;628        base->CMD = SDIF_CMD_CMD_INDEX(cmd->index) | SDIF_CMD_START_CMD_MASK | (cmd->flags & (~SDIF_CMD_CMD_INDEX_MASK));
00001c  7820              LDRB     r0,[r4,#0]
00001e  f000003f          AND      r0,r0,#0x3f
000022  f0404000          ORR      r0,r0,#0x80000000
000026  6a21              LDR      r1,[r4,#0x20]
000028  f021013f          BIC      r1,r1,#0x3f
00002c  4308              ORRS     r0,r0,r1
00002e  62e8              STR      r0,[r5,#0x2c]
;;;629    
;;;630        /* wait start_cmd bit auto clear within timeout */
;;;631        while ((base->CMD & SDIF_CMD_START_CMD_MASK) == SDIF_CMD_START_CMD_MASK)
000030  e002              B        |L18.56|
                  |L18.50|
;;;632        {
;;;633            if (!timeout)
000032  b906              CBNZ     r6,|L18.54|
;;;634            {
;;;635                break;
000034  e006              B        |L18.68|
                  |L18.54|
;;;636            }
;;;637    
;;;638            --timeout;
000036  1e76              SUBS     r6,r6,#1
                  |L18.56|
000038  6ae8              LDR      r0,[r5,#0x2c]         ;631
00003a  f0004000          AND      r0,r0,#0x80000000     ;631
00003e  f1b04f00          CMP      r0,#0x80000000        ;631
000042  d0f6              BEQ      |L18.50|
                  |L18.68|
000044  bf00              NOP                            ;635
;;;639        }
;;;640    
;;;641        return timeout ? kStatus_Success : kStatus_Fail;
000046  b90e              CBNZ     r6,|L18.76|
000048  2001              MOVS     r0,#1
                  |L18.74|
;;;642    }
00004a  bd70              POP      {r4-r6,pc}
                  |L18.76|
00004c  2000              MOVS     r0,#0                 ;641
00004e  e7fc              B        |L18.74|
;;;643    
                          ENDP

                  |L18.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  73646966
000064  2e6300  
000067  00                DCB      0
                  |L18.104|
000068  4e554c4c          DCB      "NULL != cmd",0
00006c  20213d20
000070  636d6400

                          AREA ||i.SDIF_SetCardClock||, CODE, READONLY, ALIGN=2

                  SDIF_SetCardClock PROC
;;;747    
;;;748    uint32_t SDIF_SetCardClock(SDIF_Type *base, uint32_t srcClock_Hz, uint32_t target_HZ)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;749    {
000004  b08a              SUB      sp,sp,#0x28
000006  4680              MOV      r8,r0
000008  460c              MOV      r4,r1
00000a  4615              MOV      r5,r2
;;;750        sdif_command_t cmd = {0U};
00000c  2128              MOVS     r1,#0x28
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;751        uint32_t divider = 0U, targetFreq = target_HZ;
000014  2600              MOVS     r6,#0
000016  462f              MOV      r7,r5
;;;752    
;;;753        /* if target freq bigger than the source clk, set the target_HZ to
;;;754         src clk, this interface can run up to 52MHZ with card */
;;;755        if (srcClock_Hz < targetFreq)
000018  42bc              CMP      r4,r7
00001a  d200              BCS      |L19.30|
;;;756        {
;;;757            targetFreq = srcClock_Hz;
00001c  4627              MOV      r7,r4
                  |L19.30|
;;;758        }
;;;759    
;;;760        /* disable the clock first,need sync to CIU*/
;;;761        SDIF_EnableCardClock(base, false);
00001e  2100              MOVS     r1,#0
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       SDIF_EnableCardClock
;;;762    
;;;763        /* update the clock register and wait the pre-transfer complete */
;;;764        cmd.flags = kSDIF_CmdUpdateClockRegisterOnly | kSDIF_WaitPreTransferComplete;
000026  4818              LDR      r0,|L19.136|
000028  9008              STR      r0,[sp,#0x20]
;;;765        SDIF_SendCommand(base, &cmd, SDIF_TIMEOUT_VALUE);
00002a  f64f72ff          MOV      r2,#0xffff
00002e  4669              MOV      r1,sp
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       SDIF_SendCommand
;;;766    
;;;767        /*calucate the divider*/
;;;768        if (targetFreq != srcClock_Hz)
000036  42a7              CMP      r7,r4
000038  d003              BEQ      |L19.66|
;;;769        {
;;;770            divider = (srcClock_Hz / targetFreq + 1U) / 2U;
00003a  fbb4f0f7          UDIV     r0,r4,r7
00003e  1c40              ADDS     r0,r0,#1
000040  0846              LSRS     r6,r0,#1
                  |L19.66|
;;;771        }
;;;772        /* load the clock divider */
;;;773        base->CLKDIV = SDIF_CLKDIV_CLK_DIVIDER0(divider);
000042  b2f0              UXTB     r0,r6
000044  f8c80008          STR      r0,[r8,#8]
;;;774    
;;;775        /* update the divider to CIU */
;;;776        cmd.flags = kSDIF_CmdUpdateClockRegisterOnly | kSDIF_WaitPreTransferComplete;
000048  480f              LDR      r0,|L19.136|
00004a  9008              STR      r0,[sp,#0x20]
;;;777        SDIF_SendCommand(base, &cmd, SDIF_TIMEOUT_VALUE);
00004c  f64f72ff          MOV      r2,#0xffff
000050  4669              MOV      r1,sp
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       SDIF_SendCommand
;;;778    
;;;779        /* enable the card clock and sync to CIU */
;;;780        SDIF_EnableCardClock(base, true);
000058  2101              MOVS     r1,#1
00005a  4640              MOV      r0,r8
00005c  f7fffffe          BL       SDIF_EnableCardClock
;;;781        SDIF_SendCommand(base, &cmd, SDIF_TIMEOUT_VALUE);
000060  f64f72ff          MOV      r2,#0xffff
000064  4669              MOV      r1,sp
000066  4640              MOV      r0,r8
000068  f7fffffe          BL       SDIF_SendCommand
;;;782    
;;;783        /* config the clock delay to meet the hold time and setup time */
;;;784        SDIF_ConfigClockDelay(target_HZ, divider);
00006c  4631              MOV      r1,r6
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       SDIF_ConfigClockDelay
;;;785    
;;;786        /* return the actual card clock freq */
;;;787    
;;;788        return (divider != 0U) ? (srcClock_Hz / (divider * 2U)) : srcClock_Hz;
000074  b12e              CBZ      r6,|L19.130|
000076  0070              LSLS     r0,r6,#1
000078  fbb4f0f0          UDIV     r0,r4,r0
                  |L19.124|
;;;789    }
00007c  b00a              ADD      sp,sp,#0x28
00007e  e8bd81f0          POP      {r4-r8,pc}
                  |L19.130|
000082  4620              MOV      r0,r4                 ;788
000084  e7fa              B        |L19.124|
;;;790    
                          ENDP

000086  0000              DCW      0x0000
                  |L19.136|
                          DCD      0x00202000

                          AREA ||i.SDIF_TransferBlocking||, CODE, READONLY, ALIGN=2

                  SDIF_TransferBlocking PROC
;;;987    
;;;988    status_t SDIF_TransferBlocking(SDIF_Type *base, sdif_dma_config_t *dmaConfig, sdif_transfer_t *transfer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;989    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;990        assert(NULL != transfer);
00000a  b105              CBZ      r5,|L20.14|
00000c  e005              B        |L20.26|
                  |L20.14|
00000e  f24032de          MOV      r2,#0x3de
000012  a12a              ADR      r1,|L20.188|
000014  a02f              ADR      r0,|L20.212|
000016  f7fffffe          BL       __aeabi_assert
                  |L20.26|
;;;991    
;;;992        bool isDMA = false;
00001a  2600              MOVS     r6,#0
;;;993        sdif_data_t *data = transfer->data;
00001c  682c              LDR      r4,[r5,#0]
;;;994    
;;;995        /* config the transfer parameter */
;;;996        if (SDIF_TransferConfig(base, transfer) != kStatus_Success)
00001e  4629              MOV      r1,r5
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       SDIF_TransferConfig
000026  b118              CBZ      r0,|L20.48|
;;;997        {
;;;998            return kStatue_SDIF_InvalidArgument;
000028  f241700d          MOV      r0,#0x170d
                  |L20.44|
;;;999        }
;;;1000   
;;;1001       /* if need transfer data in dma mode, config the DMA descriptor first */
;;;1002       if ((data != NULL) && (dmaConfig != NULL))
;;;1003       {
;;;1004           /* use internal DMA mode to transfer between the card and host*/
;;;1005           isDMA = true;
;;;1006   
;;;1007           if (SDIF_InternalDMAConfig(base, dmaConfig, data->rxData ? data->rxData : data->txData,
;;;1008                                      data->blockSize * data->blockCount) != kStatus_Success)
;;;1009           {
;;;1010               return kStatus_SDIF_DescriptorBufferLenError;
;;;1011           }
;;;1012       }
;;;1013   
;;;1014       /* send command first */
;;;1015       if (SDIF_SendCommand(base, transfer->command, SDIF_TIMEOUT_VALUE) != kStatus_Success)
;;;1016       {
;;;1017           return kStatus_SDIF_SyncCmdTimeout;
;;;1018       }
;;;1019   
;;;1020       /* wait the command transfer done and check if error occurs */
;;;1021       if (SDIF_WaitCommandDone(base, transfer->command) != kStatus_Success)
;;;1022       {
;;;1023           return kStatus_SDIF_SendCmdFail;
;;;1024       }
;;;1025   
;;;1026       /* if use DMA transfer mode ,check the corresponding status bit */
;;;1027       if (data != NULL)
;;;1028       {
;;;1029           /* check the if has DMA descriptor featch error */
;;;1030           if (isDMA &&
;;;1031               ((SDIF_GetInternalDMAStatus(base) & kSDIF_DMADescriptorUnavailable) == kSDIF_DMADescriptorUnavailable))
;;;1032           {
;;;1033               SDIF_ClearInternalDMAStatus(base, kSDIF_DMADescriptorUnavailable | kSDIF_AbnormalInterruptSummary);
;;;1034   
;;;1035               /* release the DMA descriptor to DMA */
;;;1036               SDIF_ReleaseDMADescriptor(base, dmaConfig);
;;;1037           }
;;;1038           /* handle data transfer */
;;;1039           if (SDIF_TransferDataBlocking(base, data, isDMA) != kStatus_Success)
;;;1040           {
;;;1041               return kStatus_SDIF_DataTransferFail;
;;;1042           }
;;;1043       }
;;;1044   
;;;1045       return kStatus_Success;
;;;1046   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L20.48|
000030  b1ac              CBZ      r4,|L20.94|
000032  f1b80f00          CMP      r8,#0                 ;1002
000036  d012              BEQ      |L20.94|
000038  2601              MOVS     r6,#1                 ;1005
00003a  e9d40101          LDRD     r0,r1,[r4,#4]         ;1007
00003e  fb00f301          MUL      r3,r0,r1              ;1007
000042  68e0              LDR      r0,[r4,#0xc]          ;1007
000044  b108              CBZ      r0,|L20.74|
000046  68e0              LDR      r0,[r4,#0xc]          ;1007
000048  e000              B        |L20.76|
                  |L20.74|
00004a  6920              LDR      r0,[r4,#0x10]         ;1007
                  |L20.76|
00004c  4602              MOV      r2,r0                 ;1007
00004e  4641              MOV      r1,r8                 ;1007
000050  4638              MOV      r0,r7                 ;1007
000052  f7fffffe          BL       SDIF_InternalDMAConfig
000056  b110              CBZ      r0,|L20.94|
000058  f241700c          MOV      r0,#0x170c            ;1010
00005c  e7e6              B        |L20.44|
                  |L20.94|
00005e  f64f72ff          MOV      r2,#0xffff            ;1015
000062  4638              MOV      r0,r7                 ;1015
000064  6869              LDR      r1,[r5,#4]            ;1015
000066  f7fffffe          BL       SDIF_SendCommand
00006a  b110              CBZ      r0,|L20.114|
00006c  f241700e          MOV      r0,#0x170e            ;1017
000070  e7dc              B        |L20.44|
                  |L20.114|
000072  4638              MOV      r0,r7                 ;1021
000074  6869              LDR      r1,[r5,#4]            ;1021
000076  f7fffffe          BL       SDIF_WaitCommandDone
00007a  b110              CBZ      r0,|L20.130|
00007c  f241700f          MOV      r0,#0x170f            ;1023
000080  e7d4              B        |L20.44|
                  |L20.130|
000082  b1cc              CBZ      r4,|L20.184|
000084  b17e              CBZ      r6,|L20.166|
000086  bf00              NOP                            ;1031
000088  f8d7008c          LDR      r0,[r7,#0x8c]         ;1031
00008c  f0000010          AND      r0,r0,#0x10           ;1031
000090  2810              CMP      r0,#0x10              ;1031
000092  d108              BNE      |L20.166|
000094  f44f7104          MOV      r1,#0x210             ;1033
000098  4638              MOV      r0,r7                 ;1033
00009a  f7fffffe          BL       SDIF_ClearInternalDMAStatus
00009e  4641              MOV      r1,r8                 ;1036
0000a0  4638              MOV      r0,r7                 ;1036
0000a2  f7fffffe          BL       SDIF_ReleaseDMADescriptor
                  |L20.166|
0000a6  4632              MOV      r2,r6                 ;1039
0000a8  4621              MOV      r1,r4                 ;1039
0000aa  4638              MOV      r0,r7                 ;1039
0000ac  f7fffffe          BL       SDIF_TransferDataBlocking
0000b0  b110              CBZ      r0,|L20.184|
0000b2  f2417012          MOV      r0,#0x1712            ;1041
0000b6  e7b9              B        |L20.44|
                  |L20.184|
0000b8  2000              MOVS     r0,#0                 ;1045
0000ba  e7b7              B        |L20.44|
;;;1047   
                          ENDP

                  |L20.188|
0000bc  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
0000c0  44726976
0000c4  6572735c
0000c8  66736c5f
0000cc  73646966
0000d0  2e6300  
0000d3  00                DCB      0
                  |L20.212|
0000d4  4e554c4c          DCB      "NULL != transfer",0
0000d8  20213d20
0000dc  7472616e
0000e0  73666572
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.SDIF_TransferConfig||, CODE, READONLY, ALIGN=1

                  SDIF_TransferConfig PROC
;;;185    
;;;186    static status_t SDIF_TransferConfig(SDIF_Type *base, sdif_transfer_t *transfer)
000000  b530              PUSH     {r4,r5,lr}
;;;187    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;188        sdif_command_t *command = transfer->command;
000006  6861              LDR      r1,[r4,#4]
;;;189        sdif_data_t *data = transfer->data;
000008  6822              LDR      r2,[r4,#0]
;;;190    
;;;191        if ((command == NULL) || (data && (data->blockSize > SDIF_BLKSIZ_BLOCK_SIZE_MASK)))
00000a  b121              CBZ      r1,|L21.22|
00000c  b132              CBZ      r2,|L21.28|
00000e  6850              LDR      r0,[r2,#4]
000010  f5b03f80          CMP      r0,#0x10000
000014  d302              BCC      |L21.28|
                  |L21.22|
;;;192        {
;;;193            return kStatue_SDIF_InvalidArgument;
000016  f241700d          MOV      r0,#0x170d
                  |L21.26|
;;;194        }
;;;195    
;;;196        if (data != NULL)
;;;197        {
;;;198            /* config the block size register ,the block size maybe smaller than FIFO
;;;199             depth, will test on the board */
;;;200            base->BLKSIZ = SDIF_BLKSIZ_BLOCK_SIZE(data->blockSize);
;;;201            /* config the byte count register */
;;;202            base->BYTCNT = SDIF_BYTCNT_BYTE_COUNT(data->blockSize * data->blockCount);
;;;203    
;;;204            command->flags |= kSDIF_DataExpect; /* need transfer data flag */
;;;205    
;;;206            if (data->txData != NULL)
;;;207            {
;;;208                command->flags |= kSDIF_DataWriteToCard; /* data transfer direction */
;;;209            }
;;;210            else
;;;211            {
;;;212                /* config the card read threshold,enable the card read threshold */
;;;213                if (data->blockSize <= (SDIF_FIFO_COUNT * sizeof(uint32_t)))
;;;214                {
;;;215                    base->CARDTHRCTL = SDIF_CARDTHRCTL_CARDRDTHREN_MASK | SDIF_CARDTHRCTL_CARDTHRESHOLD(data->blockSize);
;;;216                }
;;;217                else
;;;218                {
;;;219                    base->CARDTHRCTL &= ~SDIF_CARDTHRCTL_CARDRDTHREN_MASK;
;;;220                }
;;;221            }
;;;222    
;;;223            if (data->streamTransfer)
;;;224            {
;;;225                command->flags |= kSDIF_DataStreamTransfer; /* indicate if use stream transfer or block transfer  */
;;;226            }
;;;227    
;;;228            if ((data->enableAutoCommand12) &&
;;;229                (data->blockCount > 1U)) /* indicate if auto stop will send after the data transfer done */
;;;230            {
;;;231                command->flags |= kSDIF_DataTransferAutoStop;
;;;232            }
;;;233        }
;;;234        /* R2 response length long */
;;;235        if (command->responseType == kCARD_ResponseTypeR2)
;;;236        {
;;;237            command->flags |= (kSDIF_CmdCheckResponseCRC | kSDIF_CmdResponseLengthLong | kSDIF_CmdResponseExpect);
;;;238        }
;;;239        else if ((command->responseType == kCARD_ResponseTypeR3) || (command->responseType == kCARD_ResponseTypeR4))
;;;240        {
;;;241            command->flags |= kSDIF_CmdResponseExpect; /* response R3 do not check Response CRC */
;;;242        }
;;;243        else
;;;244        {
;;;245            if (command->responseType != kCARD_ResponseTypeNone)
;;;246            {
;;;247                command->flags |= (kSDIF_CmdCheckResponseCRC | kSDIF_CmdResponseExpect);
;;;248            }
;;;249        }
;;;250    
;;;251        if (command->type == kCARD_CommandTypeAbort)
;;;252        {
;;;253            command->flags |= kSDIF_TransferStopAbort;
;;;254        }
;;;255    
;;;256        /* wait pre-transfer complete */
;;;257        command->flags |= kSDIF_WaitPreTransferComplete | kSDIF_CmdDataUseHoldReg;
;;;258    
;;;259        return kStatus_Success;
;;;260    }
00001a  bd30              POP      {r4,r5,pc}
                  |L21.28|
00001c  b3a2              CBZ      r2,|L21.136|
00001e  8890              LDRH     r0,[r2,#4]            ;200
000020  b280              UXTH     r0,r0                 ;200
000022  61d8              STR      r0,[r3,#0x1c]         ;200
000024  e9d20501          LDRD     r0,r5,[r2,#4]         ;202
000028  4368              MULS     r0,r5,r0              ;202
00002a  6218              STR      r0,[r3,#0x20]         ;202
00002c  6a08              LDR      r0,[r1,#0x20]         ;204
00002e  f4407000          ORR      r0,r0,#0x200          ;204
000032  6208              STR      r0,[r1,#0x20]         ;204
000034  6910              LDR      r0,[r2,#0x10]         ;206
000036  b120              CBZ      r0,|L21.66|
000038  6a08              LDR      r0,[r1,#0x20]         ;208
00003a  f4406080          ORR      r0,r0,#0x400          ;208
00003e  6208              STR      r0,[r1,#0x20]         ;208
000040  e013              B        |L21.106|
                  |L21.66|
000042  6850              LDR      r0,[r2,#4]            ;213
000044  f5b07f80          CMP      r0,#0x100             ;213
000048  d809              BHI      |L21.94|
00004a  8890              LDRH     r0,[r2,#4]            ;215
00004c  f44f057f          MOV      r5,#0xff0000          ;215
000050  ea054000          AND      r0,r5,r0,LSL #16      ;215
000054  f0400001          ORR      r0,r0,#1              ;215
000058  f8c30100          STR      r0,[r3,#0x100]        ;215
00005c  e005              B        |L21.106|
                  |L21.94|
00005e  f8d30100          LDR      r0,[r3,#0x100]        ;219
000062  f0200001          BIC      r0,r0,#1              ;219
000066  f8c30100          STR      r0,[r3,#0x100]        ;219
                  |L21.106|
00006a  7810              LDRB     r0,[r2,#0]            ;223
00006c  b118              CBZ      r0,|L21.118|
00006e  6a08              LDR      r0,[r1,#0x20]         ;225
000070  f4406000          ORR      r0,r0,#0x800          ;225
000074  6208              STR      r0,[r1,#0x20]         ;225
                  |L21.118|
000076  7850              LDRB     r0,[r2,#1]            ;228
000078  b130              CBZ      r0,|L21.136|
00007a  6890              LDR      r0,[r2,#8]            ;229
00007c  2801              CMP      r0,#1                 ;229
00007e  d903              BLS      |L21.136|
000080  6a08              LDR      r0,[r1,#0x20]         ;231
000082  f4405080          ORR      r0,r0,#0x1000         ;231
000086  6208              STR      r0,[r1,#0x20]         ;231
                  |L21.136|
000088  69c8              LDR      r0,[r1,#0x1c]         ;235
00008a  2803              CMP      r0,#3                 ;235
00008c  d104              BNE      |L21.152|
00008e  6a08              LDR      r0,[r1,#0x20]         ;237
000090  f44070e0          ORR      r0,r0,#0x1c0          ;237
000094  6208              STR      r0,[r1,#0x20]         ;237
000096  e010              B        |L21.186|
                  |L21.152|
000098  69c8              LDR      r0,[r1,#0x1c]         ;239
00009a  2804              CMP      r0,#4                 ;239
00009c  d002              BEQ      |L21.164|
00009e  69c8              LDR      r0,[r1,#0x1c]         ;239
0000a0  2805              CMP      r0,#5                 ;239
0000a2  d104              BNE      |L21.174|
                  |L21.164|
0000a4  6a08              LDR      r0,[r1,#0x20]         ;241
0000a6  f0400040          ORR      r0,r0,#0x40           ;241
0000aa  6208              STR      r0,[r1,#0x20]         ;241
0000ac  e005              B        |L21.186|
                  |L21.174|
0000ae  69c8              LDR      r0,[r1,#0x1c]         ;245
0000b0  b118              CBZ      r0,|L21.186|
0000b2  6a08              LDR      r0,[r1,#0x20]         ;247
0000b4  f44070a0          ORR      r0,r0,#0x140          ;247
0000b8  6208              STR      r0,[r1,#0x20]         ;247
                  |L21.186|
0000ba  6988              LDR      r0,[r1,#0x18]         ;251
0000bc  2803              CMP      r0,#3                 ;251
0000be  d103              BNE      |L21.200|
0000c0  6a08              LDR      r0,[r1,#0x20]         ;253
0000c2  f4404080          ORR      r0,r0,#0x4000         ;253
0000c6  6208              STR      r0,[r1,#0x20]         ;253
                  |L21.200|
0000c8  6a08              LDR      r0,[r1,#0x20]         ;257
0000ca  f0402020          ORR      r0,r0,#0x20002000     ;257
0000ce  6208              STR      r0,[r1,#0x20]         ;257
0000d0  2000              MOVS     r0,#0                 ;259
0000d2  e7a2              B        |L21.26|
;;;261    
                          ENDP


                          AREA ||i.SDIF_TransferCreateHandle||, CODE, READONLY, ALIGN=2

                  SDIF_TransferCreateHandle PROC
;;;1088   
;;;1089   void SDIF_TransferCreateHandle(SDIF_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1090                                  sdif_handle_t *handle,
;;;1091                                  sdif_transfer_callback_t *callback,
;;;1092                                  void *userData)
;;;1093   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;1094       assert(handle);
00000c  b104              CBZ      r4,|L22.16|
00000e  e005              B        |L22.28|
                  |L22.16|
000010  f2404246          MOV      r2,#0x446
000014  a123              ADR      r1,|L22.164|
000016  a029              ADR      r0,|L22.188|
000018  f7fffffe          BL       __aeabi_assert
                  |L22.28|
;;;1095       assert(callback);
00001c  b105              CBZ      r5,|L22.32|
00001e  e005              B        |L22.44|
                  |L22.32|
000020  f2404247          MOV      r2,#0x447
000024  a11f              ADR      r1,|L22.164|
000026  a027              ADR      r0,|L22.196|
000028  f7fffffe          BL       __aeabi_assert
                  |L22.44|
;;;1096   
;;;1097       /* reset the handle. */
;;;1098       memset(handle, 0U, sizeof(*handle));
00002c  2128              MOVS     r1,#0x28
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       __aeabi_memclr4
;;;1099   
;;;1100       /* Set the callback. */
;;;1101       handle->callback.SDIOInterrupt = callback->SDIOInterrupt;
000034  6828              LDR      r0,[r5,#0]
000036  6160              STR      r0,[r4,#0x14]
;;;1102       handle->callback.DMADesUnavailable = callback->DMADesUnavailable;
000038  6869              LDR      r1,[r5,#4]
00003a  61a1              STR      r1,[r4,#0x18]
;;;1103       handle->callback.CommandReload = callback->CommandReload;
00003c  68a9              LDR      r1,[r5,#8]
00003e  61e1              STR      r1,[r4,#0x1c]
;;;1104       handle->callback.TransferComplete = callback->TransferComplete;
000040  68e9              LDR      r1,[r5,#0xc]
000042  6221              STR      r1,[r4,#0x20]
;;;1105   
;;;1106       handle->userData = userData;
000044  f8c48024          STR      r8,[r4,#0x24]
;;;1107   
;;;1108       /* Save the handle in global variables to support the double weak mechanism. */
;;;1109       s_sdifHandle[SDIF_GetInstance(base)] = handle;
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       SDIF_GetInstance
00004e  4920              LDR      r1,|L22.208|
000050  f8414020          STR      r4,[r1,r0,LSL #2]
;;;1110   
;;;1111       /* save IRQ handler */
;;;1112       s_sdifIsr = SDIF_TransferHandleIRQ;
000054  481f              LDR      r0,|L22.212|
000056  4920              LDR      r1,|L22.216|
000058  6008              STR      r0,[r1,#0]  ; s_sdifIsr
;;;1113   
;;;1114       /* enable the global interrupt */
;;;1115       SDIF_EnableGlobalInterrupt(base, true);
00005a  2001              MOVS     r0,#1
00005c  b120              CBZ      r0,|L22.104|
00005e  6839              LDR      r1,[r7,#0]
000060  f0410110          ORR      r1,r1,#0x10
000064  6039              STR      r1,[r7,#0]
000066  e003              B        |L22.112|
                  |L22.104|
000068  6839              LDR      r1,[r7,#0]
00006a  f0210110          BIC      r1,r1,#0x10
00006e  6039              STR      r1,[r7,#0]
                  |L22.112|
000070  bf00              NOP      
;;;1116   
;;;1117       EnableIRQ(s_sdifIRQ[SDIF_GetInstance(base)]);
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       SDIF_GetInstance
000078  4918              LDR      r1,|L22.220|
00007a  560e              LDRSB    r6,[r1,r0]
00007c  f1160f80          CMN      r6,#0x80
000080  d100              BNE      |L22.132|
000082  e00c              B        |L22.158|
                  |L22.132|
000084  bf00              NOP      
000086  f006011f          AND      r1,r6,#0x1f
00008a  2001              MOVS     r0,#1
00008c  4088              LSLS     r0,r0,r1
00008e  0971              LSRS     r1,r6,#5
000090  0089              LSLS     r1,r1,#2
000092  f10121e0          ADD      r1,r1,#0xe000e000
000096  f8c10100          STR      r0,[r1,#0x100]
00009a  bf00              NOP      
00009c  bf00              NOP      
                  |L22.158|
;;;1118   }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;1119   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L22.164|
0000a4  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
0000a8  44726976
0000ac  6572735c
0000b0  66736c5f
0000b4  73646966
0000b8  2e6300  
0000bb  00                DCB      0
                  |L22.188|
0000bc  68616e64          DCB      "handle",0
0000c0  6c6500  
0000c3  00                DCB      0
                  |L22.196|
0000c4  63616c6c          DCB      "callback",0
0000c8  6261636b
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L22.208|
                          DCD      s_sdifHandle
                  |L22.212|
                          DCD      SDIF_TransferHandleIRQ
                  |L22.216|
                          DCD      s_sdifIsr
                  |L22.220|
                          DCD      s_sdifIRQ

                          AREA ||i.SDIF_TransferDataBlocking||, CODE, READONLY, ALIGN=2

                  SDIF_TransferDataBlocking PROC
;;;569    
;;;570    static status_t SDIF_TransferDataBlocking(SDIF_Type *base, sdif_data_t *data, bool isDMA)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;571    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;572        assert(NULL != data);
00000a  b104              CBZ      r4,|L23.14|
00000c  e005              B        |L23.26|
                  |L23.14|
00000e  f44f720f          MOV      r2,#0x23c
000012  a124              ADR      r1,|L23.164|
000014  a029              ADR      r0,|L23.188|
000016  f7fffffe          BL       __aeabi_assert
                  |L23.26|
;;;573    
;;;574        uint32_t dmaStatus = 0U;
00001a  2500              MOVS     r5,#0
;;;575        status_t error = kStatus_Success;
00001c  46a8              MOV      r8,r5
;;;576    
;;;577        /* in DMA mode, only need to wait the complete flag and check error */
;;;578        if (isDMA)
00001e  b387              CBZ      r7,|L23.130|
;;;579        {
;;;580            do
000020  bf00              NOP      
                  |L23.34|
;;;581            {
;;;582                dmaStatus = SDIF_GetInternalDMAStatus(base);
000022  bf00              NOP      
000024  f8d6008c          LDR      r0,[r6,#0x8c]
000028  4605              MOV      r5,r0
;;;583                if ((dmaStatus & kSDIF_DMAFatalBusError) == kSDIF_DMAFatalBusError)
00002a  f0050004          AND      r0,r5,#4
00002e  2804              CMP      r0,#4
000030  d106              BNE      |L23.64|
;;;584                {
;;;585                    SDIF_ClearInternalDMAStatus(base, kSDIF_DMAFatalBusError | kSDIF_AbnormalInterruptSummary);
000032  f44f7101          MOV      r1,#0x204
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       SDIF_ClearInternalDMAStatus
;;;586                    error = kStatus_SDIF_DMATransferFailWithFBE; /* in this condition,need reset */
00003c  f2417811          MOV      r8,#0x1711
                  |L23.64|
;;;587                }
;;;588                /* Card error summary, include EBE,SBE,Data CRC,RTO,DRTO,Response error */
;;;589                if ((dmaStatus & kSDIF_DMACardErrorSummary) == kSDIF_DMACardErrorSummary)
000040  f0050020          AND      r0,r5,#0x20
000044  2820              CMP      r0,#0x20
000046  d109              BNE      |L23.92|
;;;590                {
;;;591                    SDIF_ClearInternalDMAStatus(base, kSDIF_DMACardErrorSummary | kSDIF_AbnormalInterruptSummary);
000048  f44f7108          MOV      r1,#0x220
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       SDIF_ClearInternalDMAStatus
;;;592                    if (!(data->enableIgnoreError))
000052  78a0              LDRB     r0,[r4,#2]
000054  b908              CBNZ     r0,|L23.90|
;;;593                    {
;;;594                        error = kStatus_SDIF_DataTransferFail;
000056  f2417812          MOV      r8,#0x1712
                  |L23.90|
;;;595                    }
;;;596    
;;;597                    /* if error occur, then return */
;;;598                    break;
00005a  e003              B        |L23.100|
                  |L23.92|
;;;599                }
;;;600            } while ((dmaStatus & (kSDIF_DMATransFinishOneDescriptor | kSDIF_DMARecvFinishOneDescriptor)) == 0U);
00005c  f0050003          AND      r0,r5,#3
000060  2800              CMP      r0,#0
000062  d0de              BEQ      |L23.34|
                  |L23.100|
000064  bf00              NOP                            ;598
;;;601    
;;;602            /* clear the corresponding status bit */
;;;603            SDIF_ClearInternalDMAStatus(base, (kSDIF_DMATransFinishOneDescriptor | kSDIF_DMARecvFinishOneDescriptor |
000066  f2401103          MOV      r1,#0x103
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       SDIF_ClearInternalDMAStatus
;;;604                                               kSDIF_NormalInterruptSummary));
;;;605    
;;;606            SDIF_ClearInterruptStatus(base, SDIF_GetInterruptStatus(base));
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       SDIF_GetInterruptStatus
000076  4681              MOV      r9,r0
000078  4649              MOV      r1,r9
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       SDIF_ClearInterruptStatus
000080  e00d              B        |L23.158|
                  |L23.130|
000082  e7ff              B        |L23.132|
                  |L23.132|
;;;607        }
;;;608        else
;;;609        {
;;;610            if (data->rxData != NULL)
000084  68e0              LDR      r0,[r4,#0xc]
000086  b128              CBZ      r0,|L23.148|
;;;611            {
;;;612                error = SDIF_ReadDataPortBlocking(base, data);
000088  4621              MOV      r1,r4
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       SDIF_ReadDataPortBlocking
000090  4680              MOV      r8,r0
000092  e004              B        |L23.158|
                  |L23.148|
;;;613            }
;;;614            else
;;;615            {
;;;616                error = SDIF_WriteDataPortBlocking(base, data);
000094  4621              MOV      r1,r4
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       SDIF_WriteDataPortBlocking
00009c  4680              MOV      r8,r0
                  |L23.158|
;;;617            }
;;;618        }
;;;619    
;;;620        return error;
00009e  4640              MOV      r0,r8
;;;621    }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;622    
                          ENDP

                  |L23.164|
0000a4  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
0000a8  44726976
0000ac  6572735c
0000b0  66736c5f
0000b4  73646966
0000b8  2e6300  
0000bb  00                DCB      0
                  |L23.188|
0000bc  4e554c4c          DCB      "NULL != data",0
0000c0  20213d20
0000c4  64617461
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.SDIF_TransferHandleCommand||, CODE, READONLY, ALIGN=2

                  SDIF_TransferHandleCommand PROC
;;;1132   
;;;1133   static void SDIF_TransferHandleCommand(SDIF_Type *base, sdif_handle_t *handle, uint32_t interruptFlags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1134   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1135       assert(handle->command);
00000a  6860              LDR      r0,[r4,#4]
00000c  b100              CBZ      r0,|L24.16|
00000e  e005              B        |L24.28|
                  |L24.16|
000010  f240426f          MOV      r2,#0x46f
000014  a111              ADR      r1,|L24.92|
000016  a017              ADR      r0,|L24.116|
000018  f7fffffe          BL       __aeabi_assert
                  |L24.28|
;;;1136   
;;;1137       /* transfer error */
;;;1138       if (interruptFlags & (kSDIF_ResponseError | kSDIF_ResponseCRCError | kSDIF_ResponseTimeout))
00001c  f40570a1          AND      r0,r5,#0x142
000020  b138              CBZ      r0,|L24.50|
;;;1139       {
;;;1140           handle->callback.TransferComplete(base, handle, kStatus_SDIF_SendCmdFail, handle->userData);
000022  f241720f          MOV      r2,#0x170f
000026  4621              MOV      r1,r4
000028  4630              MOV      r0,r6
00002a  e9d47308          LDRD     r7,r3,[r4,#0x20]
00002e  47b8              BLX      r7
000030  e012              B        |L24.88|
                  |L24.50|
;;;1141       }
;;;1142       /* cmd buffer full, in this condition user need re-send the command */
;;;1143       else if (interruptFlags & kSDIF_HardwareLockError)
000032  f4055080          AND      r0,r5,#0x1000
000036  b120              CBZ      r0,|L24.66|
;;;1144       {
;;;1145           if (handle->callback.CommandReload)
000038  69e0              LDR      r0,[r4,#0x1c]
00003a  b168              CBZ      r0,|L24.88|
;;;1146           {
;;;1147               handle->callback.CommandReload();
00003c  69e0              LDR      r0,[r4,#0x1c]
00003e  4780              BLX      r0
000040  e00a              B        |L24.88|
                  |L24.66|
;;;1148           }
;;;1149       }
;;;1150       /* transfer command success */
;;;1151       else
;;;1152       {
;;;1153           SDIF_ReadCommandResponse(base, handle->command);
000042  6861              LDR      r1,[r4,#4]
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       SDIF_ReadCommandResponse
;;;1154   
;;;1155           handle->callback.TransferComplete(base, handle, kStatus_SDIF_CommandTransferSuccess, handle->userData);
00004a  f2417214          MOV      r2,#0x1714
00004e  4621              MOV      r1,r4
000050  4630              MOV      r0,r6
000052  e9d47308          LDRD     r7,r3,[r4,#0x20]
000056  47b8              BLX      r7
                  |L24.88|
;;;1156       }
;;;1157   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1158   
                          ENDP

                  |L24.92|
00005c  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000060  44726976
000064  6572735c
000068  66736c5f
00006c  73646966
000070  2e6300  
000073  00                DCB      0
                  |L24.116|
000074  68616e64          DCB      "handle->command",0
000078  6c652d3e
00007c  636f6d6d
000080  616e6400

                          AREA ||i.SDIF_TransferHandleDMA||, CODE, READONLY, ALIGN=1

                  SDIF_TransferHandleDMA PROC
;;;1208   
;;;1209   static void SDIF_TransferHandleDMA(SDIF_Type *base, sdif_handle_t *handle, uint32_t interruptFlags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1210   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1211       if (interruptFlags & kSDIF_DMAFatalBusError)
00000a  f0050004          AND      r0,r5,#4
00000e  b138              CBZ      r0,|L25.32|
;;;1212       {
;;;1213           handle->callback.TransferComplete(base, handle, kStatus_SDIF_DMATransferFailWithFBE, handle->userData);
000010  f2417211          MOV      r2,#0x1711
000014  4621              MOV      r1,r4
000016  4630              MOV      r0,r6
000018  e9d47308          LDRD     r7,r3,[r4,#0x20]
00001c  47b8              BLX      r7
00001e  e019              B        |L25.84|
                  |L25.32|
;;;1214       }
;;;1215       else if (interruptFlags & kSDIF_DMADescriptorUnavailable)
000020  f0050010          AND      r0,r5,#0x10
000024  b120              CBZ      r0,|L25.48|
;;;1216       {
;;;1217           if (handle->callback.DMADesUnavailable)
000026  69a0              LDR      r0,[r4,#0x18]
000028  b1a0              CBZ      r0,|L25.84|
;;;1218           {
;;;1219               handle->callback.DMADesUnavailable();
00002a  69a0              LDR      r0,[r4,#0x18]
00002c  4780              BLX      r0
00002e  e011              B        |L25.84|
                  |L25.48|
;;;1220           }
;;;1221       }
;;;1222       else if (interruptFlags & kSDIF_NormalInterruptSummary)
000030  f4057080          AND      r0,r5,#0x100
000034  b138              CBZ      r0,|L25.70|
;;;1223       {
;;;1224           handle->callback.TransferComplete(base, handle, kStatus_SDIF_DMATransferSuccess, handle->userData);
000036  f2417215          MOV      r2,#0x1715
00003a  4621              MOV      r1,r4
00003c  4630              MOV      r0,r6
00003e  e9d47308          LDRD     r7,r3,[r4,#0x20]
000042  47b8              BLX      r7
000044  e006              B        |L25.84|
                  |L25.70|
;;;1225       }
;;;1226       /* card error summary */
;;;1227       else
;;;1228       {
;;;1229           handle->callback.TransferComplete(base, handle, kStatus_SDIF_DataTransferFail, handle->userData);
000046  f2417212          MOV      r2,#0x1712
00004a  4621              MOV      r1,r4
00004c  4630              MOV      r0,r6
00004e  e9d47308          LDRD     r7,r3,[r4,#0x20]
000052  47b8              BLX      r7
                  |L25.84|
;;;1230       }
;;;1231   }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;1232   
                          ENDP


                          AREA ||i.SDIF_TransferHandleData||, CODE, READONLY, ALIGN=2

                  SDIF_TransferHandleData PROC
;;;1158   
;;;1159   static void SDIF_TransferHandleData(SDIF_Type *base, sdif_handle_t *handle, uint32_t interruptFlags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1160   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1161       assert(handle->data);
00000a  6820              LDR      r0,[r4,#0]
00000c  b100              CBZ      r0,|L26.16|
00000e  e005              B        |L26.28|
                  |L26.16|
000010  f2404289          MOV      r2,#0x489
000014  a12e              ADR      r1,|L26.208|
000016  a034              ADR      r0,|L26.232|
000018  f7fffffe          BL       __aeabi_assert
                  |L26.28|
;;;1162   
;;;1163       /* data starvation by host time out, software should read/write FIFO*/
;;;1164       if (interruptFlags & kSDIF_DataStarvationByHostTimeout)
00001c  f4056080          AND      r0,r5,#0x400
000020  b1d8              CBZ      r0,|L26.90|
;;;1165       {
;;;1166           if (handle->data->rxData != NULL)
000022  6820              LDR      r0,[r4,#0]
000024  68c0              LDR      r0,[r0,#0xc]
000026  b130              CBZ      r0,|L26.54|
;;;1167           {
;;;1168               handle->transferredWords = SDIF_ReadDataPort(base, handle->data, handle->transferredWords);
000028  6922              LDR      r2,[r4,#0x10]
00002a  6821              LDR      r1,[r4,#0]
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       SDIF_ReadDataPort
000032  6120              STR      r0,[r4,#0x10]
000034  e030              B        |L26.152|
                  |L26.54|
;;;1169           }
;;;1170           else if (handle->data->txData != NULL)
000036  6820              LDR      r0,[r4,#0]
000038  6900              LDR      r0,[r0,#0x10]
00003a  b130              CBZ      r0,|L26.74|
;;;1171           {
;;;1172               handle->transferredWords = SDIF_WriteDataPort(base, handle->data, handle->transferredWords);
00003c  6922              LDR      r2,[r4,#0x10]
00003e  6821              LDR      r1,[r4,#0]
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       SDIF_WriteDataPort
000046  6120              STR      r0,[r4,#0x10]
000048  e026              B        |L26.152|
                  |L26.74|
;;;1173           }
;;;1174           else
;;;1175           {
;;;1176               handle->callback.TransferComplete(base, handle, kStatus_SDIF_DataTransferFail, handle->userData);
00004a  f2417212          MOV      r2,#0x1712
00004e  4621              MOV      r1,r4
000050  4630              MOV      r0,r6
000052  e9d47308          LDRD     r7,r3,[r4,#0x20]
000056  47b8              BLX      r7
000058  e01e              B        |L26.152|
                  |L26.90|
;;;1177           }
;;;1178       }
;;;1179       /* data transfer fail */
;;;1180       else if (interruptFlags & kSDIF_DataTransferError)
00005a  f64a2080          MOV      r0,#0xaa80
00005e  4028              ANDS     r0,r0,r5
000060  b138              CBZ      r0,|L26.114|
;;;1181       {
;;;1182           handle->callback.TransferComplete(base, handle, kStatus_SDIF_DataTransferFail, handle->userData);
000062  f2417212          MOV      r2,#0x1712
000066  4621              MOV      r1,r4
000068  4630              MOV      r0,r6
00006a  e9d47308          LDRD     r7,r3,[r4,#0x20]
00006e  47b8              BLX      r7
000070  e012              B        |L26.152|
                  |L26.114|
;;;1183       }
;;;1184       /* need fill data to FIFO */
;;;1185       else if (interruptFlags & kSDIF_WriteFIFORequest)
000072  f0050010          AND      r0,r5,#0x10
000076  b130              CBZ      r0,|L26.134|
;;;1186       {
;;;1187           handle->transferredWords = SDIF_WriteDataPort(base, handle->data, handle->transferredWords);
000078  6922              LDR      r2,[r4,#0x10]
00007a  6821              LDR      r1,[r4,#0]
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       SDIF_WriteDataPort
000082  6120              STR      r0,[r4,#0x10]
000084  e008              B        |L26.152|
                  |L26.134|
;;;1188       }
;;;1189       /* need read data from FIFO */
;;;1190       else if (interruptFlags & kSDIF_ReadFIFORequest)
000086  f0050020          AND      r0,r5,#0x20
00008a  b128              CBZ      r0,|L26.152|
;;;1191       {
;;;1192           handle->transferredWords = SDIF_ReadDataPort(base, handle->data, handle->transferredWords);
00008c  6922              LDR      r2,[r4,#0x10]
00008e  6821              LDR      r1,[r4,#0]
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       SDIF_ReadDataPort
000096  6120              STR      r0,[r4,#0x10]
                  |L26.152|
;;;1193       }
;;;1194       else
;;;1195       {
;;;1196       }
;;;1197   
;;;1198       /* data transfer over */
;;;1199       if (interruptFlags & kSDIF_DataTransferOver)
000098  f0050008          AND      r0,r5,#8
00009c  b1a8              CBZ      r0,|L26.202|
;;;1200       {
;;;1201           while ((handle->data->rxData != NULL) && ((base->STATUS & SDIF_STATUS_FIFO_COUNT_MASK) != 0U))
00009e  e005              B        |L26.172|
                  |L26.160|
;;;1202           {
;;;1203               handle->transferredWords = SDIF_ReadDataPort(base, handle->data, handle->transferredWords);
0000a0  6922              LDR      r2,[r4,#0x10]
0000a2  6821              LDR      r1,[r4,#0]
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       SDIF_ReadDataPort
0000aa  6120              STR      r0,[r4,#0x10]
                  |L26.172|
0000ac  6820              LDR      r0,[r4,#0]            ;1201
0000ae  68c0              LDR      r0,[r0,#0xc]          ;1201
0000b0  b120              CBZ      r0,|L26.188|
0000b2  6cb0              LDR      r0,[r6,#0x48]         ;1201
0000b4  4910              LDR      r1,|L26.248|
0000b6  4008              ANDS     r0,r0,r1              ;1201
0000b8  2800              CMP      r0,#0                 ;1201
0000ba  d1f1              BNE      |L26.160|
                  |L26.188|
;;;1204           }
;;;1205           handle->callback.TransferComplete(base, handle, kStatus_SDIF_DataTransferSuccess, handle->userData);
0000bc  f2417213          MOV      r2,#0x1713
0000c0  4621              MOV      r1,r4
0000c2  4630              MOV      r0,r6
0000c4  e9d47308          LDRD     r7,r3,[r4,#0x20]
0000c8  47b8              BLX      r7
                  |L26.202|
;;;1206       }
;;;1207   }
0000ca  e8bd81f0          POP      {r4-r8,pc}
;;;1208   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L26.208|
0000d0  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
0000d4  44726976
0000d8  6572735c
0000dc  66736c5f
0000e0  73646966
0000e4  2e6300  
0000e7  00                DCB      0
                  |L26.232|
0000e8  68616e64          DCB      "handle->data",0
0000ec  6c652d3e
0000f0  64617461
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L26.248|
                          DCD      0x3ffe0000

                          AREA ||i.SDIF_TransferHandleIRQ||, CODE, READONLY, ALIGN=2

                  SDIF_TransferHandleIRQ PROC
;;;1240   
;;;1241   static void SDIF_TransferHandleIRQ(SDIF_Type *base, sdif_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1242   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;1243       assert(handle);
000008  b106              CBZ      r6,|L27.12|
00000a  e005              B        |L27.24|
                  |L27.12|
00000c  f24042db          MOV      r2,#0x4db
000010  a11f              ADR      r1,|L27.144|
000012  a025              ADR      r0,|L27.168|
000014  f7fffffe          BL       __aeabi_assert
                  |L27.24|
;;;1244   
;;;1245       uint32_t interruptFlags, dmaInterruptFlags;
;;;1246   
;;;1247       interruptFlags = SDIF_GetInterruptStatus(base);
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       SDIF_GetInterruptStatus
00001e  4604              MOV      r4,r0
;;;1248       dmaInterruptFlags = SDIF_GetInternalDMAStatus(base);
000020  bf00              NOP      
000022  f8d7508c          LDR      r5,[r7,#0x8c]
000026  bf00              NOP      
;;;1249   
;;;1250       handle->interruptFlags = interruptFlags;
000028  60b4              STR      r4,[r6,#8]
;;;1251       handle->dmaInterruptFlags = dmaInterruptFlags;
00002a  60f5              STR      r5,[r6,#0xc]
;;;1252   
;;;1253       if ((interruptFlags & kSDIF_CommandTransferStatus) != 0U)
00002c  f2411146          MOV      r1,#0x1146
000030  ea040001          AND      r0,r4,r1
000034  b130              CBZ      r0,|L27.68|
;;;1254       {
;;;1255           SDIF_TransferHandleCommand(base, handle, (interruptFlags & kSDIF_CommandTransferStatus));
000036  4608              MOV      r0,r1
000038  ea040200          AND      r2,r4,r0
00003c  4631              MOV      r1,r6
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       SDIF_TransferHandleCommand
                  |L27.68|
;;;1256       }
;;;1257       if ((interruptFlags & kSDIF_DataTransferStatus) != 0U)
000044  f64e60b8          MOV      r0,#0xeeb8
000048  4020              ANDS     r0,r0,r4
00004a  b138              CBZ      r0,|L27.92|
;;;1258       {
;;;1259           SDIF_TransferHandleData(base, handle, (interruptFlags & kSDIF_DataTransferStatus));
00004c  f64e60b8          MOV      r0,#0xeeb8
000050  ea040200          AND      r2,r4,r0
000054  4631              MOV      r1,r6
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       SDIF_TransferHandleData
                  |L27.92|
;;;1260       }
;;;1261       if (interruptFlags & kSDIF_SDIOInterrupt)
00005c  f4043080          AND      r0,r4,#0x10000
000060  b110              CBZ      r0,|L27.104|
;;;1262       {
;;;1263           SDIF_TransferHandleSDIOInterrupt(handle);
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       SDIF_TransferHandleSDIOInterrupt
                  |L27.104|
;;;1264       }
;;;1265       if (dmaInterruptFlags & kSDIF_DMAAllStatus)
000068  f2403037          MOV      r0,#0x337
00006c  4028              ANDS     r0,r0,r5
00006e  b120              CBZ      r0,|L27.122|
;;;1266       {
;;;1267           SDIF_TransferHandleDMA(base, handle, dmaInterruptFlags);
000070  462a              MOV      r2,r5
000072  4631              MOV      r1,r6
000074  4638              MOV      r0,r7
000076  f7fffffe          BL       SDIF_TransferHandleDMA
                  |L27.122|
;;;1268       }
;;;1269   
;;;1270       SDIF_ClearInterruptStatus(base, interruptFlags);
00007a  4621              MOV      r1,r4
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       SDIF_ClearInterruptStatus
;;;1271       SDIF_ClearInternalDMAStatus(base, dmaInterruptFlags);
000082  4629              MOV      r1,r5
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       SDIF_ClearInternalDMAStatus
;;;1272   }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;1273   
                          ENDP

00008e  0000              DCW      0x0000
                  |L27.144|
000090  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000094  44726976
000098  6572735c
00009c  66736c5f
0000a0  73646966
0000a4  2e6300  
0000a7  00                DCB      0
                  |L27.168|
0000a8  68616e64          DCB      "handle",0
0000ac  6c6500  
0000af  00                DCB      0

                          AREA ||i.SDIF_TransferHandleSDIOInterrupt||, CODE, READONLY, ALIGN=1

                  SDIF_TransferHandleSDIOInterrupt PROC
;;;1232   
;;;1233   static void SDIF_TransferHandleSDIOInterrupt(sdif_handle_t *handle)
000000  b510              PUSH     {r4,lr}
;;;1234   {
000002  4604              MOV      r4,r0
;;;1235       if (handle->callback.SDIOInterrupt != NULL)
000004  6960              LDR      r0,[r4,#0x14]
000006  b108              CBZ      r0,|L28.12|
;;;1236       {
;;;1237           handle->callback.SDIOInterrupt();
000008  6960              LDR      r0,[r4,#0x14]
00000a  4780              BLX      r0
                  |L28.12|
;;;1238       }
;;;1239   }
00000c  bd10              POP      {r4,pc}
;;;1240   
                          ENDP


                          AREA ||i.SDIF_TransferNonBlocking||, CODE, READONLY, ALIGN=2

                  SDIF_TransferNonBlocking PROC
;;;1047   
;;;1048   status_t SDIF_TransferNonBlocking(SDIF_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1049                                     sdif_handle_t *handle,
;;;1050                                     sdif_dma_config_t *dmaConfig,
;;;1051                                     sdif_transfer_t *transfer)
;;;1052   {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;1053       assert(NULL != transfer);
00000c  b104              CBZ      r4,|L29.16|
00000e  e005              B        |L29.28|
                  |L29.16|
000010  f240421d          MOV      r2,#0x41d
000014  a11a              ADR      r1,|L29.128|
000016  a020              ADR      r0,|L29.152|
000018  f7fffffe          BL       __aeabi_assert
                  |L29.28|
;;;1054   
;;;1055       sdif_data_t *data = transfer->data;
00001c  6825              LDR      r5,[r4,#0]
;;;1056   
;;;1057       /* save the data and command before transfer */
;;;1058       handle->data = transfer->data;
00001e  6820              LDR      r0,[r4,#0]
000020  6030              STR      r0,[r6,#0]
;;;1059       handle->command = transfer->command;
000022  6860              LDR      r0,[r4,#4]
000024  6070              STR      r0,[r6,#4]
;;;1060       handle->transferredWords = 0U;
000026  2000              MOVS     r0,#0
000028  6130              STR      r0,[r6,#0x10]
;;;1061       handle->interruptFlags = 0U;
00002a  60b0              STR      r0,[r6,#8]
;;;1062       handle->dmaInterruptFlags = 0U;
00002c  60f0              STR      r0,[r6,#0xc]
;;;1063   
;;;1064       /* config the transfer parameter */
;;;1065       if (SDIF_TransferConfig(base, transfer) != kStatus_Success)
00002e  4621              MOV      r1,r4
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       SDIF_TransferConfig
000036  b118              CBZ      r0,|L29.64|
;;;1066       {
;;;1067           return kStatue_SDIF_InvalidArgument;
000038  f241700d          MOV      r0,#0x170d
                  |L29.60|
;;;1068       }
;;;1069   
;;;1070       if ((data != NULL) && (dmaConfig != NULL))
;;;1071       {
;;;1072           /* use internal DMA mode to transfer between the card and host*/
;;;1073           if (SDIF_InternalDMAConfig(base, dmaConfig, data->rxData ? data->rxData : data->txData,
;;;1074                                      data->blockSize * data->blockCount) != kStatus_Success)
;;;1075           {
;;;1076               return kStatus_SDIF_DescriptorBufferLenError;
;;;1077           }
;;;1078       }
;;;1079   
;;;1080       /* send command first */
;;;1081       if (SDIF_SendCommand(base, transfer->command, SDIF_TIMEOUT_VALUE) != kStatus_Success)
;;;1082       {
;;;1083           return kStatus_SDIF_SyncCmdTimeout;
;;;1084       }
;;;1085   
;;;1086       return kStatus_Success;
;;;1087   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L29.64|
000040  b195              CBZ      r5,|L29.104|
000042  b18f              CBZ      r7,|L29.104|
000044  e9d50101          LDRD     r0,r1,[r5,#4]         ;1073
000048  fb00f301          MUL      r3,r0,r1              ;1073
00004c  68e8              LDR      r0,[r5,#0xc]          ;1073
00004e  b108              CBZ      r0,|L29.84|
000050  68e8              LDR      r0,[r5,#0xc]          ;1073
000052  e000              B        |L29.86|
                  |L29.84|
000054  6928              LDR      r0,[r5,#0x10]         ;1073
                  |L29.86|
000056  4602              MOV      r2,r0                 ;1073
000058  4639              MOV      r1,r7                 ;1073
00005a  4640              MOV      r0,r8                 ;1073
00005c  f7fffffe          BL       SDIF_InternalDMAConfig
000060  b110              CBZ      r0,|L29.104|
000062  f241700c          MOV      r0,#0x170c            ;1076
000066  e7e9              B        |L29.60|
                  |L29.104|
000068  f64f72ff          MOV      r2,#0xffff            ;1081
00006c  4640              MOV      r0,r8                 ;1081
00006e  6861              LDR      r1,[r4,#4]            ;1081
000070  f7fffffe          BL       SDIF_SendCommand
000074  b110              CBZ      r0,|L29.124|
000076  f241700e          MOV      r0,#0x170e            ;1083
00007a  e7df              B        |L29.60|
                  |L29.124|
00007c  2000              MOVS     r0,#0                 ;1086
00007e  e7dd              B        |L29.60|
;;;1088   
                          ENDP

                  |L29.128|
000080  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
000084  44726976
000088  6572735c
00008c  66736c5f
000090  73646966
000094  2e6300  
000097  00                DCB      0
                  |L29.152|
000098  4e554c4c          DCB      "NULL != transfer",0
00009c  20213d20
0000a0  7472616e
0000a4  73666572
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.SDIF_WaitCommandDone||, CODE, READONLY, ALIGN=1

                  SDIF_WaitCommandDone PROC
;;;289    
;;;290    static status_t SDIF_WaitCommandDone(SDIF_Type *base, sdif_command_t *command)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;292        uint32_t status = 0U;
000006  2400              MOVS     r4,#0
;;;293    
;;;294        do
000008  bf00              NOP      
                  |L30.10|
;;;295        {
;;;296            status = SDIF_GetInterruptStatus(base);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       SDIF_GetInterruptStatus
000010  4604              MOV      r4,r0
;;;297            if ((status &
000012  f2411042          MOV      r0,#0x1142
000016  4020              ANDS     r0,r0,r4
000018  b148              CBZ      r0,|L30.46|
;;;298                 (kSDIF_ResponseError | kSDIF_ResponseCRCError | kSDIF_ResponseTimeout | kSDIF_HardwareLockError)) != 0u)
;;;299            {
;;;300                SDIF_ClearInterruptStatus(base, status & (kSDIF_ResponseError | kSDIF_ResponseCRCError |
00001a  f2411042          MOV      r0,#0x1142
00001e  ea040100          AND      r1,r4,r0
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       SDIF_ClearInterruptStatus
;;;301                                                          kSDIF_ResponseTimeout | kSDIF_HardwareLockError));
;;;302                return kStatus_SDIF_SendCmdFail;
000028  f241700f          MOV      r0,#0x170f
                  |L30.44|
;;;303            }
;;;304        } while ((status & kSDIF_CommandDone) != kSDIF_CommandDone);
;;;305    
;;;306        /* clear the command done bit */
;;;307        SDIF_ClearInterruptStatus(base, status & kSDIF_CommandDone);
;;;308    
;;;309        return SDIF_ReadCommandResponse(base, command);
;;;310    }
00002c  bd70              POP      {r4-r6,pc}
                  |L30.46|
00002e  f0040004          AND      r0,r4,#4              ;304
000032  2804              CMP      r0,#4                 ;304
000034  d1e9              BNE      |L30.10|
000036  f0040104          AND      r1,r4,#4              ;307
00003a  4628              MOV      r0,r5                 ;307
00003c  f7fffffe          BL       SDIF_ClearInterruptStatus
000040  4631              MOV      r1,r6                 ;309
000042  4628              MOV      r0,r5                 ;309
000044  f7fffffe          BL       SDIF_ReadCommandResponse
000048  e7f0              B        |L30.44|
;;;311    
                          ENDP


                          AREA ||i.SDIF_WriteDataPort||, CODE, READONLY, ALIGN=1

                  SDIF_WriteDataPort PROC
;;;406    
;;;407    static uint32_t SDIF_WriteDataPort(SDIF_Type *base, sdif_data_t *data, uint32_t transferredWords)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;408    {
000004  4607              MOV      r7,r0
000006  4613              MOV      r3,r2
;;;409        uint32_t i;
;;;410        uint32_t totalWords;
;;;411        uint32_t wordsCanBeWrite; /* The words can be read at this time. */
;;;412        uint32_t writeWatermark = ((base->FIFOTH & SDIF_FIFOTH_TX_WMARK_MASK) >> SDIF_FIFOTH_TX_WMARK_SHIFT);
000008  6cf8              LDR      r0,[r7,#0x4c]
00000a  f3c0060b          UBFX     r6,r0,#0,#12
;;;413    
;;;414        if (data->blockSize % sizeof(uint32_t) != 0U)
00000e  7908              LDRB     r0,[r1,#4]
000010  f0000003          AND      r0,r0,#3
000014  b140              CBZ      r0,|L31.40|
;;;415        {
;;;416            data->blockSize +=
000016  f891c004          LDRB     r12,[r1,#4]
00001a  f00c0c03          AND      r12,r12,#3
00001e  f1cc0c04          RSB      r12,r12,#4
000022  6848              LDR      r0,[r1,#4]
000024  4460              ADD      r0,r0,r12
000026  6048              STR      r0,[r1,#4]
                  |L31.40|
;;;417                sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
;;;418        }
;;;419    
;;;420        totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
000028  e9d1c001          LDRD     r12,r0,[r1,#4]
00002c  fb00f00c          MUL      r0,r0,r12
000030  0882              LSRS     r2,r0,#2
;;;421    
;;;422        /* If watermark level is equal or bigger than totalWords, transfers totalWords data. */
;;;423        if (writeWatermark >= totalWords)
000032  4296              CMP      r6,r2
000034  d301              BCC      |L31.58|
;;;424        {
;;;425            wordsCanBeWrite = totalWords;
000036  4615              MOV      r5,r2
000038  e007              B        |L31.74|
                  |L31.58|
;;;426        }
;;;427        /* If watermark level is less than totalWords and left words to be sent is equal or bigger than writeWatermark,
;;;428        transfers watermark level words. */
;;;429        else if ((writeWatermark < totalWords) && ((totalWords - transferredWords) >= writeWatermark))
00003a  4296              CMP      r6,r2
00003c  d204              BCS      |L31.72|
00003e  1ad0              SUBS     r0,r2,r3
000040  42b0              CMP      r0,r6
000042  d301              BCC      |L31.72|
;;;430        {
;;;431            wordsCanBeWrite = writeWatermark;
000044  4635              MOV      r5,r6
000046  e000              B        |L31.74|
                  |L31.72|
;;;432        }
;;;433        /* If watermark level is less than totalWords and left words to be sent is less than writeWatermark, transfers left
;;;434        words. */
;;;435        else
;;;436        {
;;;437            wordsCanBeWrite = (totalWords - transferredWords);
000048  1ad5              SUBS     r5,r2,r3
                  |L31.74|
;;;438        }
;;;439    
;;;440        i = 0U;
00004a  2400              MOVS     r4,#0
;;;441        while (i < wordsCanBeWrite)
00004c  e00a              B        |L31.100|
                  |L31.78|
;;;442        {
;;;443            base->FIFO[i] = data->txData[transferredWords++];
00004e  4618              MOV      r0,r3
000050  1c5b              ADDS     r3,r3,#1
000052  f8d18010          LDR      r8,[r1,#0x10]
000056  f858c020          LDR      r12,[r8,r0,LSL #2]
00005a  f5077000          ADD      r0,r7,#0x200
00005e  f840c024          STR      r12,[r0,r4,LSL #2]
;;;444            i++;
000062  1c64              ADDS     r4,r4,#1
                  |L31.100|
000064  42ac              CMP      r4,r5                 ;441
000066  d3f2              BCC      |L31.78|
;;;445        }
;;;446    
;;;447        return transferredWords;
000068  4618              MOV      r0,r3
;;;448    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;449    
                          ENDP


                          AREA ||i.SDIF_WriteDataPortBlocking||, CODE, READONLY, ALIGN=1

                  SDIF_WriteDataPortBlocking PROC
;;;497    
;;;498    static status_t SDIF_WriteDataPortBlocking(SDIF_Type *base, sdif_data_t *data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;499    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;500        uint32_t totalWords;
;;;501        uint32_t transferredWords = 0U;
000008  f04f0800          MOV      r8,#0
;;;502        status_t error = kStatus_Success;
00000c  2600              MOVS     r6,#0
;;;503        uint32_t status;
;;;504    
;;;505        if (data->blockSize % sizeof(uint32_t) != 0U)
00000e  7920              LDRB     r0,[r4,#4]
000010  f0000003          AND      r0,r0,#3
000014  b138              CBZ      r0,|L32.38|
;;;506        {
;;;507            data->blockSize +=
000016  7921              LDRB     r1,[r4,#4]
000018  f0010103          AND      r1,r1,#3
00001c  f1c10104          RSB      r1,r1,#4
000020  6860              LDR      r0,[r4,#4]
000022  4408              ADD      r0,r0,r1
000024  6060              STR      r0,[r4,#4]
                  |L32.38|
;;;508                sizeof(uint32_t) - (data->blockSize % sizeof(uint32_t)); /* make the block size as word-aligned */
;;;509        }
;;;510    
;;;511        totalWords = ((data->blockCount * data->blockSize) / sizeof(uint32_t));
000026  e9d41001          LDRD     r1,r0,[r4,#4]
00002a  4348              MULS     r0,r1,r0
00002c  0887              LSRS     r7,r0,#2
;;;512    
;;;513        while ((transferredWords < totalWords) && (error == kStatus_Success))
00002e  e01a              B        |L32.102|
                  |L32.48|
;;;514        {
;;;515            /* wait data transfer complete or reach RX watermark */
;;;516            do
000030  bf00              NOP      
                  |L32.50|
;;;517            {
;;;518                status = SDIF_GetInterruptStatus(base);
000032  4648              MOV      r0,r9
000034  f7fffffe          BL       SDIF_GetInterruptStatus
000038  4605              MOV      r5,r0
;;;519                if (status & kSDIF_DataTransferError)
00003a  f64a2080          MOV      r0,#0xaa80
00003e  4028              ANDS     r0,r0,r5
000040  b110              CBZ      r0,|L32.72|
;;;520                {
;;;521                    if (!(data->enableIgnoreError))
000042  78a0              LDRB     r0,[r4,#2]
000044  b900              CBNZ     r0,|L32.72|
;;;522                    {
;;;523                        error = kStatus_Fail;
000046  2601              MOVS     r6,#1
                  |L32.72|
;;;524                    }
;;;525                }
;;;526            } while ((status & kSDIF_WriteFIFORequest) == 0U);
000048  f0050010          AND      r0,r5,#0x10
00004c  2800              CMP      r0,#0
00004e  d0f0              BEQ      |L32.50|
;;;527    
;;;528            if (error == kStatus_Success)
000050  b92e              CBNZ     r6,|L32.94|
;;;529            {
;;;530                transferredWords = SDIF_WriteDataPort(base, data, transferredWords);
000052  4642              MOV      r2,r8
000054  4621              MOV      r1,r4
000056  4648              MOV      r0,r9
000058  f7fffffe          BL       SDIF_WriteDataPort
00005c  4680              MOV      r8,r0
                  |L32.94|
;;;531            }
;;;532    
;;;533            /* clear interrupt status */
;;;534            SDIF_ClearInterruptStatus(base, status);
00005e  4629              MOV      r1,r5
000060  4648              MOV      r0,r9
000062  f7fffffe          BL       SDIF_ClearInterruptStatus
                  |L32.102|
000066  45b8              CMP      r8,r7                 ;513
000068  d201              BCS      |L32.110|
00006a  2e00              CMP      r6,#0                 ;513
00006c  d0e0              BEQ      |L32.48|
                  |L32.110|
;;;535        }
;;;536    
;;;537        while ((SDIF_GetInterruptStatus(base) & kSDIF_DataTransferOver) != kSDIF_DataTransferOver)
00006e  bf00              NOP      
                  |L32.112|
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       SDIF_GetInterruptStatus
000076  f0000008          AND      r0,r0,#8
00007a  2808              CMP      r0,#8
00007c  d1f8              BNE      |L32.112|
;;;538        {
;;;539        }
;;;540    
;;;541        if (SDIF_GetInterruptStatus(base) & kSDIF_DataTransferError)
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       SDIF_GetInterruptStatus
000084  f64a2180          MOV      r1,#0xaa80
000088  4008              ANDS     r0,r0,r1
00008a  b110              CBZ      r0,|L32.146|
;;;542        {
;;;543            if (!(data->enableIgnoreError))
00008c  78a0              LDRB     r0,[r4,#2]
00008e  b900              CBNZ     r0,|L32.146|
;;;544            {
;;;545                error = kStatus_Fail;
000090  2601              MOVS     r6,#1
                  |L32.146|
;;;546            }
;;;547        }
;;;548        SDIF_ClearInterruptStatus(base, (kSDIF_DataTransferOver | kSDIF_DataTransferError));
000092  f64a2188          MOV      r1,#0xaa88
000096  4648              MOV      r0,r9
000098  f7fffffe          BL       SDIF_ClearInterruptStatus
;;;549    
;;;550        return error;
00009c  4630              MOV      r0,r6
;;;551    }
00009e  e8bd87f0          POP      {r4-r10,pc}
;;;552    
                          ENDP


                          AREA ||i.SDIO_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  SDIO_DriverIRQHandler PROC
;;;1284   #if defined(SDIF)
;;;1285   void SDIF_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1286   {
;;;1287       assert(s_sdifHandle[0]);
000002  4808              LDR      r0,|L33.36|
000004  6800              LDR      r0,[r0,#0]  ; s_sdifHandle
000006  b100              CBZ      r0,|L33.10|
000008  e005              B        |L33.22|
                  |L33.10|
00000a  f2405207          MOV      r2,#0x507
00000e  a106              ADR      r1,|L33.40|
000010  a00b              ADR      r0,|L33.64|
000012  f7fffffe          BL       __aeabi_assert
                  |L33.22|
;;;1288   
;;;1289       s_sdifIsr(SDIF, s_sdifHandle[0]);
000016  4803              LDR      r0,|L33.36|
000018  6801              LDR      r1,[r0,#0]  ; s_sdifHandle
00001a  480d              LDR      r0,|L33.80|
00001c  4a0d              LDR      r2,|L33.84|
00001e  6812              LDR      r2,[r2,#0]  ; s_sdifIsr
000020  4790              BLX      r2
;;;1290   }
000022  bd10              POP      {r4,pc}
;;;1291   #endif
                          ENDP

                  |L33.36|
                          DCD      s_sdifHandle
                  |L33.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_sdif.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  73646966
00003c  2e6300  
00003f  00                DCB      0
                  |L33.64|
000040  735f7364          DCB      "s_sdifHandle[0]",0
000044  69664861
000048  6e646c65
00004c  5b305d00
                  |L33.80|
                          DCD      0x4009b000
                  |L33.84|
                          DCD      s_sdifIsr

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_sdifBase
                          DCD      0x4009b000
                  s_sdifIRQ
000004  2a                DCB      0x2a

                          AREA ||.data||, DATA, ALIGN=2

                  s_sdifHandle
                          DCD      0x00000000
                  s_sdifIsr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_sdif.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_sdif_c_70efc2d9____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fsl_sdif_c_70efc2d9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_sdif_c_70efc2d9____REVSH|
#line 402
|__asm___10_fsl_sdif_c_70efc2d9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_sdif_c_70efc2d9____RRX|
#line 587
|__asm___10_fsl_sdif_c_70efc2d9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
