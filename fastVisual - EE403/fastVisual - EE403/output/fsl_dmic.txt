; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_dmic.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_dmic.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_dmic.crf SRC\Drivers\fsl_dmic.c]
                          THUMB

                          AREA ||i.DMIC0_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  DMIC0_DriverIRQHandler PROC
;;;219    /*DMIC0 IRQ handler */
;;;220    void DMIC0_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;221    {
;;;222        if (s_dmicCallback[0] != NULL)
000002  4803              LDR      r0,|L1.16|
000004  6800              LDR      r0,[r0,#0]  ; s_dmicCallback
000006  b110              CBZ      r0,|L1.14|
;;;223        {
;;;224            s_dmicCallback[0]();
000008  4901              LDR      r1,|L1.16|
00000a  6808              LDR      r0,[r1,#0]  ; s_dmicCallback
00000c  4780              BLX      r0
                  |L1.14|
;;;225        }
;;;226    }
00000e  bd10              POP      {r4,pc}
;;;227    /*DMIC0 HWVAD IRQ handler */
                          ENDP

                  |L1.16|
                          DCD      s_dmicCallback

                          AREA ||i.DMIC_CfgChannelDc||, CODE, READONLY, ALIGN=1

                  DMIC_CfgChannelDc PROC
;;;145    
;;;146    void DMIC_CfgChannelDc(DMIC_Type *base,
000000  b570              PUSH     {r4-r6,lr}
;;;147                           dmic_channel_t channel,
;;;148                           dc_removal_t dc_cut_level,
;;;149                           uint32_t post_dc_gain_reduce,
;;;150                           bool saturate16bit)
;;;151    {
000002  9c04              LDR      r4,[sp,#0x10]
;;;152        base->CHANNEL[channel].DC_CTRL = DMIC_CHANNEL_DC_CTRL_DCPOLE(dc_cut_level) |
000004  f0020503          AND      r5,r2,#3
000008  26f0              MOVS     r6,#0xf0
00000a  ea061603          AND      r6,r6,r3,LSL #4
00000e  4335              ORRS     r5,r5,r6
000010  f44f7680          MOV      r6,#0x100
000014  ea062604          AND      r6,r6,r4,LSL #8
000018  4335              ORRS     r5,r5,r6
00001a  eb002601          ADD      r6,r0,r1,LSL #8
00001e  f8c65090          STR      r5,[r6,#0x90]
;;;153                                         DMIC_CHANNEL_DC_CTRL_DCGAIN(post_dc_gain_reduce) |
;;;154                                         DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT(saturate16bit);
;;;155    }
000022  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP


                          AREA ||i.DMIC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  DMIC_ConfigChannel PROC
;;;128    
;;;129    void DMIC_ConfigChannel(DMIC_Type *base,
000000  b570              PUSH     {r4-r6,lr}
;;;130                            dmic_channel_t channel,
;;;131                            stereo_side_t side,
;;;132                            dmic_channel_config_t *channel_config)
;;;133    {
;;;134        base->CHANNEL[channel].DIVHFCLK = channel_config->divhfclk;
000002  781c              LDRB     r4,[r3,#0]
000004  eb002501          ADD      r5,r0,r1,LSL #8
000008  606c              STR      r4,[r5,#4]
;;;135        base->CHANNEL[channel].OSR = channel_config->osr;
00000a  eb002501          ADD      r5,r0,r1,LSL #8
00000e  685c              LDR      r4,[r3,#4]
000010  602c              STR      r4,[r5,#0]
;;;136        base->CHANNEL[channel].GAINSHIFT = channel_config->gainshft;
000012  eb002501          ADD      r5,r0,r1,LSL #8
000016  689c              LDR      r4,[r3,#8]
000018  612c              STR      r4,[r5,#0x10]
;;;137        base->CHANNEL[channel].PREAC2FSCOEF = channel_config->preac2coef;
00001a  7b1c              LDRB     r4,[r3,#0xc]
00001c  eb002501          ADD      r5,r0,r1,LSL #8
000020  60ac              STR      r4,[r5,#8]
;;;138        base->CHANNEL[channel].PREAC4FSCOEF = channel_config->preac4coef;
000022  7b5c              LDRB     r4,[r3,#0xd]
000024  eb002501          ADD      r5,r0,r1,LSL #8
000028  60ec              STR      r4,[r5,#0xc]
;;;139        base->CHANNEL[channel].PHY_CTRL =
00002a  f0020401          AND      r4,r2,#1
00002e  7d1d              LDRB     r5,[r3,#0x14]
000030  2602              MOVS     r6,#2
000032  ea060545          AND      r5,r6,r5,LSL #1
000036  432c              ORRS     r4,r4,r5
000038  eb002501          ADD      r5,r0,r1,LSL #8
00003c  f8c5408c          STR      r4,[r5,#0x8c]
;;;140            DMIC_CHANNEL_PHY_CTRL_PHY_FALL(side) | DMIC_CHANNEL_PHY_CTRL_PHY_HALF(channel_config->sample_rate);
;;;141        base->CHANNEL[channel].DC_CTRL = DMIC_CHANNEL_DC_CTRL_DCPOLE(channel_config->dc_cut_level) |
000040  7b9c              LDRB     r4,[r3,#0xe]
000042  f0040403          AND      r4,r4,#3
000046  26f0              MOVS     r6,#0xf0
000048  691d              LDR      r5,[r3,#0x10]
00004a  ea061505          AND      r5,r6,r5,LSL #4
00004e  432c              ORRS     r4,r4,r5
000050  7d5d              LDRB     r5,[r3,#0x15]
000052  f44f7680          MOV      r6,#0x100
000056  ea062505          AND      r5,r6,r5,LSL #8
00005a  432c              ORRS     r4,r4,r5
00005c  eb002501          ADD      r5,r0,r1,LSL #8
000060  f8c54090          STR      r4,[r5,#0x90]
;;;142                                         DMIC_CHANNEL_DC_CTRL_DCGAIN(channel_config->post_dc_gain_reduce) |
;;;143                                         DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT(channel_config->saturate16bit);
;;;144    }
000064  bd70              POP      {r4-r6,pc}
;;;145    
                          ENDP


                          AREA ||i.DMIC_ConfigIO||, CODE, READONLY, ALIGN=1

                  DMIC_ConfigIO PROC
;;;107    
;;;108    void DMIC_ConfigIO(DMIC_Type *base, dmic_io_t config)
000000  f8c01f0c          STR      r1,[r0,#0xf0c]
;;;109    {
;;;110        base->IOCFG = config;
;;;111    }
000004  4770              BX       lr
;;;112    
                          ENDP


                          AREA ||i.DMIC_DeInit||, CODE, READONLY, ALIGN=2

                  DMIC_DeInit PROC
;;;100    
;;;101    void DMIC_DeInit(DMIC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  4605              MOV      r5,r0
;;;103        assert(base);
000004  b105              CBZ      r5,|L5.8|
000006  e004              B        |L5.18|
                  |L5.8|
000008  2267              MOVS     r2,#0x67
00000a  a10e              ADR      r1,|L5.68|
00000c  a013              ADR      r0,|L5.92|
00000e  f7fffffe          BL       __aeabi_assert
                  |L5.18|
;;;104        /* Disable the clock to the register interface */
;;;105        CLOCK_DisableClock(s_dmicClock[DMIC_GetInstance(base)]);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       DMIC_GetInstance
000018  4912              LDR      r1,|L5.100|
00001a  f8314010          LDRH     r4,[r1,r0,LSL #1]
00001e  0a20              LSRS     r0,r4,#8
000020  2803              CMP      r0,#3
000022  d205              BCS      |L5.48|
000024  2101              MOVS     r1,#1
000026  40a1              LSLS     r1,r1,r4
000028  4a0f              LDR      r2,|L5.104|
00002a  f8421020          STR      r1,[r2,r0,LSL #2]
00002e  e006              B        |L5.62|
                  |L5.48|
000030  2101              MOVS     r1,#1
000032  40a1              LSLS     r1,r1,r4
000034  4a0d              LDR      r2,|L5.108|
000036  6191              STR      r1,[r2,#0x18]
000038  2100              MOVS     r1,#0
00003a  0312              LSLS     r2,r2,#12
00003c  64d1              STR      r1,[r2,#0x4c]
                  |L5.62|
00003e  bf00              NOP      
;;;106    }
000040  bd70              POP      {r4-r6,pc}
;;;107    
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_dmic.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  646d6963
000058  2e6300  
00005b  00                DCB      0
                  |L5.92|
00005c  62617365          DCB      "base",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L5.100|
                          DCD      s_dmicClock
                  |L5.104|
                          DCD      0x40000240
                  |L5.108|
                          DCD      0x40040000

                          AREA ||i.DMIC_DisableIntCallback||, CODE, READONLY, ALIGN=2

                  DMIC_DisableIntCallback PROC
;;;185    
;;;186    void DMIC_DisableIntCallback(DMIC_Type *base, dmic_callback_t cb)
000000  b570              PUSH     {r4-r6,lr}
;;;187    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;188        uint32_t instance;
;;;189    
;;;190        instance = DMIC_GetInstance(base);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       DMIC_GetInstance
00000c  4604              MOV      r4,r0
;;;191        DisableIRQ(s_dmicIRQ[instance]);
00000e  4906              LDR      r1,|L6.40|
000010  5708              LDRSB    r0,[r1,r4]
000012  f7fffffe          BL       DisableIRQ
;;;192        s_dmicCallback[instance] = NULL;
000016  2000              MOVS     r0,#0
000018  4904              LDR      r1,|L6.44|
00001a  f8410024          STR      r0,[r1,r4,LSL #2]
;;;193        NVIC_ClearPendingIRQ(s_dmicIRQ[instance]);
00001e  4902              LDR      r1,|L6.40|
000020  5708              LDRSB    r0,[r1,r4]
000022  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;194    }
000026  bd70              POP      {r4-r6,pc}
;;;195    
                          ENDP

                  |L6.40|
                          DCD      s_dmicIRQ
                  |L6.44|
                          DCD      s_dmicCallback

                          AREA ||i.DMIC_EnableChannnel||, CODE, READONLY, ALIGN=1

                  DMIC_EnableChannnel PROC
;;;161    
;;;162    void DMIC_EnableChannnel(DMIC_Type *base, uint32_t channelmask)
000000  f8c01f00          STR      r1,[r0,#0xf00]
;;;163    {
;;;164        base->CHANEN = channelmask;
;;;165    }
000004  4770              BX       lr
;;;166    
                          ENDP


                          AREA ||i.DMIC_EnableIntCallback||, CODE, READONLY, ALIGN=2

                  DMIC_EnableIntCallback PROC
;;;174    
;;;175    void DMIC_EnableIntCallback(DMIC_Type *base, dmic_callback_t cb)
000000  b570              PUSH     {r4-r6,lr}
;;;176    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;177        uint32_t instance;
;;;178    
;;;179        instance = DMIC_GetInstance(base);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       DMIC_GetInstance
00000c  4604              MOV      r4,r0
;;;180        NVIC_ClearPendingIRQ(s_dmicIRQ[instance]);
00000e  4906              LDR      r1,|L8.40|
000010  5708              LDRSB    r0,[r1,r4]
000012  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;181        /* Save callback pointer */
;;;182        s_dmicCallback[instance] = cb;
000016  4805              LDR      r0,|L8.44|
000018  f8405024          STR      r5,[r0,r4,LSL #2]
;;;183        EnableIRQ(s_dmicIRQ[instance]);
00001c  4902              LDR      r1,|L8.40|
00001e  5708              LDRSB    r0,[r1,r4]
000020  f7fffffe          BL       EnableIRQ
;;;184    }
000024  bd70              POP      {r4-r6,pc}
;;;185    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      s_dmicIRQ
                  |L8.44|
                          DCD      s_dmicCallback

                          AREA ||i.DMIC_FifoChannel||, CODE, READONLY, ALIGN=1

                  DMIC_FifoChannel PROC
;;;166    
;;;167    void DMIC_FifoChannel(DMIC_Type *base, uint32_t channel, uint32_t trig_level, uint32_t enable, uint32_t resetn)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  9c04              LDR      r4,[sp,#0x10]
;;;169        base->CHANNEL[channel].FIFO_CTRL |=
000004  eb002501          ADD      r5,r0,r1,LSL #8
000008  f8d55080          LDR      r5,[r5,#0x80]
00000c  f005050c          AND      r5,r5,#0xc
000010  f44f16f8          MOV      r6,#0x1f0000
000014  ea064602          AND      r6,r6,r2,LSL #16
000018  4335              ORRS     r5,r5,r6
00001a  f0030601          AND      r6,r3,#1
00001e  4335              ORRS     r5,r5,r6
000020  2602              MOVS     r6,#2
000022  ea060644          AND      r6,r6,r4,LSL #1
000026  4335              ORRS     r5,r5,r6
000028  eb002601          ADD      r6,r0,r1,LSL #8
00002c  f8d66080          LDR      r6,[r6,#0x80]
000030  4335              ORRS     r5,r5,r6
000032  eb002601          ADD      r6,r0,r1,LSL #8
000036  f8c65080          STR      r5,[r6,#0x80]
;;;170            (base->CHANNEL[channel].FIFO_CTRL & (DMIC_CHANNEL_FIFO_CTRL_INTEN_MASK | DMIC_CHANNEL_FIFO_CTRL_DMAEN_MASK)) |
;;;171            DMIC_CHANNEL_FIFO_CTRL_TRIGLVL(trig_level) | DMIC_CHANNEL_FIFO_CTRL_ENABLE(enable) |
;;;172            DMIC_CHANNEL_FIFO_CTRL_RESETN(resetn);
;;;173    }
00003a  bd70              POP      {r4-r6,pc}
;;;174    
                          ENDP


                          AREA ||i.DMIC_GetInstance||, CODE, READONLY, ALIGN=2

                  DMIC_GetInstance PROC
;;;63      */
;;;64     uint32_t DMIC_GetInstance(DMIC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {
000002  4605              MOV      r5,r0
;;;66         uint32_t instance;
;;;67     
;;;68         /* Find the instance index from base address mappings. */
;;;69         for (instance = 0; instance < FSL_FEATURE_SOC_DMIC_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L10.22|
                  |L10.8|
;;;70         {
;;;71             if (s_dmicBases[instance] == base)
000008  4809              LDR      r0,|L10.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L10.20|
;;;72             {
;;;73                 break;
000012  e002              B        |L10.26|
                  |L10.20|
000014  1c64              ADDS     r4,r4,#1              ;69
                  |L10.22|
000016  2c00              CMP      r4,#0                 ;69
000018  d0f6              BEQ      |L10.8|
                  |L10.26|
00001a  bf00              NOP      
;;;74             }
;;;75         }
;;;76     
;;;77         assert(instance < FSL_FEATURE_SOC_DMIC_COUNT);
00001c  b904              CBNZ     r4,|L10.32|
00001e  e004              B        |L10.42|
                  |L10.32|
000020  224d              MOVS     r2,#0x4d
000022  a104              ADR      r1,|L10.52|
000024  a009              ADR      r0,|L10.76|
000026  f7fffffe          BL       __aeabi_assert
                  |L10.42|
;;;78     
;;;79         return instance;
00002a  4620              MOV      r0,r4
;;;80     }
00002c  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      s_dmicBases
                  |L10.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_dmic.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  646d6963
000048  2e6300  
00004b  00                DCB      0
                  |L10.76|
00004c  696e7374          DCB      "instance < FSL_FEATURE_SOC_DMIC_COUNT",0
000050  616e6365
000054  203c2046
000058  534c5f46
00005c  45415455
000060  52455f53
000064  4f435f44
000068  4d49435f
00006c  434f554e
000070  5400    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.DMIC_HwvadDisableIntCallback||, CODE, READONLY, ALIGN=2

                  DMIC_HwvadDisableIntCallback PROC
;;;206    
;;;207    void DMIC_HwvadDisableIntCallback(DMIC_Type *base, dmic_hwvad_callback_t vadcb)
000000  b570              PUSH     {r4-r6,lr}
;;;208    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;209        uint32_t instance;
;;;210    
;;;211        instance = DMIC_GetInstance(base);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       DMIC_GetInstance
00000c  4604              MOV      r4,r0
;;;212        DisableIRQ(s_dmicHwvadIRQ[instance]);
00000e  4906              LDR      r1,|L11.40|
000010  5708              LDRSB    r0,[r1,r4]
000012  f7fffffe          BL       DisableIRQ
;;;213        s_dmicHwvadCallback[instance] = NULL;
000016  2000              MOVS     r0,#0
000018  4904              LDR      r1,|L11.44|
00001a  f8410024          STR      r0,[r1,r4,LSL #2]
;;;214        NVIC_ClearPendingIRQ(s_dmicHwvadIRQ[instance]);
00001e  4902              LDR      r1,|L11.40|
000020  5708              LDRSB    r0,[r1,r4]
000022  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;215    }
000026  bd70              POP      {r4-r6,pc}
;;;216    
                          ENDP

                  |L11.40|
                          DCD      s_dmicHwvadIRQ
                  |L11.44|
                          DCD      s_dmicHwvadCallback

                          AREA ||i.DMIC_HwvadEnableIntCallback||, CODE, READONLY, ALIGN=2

                  DMIC_HwvadEnableIntCallback PROC
;;;195    
;;;196    void DMIC_HwvadEnableIntCallback(DMIC_Type *base, dmic_hwvad_callback_t vadcb)
000000  b570              PUSH     {r4-r6,lr}
;;;197    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;198        uint32_t instance;
;;;199    
;;;200        instance = DMIC_GetInstance(base);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       DMIC_GetInstance
00000c  4604              MOV      r4,r0
;;;201        NVIC_ClearPendingIRQ(s_dmicHwvadIRQ[instance]);
00000e  4906              LDR      r1,|L12.40|
000010  5708              LDRSB    r0,[r1,r4]
000012  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;202        /* Save callback pointer */
;;;203        s_dmicHwvadCallback[instance] = vadcb;
000016  4805              LDR      r0,|L12.44|
000018  f8405024          STR      r5,[r0,r4,LSL #2]
;;;204        EnableIRQ(s_dmicHwvadIRQ[instance]);
00001c  4902              LDR      r1,|L12.40|
00001e  5708              LDRSB    r0,[r1,r4]
000020  f7fffffe          BL       EnableIRQ
;;;205    }
000024  bd70              POP      {r4-r6,pc}
;;;206    
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
                          DCD      s_dmicHwvadIRQ
                  |L12.44|
                          DCD      s_dmicHwvadCallback

                          AREA ||i.DMIC_Init||, CODE, READONLY, ALIGN=2

                  DMIC_Init PROC
;;;81     
;;;82     void DMIC_Init(DMIC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;83     {
000002  4604              MOV      r4,r0
;;;84         assert(base);
000004  b104              CBZ      r4,|L13.8|
000006  e004              B        |L13.18|
                  |L13.8|
000008  2254              MOVS     r2,#0x54
00000a  a11b              ADR      r1,|L13.120|
00000c  a020              ADR      r0,|L13.144|
00000e  f7fffffe          BL       __aeabi_assert
                  |L13.18|
;;;85     
;;;86         /* Enable the clock to the register interface */
;;;87         CLOCK_EnableClock(s_dmicClock[DMIC_GetInstance(base)]);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       DMIC_GetInstance
000018  491f              LDR      r1,|L13.152|
00001a  f8315010          LDRH     r5,[r1,r0,LSL #1]
00001e  0a28              LSRS     r0,r5,#8
000020  2803              CMP      r0,#3
000022  d205              BCS      |L13.48|
000024  2101              MOVS     r1,#1
000026  40a9              LSLS     r1,r1,r5
000028  4a1c              LDR      r2,|L13.156|
00002a  f8421020          STR      r1,[r2,r0,LSL #2]
00002e  e005              B        |L13.60|
                  |L13.48|
000030  2101              MOVS     r1,#1
000032  078a              LSLS     r2,r1,#30
000034  64d1              STR      r1,[r2,#0x4c]
000036  40a9              LSLS     r1,r1,r5
000038  4a19              LDR      r2,|L13.160|
00003a  6151              STR      r1,[r2,#0x14]
                  |L13.60|
00003c  bf00              NOP      
;;;88     
;;;89         /* Reset the peripheral */
;;;90         RESET_PeripheralReset(kDMIC_RST_SHIFT_RSTn);
00003e  4819              LDR      r0,|L13.164|
000040  f7fffffe          BL       RESET_PeripheralReset
;;;91     
;;;92         /* Disable DMA request*/
;;;93         base->CHANNEL[0].FIFO_CTRL &= ~DMIC_CHANNEL_FIFO_CTRL_DMAEN(1);
000044  f8d40080          LDR      r0,[r4,#0x80]
000048  f0200008          BIC      r0,r0,#8
00004c  f8c40080          STR      r0,[r4,#0x80]
;;;94         base->CHANNEL[1].FIFO_CTRL &= ~DMIC_CHANNEL_FIFO_CTRL_DMAEN(1);
000050  f8d40180          LDR      r0,[r4,#0x180]
000054  f0200108          BIC      r1,r0,#8
000058  f8c41180          STR      r1,[r4,#0x180]
;;;95     
;;;96         /* Disable DMIC interrupt. */
;;;97         base->CHANNEL[0].FIFO_CTRL &= ~DMIC_CHANNEL_FIFO_CTRL_INTEN(1);
00005c  f8d40080          LDR      r0,[r4,#0x80]
000060  f0200004          BIC      r0,r0,#4
000064  f8c40080          STR      r0,[r4,#0x80]
;;;98         base->CHANNEL[1].FIFO_CTRL &= ~DMIC_CHANNEL_FIFO_CTRL_INTEN(1);
000068  f8d40180          LDR      r0,[r4,#0x180]
00006c  f0200104          BIC      r1,r0,#4
000070  f8c41180          STR      r1,[r4,#0x180]
;;;99     }
000074  bd70              POP      {r4-r6,pc}
;;;100    
                          ENDP

000076  0000              DCW      0x0000
                  |L13.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_dmic.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  646d6963
00008c  2e6300  
00008f  00                DCB      0
                  |L13.144|
000090  62617365          DCB      "base",0
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L13.152|
                          DCD      s_dmicClock
                  |L13.156|
                          DCD      0x40000220
                  |L13.160|
                          DCD      0x40040000
                  |L13.164|
                          DCD      0x00010013

                          AREA ||i.DMIC_SetOperationMode||, CODE, READONLY, ALIGN=1

                  DMIC_SetOperationMode PROC
;;;112    
;;;113    void DMIC_SetOperationMode(DMIC_Type *base, operation_mode_t mode)
000000  2901              CMP      r1,#1
;;;114    {
;;;115        if (mode == kDMIC_OperationModeInterrupt)
000002  d10b              BNE      |L14.28|
;;;116        {
;;;117            /* Enable DMIC interrupt. */
;;;118            base->CHANNEL[0].FIFO_CTRL |= DMIC_CHANNEL_FIFO_CTRL_INTEN(1);
000004  f8d02080          LDR      r2,[r0,#0x80]
000008  f0420204          ORR      r2,r2,#4
00000c  f8c02080          STR      r2,[r0,#0x80]
;;;119            base->CHANNEL[1].FIFO_CTRL |= DMIC_CHANNEL_FIFO_CTRL_INTEN(1);
000010  f8d02180          LDR      r2,[r0,#0x180]
000014  f0420304          ORR      r3,r2,#4
000018  f8c03180          STR      r3,[r0,#0x180]
                  |L14.28|
;;;120        }
;;;121        if (mode == kDMIC_OperationModeDma)
00001c  2902              CMP      r1,#2
00001e  d10b              BNE      |L14.56|
;;;122        {
;;;123            /* enable DMA request*/
;;;124            base->CHANNEL[0].FIFO_CTRL |= DMIC_CHANNEL_FIFO_CTRL_DMAEN(1);
000020  f8d02080          LDR      r2,[r0,#0x80]
000024  f0420208          ORR      r2,r2,#8
000028  f8c02080          STR      r2,[r0,#0x80]
;;;125            base->CHANNEL[1].FIFO_CTRL |= DMIC_CHANNEL_FIFO_CTRL_DMAEN(1);
00002c  f8d02180          LDR      r2,[r0,#0x180]
000030  f0420308          ORR      r3,r2,#8
000034  f8c03180          STR      r3,[r0,#0x180]
                  |L14.56|
;;;126        }
;;;127    }
000038  4770              BX       lr
;;;128    
                          ENDP


                          AREA ||i.DMIC_Use2fs||, CODE, READONLY, ALIGN=1

                  DMIC_Use2fs PROC
;;;156    
;;;157    void DMIC_Use2fs(DMIC_Type *base, bool use2fs)
000000  f8c01f10          STR      r1,[r0,#0xf10]
;;;158    {
;;;159        base->USE2FS = (use2fs) ? 0x1 : 0x0;
;;;160    }
000004  4770              BX       lr
;;;161    
                          ENDP


                          AREA ||i.DisableIRQ||, CODE, READONLY, ALIGN=2

                  DisableIRQ PROC
;;;220     */
;;;221    static inline void DisableIRQ(IRQn_Type interrupt)
000000  f1100f80          CMN      r0,#0x80
;;;222    {
;;;223        if (NotAvail_IRQn == interrupt)
000004  d100              BNE      |L16.8|
                  |L16.6|
;;;224        {
;;;225            return;
;;;226        }
;;;227    
;;;228    #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
;;;229        if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
;;;230    #endif
;;;231        {
;;;232            NVIC_DisableIRQ(interrupt);
;;;233        }
;;;234    }
000006  4770              BX       lr
                  |L16.8|
000008  bf00              NOP                            ;232
00000a  f000021f          AND      r2,r0,#0x1f           ;232
00000e  2101              MOVS     r1,#1                 ;232
000010  4091              LSLS     r1,r1,r2              ;232
000012  4a03              LDR      r2,|L16.32|
000014  0943              LSRS     r3,r0,#5              ;232
000016  f8421023          STR      r1,[r2,r3,LSL #2]     ;232
00001a  bf00              NOP                            ;232
00001c  bf00              NOP      
00001e  e7f2              B        |L16.6|
;;;235    
                          ENDP

                  |L16.32|
                          DCD      0xe000e180

                          AREA ||i.EnableIRQ||, CODE, READONLY, ALIGN=1

                  EnableIRQ PROC
;;;198     */
;;;199    static inline void EnableIRQ(IRQn_Type interrupt)
000000  f1100f80          CMN      r0,#0x80
;;;200    {
;;;201        if (NotAvail_IRQn == interrupt)
000004  d100              BNE      |L17.8|
                  |L17.6|
;;;202        {
;;;203            return;
;;;204        }
;;;205    
;;;206    #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
;;;207        if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
;;;208    #endif
;;;209        {
;;;210            NVIC_EnableIRQ(interrupt);
;;;211        }
;;;212    }
000006  4770              BX       lr
                  |L17.8|
000008  bf00              NOP                            ;210
00000a  f000021f          AND      r2,r0,#0x1f           ;210
00000e  2101              MOVS     r1,#1                 ;210
000010  4091              LSLS     r1,r1,r2              ;210
000012  0942              LSRS     r2,r0,#5              ;210
000014  0092              LSLS     r2,r2,#2              ;210
000016  f10222e0          ADD      r2,r2,#0xe000e000     ;210
00001a  f8c21100          STR      r1,[r2,#0x100]        ;210
00001e  bf00              NOP                            ;210
000020  bf00              NOP      
000022  e7f0              B        |L17.6|
;;;213    
                          ENDP


                          AREA ||i.HWVAD0_IRQHandler||, CODE, READONLY, ALIGN=2

                  HWVAD0_IRQHandler PROC
;;;227    /*DMIC0 HWVAD IRQ handler */
;;;228    void HWVAD0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230        if (s_dmicHwvadCallback[0] != NULL)
000002  4803              LDR      r0,|L18.16|
000004  6800              LDR      r0,[r0,#0]  ; s_dmicHwvadCallback
000006  b110              CBZ      r0,|L18.14|
;;;231        {
;;;232            s_dmicHwvadCallback[0]();
000008  4901              LDR      r1,|L18.16|
00000a  6808              LDR      r0,[r1,#0]  ; s_dmicHwvadCallback
00000c  4780              BLX      r0
                  |L18.14|
;;;233        }
;;;234    }
00000e  bd10              POP      {r4,pc}
;;;235    #endif
                          ENDP

                  |L18.16|
                          DCD      s_dmicHwvadCallback

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;1671    */
;;;1672   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1673   {
;;;1674     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L19.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1675   }
000010  4770              BX       lr
;;;1676   
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      0xe000e280

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_dmicBases
                          DCD      0x40090000
                  s_dmicClock
000004  0113              DCW      0x0113
                  s_dmicIRQ
000006  19                DCB      0x19
                  s_dmicHwvadIRQ
000007  1a                DCB      0x1a

                          AREA ||.data||, DATA, ALIGN=2

                  s_dmicCallback
                          DCD      0x00000000
                  s_dmicHwvadCallback
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_dmic.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_dmic_c_3ad09590____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fsl_dmic_c_3ad09590____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_dmic_c_3ad09590____REVSH|
#line 402
|__asm___10_fsl_dmic_c_3ad09590____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_dmic_c_3ad09590____RRX|
#line 587
|__asm___10_fsl_dmic_c_3ad09590____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
