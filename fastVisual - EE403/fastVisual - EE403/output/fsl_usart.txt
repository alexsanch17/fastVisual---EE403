; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_usart.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_usart.crf SRC\Drivers\fsl_usart.c]
                          THUMB

                          AREA ||i.USART_Deinit||, CODE, READONLY, ALIGN=2

                  USART_Deinit PROC
;;;193    
;;;194    void USART_Deinit(USART_Type *base)
000000  b510              PUSH     {r4,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196        /* Check arguments */
;;;197        assert(NULL != base);
000004  b104              CBZ      r4,|L1.8|
000006  e004              B        |L1.18|
                  |L1.8|
000008  22c5              MOVS     r2,#0xc5
00000a  a10c              ADR      r1,|L1.60|
00000c  a011              ADR      r0,|L1.84|
00000e  f7fffffe          BL       __aeabi_assert
                  |L1.18|
;;;198        while (!(base->STAT & USART_STAT_TXIDLE_MASK))
000012  bf00              NOP      
                  |L1.20|
000014  68a0              LDR      r0,[r4,#8]
000016  f0000008          AND      r0,r0,#8
00001a  2800              CMP      r0,#0
00001c  d0fa              BEQ      |L1.20|
;;;199        {
;;;200        }
;;;201        /* Disable interrupts, disable dma requests, disable peripheral */
;;;202        base->FIFOINTENCLR = USART_FIFOINTENCLR_TXERR_MASK | USART_FIFOINTENCLR_RXERR_MASK | USART_FIFOINTENCLR_TXLVL_MASK |
00001e  200f              MOVS     r0,#0xf
000020  f8c40e14          STR      r0,[r4,#0xe14]
;;;203                             USART_FIFOINTENCLR_RXLVL_MASK;
;;;204        base->FIFOCFG &= ~(USART_FIFOCFG_DMATX_MASK | USART_FIFOCFG_DMARX_MASK);
000024  f8d40e00          LDR      r0,[r4,#0xe00]
000028  f4205040          BIC      r0,r0,#0x3000
00002c  f8c40e00          STR      r0,[r4,#0xe00]
;;;205        base->CFG &= ~(USART_CFG_ENABLE_MASK);
000030  6820              LDR      r0,[r4,#0]
000032  f0200001          BIC      r0,r0,#1
000036  6020              STR      r0,[r4,#0]
;;;206    }
000038  bd10              POP      {r4,pc}
;;;207    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
00003c  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000040  44726976
000044  6572735c
000048  66736c5f
00004c  75736172
000050  742e6300
                  |L1.84|
000054  4e554c4c          DCB      "NULL != base",0
000058  20213d20
00005c  62617365
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.USART_GetDefaultConfig||, CODE, READONLY, ALIGN=2

                  USART_GetDefaultConfig PROC
;;;207    
;;;208    void USART_GetDefaultConfig(usart_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;209    {
000002  4604              MOV      r4,r0
;;;210        /* Check arguments */
;;;211        assert(NULL != config);
000004  b104              CBZ      r4,|L2.8|
000006  e004              B        |L2.18|
                  |L2.8|
000008  22d3              MOVS     r2,#0xd3
00000a  a109              ADR      r1,|L2.48|
00000c  a00e              ADR      r0,|L2.72|
00000e  f7fffffe          BL       __aeabi_assert
                  |L2.18|
;;;212    
;;;213        /* Set always all members ! */
;;;214        config->baudRate_Bps = 115200U;
000012  f44f30e1          MOV      r0,#0x1c200
000016  6020              STR      r0,[r4,#0]
;;;215        config->parityMode = kUSART_ParityDisabled;
000018  2000              MOVS     r0,#0
00001a  7120              STRB     r0,[r4,#4]
;;;216        config->stopBitCount = kUSART_OneStopBit;
00001c  7160              STRB     r0,[r4,#5]
;;;217        config->bitCountPerChar = kUSART_8BitsPerChar;
00001e  2001              MOVS     r0,#1
000020  71a0              STRB     r0,[r4,#6]
;;;218        config->loopback = false;
000022  2000              MOVS     r0,#0
000024  71e0              STRB     r0,[r4,#7]
;;;219        config->enableRx = false;
000026  7220              STRB     r0,[r4,#8]
;;;220        config->enableTx = false;
000028  7260              STRB     r0,[r4,#9]
;;;221        config->txWatermark = kUSART_TxFifo0;
00002a  72a0              STRB     r0,[r4,#0xa]
;;;222        config->rxWatermark = kUSART_RxFifo1;
00002c  72e0              STRB     r0,[r4,#0xb]
;;;223    }
00002e  bd10              POP      {r4,pc}
;;;224    
                          ENDP

                  |L2.48|
000030  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000034  44726976
000038  6572735c
00003c  66736c5f
000040  75736172
000044  742e6300
                  |L2.72|
000048  4e554c4c          DCB      "NULL != config",0
00004c  20213d20
000050  636f6e66
000054  696700  
000057  00                DCB      0

                          AREA ||i.USART_GetInstance||, CODE, READONLY, ALIGN=2

                  USART_GetInstance PROC
;;;57     /* Get the index corresponding to the USART */
;;;58     uint32_t USART_GetInstance(USART_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;59     {
000002  4605              MOV      r5,r0
;;;60         int i;
;;;61     
;;;62         for (i = 0; i < FSL_FEATURE_SOC_USART_COUNT; i++)
000004  2400              MOVS     r4,#0
000006  e007              B        |L3.24|
                  |L3.8|
;;;63         {
;;;64             if ((uint32_t)base == s_usartBaseAddrs[i])
000008  4807              LDR      r0,|L3.40|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d101              BNE      |L3.22|
;;;65             {
;;;66                 return i;
000012  4620              MOV      r0,r4
;;;67             }
;;;68         }
;;;69     
;;;70         assert(false);
;;;71         return 0;
;;;72     }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  1c64              ADDS     r4,r4,#1              ;62
                  |L3.24|
000018  2c0a              CMP      r4,#0xa               ;62
00001a  dbf5              BLT      |L3.8|
00001c  2246              MOVS     r2,#0x46              ;70
00001e  a103              ADR      r1,|L3.44|
000020  a008              ADR      r0,|L3.68|
000022  f7fffffe          BL       __aeabi_assert
;;;73     
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      s_usartBaseAddrs
                  |L3.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  75736172
000040  742e6300
                  |L3.68|
000044  66616c73          DCB      "false",0
000048  6500    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;141    
;;;142    status_t USART_Init(USART_Type *base, const usart_config_t *config, uint32_t srcClock_Hz)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;143    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;144        int result;
;;;145    
;;;146        /* check arguments */
;;;147        assert(!((NULL == base) || (NULL == config) || (0 == srcClock_Hz)));
00000a  b114              CBZ      r4,|L4.18|
00000c  b10d              CBZ      r5,|L4.18|
00000e  b107              CBZ      r7,|L4.18|
000010  e004              B        |L4.28|
                  |L4.18|
000012  2293              MOVS     r2,#0x93
000014  a133              ADR      r1,|L4.228|
000016  a039              ADR      r0,|L4.252|
000018  f7fffffe          BL       __aeabi_assert
                  |L4.28|
;;;148        if ((NULL == base) || (NULL == config) || (0 == srcClock_Hz))
00001c  b10c              CBZ      r4,|L4.34|
00001e  b105              CBZ      r5,|L4.34|
000020  b917              CBNZ     r7,|L4.40|
                  |L4.34|
;;;149        {
;;;150            return kStatus_InvalidArgument;
000022  2004              MOVS     r0,#4
                  |L4.36|
;;;151        }
;;;152    
;;;153        /* initialize flexcomm to USART mode */
;;;154        result = FLEXCOMM_Init(base, FLEXCOMM_PERIPH_USART);
;;;155        if (kStatus_Success != result)
;;;156        {
;;;157            return result;
;;;158        }
;;;159    
;;;160        /* setup baudrate */
;;;161        result = USART_SetBaudRate(base, config->baudRate_Bps, srcClock_Hz);
;;;162        if (kStatus_Success != result)
;;;163        {
;;;164            return result;
;;;165        }
;;;166    
;;;167        if (config->enableTx)
;;;168        {
;;;169            /* empty and enable txFIFO */
;;;170            base->FIFOCFG |= USART_FIFOCFG_EMPTYTX_MASK | USART_FIFOCFG_ENABLETX_MASK;
;;;171            /* setup trigger level */
;;;172            base->FIFOTRIG &= ~(USART_FIFOTRIG_TXLVL_MASK);
;;;173            base->FIFOTRIG |= USART_FIFOTRIG_TXLVL(config->txWatermark);
;;;174            /* enable trigger interrupt */
;;;175            base->FIFOTRIG |= USART_FIFOTRIG_TXLVLENA_MASK;
;;;176        }
;;;177    
;;;178        /* empty and enable rxFIFO */
;;;179        if (config->enableRx)
;;;180        {
;;;181            base->FIFOCFG |= USART_FIFOCFG_EMPTYRX_MASK | USART_FIFOCFG_ENABLERX_MASK;
;;;182            /* setup trigger level */
;;;183            base->FIFOTRIG &= ~(USART_FIFOTRIG_RXLVL_MASK);
;;;184            base->FIFOTRIG |= USART_FIFOTRIG_RXLVL(config->rxWatermark);
;;;185            /* enable trigger interrupt */
;;;186            base->FIFOTRIG |= USART_FIFOTRIG_RXLVLENA_MASK;
;;;187        }
;;;188        /* setup configuration and enable USART */
;;;189        base->CFG = USART_CFG_PARITYSEL(config->parityMode) | USART_CFG_STOPLEN(config->stopBitCount) |
;;;190                    USART_CFG_DATALEN(config->bitCountPerChar) | USART_CFG_LOOP(config->loopback) | USART_CFG_ENABLE_MASK;
;;;191        return kStatus_Success;
;;;192    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L4.40|
000028  2101              MOVS     r1,#1                 ;154
00002a  4620              MOV      r0,r4                 ;154
00002c  f7fffffe          BL       FLEXCOMM_Init
000030  4606              MOV      r6,r0                 ;154
000032  b10e              CBZ      r6,|L4.56|
000034  4630              MOV      r0,r6                 ;157
000036  e7f5              B        |L4.36|
                  |L4.56|
000038  463a              MOV      r2,r7                 ;161
00003a  4620              MOV      r0,r4                 ;161
00003c  6829              LDR      r1,[r5,#0]            ;161
00003e  f7fffffe          BL       USART_SetBaudRate
000042  4606              MOV      r6,r0                 ;161
000044  b10e              CBZ      r6,|L4.74|
000046  4630              MOV      r0,r6                 ;164
000048  e7ec              B        |L4.36|
                  |L4.74|
00004a  7a68              LDRB     r0,[r5,#9]            ;167
00004c  b1b8              CBZ      r0,|L4.126|
00004e  f5046460          ADD      r4,r4,#0xe00          ;170
000052  6820              LDR      r0,[r4,#0]            ;170
000054  f0401001          ORR      r0,r0,#0x10001        ;170
000058  6020              STR      r0,[r4,#0]            ;170
00005a  68a0              LDR      r0,[r4,#8]            ;172
00005c  f4206070          BIC      r0,r0,#0xf00          ;172
000060  60a0              STR      r0,[r4,#8]            ;172
000062  68a0              LDR      r0,[r4,#8]            ;173
000064  7aa9              LDRB     r1,[r5,#0xa]          ;173
000066  f44f6270          MOV      r2,#0xf00             ;173
00006a  ea022101          AND      r1,r2,r1,LSL #8       ;173
00006e  4308              ORRS     r0,r0,r1              ;173
000070  60a0              STR      r0,[r4,#8]            ;173
000072  68a0              LDR      r0,[r4,#8]            ;175
000074  f0400001          ORR      r0,r0,#1              ;175
000078  60a0              STR      r0,[r4,#8]            ;175
00007a  f5a46460          SUB      r4,r4,#0xe00          ;175
                  |L4.126|
00007e  7a28              LDRB     r0,[r5,#8]            ;179
000080  b1b8              CBZ      r0,|L4.178|
000082  f5046460          ADD      r4,r4,#0xe00          ;181
000086  6820              LDR      r0,[r4,#0]            ;181
000088  f0401002          ORR      r0,r0,#0x20002        ;181
00008c  6020              STR      r0,[r4,#0]            ;181
00008e  68a0              LDR      r0,[r4,#8]            ;183
000090  f4202070          BIC      r0,r0,#0xf0000        ;183
000094  60a0              STR      r0,[r4,#8]            ;183
000096  68a0              LDR      r0,[r4,#8]            ;184
000098  7ae9              LDRB     r1,[r5,#0xb]          ;184
00009a  f44f2270          MOV      r2,#0xf0000           ;184
00009e  ea024101          AND      r1,r2,r1,LSL #16      ;184
0000a2  4308              ORRS     r0,r0,r1              ;184
0000a4  60a0              STR      r0,[r4,#8]            ;184
0000a6  68a0              LDR      r0,[r4,#8]            ;186
0000a8  f0400002          ORR      r0,r0,#2              ;186
0000ac  60a0              STR      r0,[r4,#8]            ;186
0000ae  f5a46460          SUB      r4,r4,#0xe00          ;186
                  |L4.178|
0000b2  7928              LDRB     r0,[r5,#4]            ;189
0000b4  2130              MOVS     r1,#0x30              ;189
0000b6  ea011000          AND      r0,r1,r0,LSL #4       ;189
0000ba  7969              LDRB     r1,[r5,#5]            ;189
0000bc  2240              MOVS     r2,#0x40              ;189
0000be  ea021181          AND      r1,r2,r1,LSL #6       ;189
0000c2  4308              ORRS     r0,r0,r1              ;189
0000c4  79a9              LDRB     r1,[r5,#6]            ;189
0000c6  220c              MOVS     r2,#0xc               ;189
0000c8  ea020181          AND      r1,r2,r1,LSL #2       ;189
0000cc  4308              ORRS     r0,r0,r1              ;189
0000ce  79e9              LDRB     r1,[r5,#7]            ;189
0000d0  f44f4200          MOV      r2,#0x8000            ;189
0000d4  ea0231c1          AND      r1,r2,r1,LSL #15      ;189
0000d8  4308              ORRS     r0,r0,r1              ;189
0000da  1c40              ADDS     r0,r0,#1              ;189
0000dc  6020              STR      r0,[r4,#0]            ;189
0000de  2000              MOVS     r0,#0                 ;191
0000e0  e7a0              B        |L4.36|
;;;193    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L4.228|
0000e4  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
0000e8  44726976
0000ec  6572735c
0000f0  66736c5f
0000f4  75736172
0000f8  742e6300
                  |L4.252|
0000fc  2128284e          DCB      "!((NULL == base) || (NULL == config) || (0 == srcClock_"
000100  554c4c20
000104  3d3d2062
000108  61736529
00010c  207c7c20
000110  284e554c
000114  4c203d3d
000118  20636f6e
00011c  66696729
000120  207c7c20
000124  2830203d
000128  3d207372
00012c  63436c6f
000130  636b5f  
000133  487a2929          DCB      "Hz))",0
000137  00      

                          AREA ||i.USART_ReadBlocking||, CODE, READONLY, ALIGN=2

                  USART_ReadBlocking PROC
;;;292    
;;;293    status_t USART_ReadBlocking(USART_Type *base, uint8_t *data, size_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;294    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;295        uint32_t status;
;;;296    
;;;297        /* check arguments */
;;;298        assert(!((NULL == base) || (NULL == data)));
00000a  b10c              CBZ      r4,|L5.16|
00000c  b105              CBZ      r5,|L5.16|
00000e  e005              B        |L5.28|
                  |L5.16|
000010  f44f7295          MOV      r2,#0x12a
000014  a129              ADR      r1,|L5.188|
000016  a02f              ADR      r0,|L5.212|
000018  f7fffffe          BL       __aeabi_assert
                  |L5.28|
;;;299        if ((NULL == base) || (NULL == data))
00001c  b104              CBZ      r4,|L5.32|
00001e  b915              CBNZ     r5,|L5.38|
                  |L5.32|
;;;300        {
;;;301            return kStatus_InvalidArgument;
000020  2004              MOVS     r0,#4
                  |L5.34|
;;;302        }
;;;303    
;;;304        /* Check whether rxFIFO is enabled */
;;;305        if (!(base->FIFOCFG & USART_FIFOCFG_ENABLERX_MASK))
;;;306        {
;;;307            return kStatus_Fail;
;;;308        }
;;;309        for (; length > 0; length--)
;;;310        {
;;;311            /* loop until rxFIFO have some data to read */
;;;312            while (!(base->FIFOSTAT & USART_FIFOSTAT_RXNOTEMPTY_MASK))
;;;313            {
;;;314            }
;;;315            /* check receive status */
;;;316            status = base->STAT;
;;;317            if (status & USART_STAT_FRAMERRINT_MASK)
;;;318            {
;;;319                base->STAT |= USART_STAT_FRAMERRINT_MASK;
;;;320                return kStatus_USART_FramingError;
;;;321            }
;;;322            if (status & USART_STAT_PARITYERRINT_MASK)
;;;323            {
;;;324                base->STAT |= USART_STAT_PARITYERRINT_MASK;
;;;325                return kStatus_USART_ParityError;
;;;326            }
;;;327            if (status & USART_STAT_RXNOISEINT_MASK)
;;;328            {
;;;329                base->STAT |= USART_STAT_RXNOISEINT_MASK;
;;;330                return kStatus_USART_NoiseError;
;;;331            }
;;;332            /* check rxFIFO status */
;;;333            if (base->FIFOSTAT & USART_FIFOSTAT_RXERR_MASK)
;;;334            {
;;;335                base->FIFOCFG |= USART_FIFOCFG_EMPTYRX_MASK;
;;;336                base->FIFOSTAT |= USART_FIFOSTAT_RXERR_MASK;
;;;337                return kStatus_USART_RxError;
;;;338            }
;;;339    
;;;340            *data = base->FIFORD;
;;;341            data++;
;;;342        }
;;;343        return kStatus_Success;
;;;344    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L5.38|
000026  f8d40e00          LDR      r0,[r4,#0xe00]        ;305
00002a  f0000002          AND      r0,r0,#2              ;305
00002e  b908              CBNZ     r0,|L5.52|
000030  2001              MOVS     r0,#1                 ;307
000032  e7f6              B        |L5.34|
                  |L5.52|
000034  e03e              B        |L5.180|
                  |L5.54|
000036  bf00              NOP                            ;312
                  |L5.56|
000038  f8d40e04          LDR      r0,[r4,#0xe04]        ;312
00003c  f0000040          AND      r0,r0,#0x40           ;312
000040  2800              CMP      r0,#0                 ;312
000042  d0f9              BEQ      |L5.56|
000044  68a6              LDR      r6,[r4,#8]            ;316
000046  f4065000          AND      r0,r6,#0x2000         ;317
00004a  b130              CBZ      r0,|L5.90|
00004c  68a0              LDR      r0,[r4,#8]            ;319
00004e  f4405000          ORR      r0,r0,#0x2000         ;319
000052  60a0              STR      r0,[r4,#8]            ;319
000054  f241604f          MOV      r0,#0x164f            ;320
000058  e7e3              B        |L5.34|
                  |L5.90|
00005a  f4064080          AND      r0,r6,#0x4000         ;322
00005e  b130              CBZ      r0,|L5.110|
000060  68a0              LDR      r0,[r4,#8]            ;324
000062  f4404080          ORR      r0,r0,#0x4000         ;324
000066  60a0              STR      r0,[r4,#8]            ;324
000068  f2416050          MOV      r0,#0x1650            ;325
00006c  e7d9              B        |L5.34|
                  |L5.110|
00006e  f4064000          AND      r0,r6,#0x8000         ;327
000072  b130              CBZ      r0,|L5.130|
000074  68a0              LDR      r0,[r4,#8]            ;329
000076  f4404000          ORR      r0,r0,#0x8000         ;329
00007a  60a0              STR      r0,[r4,#8]            ;329
00007c  f241604e          MOV      r0,#0x164e            ;330
000080  e7cf              B        |L5.34|
                  |L5.130|
000082  f8d40e04          LDR      r0,[r4,#0xe04]        ;333
000086  f0000002          AND      r0,r0,#2              ;333
00008a  b170              CBZ      r0,|L5.170|
00008c  f8d40e00          LDR      r0,[r4,#0xe00]        ;335
000090  f4403000          ORR      r0,r0,#0x20000        ;335
000094  f8c40e00          STR      r0,[r4,#0xe00]        ;335
000098  f8d40e04          LDR      r0,[r4,#0xe04]        ;336
00009c  f0400002          ORR      r0,r0,#2              ;336
0000a0  f8c40e04          STR      r0,[r4,#0xe04]        ;336
0000a4  f241604d          MOV      r0,#0x164d            ;337
0000a8  e7bb              B        |L5.34|
                  |L5.170|
0000aa  f8d40e30          LDR      r0,[r4,#0xe30]        ;340
0000ae  7028              STRB     r0,[r5,#0]            ;340
0000b0  1c6d              ADDS     r5,r5,#1              ;341
0000b2  1e7f              SUBS     r7,r7,#1              ;309
                  |L5.180|
0000b4  2f00              CMP      r7,#0                 ;309
0000b6  d1be              BNE      |L5.54|
0000b8  2000              MOVS     r0,#0                 ;343
0000ba  e7b2              B        |L5.34|
;;;345    
                          ENDP

                  |L5.188|
0000bc  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
0000c0  44726976
0000c4  6572735c
0000c8  66736c5f
0000cc  75736172
0000d0  742e6300
                  |L5.212|
0000d4  2128284e          DCB      "!((NULL == base) || (NULL == data))",0
0000d8  554c4c20
0000dc  3d3d2062
0000e0  61736529
0000e4  207c7c20
0000e8  284e554c
0000ec  4c203d3d
0000f0  20646174
0000f4  61292900

                          AREA ||i.USART_SetBaudRate||, CODE, READONLY, ALIGN=2

                  USART_SetBaudRate PROC
;;;224    
;;;225    status_t USART_SetBaudRate(USART_Type *base, uint32_t baudrate_Bps, uint32_t srcClock_Hz)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;226    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;227        uint32_t best_diff = (uint32_t)-1, best_osrval = 0xf, best_brgval = (uint32_t)-1;
00000a  f04f30ff          MOV      r0,#0xffffffff
00000e  9001              STR      r0,[sp,#4]
000010  f04f0a0f          MOV      r10,#0xf
000014  4683              MOV      r11,r0
;;;228        uint32_t osrval, brgval, diff, baudrate;
;;;229    
;;;230        /* check arguments */
;;;231        assert(!((NULL == base) || (0 == baudrate_Bps) || (0 == srcClock_Hz)));
000016  b116              CBZ      r6,|L6.30|
000018  b10c              CBZ      r4,|L6.30|
00001a  b107              CBZ      r7,|L6.30|
00001c  e004              B        |L6.40|
                  |L6.30|
00001e  22e7              MOVS     r2,#0xe7
000020  a11d              ADR      r1,|L6.152|
000022  a023              ADR      r0,|L6.176|
000024  f7fffffe          BL       __aeabi_assert
                  |L6.40|
;;;232        if ((NULL == base) || (0 == baudrate_Bps) || (0 == srcClock_Hz))
000028  b10e              CBZ      r6,|L6.46|
00002a  b104              CBZ      r4,|L6.46|
00002c  b917              CBNZ     r7,|L6.52|
                  |L6.46|
;;;233        {
;;;234            return kStatus_InvalidArgument;
00002e  2004              MOVS     r0,#4
                  |L6.48|
;;;235        }
;;;236    
;;;237        for (osrval = best_osrval; osrval >= 4; osrval--)
;;;238        {
;;;239            brgval = (srcClock_Hz / ((osrval + 1) * baudrate_Bps)) - 1;
;;;240            if (brgval > 0xFFFF)
;;;241            {
;;;242                continue;
;;;243            }
;;;244            baudrate = srcClock_Hz / ((osrval + 1) * (brgval + 1));
;;;245            diff = baudrate_Bps < baudrate ? baudrate - baudrate_Bps : baudrate_Bps - baudrate;
;;;246            if (diff < best_diff)
;;;247            {
;;;248                best_diff = diff;
;;;249                best_osrval = osrval;
;;;250                best_brgval = brgval;
;;;251            }
;;;252        }
;;;253    
;;;254        /* value over range */
;;;255        if (best_brgval > 0xFFFF)
;;;256        {
;;;257            return kStatus_USART_BaudrateNotSupport;
;;;258        }
;;;259    
;;;260        base->OSR = best_osrval;
;;;261        base->BRG = best_brgval;
;;;262        return kStatus_Success;
;;;263    }
000030  e8bd9ffc          POP      {r2-r12,pc}
                  |L6.52|
000034  4655              MOV      r5,r10                ;237
000036  e021              B        |L6.124|
                  |L6.56|
000038  1c68              ADDS     r0,r5,#1              ;239
00003a  4360              MULS     r0,r4,r0              ;239
00003c  fbb7f0f0          UDIV     r0,r7,r0              ;239
000040  f1a00801          SUB      r8,r0,#1              ;239
000044  f5b83f80          CMP      r8,#0x10000           ;240
000048  d300              BCC      |L6.76|
00004a  e016              B        |L6.122|
                  |L6.76|
00004c  1c68              ADDS     r0,r5,#1              ;244
00004e  f1080101          ADD      r1,r8,#1              ;244
000052  4348              MULS     r0,r1,r0              ;244
000054  fbb7f9f0          UDIV     r9,r7,r0              ;244
000058  454c              CMP      r4,r9                 ;245
00005a  d202              BCS      |L6.98|
00005c  eba90004          SUB      r0,r9,r4              ;245
000060  e001              B        |L6.102|
                  |L6.98|
000062  eba40009          SUB      r0,r4,r9              ;245
                  |L6.102|
000066  9000              STR      r0,[sp,#0]            ;245
000068  e9dd0100          LDRD     r0,r1,[sp,#0]         ;246
00006c  4288              CMP      r0,r1                 ;246
00006e  d203              BCS      |L6.120|
000070  9800              LDR      r0,[sp,#0]            ;248
000072  9001              STR      r0,[sp,#4]            ;248
000074  46aa              MOV      r10,r5                ;249
000076  46c3              MOV      r11,r8                ;250
                  |L6.120|
000078  bf00              NOP                            ;242
                  |L6.122|
00007a  1e6d              SUBS     r5,r5,#1              ;237
                  |L6.124|
00007c  2d04              CMP      r5,#4                 ;237
00007e  d2db              BCS      |L6.56|
000080  f5bb3f80          CMP      r11,#0x10000          ;255
000084  d302              BCC      |L6.140|
000086  f2416051          MOV      r0,#0x1651            ;257
00008a  e7d1              B        |L6.48|
                  |L6.140|
00008c  f8c6a028          STR      r10,[r6,#0x28]        ;260
000090  f8c6b020          STR      r11,[r6,#0x20]        ;261
000094  2000              MOVS     r0,#0                 ;262
000096  e7cb              B        |L6.48|
;;;264    
                          ENDP

                  |L6.152|
000098  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
00009c  44726976
0000a0  6572735c
0000a4  66736c5f
0000a8  75736172
0000ac  742e6300
                  |L6.176|
0000b0  2128284e          DCB      "!((NULL == base) || (0 == baudrate_Bps) || (0 == srcClo"
0000b4  554c4c20
0000b8  3d3d2062
0000bc  61736529
0000c0  207c7c20
0000c4  2830203d
0000c8  3d206261
0000cc  75647261
0000d0  74655f42
0000d4  70732920
0000d8  7c7c2028
0000dc  30203d3d
0000e0  20737263
0000e4  436c6f  
0000e7  636b5f48          DCB      "ck_Hz))",0
0000eb  7a292900
0000ef  00                DCB      0

                          AREA ||i.USART_TransferAbortReceive||, CODE, READONLY, ALIGN=2

                  USART_TransferAbortReceive PROC
;;;549    
;;;550    void USART_TransferAbortReceive(USART_Type *base, usart_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;551    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;552        assert(NULL != handle);
000006  b105              CBZ      r5,|L7.10|
000008  e005              B        |L7.22|
                  |L7.10|
00000a  f44f720a          MOV      r2,#0x228
00000e  a10c              ADR      r1,|L7.64|
000010  a011              ADR      r0,|L7.88|
000012  f7fffffe          BL       __aeabi_assert
                  |L7.22|
;;;553    
;;;554        /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
;;;555        if (!handle->rxRingBuffer)
000016  69a8              LDR      r0,[r5,#0x18]
000018  b958              CBNZ     r0,|L7.50|
;;;556        {
;;;557            /* Disable interrupts */
;;;558            base->FIFOINTENSET &= ~USART_FIFOINTENSET_RXLVL_MASK;
00001a  f8d40e10          LDR      r0,[r4,#0xe10]
00001e  f0200008          BIC      r0,r0,#8
000022  f8c40e10          STR      r0,[r4,#0xe10]
;;;559            /* Empty rxFIFO */
;;;560            base->FIFOCFG |= USART_FIFOCFG_EMPTYRX_MASK;
000026  f8d40e00          LDR      r0,[r4,#0xe00]
00002a  f4403000          ORR      r0,r0,#0x20000
00002e  f8c40e00          STR      r0,[r4,#0xe00]
                  |L7.50|
;;;561        }
;;;562    
;;;563        handle->rxDataSize = 0U;
000032  2000              MOVS     r0,#0
000034  6128              STR      r0,[r5,#0x10]
;;;564        handle->rxState = kUSART_RxIdle;
000036  2002              MOVS     r0,#2
000038  f885002d          STRB     r0,[r5,#0x2d]
;;;565    }
00003c  bd70              POP      {r4-r6,pc}
;;;566    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
000040  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000044  44726976
000048  6572735c
00004c  66736c5f
000050  75736172
000054  742e6300
                  |L7.88|
000058  4e554c4c          DCB      "NULL != handle",0
00005c  20213d20
000060  68616e64
000064  6c6500  
000067  00                DCB      0

                          AREA ||i.USART_TransferAbortSend||, CODE, READONLY, ALIGN=2

                  USART_TransferAbortSend PROC
;;;411    
;;;412    void USART_TransferAbortSend(USART_Type *base, usart_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;413    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;414        assert(NULL != handle);
000006  b105              CBZ      r5,|L8.10|
000008  e005              B        |L8.22|
                  |L8.10|
00000a  f44f72cf          MOV      r2,#0x19e
00000e  a10a              ADR      r1,|L8.56|
000010  a00f              ADR      r0,|L8.80|
000012  f7fffffe          BL       __aeabi_assert
                  |L8.22|
;;;415    
;;;416        /* Disable interrupts */
;;;417        base->FIFOINTENSET &= ~USART_FIFOINTENSET_TXLVL_MASK;
000016  f8d40e10          LDR      r0,[r4,#0xe10]
00001a  f0200004          BIC      r0,r0,#4
00001e  f8c40e10          STR      r0,[r4,#0xe10]
;;;418        /* Empty txFIFO */
;;;419        base->FIFOCFG |= USART_FIFOCFG_EMPTYTX_MASK;
000022  f8d40e00          LDR      r0,[r4,#0xe00]
000026  f4403080          ORR      r0,r0,#0x10000
00002a  f8c40e00          STR      r0,[r4,#0xe00]
;;;420    
;;;421        handle->txDataSize = 0;
00002e  2000              MOVS     r0,#0
000030  6068              STR      r0,[r5,#4]
;;;422        handle->txState = kUSART_TxIdle;
000032  f885002c          STRB     r0,[r5,#0x2c]
;;;423    }
000036  bd70              POP      {r4-r6,pc}
;;;424    
                          ENDP

                  |L8.56|
000038  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
00003c  44726976
000040  6572735c
000044  66736c5f
000048  75736172
00004c  742e6300
                  |L8.80|
000050  4e554c4c          DCB      "NULL != handle",0
000054  20213d20
000058  68616e64
00005c  6c6500  
00005f  00                DCB      0

                          AREA ||i.USART_TransferCreateHandle||, CODE, READONLY, ALIGN=2

                  USART_TransferCreateHandle PROC
;;;345    
;;;346    status_t USART_TransferCreateHandle(USART_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;347                                        usart_handle_t *handle,
;;;348                                        usart_transfer_callback_t callback,
;;;349                                        void *userData)
;;;350    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;351        int32_t instance = 0;
00000c  f04f0800          MOV      r8,#0
;;;352    
;;;353        /* Check 'base' */
;;;354        assert(!((NULL == base) || (NULL == handle)));
000010  b10d              CBZ      r5,|L9.22|
000012  b104              CBZ      r4,|L9.22|
000014  e005              B        |L9.34|
                  |L9.22|
000016  f44f72b1          MOV      r2,#0x162
00001a  a11f              ADR      r1,|L9.152|
00001c  a024              ADR      r0,|L9.176|
00001e  f7fffffe          BL       __aeabi_assert
                  |L9.34|
;;;355        if ((NULL == base) || (NULL == handle))
000022  b105              CBZ      r5,|L9.38|
000024  b914              CBNZ     r4,|L9.44|
                  |L9.38|
;;;356        {
;;;357            return kStatus_InvalidArgument;
000026  2004              MOVS     r0,#4
                  |L9.40|
;;;358        }
;;;359    
;;;360        instance = USART_GetInstance(base);
;;;361    
;;;362        memset(handle, 0, sizeof(*handle));
;;;363        /* Set the TX/RX state. */
;;;364        handle->rxState = kUSART_RxIdle;
;;;365        handle->txState = kUSART_TxIdle;
;;;366        /* Set the callback and user data. */
;;;367        handle->callback = callback;
;;;368        handle->userData = userData;
;;;369        handle->rxWatermark = (usart_rxfifo_watermark_t)USART_FIFOTRIG_RXLVL_GET(base);
;;;370        handle->txWatermark = (usart_txfifo_watermark_t)USART_FIFOTRIG_TXLVL_GET(base);
;;;371    
;;;372        FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)USART_TransferHandleIRQ, handle);
;;;373    
;;;374        /* Enable interrupt in NVIC. */
;;;375        EnableIRQ(s_usartIRQ[instance]);
;;;376    
;;;377        return kStatus_Success;
;;;378    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L9.44|
00002c  4628              MOV      r0,r5                 ;360
00002e  f7fffffe          BL       USART_GetInstance
000032  4680              MOV      r8,r0                 ;360
000034  2130              MOVS     r1,#0x30              ;362
000036  4620              MOV      r0,r4                 ;362
000038  f7fffffe          BL       __aeabi_memclr4
00003c  2002              MOVS     r0,#2                 ;364
00003e  3424              ADDS     r4,r4,#0x24           ;364
000040  7260              STRB     r0,[r4,#9]            ;364
000042  2000              MOVS     r0,#0                 ;365
000044  7220              STRB     r0,[r4,#8]            ;365
000046  6026              STR      r6,[r4,#0]            ;367
000048  6067              STR      r7,[r4,#4]            ;368
00004a  f8d50e08          LDR      r0,[r5,#0xe08]        ;369
00004e  f3c04003          UBFX     r0,r0,#16,#4          ;369
000052  72e0              STRB     r0,[r4,#0xb]          ;369
000054  f8d50e08          LDR      r0,[r5,#0xe08]        ;370
000058  f3c02003          UBFX     r0,r0,#8,#4           ;370
00005c  72a0              STRB     r0,[r4,#0xa]          ;370
00005e  3c24              SUBS     r4,r4,#0x24           ;370
000060  4622              MOV      r2,r4                 ;372
000062  491d              LDR      r1,|L9.216|
000064  4628              MOV      r0,r5                 ;372
000066  f7fffffe          BL       FLEXCOMM_SetIRQHandler
00006a  491c              LDR      r1,|L9.220|
00006c  f9110008          LDRSB    r0,[r1,r8]            ;375
000070  f1100f80          CMN      r0,#0x80              ;375
000074  d100              BNE      |L9.120|
000076  e00c              B        |L9.146|
                  |L9.120|
000078  bf00              NOP                            ;375
00007a  f000021f          AND      r2,r0,#0x1f           ;375
00007e  2101              MOVS     r1,#1                 ;375
000080  4091              LSLS     r1,r1,r2              ;375
000082  0942              LSRS     r2,r0,#5              ;375
000084  0092              LSLS     r2,r2,#2              ;375
000086  f10222e0          ADD      r2,r2,#0xe000e000     ;375
00008a  f8c21100          STR      r1,[r2,#0x100]        ;375
00008e  bf00              NOP                            ;375
000090  bf00              NOP                            ;375
                  |L9.146|
000092  2000              MOVS     r0,#0                 ;377
000094  e7c8              B        |L9.40|
;;;379    
                          ENDP

000096  0000              DCW      0x0000
                  |L9.152|
000098  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
00009c  44726976
0000a0  6572735c
0000a4  66736c5f
0000a8  75736172
0000ac  742e6300
                  |L9.176|
0000b0  2128284e          DCB      "!((NULL == base) || (NULL == handle))",0
0000b4  554c4c20
0000b8  3d3d2062
0000bc  61736529
0000c0  207c7c20
0000c4  284e554c
0000c8  4c203d3d
0000cc  2068616e
0000d0  646c6529
0000d4  2900    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L9.216|
                          DCD      USART_TransferHandleIRQ
                  |L9.220|
                          DCD      s_usartIRQ

                          AREA ||i.USART_TransferGetReceiveCount||, CODE, READONLY, ALIGN=2

                  USART_TransferGetReceiveCount PROC
;;;566    
;;;567    status_t USART_TransferGetReceiveCount(USART_Type *base, usart_handle_t *handle, uint32_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;568    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;569        assert(NULL != handle);
000008  b104              CBZ      r4,|L10.12|
00000a  e005              B        |L10.24|
                  |L10.12|
00000c  f2402239          MOV      r2,#0x239
000010  a10b              ADR      r1,|L10.64|
000012  a011              ADR      r0,|L10.88|
000014  f7fffffe          BL       __aeabi_assert
                  |L10.24|
;;;570        assert(NULL != count);
000018  b105              CBZ      r5,|L10.28|
00001a  e005              B        |L10.40|
                  |L10.28|
00001c  f240223a          MOV      r2,#0x23a
000020  a107              ADR      r1,|L10.64|
000022  a011              ADR      r0,|L10.104|
000024  f7fffffe          BL       __aeabi_assert
                  |L10.40|
;;;571    
;;;572        if (kUSART_RxIdle == handle->rxState)
000028  f894002d          LDRB     r0,[r4,#0x2d]
00002c  2802              CMP      r0,#2
00002e  d101              BNE      |L10.52|
;;;573        {
;;;574            return kStatus_NoTransferInProgress;
000030  2006              MOVS     r0,#6
                  |L10.50|
;;;575        }
;;;576    
;;;577        *count = handle->rxDataSizeAll - handle->rxDataSize;
;;;578    
;;;579        return kStatus_Success;
;;;580    }
000032  bd70              POP      {r4-r6,pc}
                  |L10.52|
000034  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;577
000038  1a40              SUBS     r0,r0,r1              ;577
00003a  6028              STR      r0,[r5,#0]            ;577
00003c  2000              MOVS     r0,#0                 ;579
00003e  e7f8              B        |L10.50|
;;;581    
                          ENDP

                  |L10.64|
000040  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000044  44726976
000048  6572735c
00004c  66736c5f
000050  75736172
000054  742e6300
                  |L10.88|
000058  4e554c4c          DCB      "NULL != handle",0
00005c  20213d20
000060  68616e64
000064  6c6500  
000067  00                DCB      0
                  |L10.104|
000068  4e554c4c          DCB      "NULL != count",0
00006c  20213d20
000070  636f756e
000074  7400    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.USART_TransferGetRxRingBufferLength||, CODE, READONLY, ALIGN=2

                  USART_TransferGetRxRingBufferLength PROC
;;;73     
;;;74     static size_t USART_TransferGetRxRingBufferLength(usart_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;75     {
000002  4604              MOV      r4,r0
;;;76         size_t size;
;;;77     
;;;78         /* Check arguments */
;;;79         assert(NULL != handle);
000004  b104              CBZ      r4,|L11.8|
000006  e004              B        |L11.18|
                  |L11.8|
000008  224f              MOVS     r2,#0x4f
00000a  a109              ADR      r1,|L11.48|
00000c  a00e              ADR      r0,|L11.72|
00000e  f7fffffe          BL       __aeabi_assert
                  |L11.18|
;;;80     
;;;81         if (handle->rxRingBufferTail > handle->rxRingBufferHead)
000012  8c60              LDRH     r0,[r4,#0x22]
000014  8c21              LDRH     r1,[r4,#0x20]
000016  4288              CMP      r0,r1
000018  dd05              BLE      |L11.38|
;;;82         {
;;;83             size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferTail);
00001a  8c20              LDRH     r0,[r4,#0x20]
00001c  69e1              LDR      r1,[r4,#0x1c]
00001e  4408              ADD      r0,r0,r1
000020  8c61              LDRH     r1,[r4,#0x22]
000022  1a45              SUBS     r5,r0,r1
000024  e002              B        |L11.44|
                  |L11.38|
;;;84         }
;;;85         else
;;;86         {
;;;87             size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
000026  8c20              LDRH     r0,[r4,#0x20]
000028  8c61              LDRH     r1,[r4,#0x22]
00002a  1a45              SUBS     r5,r0,r1
                  |L11.44|
;;;88         }
;;;89         return size;
00002c  4628              MOV      r0,r5
;;;90     }
00002e  bd70              POP      {r4-r6,pc}
;;;91     
                          ENDP

                  |L11.48|
000030  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000034  44726976
000038  6572735c
00003c  66736c5f
000040  75736172
000044  742e6300
                  |L11.72|
000048  4e554c4c          DCB      "NULL != handle",0
00004c  20213d20
000050  68616e64
000054  6c6500  
000057  00                DCB      0

                          AREA ||i.USART_TransferGetSendCount||, CODE, READONLY, ALIGN=2

                  USART_TransferGetSendCount PROC
;;;424    
;;;425    status_t USART_TransferGetSendCount(USART_Type *base, usart_handle_t *handle, uint32_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;426    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;427        assert(NULL != handle);
000008  b104              CBZ      r4,|L12.12|
00000a  e005              B        |L12.24|
                  |L12.12|
00000c  f24012ab          MOV      r2,#0x1ab
000010  a10b              ADR      r1,|L12.64|
000012  a011              ADR      r0,|L12.88|
000014  f7fffffe          BL       __aeabi_assert
                  |L12.24|
;;;428        assert(NULL != count);
000018  b105              CBZ      r5,|L12.28|
00001a  e005              B        |L12.40|
                  |L12.28|
00001c  f44f72d6          MOV      r2,#0x1ac
000020  a107              ADR      r1,|L12.64|
000022  a011              ADR      r0,|L12.104|
000024  f7fffffe          BL       __aeabi_assert
                  |L12.40|
;;;429    
;;;430        if (kUSART_TxIdle == handle->txState)
000028  f894002c          LDRB     r0,[r4,#0x2c]
00002c  b908              CBNZ     r0,|L12.50|
;;;431        {
;;;432            return kStatus_NoTransferInProgress;
00002e  2006              MOVS     r0,#6
                  |L12.48|
;;;433        }
;;;434    
;;;435        *count = handle->txDataSizeAll - handle->txDataSize;
;;;436    
;;;437        return kStatus_Success;
;;;438    }
000030  bd70              POP      {r4-r6,pc}
                  |L12.50|
000032  e9d41001          LDRD     r1,r0,[r4,#4]         ;435
000036  1a40              SUBS     r0,r0,r1              ;435
000038  6028              STR      r0,[r5,#0]            ;435
00003a  2000              MOVS     r0,#0                 ;437
00003c  e7f8              B        |L12.48|
;;;439    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
000040  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000044  44726976
000048  6572735c
00004c  66736c5f
000050  75736172
000054  742e6300
                  |L12.88|
000058  4e554c4c          DCB      "NULL != handle",0
00005c  20213d20
000060  68616e64
000064  6c6500  
000067  00                DCB      0
                  |L12.104|
000068  4e554c4c          DCB      "NULL != count",0
00006c  20213d20
000070  636f756e
000074  7400    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.USART_TransferHandleIRQ||, CODE, READONLY, ALIGN=2

                  USART_TransferHandleIRQ PROC
;;;581    
;;;582    void USART_TransferHandleIRQ(USART_Type *base, usart_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;583    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;584        /* Check arguments */
;;;585        assert((NULL != base) && (NULL != handle));
000008  b10d              CBZ      r5,|L13.14|
00000a  b104              CBZ      r4,|L13.14|
00000c  e005              B        |L13.26|
                  |L13.14|
00000e  f2402249          MOV      r2,#0x249
000012  a174              ADR      r1,|L13.484|
000014  a079              ADR      r0,|L13.508|
000016  f7fffffe          BL       __aeabi_assert
                  |L13.26|
;;;586    
;;;587        bool receiveEnabled = (handle->rxDataSize) || (handle->rxRingBuffer);
00001a  6920              LDR      r0,[r4,#0x10]
00001c  b908              CBNZ     r0,|L13.34|
00001e  69a0              LDR      r0,[r4,#0x18]
000020  b108              CBZ      r0,|L13.38|
                  |L13.34|
000022  2001              MOVS     r0,#1
000024  e000              B        |L13.40|
                  |L13.38|
000026  2000              MOVS     r0,#0
                  |L13.40|
000028  4607              MOV      r7,r0
;;;588        bool sendEnabled = handle->txDataSize;
00002a  6860              LDR      r0,[r4,#4]
00002c  b108              CBZ      r0,|L13.50|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L13.52|
                  |L13.50|
000032  2000              MOVS     r0,#0
                  |L13.52|
000034  4606              MOV      r6,r0
;;;589    
;;;590        /* If RX overrun. */
;;;591        if (base->FIFOSTAT & USART_FIFOSTAT_RXERR_MASK)
000036  f8d50e04          LDR      r0,[r5,#0xe04]
00003a  f0000002          AND      r0,r0,#2
00003e  b1a0              CBZ      r0,|L13.106|
;;;592        {
;;;593            /* Clear rx error state. */
;;;594            base->FIFOSTAT |= USART_FIFOSTAT_RXERR_MASK;
000040  f8d50e04          LDR      r0,[r5,#0xe04]
000044  f0400002          ORR      r0,r0,#2
000048  f8c50e04          STR      r0,[r5,#0xe04]
;;;595            /* clear rxFIFO */
;;;596            base->FIFOCFG |= USART_FIFOCFG_EMPTYRX_MASK;
00004c  f8d50e00          LDR      r0,[r5,#0xe00]
000050  f4403000          ORR      r0,r0,#0x20000
000054  f8c50e00          STR      r0,[r5,#0xe00]
;;;597            /* Trigger callback. */
;;;598            if (handle->callback)
000058  6a60              LDR      r0,[r4,#0x24]
00005a  b130              CBZ      r0,|L13.106|
;;;599            {
;;;600                handle->callback(base, handle, kStatus_USART_RxError, handle->userData);
00005c  f241624d          MOV      r2,#0x164d
000060  4621              MOV      r1,r4
000062  4628              MOV      r0,r5
000064  e9d4c309          LDRD     r12,r3,[r4,#0x24]
000068  47e0              BLX      r12
                  |L13.106|
;;;601            }
;;;602        }
;;;603        while ((receiveEnabled && (base->FIFOSTAT & USART_FIFOSTAT_RXNOTEMPTY_MASK)) ||
00006a  e084              B        |L13.374|
                  |L13.108|
;;;604               (sendEnabled && (base->FIFOSTAT & USART_FIFOSTAT_TXNOTFULL_MASK)))
;;;605        {
;;;606            /* Receive data */
;;;607            if (receiveEnabled && (base->FIFOSTAT & USART_FIFOSTAT_RXNOTEMPTY_MASK))
00006c  2f00              CMP      r7,#0
00006e  d05c              BEQ      |L13.298|
000070  f8d50e04          LDR      r0,[r5,#0xe04]
000074  f0000040          AND      r0,r0,#0x40
000078  2800              CMP      r0,#0
00007a  d056              BEQ      |L13.298|
;;;608            {
;;;609                /* Receive to app bufffer if app buffer is present */
;;;610                if (handle->rxDataSize)
00007c  6920              LDR      r0,[r4,#0x10]
00007e  b330              CBZ      r0,|L13.206|
;;;611                {
;;;612                    *handle->rxData = base->FIFORD;
000080  f8d50e30          LDR      r0,[r5,#0xe30]
000084  68e1              LDR      r1,[r4,#0xc]
000086  7008              STRB     r0,[r1,#0]
;;;613                    handle->rxDataSize--;
000088  6920              LDR      r0,[r4,#0x10]
00008a  1e40              SUBS     r0,r0,#1
00008c  6120              STR      r0,[r4,#0x10]
;;;614                    handle->rxData++;
00008e  68e0              LDR      r0,[r4,#0xc]
000090  1c40              ADDS     r0,r0,#1
000092  60e0              STR      r0,[r4,#0xc]
;;;615                    receiveEnabled = ((handle->rxDataSize != 0) || (handle->rxRingBuffer));
000094  6920              LDR      r0,[r4,#0x10]
000096  b908              CBNZ     r0,|L13.156|
000098  69a0              LDR      r0,[r4,#0x18]
00009a  b108              CBZ      r0,|L13.160|
                  |L13.156|
00009c  2001              MOVS     r0,#1
00009e  e000              B        |L13.162|
                  |L13.160|
0000a0  2000              MOVS     r0,#0
                  |L13.162|
0000a2  4607              MOV      r7,r0
;;;616                    if (!handle->rxDataSize)
0000a4  6920              LDR      r0,[r4,#0x10]
0000a6  2800              CMP      r0,#0
0000a8  d13f              BNE      |L13.298|
;;;617                    {
;;;618                        if (!handle->rxRingBuffer)
0000aa  69a0              LDR      r0,[r4,#0x18]
0000ac  b910              CBNZ     r0,|L13.180|
;;;619                        {
;;;620                            base->FIFOINTENCLR = USART_FIFOINTENCLR_RXLVL_MASK | USART_FIFOINTENSET_RXERR_MASK;
0000ae  200a              MOVS     r0,#0xa
0000b0  f8c50e14          STR      r0,[r5,#0xe14]
                  |L13.180|
;;;621                        }
;;;622                        handle->rxState = kUSART_RxIdle;
0000b4  2002              MOVS     r0,#2
0000b6  f884002d          STRB     r0,[r4,#0x2d]
;;;623                        if (handle->callback)
0000ba  6a60              LDR      r0,[r4,#0x24]
0000bc  b388              CBZ      r0,|L13.290|
;;;624                        {
;;;625                            handle->callback(base, handle, kStatus_USART_RxIdle, handle->userData);
0000be  f2416247          MOV      r2,#0x1647
0000c2  4621              MOV      r1,r4
0000c4  4628              MOV      r0,r5
0000c6  e9d4c309          LDRD     r12,r3,[r4,#0x24]
0000ca  47e0              BLX      r12
0000cc  e02d              B        |L13.298|
                  |L13.206|
;;;626                        }
;;;627                    }
;;;628                }
;;;629                /* Otherwise receive to ring buffer if ring buffer is present */
;;;630                else
;;;631                {
;;;632                    if (handle->rxRingBuffer)
0000ce  69a0              LDR      r0,[r4,#0x18]
0000d0  b338              CBZ      r0,|L13.290|
;;;633                    {
;;;634                        /* If RX ring buffer is full, trigger callback to notify over run. */
;;;635                        if (USART_TransferIsRxRingBufferFull(handle))
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       USART_TransferIsRxRingBufferFull
0000d8  b140              CBZ      r0,|L13.236|
;;;636                        {
;;;637                            if (handle->callback)
0000da  6a60              LDR      r0,[r4,#0x24]
0000dc  b130              CBZ      r0,|L13.236|
;;;638                            {
;;;639                                handle->callback(base, handle, kStatus_USART_RxRingBufferOverrun, handle->userData);
0000de  f241624c          MOV      r2,#0x164c
0000e2  4621              MOV      r1,r4
0000e4  4628              MOV      r0,r5
0000e6  e9d4c309          LDRD     r12,r3,[r4,#0x24]
0000ea  47e0              BLX      r12
                  |L13.236|
;;;640                            }
;;;641                        }
;;;642                        /* If ring buffer is still full after callback function, the oldest data is overrided. */
;;;643                        if (USART_TransferIsRxRingBufferFull(handle))
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       USART_TransferIsRxRingBufferFull
0000f2  b150              CBZ      r0,|L13.266|
;;;644                        {
;;;645                            /* Increase handle->rxRingBufferTail to make room for new data. */
;;;646                            if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
0000f4  8c60              LDRH     r0,[r4,#0x22]
0000f6  1c40              ADDS     r0,r0,#1
0000f8  69e1              LDR      r1,[r4,#0x1c]
0000fa  4288              CMP      r0,r1
0000fc  d102              BNE      |L13.260|
;;;647                            {
;;;648                                handle->rxRingBufferTail = 0U;
0000fe  2000              MOVS     r0,#0
000100  8460              STRH     r0,[r4,#0x22]
000102  e002              B        |L13.266|
                  |L13.260|
;;;649                            }
;;;650                            else
;;;651                            {
;;;652                                handle->rxRingBufferTail++;
000104  8c60              LDRH     r0,[r4,#0x22]
000106  1c40              ADDS     r0,r0,#1
000108  8460              STRH     r0,[r4,#0x22]
                  |L13.266|
;;;653                            }
;;;654                        }
;;;655                        /* Read data. */
;;;656                        handle->rxRingBuffer[handle->rxRingBufferHead] = base->FIFORD;
00010a  f8d50e30          LDR      r0,[r5,#0xe30]
00010e  8c22              LDRH     r2,[r4,#0x20]
000110  69a1              LDR      r1,[r4,#0x18]
000112  5488              STRB     r0,[r1,r2]
;;;657                        /* Increase handle->rxRingBufferHead. */
;;;658                        if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
000114  8c20              LDRH     r0,[r4,#0x20]
000116  1c40              ADDS     r0,r0,#1
000118  69e1              LDR      r1,[r4,#0x1c]
00011a  4288              CMP      r0,r1
00011c  d102              BNE      |L13.292|
;;;659                        {
;;;660                            handle->rxRingBufferHead = 0U;
00011e  2000              MOVS     r0,#0
000120  8420              STRH     r0,[r4,#0x20]
                  |L13.290|
000122  e002              B        |L13.298|
                  |L13.292|
;;;661                        }
;;;662                        else
;;;663                        {
;;;664                            handle->rxRingBufferHead++;
000124  8c20              LDRH     r0,[r4,#0x20]
000126  1c40              ADDS     r0,r0,#1
000128  8420              STRH     r0,[r4,#0x20]
                  |L13.298|
;;;665                        }
;;;666                    }
;;;667                }
;;;668            }
;;;669            /* Send data */
;;;670            if (sendEnabled && (base->FIFOSTAT & USART_FIFOSTAT_TXNOTFULL_MASK))
00012a  b326              CBZ      r6,|L13.374|
00012c  f8d50e04          LDR      r0,[r5,#0xe04]
000130  f0000020          AND      r0,r0,#0x20
000134  b1f8              CBZ      r0,|L13.374|
;;;671            {
;;;672                base->FIFOWR = *handle->txData;
000136  6820              LDR      r0,[r4,#0]
000138  7800              LDRB     r0,[r0,#0]
00013a  f8c50e20          STR      r0,[r5,#0xe20]
;;;673                handle->txDataSize--;
00013e  6860              LDR      r0,[r4,#4]
000140  1e40              SUBS     r0,r0,#1
000142  6060              STR      r0,[r4,#4]
;;;674                handle->txData++;
000144  6820              LDR      r0,[r4,#0]
000146  1c40              ADDS     r0,r0,#1
000148  6020              STR      r0,[r4,#0]
;;;675                sendEnabled = handle->txDataSize != 0;
00014a  6860              LDR      r0,[r4,#4]
00014c  b108              CBZ      r0,|L13.338|
00014e  2001              MOVS     r0,#1
000150  e000              B        |L13.340|
                  |L13.338|
000152  2000              MOVS     r0,#0
                  |L13.340|
000154  4606              MOV      r6,r0
;;;676                if (!sendEnabled)
000156  b976              CBNZ     r6,|L13.374|
;;;677                {
;;;678                    base->FIFOINTENCLR = USART_FIFOINTENCLR_TXLVL_MASK;
000158  2004              MOVS     r0,#4
00015a  f8c50e14          STR      r0,[r5,#0xe14]
;;;679                    handle->txState = kUSART_TxIdle;
00015e  2000              MOVS     r0,#0
000160  f884002c          STRB     r0,[r4,#0x2c]
;;;680                    if (handle->callback)
000164  6a60              LDR      r0,[r4,#0x24]
000166  b130              CBZ      r0,|L13.374|
;;;681                    {
;;;682                        handle->callback(base, handle, kStatus_USART_TxIdle, handle->userData);
000168  f2416246          MOV      r2,#0x1646
00016c  4621              MOV      r1,r4
00016e  4628              MOV      r0,r5
000170  e9d4c309          LDRD     r12,r3,[r4,#0x24]
000174  47e0              BLX      r12
                  |L13.374|
000176  b137              CBZ      r7,|L13.390|
000178  f8d50e04          LDR      r0,[r5,#0xe04]        ;603
00017c  f0000040          AND      r0,r0,#0x40           ;603
000180  2800              CMP      r0,#0                 ;603
                  |L13.386|
000182  f47faf73          BNE      |L13.108|
                  |L13.390|
000186  b12e              CBZ      r6,|L13.404|
000188  f8d50e04          LDR      r0,[r5,#0xe04]        ;604
00018c  f0000020          AND      r0,r0,#0x20           ;604
000190  2800              CMP      r0,#0                 ;604
000192  d1f6              BNE      |L13.386|
                  |L13.404|
;;;683                    }
;;;684                }
;;;685            }
;;;686        }
;;;687    
;;;688        /* ring buffer is not used */
;;;689        if (NULL == handle->rxRingBuffer)
000194  69a0              LDR      r0,[r4,#0x18]
000196  bb18              CBNZ     r0,|L13.480|
;;;690        {
;;;691            /* restore if rx transfer ends and rxLevel is different from default value */
;;;692            if ((handle->rxDataSize == 0) && (USART_FIFOTRIG_RXLVL_GET(base) != handle->rxWatermark))
000198  6920              LDR      r0,[r4,#0x10]
00019a  b978              CBNZ     r0,|L13.444|
00019c  f8d50e08          LDR      r0,[r5,#0xe08]
0001a0  f3c04003          UBFX     r0,r0,#16,#4
0001a4  f894102f          LDRB     r1,[r4,#0x2f]
0001a8  4288              CMP      r0,r1
0001aa  d007              BEQ      |L13.444|
;;;693            {
;;;694                base->FIFOTRIG =
0001ac  f894102f          LDRB     r1,[r4,#0x2f]
0001b0  f8d50e08          LDR      r0,[r5,#0xe08]
0001b4  f3614013          BFI      r0,r1,#16,#4
0001b8  f8c50e08          STR      r0,[r5,#0xe08]
                  |L13.444|
;;;695                    (base->FIFOTRIG & (~USART_FIFOTRIG_RXLVL_MASK)) | USART_FIFOTRIG_RXLVL(handle->rxWatermark);
;;;696            }
;;;697            /* decrease level if rx transfer is bellow */
;;;698            if ((handle->rxDataSize != 0) && (handle->rxDataSize < (USART_FIFOTRIG_RXLVL_GET(base) + 1)))
0001bc  6920              LDR      r0,[r4,#0x10]
0001be  b178              CBZ      r0,|L13.480|
0001c0  6921              LDR      r1,[r4,#0x10]
0001c2  f8d50e08          LDR      r0,[r5,#0xe08]
0001c6  f3c04003          UBFX     r0,r0,#16,#4
0001ca  1c40              ADDS     r0,r0,#1
0001cc  4281              CMP      r1,r0
0001ce  d207              BCS      |L13.480|
;;;699            {
;;;700                base->FIFOTRIG =
0001d0  6920              LDR      r0,[r4,#0x10]
0001d2  1e40              SUBS     r0,r0,#1
0001d4  f8d51e08          LDR      r1,[r5,#0xe08]
0001d8  f3604113          BFI      r1,r0,#16,#4
0001dc  f8c51e08          STR      r1,[r5,#0xe08]
                  |L13.480|
;;;701                    (base->FIFOTRIG & (~USART_FIFOTRIG_RXLVL_MASK)) | (USART_FIFOTRIG_RXLVL(handle->rxDataSize - 1));
;;;702            }
;;;703        }
;;;704    }
0001e0  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L13.484|
0001e4  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
0001e8  44726976
0001ec  6572735c
0001f0  66736c5f
0001f4  75736172
0001f8  742e6300
                  |L13.508|
0001fc  284e554c          DCB      "(NULL != base) && (NULL != handle)",0
000200  4c20213d
000204  20626173
000208  65292026
00020c  2620284e
000210  554c4c20
000214  213d2068
000218  616e646c
00021c  652900  
00021f  00                DCB      0

                          AREA ||i.USART_TransferIsRxRingBufferFull||, CODE, READONLY, ALIGN=2

                  USART_TransferIsRxRingBufferFull PROC
;;;91     
;;;92     static bool USART_TransferIsRxRingBufferFull(usart_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
000002  4604              MOV      r4,r0
;;;94         bool full;
;;;95     
;;;96         /* Check arguments */
;;;97         assert(NULL != handle);
000004  b104              CBZ      r4,|L14.8|
000006  e004              B        |L14.18|
                  |L14.8|
000008  2261              MOVS     r2,#0x61
00000a  a108              ADR      r1,|L14.44|
00000c  a00d              ADR      r0,|L14.68|
00000e  f7fffffe          BL       __aeabi_assert
                  |L14.18|
;;;98     
;;;99         if (USART_TransferGetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_TransferGetRxRingBufferLength
000018  69e1              LDR      r1,[r4,#0x1c]
00001a  1e49              SUBS     r1,r1,#1
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L14.36|
;;;100        {
;;;101            full = true;
000020  2501              MOVS     r5,#1
000022  e000              B        |L14.38|
                  |L14.36|
;;;102        }
;;;103        else
;;;104        {
;;;105            full = false;
000024  2500              MOVS     r5,#0
                  |L14.38|
;;;106        }
;;;107        return full;
000026  4628              MOV      r0,r5
;;;108    }
000028  bd70              POP      {r4-r6,pc}
;;;109    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  75736172
000040  742e6300
                  |L14.68|
000044  4e554c4c          DCB      "NULL != handle",0
000048  20213d20
00004c  68616e64
000050  6c6500  
000053  00                DCB      0

                          AREA ||i.USART_TransferReceiveNonBlocking||, CODE, READONLY, ALIGN=2

                  USART_TransferReceiveNonBlocking PROC
;;;439    
;;;440    status_t USART_TransferReceiveNonBlocking(USART_Type *base,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;441                                              usart_handle_t *handle,
;;;442                                              usart_transfer_t *xfer,
;;;443                                              size_t *receivedBytes)
;;;444    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  469b              MOV      r11,r3
;;;445        uint32_t i;
;;;446        /* How many bytes to copy from ring buffer to user memory. */
;;;447        size_t bytesToCopy = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;448        /* How many bytes to receive. */
;;;449        size_t bytesToReceive;
;;;450        /* How many bytes currently have received. */
;;;451        size_t bytesCurrentReceived;
;;;452        uint32_t regPrimask = 0U;
000010  46d1              MOV      r9,r10
;;;453    
;;;454        /* Check arguments */
;;;455        assert(!((NULL == base) || (NULL == handle) || (NULL == xfer)));
000012  b117              CBZ      r7,|L15.26|
000014  b10c              CBZ      r4,|L15.26|
000016  b105              CBZ      r5,|L15.26|
000018  e005              B        |L15.38|
                  |L15.26|
00001a  f24012c7          MOV      r2,#0x1c7
00001e  a145              ADR      r1,|L15.308|
000020  a04a              ADR      r0,|L15.332|
000022  f7fffffe          BL       __aeabi_assert
                  |L15.38|
;;;456        if ((NULL == base) || (NULL == handle) || (NULL == xfer))
000026  b10f              CBZ      r7,|L15.44|
000028  b104              CBZ      r4,|L15.44|
00002a  b915              CBNZ     r5,|L15.50|
                  |L15.44|
;;;457        {
;;;458            return kStatus_InvalidArgument;
00002c  2004              MOVS     r0,#4
                  |L15.46|
;;;459        }
;;;460        /* Check xfer members */
;;;461        assert(!((0 == xfer->dataSize) || (NULL == xfer->data)));
;;;462        if ((0 == xfer->dataSize) || (NULL == xfer->data))
;;;463        {
;;;464            return kStatus_InvalidArgument;
;;;465        }
;;;466    
;;;467        /* How to get data:
;;;468           1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
;;;469              to uart handle, enable interrupt to store received data to xfer->data. When
;;;470              all data received, trigger callback.
;;;471           2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
;;;472              If there are enough data in ring buffer, copy them to xfer->data and return.
;;;473              If there are not enough data in ring buffer, copy all of them to xfer->data,
;;;474              save the xfer->data remained empty space to uart handle, receive data
;;;475              to this empty space and trigger callback when finished. */
;;;476        if (kUSART_RxBusy == handle->rxState)
;;;477        {
;;;478            return kStatus_USART_RxBusy;
;;;479        }
;;;480        else
;;;481        {
;;;482            bytesToReceive = xfer->dataSize;
;;;483            bytesCurrentReceived = 0U;
;;;484            /* If RX ring buffer is used. */
;;;485            if (handle->rxRingBuffer)
;;;486            {
;;;487                /* Disable IRQ, protect ring buffer. */
;;;488                regPrimask = DisableGlobalIRQ();
;;;489                /* How many bytes in RX ring buffer currently. */
;;;490                bytesToCopy = USART_TransferGetRxRingBufferLength(handle);
;;;491                if (bytesToCopy)
;;;492                {
;;;493                    bytesToCopy = MIN(bytesToReceive, bytesToCopy);
;;;494                    bytesToReceive -= bytesToCopy;
;;;495                    /* Copy data from ring buffer to user memory. */
;;;496                    for (i = 0U; i < bytesToCopy; i++)
;;;497                    {
;;;498                        xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferTail];
;;;499                        /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
;;;500                        if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
;;;501                        {
;;;502                            handle->rxRingBufferTail = 0U;
;;;503                        }
;;;504                        else
;;;505                        {
;;;506                            handle->rxRingBufferTail++;
;;;507                        }
;;;508                    }
;;;509                }
;;;510                /* If ring buffer does not have enough data, still need to read more data. */
;;;511                if (bytesToReceive)
;;;512                {
;;;513                    /* No data in ring buffer, save the request to UART handle. */
;;;514                    handle->rxData = xfer->data + bytesCurrentReceived;
;;;515                    handle->rxDataSize = bytesToReceive;
;;;516                    handle->rxDataSizeAll = bytesToReceive;
;;;517                    handle->rxState = kUSART_RxBusy;
;;;518                }
;;;519                /* Enable IRQ if previously enabled. */
;;;520                EnableGlobalIRQ(regPrimask);
;;;521                /* Call user callback since all data are received. */
;;;522                if (0 == bytesToReceive)
;;;523                {
;;;524                    if (handle->callback)
;;;525                    {
;;;526                        handle->callback(base, handle, kStatus_USART_RxIdle, handle->userData);
;;;527                    }
;;;528                }
;;;529            }
;;;530            /* Ring buffer not used. */
;;;531            else
;;;532            {
;;;533                handle->rxData = xfer->data + bytesCurrentReceived;
;;;534                handle->rxDataSize = bytesToReceive;
;;;535                handle->rxDataSizeAll = bytesToReceive;
;;;536                handle->rxState = kUSART_RxBusy;
;;;537    
;;;538                /* Enable RX interrupt. */
;;;539                base->FIFOINTENSET |= USART_FIFOINTENSET_RXLVL_MASK;
;;;540            }
;;;541            /* Return the how many bytes have read. */
;;;542            if (receivedBytes)
;;;543            {
;;;544                *receivedBytes = bytesCurrentReceived;
;;;545            }
;;;546        }
;;;547        return kStatus_Success;
;;;548    }
00002e  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.50|
000032  6868              LDR      r0,[r5,#4]            ;461
000034  b110              CBZ      r0,|L15.60|
000036  6828              LDR      r0,[r5,#0]            ;461
000038  b100              CBZ      r0,|L15.60|
00003a  e005              B        |L15.72|
                  |L15.60|
00003c  f24012cd          MOV      r2,#0x1cd             ;461
000040  a13c              ADR      r1,|L15.308|
000042  a050              ADR      r0,|L15.388|
000044  f7fffffe          BL       __aeabi_assert
                  |L15.72|
000048  6868              LDR      r0,[r5,#4]            ;462
00004a  b108              CBZ      r0,|L15.80|
00004c  6828              LDR      r0,[r5,#0]            ;462
00004e  b908              CBNZ     r0,|L15.84|
                  |L15.80|
000050  2004              MOVS     r0,#4                 ;464
000052  e7ec              B        |L15.46|
                  |L15.84|
000054  f894002d          LDRB     r0,[r4,#0x2d]         ;476
000058  2803              CMP      r0,#3                 ;476
00005a  d102              BNE      |L15.98|
00005c  f2416045          MOV      r0,#0x1645            ;478
000060  e7e5              B        |L15.46|
                  |L15.98|
000062  686e              LDR      r6,[r5,#4]            ;482
000064  f04f0800          MOV      r8,#0                 ;483
000068  69a0              LDR      r0,[r4,#0x18]         ;485
00006a  2800              CMP      r0,#0                 ;485
00006c  d04c              BEQ      |L15.264|
00006e  bf00              NOP                            ;488
000070  bf00              NOP                            ;488
000072  f3ef8110          MRS      r1,PRIMASK            ;488
000076  4608              MOV      r0,r1                 ;488
000078  b672              CPSID    i                     ;488
00007a  bf00              NOP                            ;488
00007c  4681              MOV      r9,r0                 ;488
00007e  4620              MOV      r0,r4                 ;490
000080  f7fffffe          BL       USART_TransferGetRxRingBufferLength
000084  4682              MOV      r10,r0                ;490
000086  f1ba0f00          CMP      r10,#0                ;491
00008a  d023              BEQ      |L15.212|
00008c  4556              CMP      r6,r10                ;493
00008e  d201              BCS      |L15.148|
000090  4630              MOV      r0,r6                 ;493
000092  e000              B        |L15.150|
                  |L15.148|
000094  4650              MOV      r0,r10                ;493
                  |L15.150|
000096  4682              MOV      r10,r0                ;493
000098  eba6060a          SUB      r6,r6,r10             ;494
00009c  2000              MOVS     r0,#0                 ;496
00009e  9000              STR      r0,[sp,#0]            ;496
0000a0  e015              B        |L15.206|
                  |L15.162|
0000a2  8c61              LDRH     r1,[r4,#0x22]         ;498
0000a4  69a0              LDR      r0,[r4,#0x18]         ;498
0000a6  5c42              LDRB     r2,[r0,r1]            ;498
0000a8  4640              MOV      r0,r8                 ;498
0000aa  f1080801          ADD      r8,r8,#1              ;498
0000ae  682b              LDR      r3,[r5,#0]            ;498
0000b0  541a              STRB     r2,[r3,r0]            ;498
0000b2  8c60              LDRH     r0,[r4,#0x22]         ;500
0000b4  1c40              ADDS     r0,r0,#1              ;500
0000b6  69e1              LDR      r1,[r4,#0x1c]         ;500
0000b8  4288              CMP      r0,r1                 ;500
0000ba  d102              BNE      |L15.194|
0000bc  2000              MOVS     r0,#0                 ;502
0000be  8460              STRH     r0,[r4,#0x22]         ;502
0000c0  e002              B        |L15.200|
                  |L15.194|
0000c2  8c60              LDRH     r0,[r4,#0x22]         ;506
0000c4  1c40              ADDS     r0,r0,#1              ;506
0000c6  8460              STRH     r0,[r4,#0x22]         ;506
                  |L15.200|
0000c8  9800              LDR      r0,[sp,#0]            ;496
0000ca  1c40              ADDS     r0,r0,#1              ;496
0000cc  9000              STR      r0,[sp,#0]            ;496
                  |L15.206|
0000ce  9800              LDR      r0,[sp,#0]            ;496
0000d0  4550              CMP      r0,r10                ;496
0000d2  d3e6              BCC      |L15.162|
                  |L15.212|
0000d4  b13e              CBZ      r6,|L15.230|
0000d6  6828              LDR      r0,[r5,#0]            ;514
0000d8  4440              ADD      r0,r0,r8              ;514
0000da  60e0              STR      r0,[r4,#0xc]          ;514
0000dc  6126              STR      r6,[r4,#0x10]         ;515
0000de  6166              STR      r6,[r4,#0x14]         ;516
0000e0  2003              MOVS     r0,#3                 ;517
0000e2  f884002d          STRB     r0,[r4,#0x2d]         ;517
                  |L15.230|
0000e6  bf00              NOP                            ;520
0000e8  bf00              NOP                            ;520
0000ea  f3898810          MSR      PRIMASK,r9            ;520
0000ee  bf00              NOP                            ;520
0000f0  bf00              NOP                            ;520
0000f2  b9be              CBNZ     r6,|L15.292|
0000f4  6a60              LDR      r0,[r4,#0x24]         ;524
0000f6  b1a8              CBZ      r0,|L15.292|
0000f8  f2416247          MOV      r2,#0x1647            ;526
0000fc  4621              MOV      r1,r4                 ;526
0000fe  4638              MOV      r0,r7                 ;526
000100  e9d4c309          LDRD     r12,r3,[r4,#0x24]     ;526
000104  47e0              BLX      r12                   ;526
000106  e00d              B        |L15.292|
                  |L15.264|
000108  6828              LDR      r0,[r5,#0]            ;533
00010a  4440              ADD      r0,r0,r8              ;533
00010c  60e0              STR      r0,[r4,#0xc]          ;533
00010e  6126              STR      r6,[r4,#0x10]         ;534
000110  6166              STR      r6,[r4,#0x14]         ;535
000112  2003              MOVS     r0,#3                 ;536
000114  f884002d          STRB     r0,[r4,#0x2d]         ;536
000118  f8d70e10          LDR      r0,[r7,#0xe10]        ;539
00011c  f0400008          ORR      r0,r0,#8              ;539
000120  f8c70e10          STR      r0,[r7,#0xe10]        ;539
                  |L15.292|
000124  f1bb0f00          CMP      r11,#0                ;542
000128  d001              BEQ      |L15.302|
00012a  f8cb8000          STR      r8,[r11,#0]           ;544
                  |L15.302|
00012e  2000              MOVS     r0,#0                 ;547
000130  e77d              B        |L15.46|
;;;549    
                          ENDP

000132  0000              DCW      0x0000
                  |L15.308|
000134  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000138  44726976
00013c  6572735c
000140  66736c5f
000144  75736172
000148  742e6300
                  |L15.332|
00014c  2128284e          DCB      "!((NULL == base) || (NULL == handle) || (NULL == xfer))"
000150  554c4c20
000154  3d3d2062
000158  61736529
00015c  207c7c20
000160  284e554c
000164  4c203d3d
000168  2068616e
00016c  646c6529
000170  207c7c20
000174  284e554c
000178  4c203d3d
00017c  20786665
000180  722929  
000183  00                DCB      0
                  |L15.388|
000184  21282830          DCB      "!((0 == xfer->dataSize) || (NULL == xfer->data))",0
000188  203d3d20
00018c  78666572
000190  2d3e6461
000194  74615369
000198  7a652920
00019c  7c7c2028
0001a0  4e554c4c
0001a4  203d3d20
0001a8  78666572
0001ac  2d3e6461
0001b0  74612929
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0

                          AREA ||i.USART_TransferSendNonBlocking||, CODE, READONLY, ALIGN=2

                  USART_TransferSendNonBlocking PROC
;;;379    
;;;380    status_t USART_TransferSendNonBlocking(USART_Type *base, usart_handle_t *handle, usart_transfer_t *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;381    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;382        /* Check arguments */
;;;383        assert(!((NULL == base) || (NULL == handle) || (NULL == xfer)));
000008  b116              CBZ      r6,|L16.16|
00000a  b10d              CBZ      r5,|L16.16|
00000c  b104              CBZ      r4,|L16.16|
00000e  e005              B        |L16.28|
                  |L16.16|
000010  f240127f          MOV      r2,#0x17f
000014  a118              ADR      r1,|L16.120|
000016  a01e              ADR      r0,|L16.144|
000018  f7fffffe          BL       __aeabi_assert
                  |L16.28|
;;;384        if ((NULL == base) || (NULL == handle) || (NULL == xfer))
00001c  b10e              CBZ      r6,|L16.34|
00001e  b105              CBZ      r5,|L16.34|
000020  b90c              CBNZ     r4,|L16.38|
                  |L16.34|
;;;385        {
;;;386            return kStatus_InvalidArgument;
000022  2004              MOVS     r0,#4
                  |L16.36|
;;;387        }
;;;388        /* Check xfer members */
;;;389        assert(!((0 == xfer->dataSize) || (NULL == xfer->data)));
;;;390        if ((0 == xfer->dataSize) || (NULL == xfer->data))
;;;391        {
;;;392            return kStatus_InvalidArgument;
;;;393        }
;;;394    
;;;395        /* Return error if current TX busy. */
;;;396        if (kUSART_TxBusy == handle->txState)
;;;397        {
;;;398            return kStatus_USART_TxBusy;
;;;399        }
;;;400        else
;;;401        {
;;;402            handle->txData = xfer->data;
;;;403            handle->txDataSize = xfer->dataSize;
;;;404            handle->txDataSizeAll = xfer->dataSize;
;;;405            handle->txState = kUSART_TxBusy;
;;;406            /* Enable transmiter interrupt. */
;;;407            base->FIFOINTENSET |= USART_FIFOINTENSET_TXLVL_MASK;
;;;408        }
;;;409        return kStatus_Success;
;;;410    }
000024  bd70              POP      {r4-r6,pc}
                  |L16.38|
000026  6860              LDR      r0,[r4,#4]            ;389
000028  b110              CBZ      r0,|L16.48|
00002a  6820              LDR      r0,[r4,#0]            ;389
00002c  b100              CBZ      r0,|L16.48|
00002e  e005              B        |L16.60|
                  |L16.48|
000030  f2401285          MOV      r2,#0x185             ;389
000034  a110              ADR      r1,|L16.120|
000036  a024              ADR      r0,|L16.200|
000038  f7fffffe          BL       __aeabi_assert
                  |L16.60|
00003c  6860              LDR      r0,[r4,#4]            ;390
00003e  b108              CBZ      r0,|L16.68|
000040  6820              LDR      r0,[r4,#0]            ;390
000042  b908              CBNZ     r0,|L16.72|
                  |L16.68|
000044  2004              MOVS     r0,#4                 ;392
000046  e7ed              B        |L16.36|
                  |L16.72|
000048  f895002c          LDRB     r0,[r5,#0x2c]         ;396
00004c  2801              CMP      r0,#1                 ;396
00004e  d102              BNE      |L16.86|
000050  f2416044          MOV      r0,#0x1644            ;398
000054  e7e6              B        |L16.36|
                  |L16.86|
000056  6820              LDR      r0,[r4,#0]            ;402
000058  6028              STR      r0,[r5,#0]            ;402
00005a  6860              LDR      r0,[r4,#4]            ;403
00005c  6068              STR      r0,[r5,#4]            ;403
00005e  6860              LDR      r0,[r4,#4]            ;404
000060  60a8              STR      r0,[r5,#8]            ;404
000062  2001              MOVS     r0,#1                 ;405
000064  f885002c          STRB     r0,[r5,#0x2c]         ;405
000068  f8d60e10          LDR      r0,[r6,#0xe10]        ;407
00006c  f0400004          ORR      r0,r0,#4              ;407
000070  f8c60e10          STR      r0,[r6,#0xe10]        ;407
000074  2000              MOVS     r0,#0                 ;409
000076  e7d5              B        |L16.36|
;;;411    
                          ENDP

                  |L16.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  75736172
00008c  742e6300
                  |L16.144|
000090  2128284e          DCB      "!((NULL == base) || (NULL == handle) || (NULL == xfer))"
000094  554c4c20
000098  3d3d2062
00009c  61736529
0000a0  207c7c20
0000a4  284e554c
0000a8  4c203d3d
0000ac  2068616e
0000b0  646c6529
0000b4  207c7c20
0000b8  284e554c
0000bc  4c203d3d
0000c0  20786665
0000c4  722929  
0000c7  00                DCB      0
                  |L16.200|
0000c8  21282830          DCB      "!((0 == xfer->dataSize) || (NULL == xfer->data))",0
0000cc  203d3d20
0000d0  78666572
0000d4  2d3e6461
0000d8  74615369
0000dc  7a652920
0000e0  7c7c2028
0000e4  4e554c4c
0000e8  203d3d20
0000ec  78666572
0000f0  2d3e6461
0000f4  74612929
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0

                          AREA ||i.USART_TransferStartRingBuffer||, CODE, READONLY, ALIGN=2

                  USART_TransferStartRingBuffer PROC
;;;109    
;;;110    void USART_TransferStartRingBuffer(USART_Type *base, usart_handle_t *handle, uint8_t *ringBuffer, size_t ringBufferSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;111    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;112        /* Check arguments */
;;;113        assert(NULL != base);
00000c  b105              CBZ      r5,|L17.16|
00000e  e004              B        |L17.26|
                  |L17.16|
000010  2271              MOVS     r2,#0x71
000012  a10f              ADR      r1,|L17.80|
000014  a014              ADR      r0,|L17.104|
000016  f7fffffe          BL       __aeabi_assert
                  |L17.26|
;;;114        assert(NULL != handle);
00001a  b104              CBZ      r4,|L17.30|
00001c  e004              B        |L17.40|
                  |L17.30|
00001e  2272              MOVS     r2,#0x72
000020  a10b              ADR      r1,|L17.80|
000022  a015              ADR      r0,|L17.120|
000024  f7fffffe          BL       __aeabi_assert
                  |L17.40|
;;;115        assert(NULL != ringBuffer);
000028  b106              CBZ      r6,|L17.44|
00002a  e004              B        |L17.54|
                  |L17.44|
00002c  2273              MOVS     r2,#0x73
00002e  a108              ADR      r1,|L17.80|
000030  a015              ADR      r0,|L17.136|
000032  f7fffffe          BL       __aeabi_assert
                  |L17.54|
;;;116    
;;;117        /* Setup the ringbuffer address */
;;;118        handle->rxRingBuffer = ringBuffer;
000036  61a6              STR      r6,[r4,#0x18]
;;;119        handle->rxRingBufferSize = ringBufferSize;
000038  61e7              STR      r7,[r4,#0x1c]
;;;120        handle->rxRingBufferHead = 0U;
00003a  2000              MOVS     r0,#0
00003c  8420              STRH     r0,[r4,#0x20]
;;;121        handle->rxRingBufferTail = 0U;
00003e  8460              STRH     r0,[r4,#0x22]
;;;122        /* ring buffer is ready we can start receiving data */
;;;123        base->FIFOINTENSET |= USART_FIFOINTENSET_RXLVL_MASK | USART_FIFOINTENSET_RXERR_MASK;
000040  f8d50e10          LDR      r0,[r5,#0xe10]
000044  f040000a          ORR      r0,r0,#0xa
000048  f8c50e10          STR      r0,[r5,#0xe10]
;;;124    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;125    
                          ENDP

                  |L17.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  75736172
000064  742e6300
                  |L17.104|
000068  4e554c4c          DCB      "NULL != base",0
00006c  20213d20
000070  62617365
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L17.120|
000078  4e554c4c          DCB      "NULL != handle",0
00007c  20213d20
000080  68616e64
000084  6c6500  
000087  00                DCB      0
                  |L17.136|
000088  4e554c4c          DCB      "NULL != ringBuffer",0
00008c  20213d20
000090  72696e67
000094  42756666
000098  657200  
00009b  00                DCB      0

                          AREA ||i.USART_TransferStopRingBuffer||, CODE, READONLY, ALIGN=2

                  USART_TransferStopRingBuffer PROC
;;;125    
;;;126    void USART_TransferStopRingBuffer(USART_Type *base, usart_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;127    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;128        /* Check arguments */
;;;129        assert(NULL != base);
000006  b105              CBZ      r5,|L18.10|
000008  e004              B        |L18.20|
                  |L18.10|
00000a  2281              MOVS     r2,#0x81
00000c  a10b              ADR      r1,|L18.60|
00000e  a011              ADR      r0,|L18.84|
000010  f7fffffe          BL       __aeabi_assert
                  |L18.20|
;;;130        assert(NULL != handle);
000014  b104              CBZ      r4,|L18.24|
000016  e004              B        |L18.34|
                  |L18.24|
000018  2282              MOVS     r2,#0x82
00001a  a108              ADR      r1,|L18.60|
00001c  a011              ADR      r0,|L18.100|
00001e  f7fffffe          BL       __aeabi_assert
                  |L18.34|
;;;131    
;;;132        if (handle->rxState == kUSART_RxIdle)
000022  f894002d          LDRB     r0,[r4,#0x2d]
000026  2802              CMP      r0,#2
000028  d102              BNE      |L18.48|
;;;133        {
;;;134            base->FIFOINTENCLR = USART_FIFOINTENCLR_RXLVL_MASK | USART_FIFOINTENCLR_RXERR_MASK;
00002a  200a              MOVS     r0,#0xa
00002c  f8c50e14          STR      r0,[r5,#0xe14]
                  |L18.48|
;;;135        }
;;;136        handle->rxRingBuffer = NULL;
000030  2000              MOVS     r0,#0
000032  61a0              STR      r0,[r4,#0x18]
;;;137        handle->rxRingBufferSize = 0U;
000034  61e0              STR      r0,[r4,#0x1c]
;;;138        handle->rxRingBufferHead = 0U;
000036  8420              STRH     r0,[r4,#0x20]
;;;139        handle->rxRingBufferTail = 0U;
000038  8460              STRH     r0,[r4,#0x22]
;;;140    }
00003a  bd70              POP      {r4-r6,pc}
;;;141    
                          ENDP

                  |L18.60|
00003c  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000040  44726976
000044  6572735c
000048  66736c5f
00004c  75736172
000050  742e6300
                  |L18.84|
000054  4e554c4c          DCB      "NULL != base",0
000058  20213d20
00005c  62617365
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L18.100|
000064  4e554c4c          DCB      "NULL != handle",0
000068  20213d20
00006c  68616e64
000070  6c6500  
000073  00                DCB      0

                          AREA ||i.USART_WriteBlocking||, CODE, READONLY, ALIGN=2

                  USART_WriteBlocking PROC
;;;264    
;;;265    void USART_WriteBlocking(USART_Type *base, const uint8_t *data, size_t length)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;267        /* Check arguments */
;;;268        assert(!((NULL == base) || (NULL == data)));
000008  b10c              CBZ      r4,|L19.14|
00000a  b105              CBZ      r5,|L19.14|
00000c  e005              B        |L19.26|
                  |L19.14|
00000e  f44f7286          MOV      r2,#0x10c
000012  a112              ADR      r1,|L19.92|
000014  a017              ADR      r0,|L19.116|
000016  f7fffffe          BL       __aeabi_assert
                  |L19.26|
;;;269        if ((NULL == base) || (NULL == data))
00001a  b104              CBZ      r4,|L19.30|
00001c  b905              CBNZ     r5,|L19.32|
                  |L19.30|
;;;270        {
;;;271            return;
;;;272        }
;;;273        /* Check whether txFIFO is enabled */
;;;274        if (!(base->FIFOCFG & USART_FIFOCFG_ENABLETX_MASK))
;;;275        {
;;;276            return;
;;;277        }
;;;278        for (; length > 0; length--)
;;;279        {
;;;280            /* Loop until txFIFO get some space for new data */
;;;281            while (!(base->FIFOSTAT & USART_FIFOSTAT_TXNOTFULL_MASK))
;;;282            {
;;;283            }
;;;284            base->FIFOWR = *data;
;;;285            data++;
;;;286        }
;;;287        /* Wait to finish transfer */
;;;288        while (!(base->FIFOSTAT & USART_FIFOSTAT_TXEMPTY_MASK))
;;;289        {
;;;290        }
;;;291    }
00001e  bd70              POP      {r4-r6,pc}
                  |L19.32|
000020  f8d40e00          LDR      r0,[r4,#0xe00]        ;274
000024  f0000001          AND      r0,r0,#1              ;274
000028  b900              CBNZ     r0,|L19.44|
00002a  e7f8              B        |L19.30|
                  |L19.44|
00002c  e00b              B        |L19.70|
                  |L19.46|
00002e  bf00              NOP                            ;281
                  |L19.48|
000030  f8d40e04          LDR      r0,[r4,#0xe04]        ;281
000034  f0000020          AND      r0,r0,#0x20           ;281
000038  2800              CMP      r0,#0                 ;281
00003a  d0f9              BEQ      |L19.48|
00003c  7828              LDRB     r0,[r5,#0]            ;284
00003e  f8c40e20          STR      r0,[r4,#0xe20]        ;284
000042  1c6d              ADDS     r5,r5,#1              ;285
000044  1e76              SUBS     r6,r6,#1              ;278
                  |L19.70|
000046  2e00              CMP      r6,#0                 ;278
000048  d1f1              BNE      |L19.46|
00004a  bf00              NOP                            ;288
                  |L19.76|
00004c  f8d40e04          LDR      r0,[r4,#0xe04]        ;288
000050  f0000010          AND      r0,r0,#0x10           ;288
000054  2800              CMP      r0,#0                 ;288
000056  d0f9              BEQ      |L19.76|
000058  bf00              NOP      
00005a  e7e0              B        |L19.30|
;;;292    
                          ENDP

                  |L19.92|
00005c  5352435c          DCB      "SRC\\Drivers\\fsl_usart.c",0
000060  44726976
000064  6572735c
000068  66736c5f
00006c  75736172
000070  742e6300
                  |L19.116|
000074  2128284e          DCB      "!((NULL == base) || (NULL == data))",0
000078  554c4c20
00007c  3d3d2062
000080  61736529
000084  207c7c20
000088  284e554c
00008c  4c203d3d
000090  20646174
000094  61292900

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_usartIRQ
000000  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
000004  12131415          DCB      0x12,0x13,0x14,0x15
000008  28290000          DCB      0x28,0x29,0x00,0x00
                  s_usartBaseAddrs
                          DCD      0x40086000
                          DCD      0x40087000
                          DCD      0x40088000
                          DCD      0x40089000
                          DCD      0x4008a000
                          DCD      0x40096000
                          DCD      0x40097000
                          DCD      0x40098000
                          DCD      0x40099000
                          DCD      0x4009a000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_fsl_usart_c_1fe8f771____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_fsl_usart_c_1fe8f771____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_fsl_usart_c_1fe8f771____REVSH|
#line 402
|__asm___11_fsl_usart_c_1fe8f771____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_fsl_usart_c_1fe8f771____RRX|
#line 587
|__asm___11_fsl_usart_c_1fe8f771____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
