; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\system_lpc54608.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\system_lpc54608.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\system_lpc54608.crf SRC\System\system_LPC54608.c]
                          THUMB

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;280    
;;;281    void SystemCoreClockUpdate (void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;282    uint32_t clkRate = 0;
000004  2400              MOVS     r4,#0
;;;283        uint32_t prediv, postdiv;
;;;284        uint64_t workRate;
;;;285    
;;;286        switch (SYSCON->MAINCLKSELB & SYSCON_MAINCLKSELB_SEL_MASK)
000006  483f              LDR      r0,|L1.260|
000008  6800              LDR      r0,[r0,#0]
00000a  f0000003          AND      r0,r0,#3
00000e  b120              CBZ      r0,|L1.26|
000010  2802              CMP      r0,#2
000012  d020              BEQ      |L1.86|
000014  2803              CMP      r0,#3
000016  d168              BNE      |L1.234|
000018  e064              B        |L1.228|
                  |L1.26|
;;;287        {
;;;288            case 0x00: /* MAINCLKSELA clock (main_clk_a)*/
;;;289                switch (SYSCON->MAINCLKSELA & SYSCON_MAINCLKSELA_SEL_MASK)
00001a  483a              LDR      r0,|L1.260|
00001c  1f00              SUBS     r0,r0,#4
00001e  6800              LDR      r0,[r0,#0]
000020  f0000003          AND      r0,r0,#3
000024  b120              CBZ      r0,|L1.48|
000026  2801              CMP      r0,#1
000028  d004              BEQ      |L1.52|
00002a  2802              CMP      r0,#2
00002c  d108              BNE      |L1.64|
00002e  e003              B        |L1.56|
                  |L1.48|
;;;290                {
;;;291                    case 0x00: /* FRO 12 MHz (fro_12m) */
;;;292                        clkRate = CLK_FRO_12MHZ;
000030  4c35              LDR      r4,|L1.264|
;;;293                        break;
000032  e00e              B        |L1.82|
                  |L1.52|
;;;294                    case 0x01: /* CLKIN (clk_in) */
;;;295                        clkRate = CLK_CLK_IN;
000034  2400              MOVS     r4,#0
;;;296                        break;
000036  e00c              B        |L1.82|
                  |L1.56|
;;;297                    case 0x02: /* Watchdog oscillator (wdt_clk) */
;;;298                        clkRate = getWdtOscFreq();
000038  f7fffffe          BL       getWdtOscFreq
00003c  4604              MOV      r4,r0
;;;299                        break;
00003e  e008              B        |L1.82|
                  |L1.64|
;;;300                    default: /* = 0x03 = FRO 96 or 48 MHz (fro_hf) */
;;;301                        if (SYSCON->FROCTRL & SYSCON_FROCTRL_SEL_MASK)
000040  4832              LDR      r0,|L1.268|
000042  6800              LDR      r0,[r0,#0]
000044  f4004080          AND      r0,r0,#0x4000
000048  b108              CBZ      r0,|L1.78|
;;;302                        {
;;;303                            clkRate = CLK_FRO_96MHZ;
00004a  4c31              LDR      r4,|L1.272|
00004c  e000              B        |L1.80|
                  |L1.78|
;;;304                        }
;;;305                        else
;;;306                        {
;;;307                            clkRate = CLK_FRO_48MHZ;
00004e  4c31              LDR      r4,|L1.276|
                  |L1.80|
;;;308                        }
;;;309                        break;
000050  bf00              NOP      
                  |L1.82|
000052  bf00              NOP                            ;293
;;;310                }
;;;311                break;
000054  e04a              B        |L1.236|
                  |L1.86|
;;;312            case 0x02: /* System PLL clock (pll_clk)*/
;;;313                switch (SYSCON->SYSPLLCLKSEL & SYSCON_SYSPLLCLKSEL_SEL_MASK)
000056  482b              LDR      r0,|L1.260|
000058  300c              ADDS     r0,r0,#0xc
00005a  6800              LDR      r0,[r0,#0]
00005c  f0000007          AND      r0,r0,#7
000060  b130              CBZ      r0,|L1.112|
000062  2801              CMP      r0,#1
000064  d006              BEQ      |L1.116|
000066  2802              CMP      r0,#2
000068  d006              BEQ      |L1.120|
00006a  2803              CMP      r0,#3
00006c  d10b              BNE      |L1.134|
00006e  e007              B        |L1.128|
                  |L1.112|
;;;314                {
;;;315                    case 0x00: /* FRO 12 MHz (fro_12m) */
;;;316                        clkRate = CLK_FRO_12MHZ;
000070  4c25              LDR      r4,|L1.264|
;;;317                        break;
000072  e009              B        |L1.136|
                  |L1.116|
;;;318                    case 0x01: /* CLKIN (clk_in) */
;;;319                        clkRate = CLK_CLK_IN;
000074  2400              MOVS     r4,#0
;;;320                        break;
000076  e007              B        |L1.136|
                  |L1.120|
;;;321                    case 0x02: /* Watchdog oscillator (wdt_clk) */
;;;322                        clkRate = getWdtOscFreq();
000078  f7fffffe          BL       getWdtOscFreq
00007c  4604              MOV      r4,r0
;;;323                        break;
00007e  e003              B        |L1.136|
                  |L1.128|
;;;324                    case 0x03: /* RTC oscillator 32 kHz output (32k_clk) */
;;;325                        clkRate = CLK_RTC_32K_CLK;
000080  f44f4400          MOV      r4,#0x8000
;;;326                        break;
000084  e000              B        |L1.136|
                  |L1.134|
;;;327                    default:
;;;328                        break;
000086  bf00              NOP      
                  |L1.136|
000088  bf00              NOP                            ;317
;;;329                }
;;;330                if ((SYSCON->SYSPLLCTRL & SYSCON_SYSPLLCTRL_BYPASS_MASK) == 0)
00008a  4820              LDR      r0,|L1.268|
00008c  3080              ADDS     r0,r0,#0x80
00008e  6800              LDR      r0,[r0,#0]
000090  f4004000          AND      r0,r0,#0x8000
000094  bb28              CBNZ     r0,|L1.226|
;;;331                {
;;;332                    /* PLL is not in bypass mode, get pre-divider, post-divider, and M divider */
;;;333                    prediv = findPllPreDiv(SYSCON->SYSPLLCTRL, SYSCON->SYSPLLNDEC);
000096  4a1d              LDR      r2,|L1.268|
000098  3288              ADDS     r2,r2,#0x88
00009a  6811              LDR      r1,[r2,#0]
00009c  4a1b              LDR      r2,|L1.268|
00009e  3280              ADDS     r2,r2,#0x80
0000a0  6810              LDR      r0,[r2,#0]
0000a2  f7fffffe          BL       findPllPreDiv
0000a6  4680              MOV      r8,r0
;;;334                    postdiv = findPllPostDiv(SYSCON->SYSPLLCTRL, SYSCON->SYSPLLPDEC);
0000a8  4a18              LDR      r2,|L1.268|
0000aa  328c              ADDS     r2,r2,#0x8c
0000ac  6811              LDR      r1,[r2,#0]
0000ae  4a17              LDR      r2,|L1.268|
0000b0  3280              ADDS     r2,r2,#0x80
0000b2  6810              LDR      r0,[r2,#0]
0000b4  f7fffffe          BL       findPllPostDiv
0000b8  4605              MOV      r5,r0
;;;335                    /* Adjust input clock */
;;;336                    clkRate = clkRate / prediv;
0000ba  fbb4f4f8          UDIV     r4,r4,r8
;;;337    
;;;338                    /* MDEC used for rate */
;;;339                    workRate = (uint64_t)clkRate * (uint64_t)findPllMMult(SYSCON->SYSPLLCTRL, SYSCON->SYSPLLMDEC);
0000be  4a13              LDR      r2,|L1.268|
0000c0  3290              ADDS     r2,r2,#0x90
0000c2  6811              LDR      r1,[r2,#0]
0000c4  4a11              LDR      r2,|L1.268|
0000c6  3280              ADDS     r2,r2,#0x80
0000c8  6810              LDR      r0,[r2,#0]
0000ca  f7fffffe          BL       findPllMMult
0000ce  fba46100          UMULL    r6,r1,r4,r0
0000d2  460f              MOV      r7,r1
;;;340    
;;;341                    clkRate = workRate / ((uint64_t)postdiv);
0000d4  462a              MOV      r2,r5
0000d6  2300              MOVS     r3,#0
0000d8  4630              MOV      r0,r6
0000da  4639              MOV      r1,r7
0000dc  f7fffffe          BL       __aeabi_uldivmod
0000e0  4604              MOV      r4,r0
                  |L1.226|
;;;342                }
;;;343                break;
0000e2  e003              B        |L1.236|
                  |L1.228|
;;;344            case 0x03: /* RTC oscillator 32 kHz output (32k_clk) */
;;;345                clkRate = CLK_RTC_32K_CLK;
0000e4  f44f4400          MOV      r4,#0x8000
;;;346                break;
0000e8  e000              B        |L1.236|
                  |L1.234|
;;;347            default:
;;;348                break;
0000ea  bf00              NOP      
                  |L1.236|
0000ec  bf00              NOP                            ;311
;;;349        }
;;;350        SystemCoreClock = clkRate / ((SYSCON->AHBCLKDIV & 0xFF) + 1);
0000ee  4805              LDR      r0,|L1.260|
0000f0  30fc              ADDS     r0,r0,#0xfc
0000f2  6800              LDR      r0,[r0,#0]
0000f4  b2c0              UXTB     r0,r0
0000f6  1c40              ADDS     r0,r0,#1
0000f8  fbb4f0f0          UDIV     r0,r4,r0
0000fc  4906              LDR      r1,|L1.280|
0000fe  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;351    }
000100  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.260|
                          DCD      0x40000284
                  |L1.264|
                          DCD      0x00b71b00
                  |L1.268|
                          DCD      0x40000500
                  |L1.272|
                          DCD      0x05b8d800
                  |L1.276|
                          DCD      0x02dc6c00
                  |L1.280|
                          DCD      SystemCoreClock

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;264    
;;;265    void SystemInit (void) {
000000  4806              LDR      r0,|L2.28|
;;;266    #if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
;;;267      SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
000002  6800              LDR      r0,[r0,#0]
000004  f4400070          ORR      r0,r0,#0xf00000
000008  4904              LDR      r1,|L2.28|
00000a  6008              STR      r0,[r1,#0]
;;;268    #endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */
;;;269    
;;;270        SCB->VTOR = (uint32_t)&__Vectors;
00000c  4804              LDR      r0,|L2.32|
00000e  4903              LDR      r1,|L2.28|
000010  3980              SUBS     r1,r1,#0x80
000012  6008              STR      r0,[r1,#0]
;;;271    /* Optionally enable RAM banks that may be off by default at reset */
;;;272    #if !defined(DONT_ENABLE_DISABLED_RAMBANKS)
;;;273      SYSCON->AHBCLKCTRLSET[0] = SYSCON_AHBCLKCTRL_SRAM1_MASK | SYSCON_AHBCLKCTRL_SRAM2_MASK | SYSCON_AHBCLKCTRL_SRAM3_MASK;
000014  2038              MOVS     r0,#0x38
000016  4903              LDR      r1,|L2.36|
000018  6008              STR      r0,[r1,#0]
;;;274    #endif
;;;275    }
00001a  4770              BX       lr
;;;276    
                          ENDP

                  |L2.28|
                          DCD      0xe000ed88
                  |L2.32|
                          DCD      __Vectors
                  |L2.36|
                          DCD      0x40000220

                          AREA ||i.findPllMMult||, CODE, READONLY, ALIGN=1

                  findPllMMult PROC
;;;239    /* Get multiplier (M) from PLL MDEC and BYPASS_FBDIV2 settings */
;;;240    static uint32_t findPllMMult(uint32_t ctrlReg, uint32_t mDecReg)
000000  b570              PUSH     {r4-r6,lr}
;;;241    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;242        uint32_t mMult = 1;
000006  2501              MOVS     r5,#1
;;;243    
;;;244        /* Decode MDEC value to get (M) multiplier */
;;;245        mMult = pllDecodeM(mDecReg & 0x1FFFF);
000008  f3c40010          UBFX     r0,r4,#0,#17
00000c  f7fffffe          BL       pllDecodeM
000010  4605              MOV      r5,r0
;;;246        if (mMult == 0)
000012  b905              CBNZ     r5,|L3.22|
;;;247        {
;;;248            mMult = 1;
000014  2501              MOVS     r5,#1
                  |L3.22|
;;;249        }
;;;250        return mMult;
000016  4628              MOV      r0,r5
;;;251    }
000018  bd70              POP      {r4-r6,pc}
;;;252    
                          ENDP


                          AREA ||i.findPllPostDiv||, CODE, READONLY, ALIGN=1

                  findPllPostDiv PROC
;;;220    /* Get postdivider (P) from PLL PDEC setting */
;;;221    static uint32_t findPllPostDiv(uint32_t ctrlReg, uint32_t pDecReg)
000000  b570              PUSH     {r4-r6,lr}
;;;222    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;223        uint32_t postDiv = 1;
000006  2601              MOVS     r6,#1
;;;224    
;;;225        /* Direct input is not used? */
;;;226        if ((ctrlReg & SYSCON_SYSPLLCTRL_DIRECTO_MASK) == 0)
000008  f4041080          AND      r0,r4,#0x100000
00000c  b930              CBNZ     r0,|L4.28|
;;;227        {
;;;228            /* Decode PDEC value to get (P) post divider */
;;;229            postDiv = 2 * pllDecodeP(pDecReg & 0x7F);
00000e  f005007f          AND      r0,r5,#0x7f
000012  f7fffffe          BL       pllDecodeP
000016  0046              LSLS     r6,r0,#1
;;;230            if (postDiv == 0)
000018  b906              CBNZ     r6,|L4.28|
;;;231            {
;;;232                postDiv = 2;
00001a  2602              MOVS     r6,#2
                  |L4.28|
;;;233            }
;;;234        }
;;;235        /* Adjusted by 1, directo is used to bypass */
;;;236        return postDiv;
00001c  4630              MOV      r0,r6
;;;237    }
00001e  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP


                          AREA ||i.findPllPreDiv||, CODE, READONLY, ALIGN=1

                  findPllPreDiv PROC
;;;201    /* Get predivider (N) from PLL NDEC setting */
;;;202    static uint32_t findPllPreDiv(uint32_t ctrlReg, uint32_t nDecReg)
000000  b570              PUSH     {r4-r6,lr}
;;;203    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;204        uint32_t preDiv = 1;
000006  2601              MOVS     r6,#1
;;;205    
;;;206        /* Direct input is not used? */
;;;207        if ((ctrlReg & SYSCON_SYSPLLCTRL_DIRECTI_MASK) == 0)
000008  f4042000          AND      r0,r4,#0x80000
00000c  b930              CBNZ     r0,|L5.28|
;;;208        {
;;;209            /* Decode NDEC value to get (N) pre divider */
;;;210            preDiv = pllDecodeN(nDecReg & 0x3FF);
00000e  f3c50009          UBFX     r0,r5,#0,#10
000012  f7fffffe          BL       pllDecodeN
000016  4606              MOV      r6,r0
;;;211            if (preDiv == 0)
000018  b906              CBNZ     r6,|L5.28|
;;;212            {
;;;213                preDiv = 1;
00001a  2601              MOVS     r6,#1
                  |L5.28|
;;;214            }
;;;215        }
;;;216        /* Adjusted by 1, directi is used to bypass */
;;;217        return preDiv;
00001c  4630              MOV      r0,r6
;;;218    }
00001e  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP


                          AREA ||i.getWdtOscFreq||, CODE, READONLY, ALIGN=2

                  getWdtOscFreq PROC
;;;85     /* Get WATCH DOG Clk */
;;;86     static uint32_t getWdtOscFreq(void)
000000  480c              LDR      r0,|L6.52|
;;;87     {
;;;88         uint8_t freq_sel, div_sel;
;;;89         if (SYSCON->PDRUNCFG[0] & SYSCON_PDRUNCFG_PDEN_WDT_OSC_MASK)
000002  6800              LDR      r0,[r0,#0]
000004  f4001080          AND      r0,r0,#0x100000
000008  b108              CBZ      r0,|L6.14|
;;;90         {
;;;91             return 0U;
00000a  2000              MOVS     r0,#0
                  |L6.12|
;;;92         }
;;;93         else
;;;94         {
;;;95             div_sel = ((SYSCON->WDTOSCCTRL & 0x1f) + 1) << 1;
;;;96             freq_sel = wdtFreqLookup[((SYSCON->WDTOSCCTRL & SYSCON_WDTOSCCTRL_FREQSEL_MASK) >> SYSCON_WDTOSCCTRL_FREQSEL_SHIFT)];
;;;97             return ((uint32_t) freq_sel * 50000U)/((uint32_t)div_sel);
;;;98         }
;;;99     }
00000c  4770              BX       lr
                  |L6.14|
00000e  480a              LDR      r0,|L6.56|
000010  6800              LDR      r0,[r0,#0]            ;95
000012  f000001f          AND      r0,r0,#0x1f           ;95
000016  1c40              ADDS     r0,r0,#1              ;95
000018  0041              LSLS     r1,r0,#1              ;95
00001a  4807              LDR      r0,|L6.56|
00001c  6800              LDR      r0,[r0,#0]            ;96
00001e  f3c01044          UBFX     r0,r0,#5,#5           ;96
000022  4b06              LDR      r3,|L6.60|
000024  5c1a              LDRB     r2,[r3,r0]            ;96
000026  f24c3050          MOV      r0,#0xc350            ;97
00002a  4350              MULS     r0,r2,r0              ;97
00002c  fbb0f0f1          UDIV     r0,r0,r1              ;97
000030  e7ec              B        |L6.12|
;;;100    /* Find decoded N value for raw NDEC value */
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40000610
                  |L6.56|
                          DCD      0x40000508
                  |L6.60|
                          DCD      wdtFreqLookup

                          AREA ||i.pllDecodeM||, CODE, READONLY, ALIGN=2

                  pllDecodeM PROC
;;;167    /* Find decoded M value for raw MDEC value */
;;;168    static uint32_t pllDecodeM(uint32_t MDEC)
000000  b530              PUSH     {r4,r5,lr}
;;;169    {
000002  4603              MOV      r3,r0
;;;170        uint32_t m, i, x;
;;;171    
;;;172        /* Find MDec */
;;;173        switch (MDEC)
000004  f5a33480          SUB      r4,r3,#0x10000
000008  1ee4              SUBS     r4,r4,#3
00000a  b14c              CBZ      r4,|L7.32|
00000c  f5b44f00          CMP      r4,#0x8000
000010  d004              BEQ      |L7.28|
000012  4d11              LDR      r5,|L7.88|
000014  442c              ADD      r4,r4,r5
000016  b92c              CBNZ     r4,|L7.36|
;;;174        {
;;;175            case 0xFFFFF:
;;;176                m = 0;
000018  2000              MOVS     r0,#0
;;;177                break;
00001a  e01b              B        |L7.84|
                  |L7.28|
;;;178            case 0x18003:
;;;179                m = 1;
00001c  2001              MOVS     r0,#1
;;;180                break;
00001e  e019              B        |L7.84|
                  |L7.32|
;;;181            case 0x10003:
;;;182                m = 2;
000020  2002              MOVS     r0,#2
;;;183                break;
000022  e017              B        |L7.84|
                  |L7.36|
;;;184            default:
;;;185                x = 0x04000;
000024  f44f4180          MOV      r1,#0x4000
;;;186                m = 0xFFFFFFFFU;
000028  f04f30ff          MOV      r0,#0xffffffff
;;;187                for (i = MVALMAX; ((i >= 3) && (m == 0xFFFFFFFFU)); i--)
00002c  004a              LSLS     r2,r1,#1
00002e  e00b              B        |L7.72|
                  |L7.48|
;;;188                {
;;;189                    x = (((x ^ (x >> 1)) & 1) << 14) | ((x >> 1) & 0x3FFFU);
000030  ea810451          EOR      r4,r1,r1,LSR #1
000034  f0040401          AND      r4,r4,#1
000038  f3c1054d          UBFX     r5,r1,#1,#14
00003c  ea453184          ORR      r1,r5,r4,LSL #14
;;;190                    if ((x & (PLL_SSCG0_MDEC_VAL_M >> PLL_SSCG0_MDEC_VAL_P)) == MDEC)
000040  4299              CMP      r1,r3
000042  d100              BNE      |L7.70|
;;;191                    {
;;;192                        /* Decoded value of MDEC */
;;;193                        m = i;
000044  4610              MOV      r0,r2
                  |L7.70|
000046  1e52              SUBS     r2,r2,#1              ;187
                  |L7.72|
000048  2a03              CMP      r2,#3                 ;187
00004a  d302              BCC      |L7.82|
00004c  1c44              ADDS     r4,r0,#1              ;187
00004e  2c00              CMP      r4,#0                 ;187
000050  d0ee              BEQ      |L7.48|
                  |L7.82|
;;;194                    }
;;;195                }
;;;196                break;
000052  bf00              NOP      
                  |L7.84|
000054  bf00              NOP                            ;177
;;;197        }
;;;198        return m;
;;;199    }
000056  bd30              POP      {r4,r5,pc}
;;;200    
                          ENDP

                  |L7.88|
                          DCD      0xfff10004

                          AREA ||i.pllDecodeN||, CODE, READONLY, ALIGN=1

                  pllDecodeN PROC
;;;100    /* Find decoded N value for raw NDEC value */
;;;101    static uint32_t pllDecodeN(uint32_t NDEC)
000000  b530              PUSH     {r4,r5,lr}
;;;102    {
000002  4603              MOV      r3,r0
;;;103        uint32_t n, x, i;
;;;104    
;;;105        /* Find NDec */
;;;106        switch (NDEC)
000004  f2a32402          SUB      r4,r3,#0x202
000008  b14c              CBZ      r4,|L8.30|
00000a  f5b47f80          CMP      r4,#0x100
00000e  d004              BEQ      |L8.26|
000010  f6a454fd          SUB      r4,r4,#0xdfd
000014  b92c              CBNZ     r4,|L8.34|
;;;107        {
;;;108            case 0xFFF:
;;;109                n = 0;
000016  2000              MOVS     r0,#0
;;;110                break;
000018  e01e              B        |L8.88|
                  |L8.26|
;;;111            case 0x302:
;;;112                n = 1;
00001a  2001              MOVS     r0,#1
;;;113                break;
00001c  e01c              B        |L8.88|
                  |L8.30|
;;;114            case 0x202:
;;;115                n = 2;
00001e  2002              MOVS     r0,#2
;;;116                break;
000020  e01a              B        |L8.88|
                  |L8.34|
;;;117            default:
;;;118                x = 0x080;
000022  2180              MOVS     r1,#0x80
;;;119                n = 0xFFFFFFFFU;
000024  f04f30ff          MOV      r0,#0xffffffff
;;;120                for (i = NVALMAX; ((i >= 3) && (n == 0xFFFFFFFFU)); i--)
000028  004a              LSLS     r2,r1,#1
00002a  e00f              B        |L8.76|
                  |L8.44|
;;;121                {
;;;122                    x = (((x ^ (x >> 2) ^ (x >> 3) ^ (x >> 4)) & 1) << 7) | ((x >> 1) & 0x7F);
00002c  ea810491          EOR      r4,r1,r1,LSR #2
000030  ea8404d1          EOR      r4,r4,r1,LSR #3
000034  ea841411          EOR      r4,r4,r1,LSR #4
000038  f0040401          AND      r4,r4,#1
00003c  f3c10546          UBFX     r5,r1,#1,#7
000040  ea4511c4          ORR      r1,r5,r4,LSL #7
;;;123                    if ((x & (PLL_NDEC_VAL_M >> PLL_NDEC_VAL_P)) == NDEC)
000044  4299              CMP      r1,r3
000046  d100              BNE      |L8.74|
;;;124                    {
;;;125                        /* Decoded value of NDEC */
;;;126                        n = i;
000048  4610              MOV      r0,r2
                  |L8.74|
00004a  1e52              SUBS     r2,r2,#1              ;120
                  |L8.76|
00004c  2a03              CMP      r2,#3                 ;120
00004e  d302              BCC      |L8.86|
000050  1c44              ADDS     r4,r0,#1              ;120
000052  2c00              CMP      r4,#0                 ;120
000054  d0ea              BEQ      |L8.44|
                  |L8.86|
;;;127                    }
;;;128                }
;;;129                break;
000056  bf00              NOP      
                  |L8.88|
000058  bf00              NOP                            ;110
;;;130        }
;;;131        return n;
;;;132    }
00005a  bd30              POP      {r4,r5,pc}
;;;133    
                          ENDP


                          AREA ||i.pllDecodeP||, CODE, READONLY, ALIGN=1

                  pllDecodeP PROC
;;;134    /* Find decoded P value for raw PDEC value */
;;;135    static uint32_t pllDecodeP(uint32_t PDEC)
000000  b530              PUSH     {r4,r5,lr}
;;;136    {
000002  4603              MOV      r3,r0
;;;137        uint32_t p, x, i;
;;;138        /* Find PDec */
;;;139        switch (PDEC)
000004  2b42              CMP      r3,#0x42
000006  d007              BEQ      |L9.24|
000008  2b62              CMP      r3,#0x62
00000a  d003              BEQ      |L9.20|
00000c  2bff              CMP      r3,#0xff
00000e  d105              BNE      |L9.28|
;;;140        {
;;;141            case 0xFF:
;;;142                p = 0;
000010  2000              MOVS     r0,#0
;;;143                break;
000012  e01a              B        |L9.74|
                  |L9.20|
;;;144            case 0x62:
;;;145                p = 1;
000014  2001              MOVS     r0,#1
;;;146                break;
000016  e018              B        |L9.74|
                  |L9.24|
;;;147            case 0x42:
;;;148                p = 2;
000018  2002              MOVS     r0,#2
;;;149                break;
00001a  e016              B        |L9.74|
                  |L9.28|
;;;150            default:
;;;151                x = 0x10;
00001c  2110              MOVS     r1,#0x10
;;;152                p = 0xFFFFFFFFU;
00001e  f04f30ff          MOV      r0,#0xffffffff
;;;153                for (i = PVALMAX; ((i >= 3) && (p == 0xFFFFFFFFU)); i--)
000022  2220              MOVS     r2,#0x20
000024  e00b              B        |L9.62|
                  |L9.38|
;;;154                {
;;;155                    x = (((x ^ (x >> 2)) & 1) << 4) | ((x >> 1) & 0xFU);
000026  ea810491          EOR      r4,r1,r1,LSR #2
00002a  f0040401          AND      r4,r4,#1
00002e  f3c10543          UBFX     r5,r1,#1,#4
000032  ea451104          ORR      r1,r5,r4,LSL #4
;;;156                    if ((x & (PLL_PDEC_VAL_M >> PLL_PDEC_VAL_P)) == PDEC)
000036  4299              CMP      r1,r3
000038  d100              BNE      |L9.60|
;;;157                    {
;;;158                        /* Decoded value of PDEC */
;;;159                        p = i;
00003a  4610              MOV      r0,r2
                  |L9.60|
00003c  1e52              SUBS     r2,r2,#1              ;153
                  |L9.62|
00003e  2a03              CMP      r2,#3                 ;153
000040  d302              BCC      |L9.72|
000042  1c44              ADDS     r4,r0,#1              ;153
000044  2c00              CMP      r4,#0                 ;153
000046  d0ee              BEQ      |L9.38|
                  |L9.72|
;;;160                    }
;;;161                }
;;;162                break;
000048  bf00              NOP      
                  |L9.74|
00004a  bf00              NOP                            ;143
;;;163        }
;;;164        return p;
;;;165    }
00004c  bd30              POP      {r4,r5,pc}
;;;166    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  wdtFreqLookup
000000  00080c0f          DCB      0x00,0x08,0x0c,0x0f
000004  1214181a          DCB      0x12,0x14,0x18,0x1a
000008  1c1e2022          DCB      0x1c,0x1e,0x20,0x22
00000c  24262829          DCB      0x24,0x26,0x28,0x29
000010  2a2c2d2e          DCB      0x2a,0x2c,0x2d,0x2e
000014  30313234          DCB      0x30,0x31,0x32,0x34
000018  35363839          DCB      0x35,0x36,0x38,0x39
00001c  3a3b3c3d          DCB      0x3a,0x3b,0x3c,0x3d

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "SRC\\System\\system_LPC54608.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_system_LPC54608_c_5d646a67____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___17_system_LPC54608_c_5d646a67____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_system_LPC54608_c_5d646a67____REVSH|
#line 402
|__asm___17_system_LPC54608_c_5d646a67____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_system_LPC54608_c_5d646a67____RRX|
#line 587
|__asm___17_system_LPC54608_c_5d646a67____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
