; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_sctimer.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_sctimer.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_sctimer.crf SRC\Drivers\fsl_sctimer.c]
                          THUMB

                          AREA ||i.SCT0_IRQHandler||, CODE, READONLY, ALIGN=2

                  SCT0_IRQHandler PROC
;;;531    
;;;532    void SCT0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;533    {
;;;534        s_sctimerIsr(SCT0);
000002  4802              LDR      r0,|L1.12|
000004  4902              LDR      r1,|L1.16|
000006  6809              LDR      r1,[r1,#0]  ; s_sctimerIsr
000008  4788              BLX      r1
;;;535    }
00000a  bd10              POP      {r4,pc}
                          ENDP

                  |L1.12|
                          DCD      0x40085000
                  |L1.16|
                          DCD      s_sctimerIsr

                          AREA ||i.SCTIMER_CreateAndScheduleEvent||, CODE, READONLY, ALIGN=2

                  SCTIMER_CreateAndScheduleEvent PROC
;;;336    
;;;337    status_t SCTIMER_CreateAndScheduleEvent(SCT_Type *base,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;338                                            sctimer_event_t howToMonitor,
;;;339                                            uint32_t matchValue,
;;;340                                            uint32_t whichIO,
;;;341                                            sctimer_counter_t whichCounter,
;;;342                                            uint32_t *event)
;;;343    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  e9dd5c07          LDRD     r5,r12,[sp,#0x1c]
;;;344        uint32_t combMode = (((uint32_t)howToMonitor & SCT_EVENT_CTRL_COMBMODE_MASK) >> SCT_EVENT_CTRL_COMBMODE_SHIFT);
00000c  f3c63701          UBFX     r7,r6,#12,#2
;;;345        uint32_t currentCtrlVal = howToMonitor;
000010  4631              MOV      r1,r6
;;;346    
;;;347        /* Return an error if we have hit the limit in terms of number of events created */
;;;348        if (s_currentEvent >= FSL_FEATURE_SCT_NUMBER_OF_EVENTS)
000012  486d              LDR      r0,|L2.456|
000014  6800              LDR      r0,[r0,#0]  ; s_currentEvent
000016  280a              CMP      r0,#0xa
000018  d302              BCC      |L2.32|
;;;349        {
;;;350            return kStatus_Fail;
00001a  2001              MOVS     r0,#1
                  |L2.28|
;;;351        }
;;;352    
;;;353        /* IO only mode */
;;;354        if (combMode == 0x2U)
;;;355        {
;;;356            base->EVENT[s_currentEvent].CTRL = currentCtrlVal | SCT_EVENT_CTRL_IOSEL(whichIO);
;;;357        }
;;;358        /* Match mode only */
;;;359        else if (combMode == 0x1U)
;;;360        {
;;;361            /* Return an error if we have hit the limit in terms of number of number of match registers */
;;;362            if (s_currentMatch >= FSL_FEATURE_SCT_NUMBER_OF_MATCH_CAPTURE)
;;;363            {
;;;364                return kStatus_Fail;
;;;365            }
;;;366    
;;;367            currentCtrlVal |= SCT_EVENT_CTRL_MATCHSEL(s_currentMatch);
;;;368            /* Use Counter_L bits if counter is operating in 32-bit mode or user wants to setup the L counter */
;;;369            if ((base->CONFIG & SCT_CONFIG_UNIFY_MASK) || (whichCounter == kSCTIMER_Counter_L))
;;;370            {
;;;371                base->SCTMATCH[s_currentMatch] = SCT_SCTMATCH_MATCHn_L(matchValue);
;;;372                base->SCTMATCHREL[s_currentMatch] = SCT_SCTMATCHREL_RELOADn_L(matchValue);
;;;373            }
;;;374            else
;;;375            {
;;;376                /* Select the counter, no need for this if operating in 32-bit mode */
;;;377                currentCtrlVal |= SCT_EVENT_CTRL_HEVENT(whichCounter);
;;;378                base->SCTMATCH[s_currentMatch] = SCT_SCTMATCH_MATCHn_H(matchValue);
;;;379                base->SCTMATCHREL[s_currentMatch] = SCT_SCTMATCHREL_RELOADn_H(matchValue);
;;;380            }
;;;381            base->EVENT[s_currentEvent].CTRL = currentCtrlVal;
;;;382            /* Increment the match register number */
;;;383            s_currentMatch++;
;;;384        }
;;;385        /* Use both Match & IO */
;;;386        else
;;;387        {
;;;388            /* Return an error if we have hit the limit in terms of number of number of match registers */
;;;389            if (s_currentMatch >= FSL_FEATURE_SCT_NUMBER_OF_MATCH_CAPTURE)
;;;390            {
;;;391                return kStatus_Fail;
;;;392            }
;;;393    
;;;394            currentCtrlVal |= SCT_EVENT_CTRL_MATCHSEL(s_currentMatch) | SCT_EVENT_CTRL_IOSEL(whichIO);
;;;395            /* Use Counter_L bits if counter is operating in 32-bit mode or user wants to setup the L counter */
;;;396            if ((base->CONFIG & SCT_CONFIG_UNIFY_MASK) || (whichCounter == kSCTIMER_Counter_L))
;;;397            {
;;;398                base->SCTMATCH[s_currentMatch] = SCT_SCTMATCH_MATCHn_L(matchValue);
;;;399                base->SCTMATCHREL[s_currentMatch] = SCT_SCTMATCHREL_RELOADn_L(matchValue);
;;;400            }
;;;401            else
;;;402            {
;;;403                /* Select the counter, no need for this if operating in 32-bit mode */
;;;404                currentCtrlVal |= SCT_EVENT_CTRL_HEVENT(whichCounter);
;;;405                base->SCTMATCH[s_currentMatch] = SCT_SCTMATCH_MATCHn_H(matchValue);
;;;406                base->SCTMATCHREL[s_currentMatch] = SCT_SCTMATCHREL_RELOADn_H(matchValue);
;;;407            }
;;;408            base->EVENT[s_currentEvent].CTRL = currentCtrlVal;
;;;409            /* Increment the match register number */
;;;410            s_currentMatch++;
;;;411        }
;;;412    
;;;413        /* Enable the event in the current state */
;;;414        base->EVENT[s_currentEvent].STATE = (1U << s_currentState);
;;;415    
;;;416        /* Return the event number */
;;;417        *event = s_currentEvent;
;;;418    
;;;419        /* Increment the event number */
;;;420        s_currentEvent++;
;;;421    
;;;422        return kStatus_Success;
;;;423    }
00001c  e8bd83f0          POP      {r4-r9,pc}
                  |L2.32|
000020  2f02              CMP      r7,#2                 ;354
000022  d10f              BNE      |L2.68|
000024  f44f7070          MOV      r0,#0x3c0             ;356
000028  ea001083          AND      r0,r0,r3,LSL #6       ;356
00002c  4308              ORRS     r0,r0,r1              ;356
00002e  f5047840          ADD      r8,r4,#0x300          ;356
000032  f8df9194          LDR      r9,|L2.456|
000036  f8d99000          LDR      r9,[r9,#0]            ;356  ; s_currentEvent
00003a  eb0808c9          ADD      r8,r8,r9,LSL #3       ;356
00003e  f8c80004          STR      r0,[r8,#4]            ;356
000042  e0a6              B        |L2.402|
                  |L2.68|
000044  2f01              CMP      r7,#1                 ;359
000046  d14f              BNE      |L2.232|
000048  4860              LDR      r0,|L2.460|
00004a  6800              LDR      r0,[r0,#0]            ;362  ; s_currentMatch
00004c  280a              CMP      r0,#0xa               ;362
00004e  d301              BCC      |L2.84|
000050  2001              MOVS     r0,#1                 ;364
000052  e7e3              B        |L2.28|
                  |L2.84|
000054  485d              LDR      r0,|L2.460|
000056  7800              LDRB     r0,[r0,#0]            ;367  ; s_currentMatch
000058  f000000f          AND      r0,r0,#0xf            ;367
00005c  4301              ORRS     r1,r1,r0              ;367
00005e  6820              LDR      r0,[r4,#0]            ;369
000060  f0000001          AND      r0,r0,#1              ;369
000064  b900              CBNZ     r0,|L2.104|
000066  b9a5              CBNZ     r5,|L2.146|
                  |L2.104|
000068  fa1ff882          UXTH     r8,r2                 ;371
00006c  f5047080          ADD      r0,r4,#0x100          ;371
000070  f8df9158          LDR      r9,|L2.460|
000074  f8d99000          LDR      r9,[r9,#0]            ;371  ; s_currentMatch
000078  f8408029          STR      r8,[r0,r9,LSL #2]     ;371
00007c  fa1ff882          UXTH     r8,r2                 ;372
000080  f5047000          ADD      r0,r4,#0x200          ;372
000084  f8df9144          LDR      r9,|L2.460|
000088  f8d99000          LDR      r9,[r9,#0]            ;372  ; s_currentMatch
00008c  f8408029          STR      r8,[r0,r9,LSL #2]     ;372
000090  e019              B        |L2.198|
                  |L2.146|
000092  2010              MOVS     r0,#0x10              ;377
000094  ea001005          AND      r0,r0,r5,LSL #4       ;377
000098  4301              ORRS     r1,r1,r0              ;377
00009a  484d              LDR      r0,|L2.464|
00009c  ea004802          AND      r8,r0,r2,LSL #16      ;378
0000a0  f5047080          ADD      r0,r4,#0x100          ;378
0000a4  f8df9124          LDR      r9,|L2.460|
0000a8  f8d99000          LDR      r9,[r9,#0]            ;378  ; s_currentMatch
0000ac  f8408029          STR      r8,[r0,r9,LSL #2]     ;378
0000b0  4847              LDR      r0,|L2.464|
0000b2  ea004802          AND      r8,r0,r2,LSL #16      ;379
0000b6  f5047000          ADD      r0,r4,#0x200          ;379
0000ba  f8df9110          LDR      r9,|L2.460|
0000be  f8d99000          LDR      r9,[r9,#0]            ;379  ; s_currentMatch
0000c2  f8408029          STR      r8,[r0,r9,LSL #2]     ;379
                  |L2.198|
0000c6  f5047040          ADD      r0,r4,#0x300          ;381
0000ca  f8df80fc          LDR      r8,|L2.456|
0000ce  f8d88000          LDR      r8,[r8,#0]            ;381  ; s_currentEvent
0000d2  eb0000c8          ADD      r0,r0,r8,LSL #3       ;381
0000d6  6041              STR      r1,[r0,#4]            ;381
0000d8  483c              LDR      r0,|L2.460|
0000da  6800              LDR      r0,[r0,#0]            ;383  ; s_currentMatch
0000dc  1c40              ADDS     r0,r0,#1              ;383
0000de  f8df80ec          LDR      r8,|L2.460|
0000e2  f8c80000          STR      r0,[r8,#0]            ;383  ; s_currentMatch
0000e6  e054              B        |L2.402|
                  |L2.232|
0000e8  4838              LDR      r0,|L2.460|
0000ea  6800              LDR      r0,[r0,#0]            ;389  ; s_currentMatch
0000ec  280a              CMP      r0,#0xa               ;389
0000ee  d301              BCC      |L2.244|
0000f0  2001              MOVS     r0,#1                 ;391
0000f2  e793              B        |L2.28|
                  |L2.244|
0000f4  4835              LDR      r0,|L2.460|
0000f6  7800              LDRB     r0,[r0,#0]            ;394  ; s_currentMatch
0000f8  f000000f          AND      r0,r0,#0xf            ;394
0000fc  f44f7870          MOV      r8,#0x3c0             ;394
000100  ea081883          AND      r8,r8,r3,LSL #6       ;394
000104  ea400008          ORR      r0,r0,r8              ;394
000108  4301              ORRS     r1,r1,r0              ;394
00010a  6820              LDR      r0,[r4,#0]            ;396
00010c  f0000001          AND      r0,r0,#1              ;396
000110  b900              CBNZ     r0,|L2.276|
000112  b9a5              CBNZ     r5,|L2.318|
                  |L2.276|
000114  fa1ff882          UXTH     r8,r2                 ;398
000118  f5047080          ADD      r0,r4,#0x100          ;398
00011c  f8df90ac          LDR      r9,|L2.460|
000120  f8d99000          LDR      r9,[r9,#0]            ;398  ; s_currentMatch
000124  f8408029          STR      r8,[r0,r9,LSL #2]     ;398
000128  fa1ff882          UXTH     r8,r2                 ;399
00012c  f5047000          ADD      r0,r4,#0x200          ;399
000130  f8df9098          LDR      r9,|L2.460|
000134  f8d99000          LDR      r9,[r9,#0]            ;399  ; s_currentMatch
000138  f8408029          STR      r8,[r0,r9,LSL #2]     ;399
00013c  e019              B        |L2.370|
                  |L2.318|
00013e  2010              MOVS     r0,#0x10              ;404
000140  ea001005          AND      r0,r0,r5,LSL #4       ;404
000144  4301              ORRS     r1,r1,r0              ;404
000146  4822              LDR      r0,|L2.464|
000148  ea004802          AND      r8,r0,r2,LSL #16      ;405
00014c  f5047080          ADD      r0,r4,#0x100          ;405
000150  f8df9078          LDR      r9,|L2.460|
000154  f8d99000          LDR      r9,[r9,#0]            ;405  ; s_currentMatch
000158  f8408029          STR      r8,[r0,r9,LSL #2]     ;405
00015c  481c              LDR      r0,|L2.464|
00015e  ea004802          AND      r8,r0,r2,LSL #16      ;406
000162  f5047000          ADD      r0,r4,#0x200          ;406
000166  f8df9064          LDR      r9,|L2.460|
00016a  f8d99000          LDR      r9,[r9,#0]            ;406  ; s_currentMatch
00016e  f8408029          STR      r8,[r0,r9,LSL #2]     ;406
                  |L2.370|
000172  f5047040          ADD      r0,r4,#0x300          ;408
000176  f8df8050          LDR      r8,|L2.456|
00017a  f8d88000          LDR      r8,[r8,#0]            ;408  ; s_currentEvent
00017e  eb0000c8          ADD      r0,r0,r8,LSL #3       ;408
000182  6041              STR      r1,[r0,#4]            ;408
000184  4811              LDR      r0,|L2.460|
000186  6800              LDR      r0,[r0,#0]            ;410  ; s_currentMatch
000188  1c40              ADDS     r0,r0,#1              ;410
00018a  f8df8040          LDR      r8,|L2.460|
00018e  f8c80000          STR      r0,[r8,#0]            ;410  ; s_currentMatch
                  |L2.402|
000192  4810              LDR      r0,|L2.468|
000194  f8908000          LDRB     r8,[r0,#0]            ;414  ; s_currentState
000198  2001              MOVS     r0,#1                 ;414
00019a  fa00f008          LSL      r0,r0,r8              ;414
00019e  f5047840          ADD      r8,r4,#0x300          ;414
0001a2  f8df9024          LDR      r9,|L2.456|
0001a6  f8d99000          LDR      r9,[r9,#0]            ;414  ; s_currentEvent
0001aa  f8480039          STR      r0,[r8,r9,LSL #3]     ;414
0001ae  4806              LDR      r0,|L2.456|
0001b0  6800              LDR      r0,[r0,#0]            ;417  ; s_currentEvent
0001b2  f8cc0000          STR      r0,[r12,#0]           ;417
0001b6  4804              LDR      r0,|L2.456|
0001b8  6800              LDR      r0,[r0,#0]            ;420  ; s_currentEvent
0001ba  1c40              ADDS     r0,r0,#1              ;420
0001bc  f8df8008          LDR      r8,|L2.456|
0001c0  f8c80000          STR      r0,[r8,#0]            ;420  ; s_currentEvent
0001c4  2000              MOVS     r0,#0                 ;422
0001c6  e729              B        |L2.28|
;;;424    
                          ENDP

                  |L2.456|
                          DCD      s_currentEvent
                  |L2.460|
                          DCD      s_currentMatch
                  |L2.464|
                          DCD      0xffff0000
                  |L2.468|
                          DCD      s_currentState

                          AREA ||i.SCTIMER_Deinit||, CODE, READONLY, ALIGN=2

                  SCTIMER_Deinit PROC
;;;148    
;;;149    void SCTIMER_Deinit(SCT_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4605              MOV      r5,r0
;;;151        /* Halt the counters */
;;;152        base->CTRL |= (SCT_CTRL_HALT_L_MASK | SCT_CTRL_HALT_H_MASK);
000004  6868              LDR      r0,[r5,#4]
000006  f0401004          ORR      r0,r0,#0x40004
00000a  6068              STR      r0,[r5,#4]
;;;153    
;;;154    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;155        /* Disable the SCTimer clock*/
;;;156        CLOCK_DisableClock(s_sctClocks[SCTIMER_GetInstance(base)]);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       SCTIMER_GetInstance
000012  490a              LDR      r1,|L3.60|
000014  f8314010          LDRH     r4,[r1,r0,LSL #1]
000018  0a20              LSRS     r0,r4,#8
00001a  2803              CMP      r0,#3
00001c  d205              BCS      |L3.42|
00001e  2101              MOVS     r1,#1
000020  40a1              LSLS     r1,r1,r4
000022  4a07              LDR      r2,|L3.64|
000024  f8421020          STR      r1,[r2,r0,LSL #2]
000028  e006              B        |L3.56|
                  |L3.42|
00002a  2101              MOVS     r1,#1
00002c  40a1              LSLS     r1,r1,r4
00002e  4a05              LDR      r2,|L3.68|
000030  6191              STR      r1,[r2,#0x18]
000032  2100              MOVS     r1,#0
000034  0312              LSLS     r2,r2,#12
000036  64d1              STR      r1,[r2,#0x4c]
                  |L3.56|
000038  bf00              NOP      
;;;157    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;158    }
00003a  bd70              POP      {r4-r6,pc}
;;;159    
                          ENDP

                  |L3.60|
                          DCD      s_sctClocks
                  |L3.64|
                          DCD      0x40000240
                  |L3.68|
                          DCD      0x40040000

                          AREA ||i.SCTIMER_EventHandleIRQ||, CODE, READONLY, ALIGN=2

                  SCTIMER_EventHandleIRQ PROC
;;;506    
;;;507    void SCTIMER_EventHandleIRQ(SCT_Type *base)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;508    {
000004  4680              MOV      r8,r0
;;;509        uint32_t eventFlag = SCT0->EVFLAG;
000006  4810              LDR      r0,|L4.72|
000008  6806              LDR      r6,[r0,#0]
;;;510        /* Only clear the flags whose interrupt field is enabled */
;;;511        uint32_t clearFlag = (eventFlag & SCT0->EVEN);
00000a  480f              LDR      r0,|L4.72|
00000c  38f4              SUBS     r0,r0,#0xf4
00000e  f8d000f0          LDR      r0,[r0,#0xf0]
000012  ea000706          AND      r7,r0,r6
;;;512        uint32_t mask = eventFlag;
000016  4635              MOV      r5,r6
;;;513        int i = 0;
000018  2400              MOVS     r4,#0
;;;514    
;;;515        /* Invoke the callback for certain events */
;;;516        for (i = 0; (i < FSL_FEATURE_SCT_NUMBER_OF_EVENTS) && (mask != 0); i++)
00001a  bf00              NOP      
00001c  e00c              B        |L4.56|
                  |L4.30|
;;;517        {
;;;518            if (mask & 0x1)
00001e  f0050001          AND      r0,r5,#1
000022  b138              CBZ      r0,|L4.52|
;;;519            {
;;;520                if (s_eventCallback[i] != NULL)
000024  4809              LDR      r0,|L4.76|
000026  f8500024          LDR      r0,[r0,r4,LSL #2]
00002a  b118              CBZ      r0,|L4.52|
;;;521                {
;;;522                    s_eventCallback[i]();
00002c  4907              LDR      r1,|L4.76|
00002e  f8510024          LDR      r0,[r1,r4,LSL #2]
000032  4780              BLX      r0
                  |L4.52|
;;;523                }
;;;524            }
;;;525            mask >>= 1;
000034  086d              LSRS     r5,r5,#1
000036  1c64              ADDS     r4,r4,#1              ;516
                  |L4.56|
000038  2c0a              CMP      r4,#0xa               ;516
00003a  da01              BGE      |L4.64|
00003c  2d00              CMP      r5,#0                 ;516
00003e  d1ee              BNE      |L4.30|
                  |L4.64|
;;;526        }
;;;527    
;;;528        /* Clear event interrupt flag */
;;;529        SCT0->EVFLAG = clearFlag;
000040  4801              LDR      r0,|L4.72|
000042  6007              STR      r7,[r0,#0]
;;;530    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;531    
                          ENDP

                  |L4.72|
                          DCD      0x400850f4
                  |L4.76|
                          DCD      s_eventCallback

                          AREA ||i.SCTIMER_GetCurrentState||, CODE, READONLY, ALIGN=2

                  SCTIMER_GetCurrentState PROC
;;;443    
;;;444    uint32_t SCTIMER_GetCurrentState(SCT_Type *base)
000000  4601              MOV      r1,r0
;;;445    {
;;;446        return s_currentState;
000002  4801              LDR      r0,|L5.8|
000004  6800              LDR      r0,[r0,#0]  ; s_currentState
;;;447    }
000006  4770              BX       lr
;;;448    
                          ENDP

                  |L5.8|
                          DCD      s_currentState

                          AREA ||i.SCTIMER_GetDefaultConfig||, CODE, READONLY, ALIGN=2

                  SCTIMER_GetDefaultConfig PROC
;;;159    
;;;160    void SCTIMER_GetDefaultConfig(sctimer_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;161    {
000002  4604              MOV      r4,r0
;;;162        assert(config);
000004  b104              CBZ      r4,|L6.8|
000006  e004              B        |L6.18|
                  |L6.8|
000008  22a2              MOVS     r2,#0xa2
00000a  a107              ADR      r1,|L6.40|
00000c  a00d              ADR      r0,|L6.68|
00000e  f7fffffe          BL       __aeabi_assert
                  |L6.18|
;;;163    
;;;164        /* SCT operates as a unified 32-bit counter */
;;;165        config->enableCounterUnify = true;
000012  2001              MOVS     r0,#1
000014  7020              STRB     r0,[r4,#0]
;;;166        /* System clock clocks the entire SCT module */
;;;167        config->clockMode = kSCTIMER_System_ClockMode;
000016  2000              MOVS     r0,#0
000018  7060              STRB     r0,[r4,#1]
;;;168        /* This is used only by certain clock modes */
;;;169        config->clockSelect = kSCTIMER_Clock_On_Rise_Input_0;
00001a  70a0              STRB     r0,[r4,#2]
;;;170        /* Up count mode only for the unified counter */
;;;171        config->enableBidirection_l = false;
00001c  70e0              STRB     r0,[r4,#3]
;;;172        /* Up count mode only for Counte_H */
;;;173        config->enableBidirection_h = false;
00001e  7120              STRB     r0,[r4,#4]
;;;174        /* Prescale factor of 1 */
;;;175        config->prescale_l = 0;
000020  7160              STRB     r0,[r4,#5]
;;;176        /* Prescale factor of 1 for Counter_H*/
;;;177        config->prescale_h = 0;
000022  71a0              STRB     r0,[r4,#6]
;;;178        /* Clear outputs */
;;;179        config->outInitState = 0;
000024  71e0              STRB     r0,[r4,#7]
;;;180    }
000026  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  |L6.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_sctimer.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  73637469
00003c  6d65722e
000040  6300    
000042  00                DCB      0
000043  00                DCB      0
                  |L6.68|
000044  636f6e66          DCB      "config",0
000048  696700  
00004b  00                DCB      0

                          AREA ||i.SCTIMER_GetInstance||, CODE, READONLY, ALIGN=2

                  SCTIMER_GetInstance PROC
;;;82      ******************************************************************************/
;;;83     static uint32_t SCTIMER_GetInstance(SCT_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4605              MOV      r5,r0
;;;85         uint32_t instance;
;;;86         uint32_t sctArrayCount = (sizeof(s_sctBases) / sizeof(s_sctBases[0]));
000004  2601              MOVS     r6,#1
;;;87     
;;;88         /* Find the instance index from base address mappings. */
;;;89         for (instance = 0; instance < sctArrayCount; instance++)
000006  2400              MOVS     r4,#0
000008  e006              B        |L7.24|
                  |L7.10|
;;;90         {
;;;91             if (s_sctBases[instance] == base)
00000a  480a              LDR      r0,|L7.52|
00000c  f8500024          LDR      r0,[r0,r4,LSL #2]
000010  42a8              CMP      r0,r5
000012  d100              BNE      |L7.22|
;;;92             {
;;;93                 break;
000014  e002              B        |L7.28|
                  |L7.22|
000016  1c64              ADDS     r4,r4,#1              ;89
                  |L7.24|
000018  42b4              CMP      r4,r6                 ;89
00001a  d3f6              BCC      |L7.10|
                  |L7.28|
00001c  bf00              NOP      
;;;94             }
;;;95         }
;;;96     
;;;97         assert(instance < sctArrayCount);
00001e  42b4              CMP      r4,r6
000020  d200              BCS      |L7.36|
000022  e004              B        |L7.46|
                  |L7.36|
000024  2261              MOVS     r2,#0x61
000026  a104              ADR      r1,|L7.56|
000028  a00a              ADR      r0,|L7.84|
00002a  f7fffffe          BL       __aeabi_assert
                  |L7.46|
;;;98     
;;;99         return instance;
00002e  4620              MOV      r0,r4
;;;100    }
000030  bd70              POP      {r4-r6,pc}
;;;101    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      s_sctBases
                  |L7.56|
000038  5352435c          DCB      "SRC\\Drivers\\fsl_sctimer.c",0
00003c  44726976
000040  6572735c
000044  66736c5f
000048  73637469
00004c  6d65722e
000050  6300    
000052  00                DCB      0
000053  00                DCB      0
                  |L7.84|
000054  696e7374          DCB      "instance < sctArrayCount",0
000058  616e6365
00005c  203c2073
000060  63744172
000064  72617943
000068  6f756e74
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.SCTIMER_IncreaseState||, CODE, READONLY, ALIGN=2

                  SCTIMER_IncreaseState PROC
;;;430    
;;;431    status_t SCTIMER_IncreaseState(SCT_Type *base)
000000  4601              MOV      r1,r0
;;;432    {
;;;433        /* Return an error if we have hit the limit in terms of states used */
;;;434        if (s_currentState >= FSL_FEATURE_SCT_NUMBER_OF_STATES)
000002  4806              LDR      r0,|L8.28|
000004  6800              LDR      r0,[r0,#0]  ; s_currentState
000006  280a              CMP      r0,#0xa
000008  d301              BCC      |L8.14|
;;;435        {
;;;436            return kStatus_Fail;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;437        }
;;;438    
;;;439        s_currentState++;
;;;440    
;;;441        return kStatus_Success;
;;;442    }
00000c  4770              BX       lr
                  |L8.14|
00000e  4803              LDR      r0,|L8.28|
000010  6800              LDR      r0,[r0,#0]            ;439  ; s_currentState
000012  1c40              ADDS     r0,r0,#1              ;439
000014  4a01              LDR      r2,|L8.28|
000016  6010              STR      r0,[r2,#0]            ;439  ; s_currentState
000018  2000              MOVS     r0,#0                 ;441
00001a  e7f7              B        |L8.12|
;;;443    
                          ENDP

                  |L8.28|
                          DCD      s_currentState

                          AREA ||i.SCTIMER_Init||, CODE, READONLY, ALIGN=2

                  SCTIMER_Init PROC
;;;101    
;;;102    status_t SCTIMER_Init(SCT_Type *base, const sctimer_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;103    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;104        assert(config);
000008  b104              CBZ      r4,|L9.12|
00000a  e004              B        |L9.22|
                  |L9.12|
00000c  2268              MOVS     r2,#0x68
00000e  a134              ADR      r1,|L9.224|
000010  a03a              ADR      r0,|L9.252|
000012  f7fffffe          BL       __aeabi_assert
                  |L9.22|
;;;105        uint32_t i;
;;;106    
;;;107    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;108        /* Enable the SCTimer clock*/
;;;109        CLOCK_EnableClock(s_sctClocks[SCTIMER_GetInstance(base)]);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       SCTIMER_GetInstance
00001c  4939              LDR      r1,|L9.260|
00001e  f8317010          LDRH     r7,[r1,r0,LSL #1]
000022  0a38              LSRS     r0,r7,#8
000024  2803              CMP      r0,#3
000026  d205              BCS      |L9.52|
000028  2101              MOVS     r1,#1
00002a  40b9              LSLS     r1,r1,r7
00002c  4a36              LDR      r2,|L9.264|
00002e  f8421020          STR      r1,[r2,r0,LSL #2]
000032  e005              B        |L9.64|
                  |L9.52|
000034  2101              MOVS     r1,#1
000036  078a              LSLS     r2,r1,#30
000038  64d1              STR      r1,[r2,#0x4c]
00003a  40b9              LSLS     r1,r1,r7
00003c  4a33              LDR      r2,|L9.268|
00003e  6151              STR      r1,[r2,#0x14]
                  |L9.64|
000040  bf00              NOP      
;;;110    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;111    
;;;112        /* Reset the module */
;;;113        RESET_PeripheralReset(s_sctResets[SCTIMER_GetInstance(base)]);
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       SCTIMER_GetInstance
000048  4931              LDR      r1,|L9.272|
00004a  f8517020          LDR      r7,[r1,r0,LSL #2]
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       RESET_PeripheralReset
;;;114    
;;;115        /* Setup the counter operation */
;;;116        base->CONFIG = SCT_CONFIG_CKSEL(config->clockSelect) | SCT_CONFIG_CLKMODE(config->clockMode) |
000054  78a0              LDRB     r0,[r4,#2]
000056  2178              MOVS     r1,#0x78
000058  ea0100c0          AND      r0,r1,r0,LSL #3
00005c  7861              LDRB     r1,[r4,#1]
00005e  2206              MOVS     r2,#6
000060  ea020141          AND      r1,r2,r1,LSL #1
000064  4308              ORRS     r0,r0,r1
000066  7821              LDRB     r1,[r4,#0]
000068  f0010101          AND      r1,r1,#1
00006c  4308              ORRS     r0,r0,r1
00006e  6028              STR      r0,[r5,#0]
;;;117                       SCT_CONFIG_UNIFY(config->enableCounterUnify);
;;;118    
;;;119        /* Write to the control register, clear the counter and keep the counters halted */
;;;120        base->CTRL = SCT_CTRL_BIDIR_L(config->enableBidirection_l) | SCT_CTRL_PRE_L(config->prescale_l) |
000070  78e0              LDRB     r0,[r4,#3]
000072  2110              MOVS     r1,#0x10
000074  ea011000          AND      r0,r1,r0,LSL #4
000078  7961              LDRB     r1,[r4,#5]
00007a  f44f52ff          MOV      r2,#0x1fe0
00007e  ea021141          AND      r1,r2,r1,LSL #5
000082  4308              ORRS     r0,r0,r1
000084  f0400008          ORR      r0,r0,#8
000088  1d00              ADDS     r0,r0,#4
00008a  6068              STR      r0,[r5,#4]
;;;121                     SCT_CTRL_CLRCTR_L_MASK | SCT_CTRL_HALT_L_MASK;
;;;122    
;;;123        if (!(config->enableCounterUnify))
00008c  7820              LDRB     r0,[r4,#0]
00008e  b970              CBNZ     r0,|L9.174|
;;;124        {
;;;125            base->CTRL |= SCT_CTRL_BIDIR_H(config->enableBidirection_h) | SCT_CTRL_PRE_H(config->prescale_h) |
000090  7920              LDRB     r0,[r4,#4]
000092  f44f1180          MOV      r1,#0x100000
000096  ea015000          AND      r0,r1,r0,LSL #20
00009a  79a1              LDRB     r1,[r4,#6]
00009c  0412              LSLS     r2,r2,#16
00009e  ea025141          AND      r1,r2,r1,LSL #21
0000a2  4308              ORRS     r0,r0,r1
0000a4  f4402040          ORR      r0,r0,#0xc0000
0000a8  6869              LDR      r1,[r5,#4]
0000aa  4308              ORRS     r0,r0,r1
0000ac  6068              STR      r0,[r5,#4]
                  |L9.174|
;;;126                          SCT_CTRL_CLRCTR_H_MASK | SCT_CTRL_HALT_H_MASK;
;;;127        }
;;;128    
;;;129        /* Initial state of channel output */
;;;130        base->OUTPUT = config->outInitState;
0000ae  79e0              LDRB     r0,[r4,#7]
0000b0  6528              STR      r0,[r5,#0x50]
;;;131    
;;;132        /* Clear the global variables */
;;;133        s_currentEvent = 0;
0000b2  2000              MOVS     r0,#0
0000b4  4917              LDR      r1,|L9.276|
0000b6  6008              STR      r0,[r1,#0]  ; s_currentEvent
;;;134        s_currentState = 0;
0000b8  4917              LDR      r1,|L9.280|
0000ba  6008              STR      r0,[r1,#0]  ; s_currentState
;;;135        s_currentMatch = 0;
0000bc  4917              LDR      r1,|L9.284|
0000be  6008              STR      r0,[r1,#0]  ; s_currentMatch
;;;136    
;;;137        /* Clear the callback array */
;;;138        for (i = 0; i < FSL_FEATURE_SCT_NUMBER_OF_EVENTS; i++)
0000c0  2600              MOVS     r6,#0
0000c2  e004              B        |L9.206|
                  |L9.196|
;;;139        {
;;;140            s_eventCallback[i] = NULL;
0000c4  2000              MOVS     r0,#0
0000c6  4916              LDR      r1,|L9.288|
0000c8  f8410026          STR      r0,[r1,r6,LSL #2]
0000cc  1c76              ADDS     r6,r6,#1              ;138
                  |L9.206|
0000ce  2e0a              CMP      r6,#0xa               ;138
0000d0  d3f8              BCC      |L9.196|
;;;141        }
;;;142    
;;;143        /* Save interrupt handler */
;;;144        s_sctimerIsr = SCTIMER_EventHandleIRQ;
0000d2  4814              LDR      r0,|L9.292|
0000d4  4914              LDR      r1,|L9.296|
0000d6  6008              STR      r0,[r1,#0]  ; s_sctimerIsr
;;;145    
;;;146        return kStatus_Success;
0000d8  2000              MOVS     r0,#0
;;;147    }
0000da  e8bd81f0          POP      {r4-r8,pc}
;;;148    
                          ENDP

0000de  0000              DCW      0x0000
                  |L9.224|
0000e0  5352435c          DCB      "SRC\\Drivers\\fsl_sctimer.c",0
0000e4  44726976
0000e8  6572735c
0000ec  66736c5f
0000f0  73637469
0000f4  6d65722e
0000f8  6300    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L9.252|
0000fc  636f6e66          DCB      "config",0
000100  696700  
000103  00                DCB      0
                  |L9.260|
                          DCD      s_sctClocks
                  |L9.264|
                          DCD      0x40000220
                  |L9.268|
                          DCD      0x40040000
                  |L9.272|
                          DCD      s_sctResets
                  |L9.276|
                          DCD      s_currentEvent
                  |L9.280|
                          DCD      s_currentState
                  |L9.284|
                          DCD      s_currentMatch
                  |L9.288|
                          DCD      s_eventCallback
                  |L9.292|
                          DCD      SCTIMER_EventHandleIRQ
                  |L9.296|
                          DCD      s_sctimerIsr

                          AREA ||i.SCTIMER_ScheduleEvent||, CODE, READONLY, ALIGN=2

                  SCTIMER_ScheduleEvent PROC
;;;424    
;;;425    void SCTIMER_ScheduleEvent(SCT_Type *base, uint32_t event)
000000  b510              PUSH     {r4,lr}
;;;426    {
;;;427        /* Enable event in the current state */
;;;428        base->EVENT[event].STATE |= (1U << s_currentState);
000002  f5007240          ADD      r2,r0,#0x300
000006  f8522031          LDR      r2,[r2,r1,LSL #3]
00000a  4b05              LDR      r3,|L10.32|
00000c  781c              LDRB     r4,[r3,#0]  ; s_currentState
00000e  2301              MOVS     r3,#1
000010  40a3              LSLS     r3,r3,r4
000012  431a              ORRS     r2,r2,r3
000014  f5007340          ADD      r3,r0,#0x300
000018  f8432031          STR      r2,[r3,r1,LSL #3]
;;;429    }
00001c  bd10              POP      {r4,pc}
;;;430    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      s_currentState

                          AREA ||i.SCTIMER_SetCallback||, CODE, READONLY, ALIGN=2

                  SCTIMER_SetCallback PROC
;;;501    
;;;502    void SCTIMER_SetCallback(SCT_Type *base, sctimer_event_callback_t callback, uint32_t event)
000000  4b01              LDR      r3,|L11.8|
;;;503    {
;;;504        s_eventCallback[event] = callback;
000002  f8431022          STR      r1,[r3,r2,LSL #2]
;;;505    }
000006  4770              BX       lr
;;;506    
                          ENDP

                  |L11.8|
                          DCD      s_eventCallback

                          AREA ||i.SCTIMER_SetupCaptureAction||, CODE, READONLY, ALIGN=2

                  SCTIMER_SetupCaptureAction PROC
;;;463    
;;;464    status_t SCTIMER_SetupCaptureAction(SCT_Type *base,
000000  b570              PUSH     {r4-r6,lr}
;;;465                                        sctimer_counter_t whichCounter,
;;;466                                        uint32_t *captureRegister,
;;;467                                        uint32_t event)
;;;468    {
000002  4604              MOV      r4,r0
;;;469        /* Return an error if we have hit the limit in terms of number of capture/match registers used */
;;;470        if (s_currentMatch >= FSL_FEATURE_SCT_NUMBER_OF_MATCH_CAPTURE)
000004  4824              LDR      r0,|L12.152|
000006  6800              LDR      r0,[r0,#0]  ; s_currentMatch
000008  280a              CMP      r0,#0xa
00000a  d301              BCC      |L12.16|
;;;471        {
;;;472            return kStatus_Fail;
00000c  2001              MOVS     r0,#1
                  |L12.14|
;;;473        }
;;;474    
;;;475        /* Use Counter_L bits if counter is operating in 32-bit mode or user wants to setup the L counter */
;;;476        if ((base->CONFIG & SCT_CONFIG_UNIFY_MASK) || (whichCounter == kSCTIMER_Counter_L))
;;;477        {
;;;478            /* Set the bit to enable event */
;;;479            base->SCTCAPCTRL[s_currentMatch] |= SCT_SCTCAPCTRL_CAPCONn_L(1 << event);
;;;480    
;;;481            /* Set this resource to be a capture rather than match */
;;;482            base->REGMODE |= SCT_REGMODE_REGMOD_L(1 << s_currentMatch);
;;;483        }
;;;484        else
;;;485        {
;;;486            /* Set bit to enable event */
;;;487            base->SCTCAPCTRL[s_currentMatch] |= SCT_SCTCAPCTRL_CAPCONn_H(1 << event);
;;;488    
;;;489            /* Set this resource to be a capture rather than match */
;;;490            base->REGMODE |= SCT_REGMODE_REGMOD_H(1 << s_currentMatch);
;;;491        }
;;;492    
;;;493        /* Return the match register number */
;;;494        *captureRegister = s_currentMatch;
;;;495    
;;;496        /* Increase the match register number */
;;;497        s_currentMatch++;
;;;498    
;;;499        return kStatus_Success;
;;;500    }
00000e  bd70              POP      {r4-r6,pc}
                  |L12.16|
000010  6820              LDR      r0,[r4,#0]            ;476
000012  f0000001          AND      r0,r0,#1              ;476
000016  b900              CBNZ     r0,|L12.26|
000018  b9c1              CBNZ     r1,|L12.76|
                  |L12.26|
00001a  f5047000          ADD      r0,r4,#0x200          ;479
00001e  4d1e              LDR      r5,|L12.152|
000020  682d              LDR      r5,[r5,#0]            ;479  ; s_currentMatch
000022  f8500025          LDR      r0,[r0,r5,LSL #2]     ;479
000026  2501              MOVS     r5,#1                 ;479
000028  409d              LSLS     r5,r5,r3              ;479
00002a  b2ad              UXTH     r5,r5                 ;479
00002c  4328              ORRS     r0,r0,r5              ;479
00002e  f5047500          ADD      r5,r4,#0x200          ;479
000032  4e19              LDR      r6,|L12.152|
000034  6836              LDR      r6,[r6,#0]            ;479  ; s_currentMatch
000036  f8450026          STR      r0,[r5,r6,LSL #2]     ;479
00003a  6ce0              LDR      r0,[r4,#0x4c]         ;482
00003c  4d16              LDR      r5,|L12.152|
00003e  782e              LDRB     r6,[r5,#0]            ;482  ; s_currentMatch
000040  2501              MOVS     r5,#1                 ;482
000042  40b5              LSLS     r5,r5,r6              ;482
000044  b2ad              UXTH     r5,r5                 ;482
000046  4328              ORRS     r0,r0,r5              ;482
000048  64e0              STR      r0,[r4,#0x4c]         ;482
00004a  e01b              B        |L12.132|
                  |L12.76|
00004c  f5047000          ADD      r0,r4,#0x200          ;487
000050  4d11              LDR      r5,|L12.152|
000052  682d              LDR      r5,[r5,#0]            ;487  ; s_currentMatch
000054  f8505025          LDR      r5,[r0,r5,LSL #2]     ;487
000058  2001              MOVS     r0,#1                 ;487
00005a  4098              LSLS     r0,r0,r3              ;487
00005c  4e0f              LDR      r6,|L12.156|
00005e  ea064000          AND      r0,r6,r0,LSL #16      ;487
000062  4328              ORRS     r0,r0,r5              ;487
000064  f5047500          ADD      r5,r4,#0x200          ;487
000068  4e0b              LDR      r6,|L12.152|
00006a  6836              LDR      r6,[r6,#0]            ;487  ; s_currentMatch
00006c  f8450026          STR      r0,[r5,r6,LSL #2]     ;487
000070  6ce0              LDR      r0,[r4,#0x4c]         ;490
000072  4d09              LDR      r5,|L12.152|
000074  782e              LDRB     r6,[r5,#0]            ;490  ; s_currentMatch
000076  2501              MOVS     r5,#1                 ;490
000078  40b5              LSLS     r5,r5,r6              ;490
00007a  4e08              LDR      r6,|L12.156|
00007c  ea064505          AND      r5,r6,r5,LSL #16      ;490
000080  4328              ORRS     r0,r0,r5              ;490
000082  64e0              STR      r0,[r4,#0x4c]         ;490
                  |L12.132|
000084  4804              LDR      r0,|L12.152|
000086  6800              LDR      r0,[r0,#0]            ;494  ; s_currentMatch
000088  6010              STR      r0,[r2,#0]            ;494
00008a  4803              LDR      r0,|L12.152|
00008c  6800              LDR      r0,[r0,#0]            ;497  ; s_currentMatch
00008e  1c40              ADDS     r0,r0,#1              ;497
000090  4d01              LDR      r5,|L12.152|
000092  6028              STR      r0,[r5,#0]            ;497  ; s_currentMatch
000094  2000              MOVS     r0,#0                 ;499
000096  e7ba              B        |L12.14|
;;;501    
                          ENDP

                  |L12.152|
                          DCD      s_currentMatch
                  |L12.156|
                          DCD      0xffff0000

                          AREA ||i.SCTIMER_SetupOutputClearAction||, CODE, READONLY, ALIGN=1

                  SCTIMER_SetupOutputClearAction PROC
;;;672     */
;;;673    static inline void SCTIMER_SetupOutputClearAction(SCT_Type *base, uint32_t whichIO, uint32_t event)
000000  b510              PUSH     {r4,lr}
;;;674    {
;;;675        base->OUT[whichIO].CLR |= (1U << event);
000002  f50063a0          ADD      r3,r0,#0x500
000006  eb0303c1          ADD      r3,r3,r1,LSL #3
00000a  685b              LDR      r3,[r3,#4]
00000c  2401              MOVS     r4,#1
00000e  4094              LSLS     r4,r4,r2
000010  4323              ORRS     r3,r3,r4
000012  f50064a0          ADD      r4,r0,#0x500
000016  eb0404c1          ADD      r4,r4,r1,LSL #3
00001a  6063              STR      r3,[r4,#4]
;;;676    }
00001c  bd10              POP      {r4,pc}
;;;677    
                          ENDP


                          AREA ||i.SCTIMER_SetupOutputSetAction||, CODE, READONLY, ALIGN=1

                  SCTIMER_SetupOutputSetAction PROC
;;;658     */
;;;659    static inline void SCTIMER_SetupOutputSetAction(SCT_Type *base, uint32_t whichIO, uint32_t event)
000000  b510              PUSH     {r4,lr}
;;;660    {
;;;661        base->OUT[whichIO].SET |= (1U << event);
000002  f50063a0          ADD      r3,r0,#0x500
000006  f8534031          LDR      r4,[r3,r1,LSL #3]
00000a  2301              MOVS     r3,#1
00000c  4093              LSLS     r3,r3,r2
00000e  4323              ORRS     r3,r3,r4
000010  f50064a0          ADD      r4,r0,#0x500
000014  f8443031          STR      r3,[r4,r1,LSL #3]
;;;662    }
000018  bd10              POP      {r4,pc}
;;;663    
                          ENDP


                          AREA ||i.SCTIMER_SetupOutputToggleAction||, CODE, READONLY, ALIGN=1

                  SCTIMER_SetupOutputToggleAction PROC
;;;448    
;;;449    void SCTIMER_SetupOutputToggleAction(SCT_Type *base, uint32_t whichIO, uint32_t event)
000000  b530              PUSH     {r4,r5,lr}
;;;450    {
;;;451        uint32_t reg;
;;;452    
;;;453        /* Set the same event to set and clear the output */
;;;454        base->OUT[whichIO].CLR |= (1U << event);
000002  f50064a0          ADD      r4,r0,#0x500
000006  eb0404c1          ADD      r4,r4,r1,LSL #3
00000a  6864              LDR      r4,[r4,#4]
00000c  2501              MOVS     r5,#1
00000e  4095              LSLS     r5,r5,r2
000010  432c              ORRS     r4,r4,r5
000012  f50065a0          ADD      r5,r0,#0x500
000016  eb0505c1          ADD      r5,r5,r1,LSL #3
00001a  606c              STR      r4,[r5,#4]
;;;455        base->OUT[whichIO].SET |= (1U << event);
00001c  f50064a0          ADD      r4,r0,#0x500
000020  f8544031          LDR      r4,[r4,r1,LSL #3]
000024  2501              MOVS     r5,#1
000026  4095              LSLS     r5,r5,r2
000028  432c              ORRS     r4,r4,r5
00002a  f50065a0          ADD      r5,r0,#0x500
00002e  f8454031          STR      r4,[r5,r1,LSL #3]
;;;456    
;;;457        /* Set the conflict resolution to toggle output */
;;;458        reg = base->RES;
000032  6d83              LDR      r3,[r0,#0x58]
;;;459        reg &= ~(SCT_RES_O0RES_MASK << (2 * whichIO));
000034  004d              LSLS     r5,r1,#1
000036  2403              MOVS     r4,#3
000038  40ac              LSLS     r4,r4,r5
00003a  43a3              BICS     r3,r3,r4
;;;460        reg |= (uint32_t)(kSCTIMER_ResolveToggle << (2 * whichIO));
00003c  004d              LSLS     r5,r1,#1
00003e  2403              MOVS     r4,#3
000040  40ac              LSLS     r4,r4,r5
000042  4323              ORRS     r3,r3,r4
;;;461        base->RES = reg;
000044  6583              STR      r3,[r0,#0x58]
;;;462    }
000046  bd30              POP      {r4,r5,pc}
;;;463    
                          ENDP


                          AREA ||i.SCTIMER_SetupPwm||, CODE, READONLY, ALIGN=2

                  SCTIMER_SetupPwm PROC
;;;181    
;;;182    status_t SCTIMER_SetupPwm(SCT_Type *base,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;183                              const sctimer_pwm_signal_param_t *pwmParams,
;;;184                              sctimer_pwm_mode_t mode,
;;;185                              uint32_t pwmFreq_Hz,
;;;186                              uint32_t srcClock_Hz,
;;;187                              uint32_t *event)
;;;188    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
00000c  4699              MOV      r9,r3
00000e  f8ddb038          LDR      r11,[sp,#0x38]
;;;189        assert(pwmParams);
000012  b105              CBZ      r5,|L16.22|
000014  e004              B        |L16.32|
                  |L16.22|
000016  22bd              MOVS     r2,#0xbd
000018  a164              ADR      r1,|L16.428|
00001a  a06b              ADR      r0,|L16.456|
00001c  f7fffffe          BL       __aeabi_assert
                  |L16.32|
;;;190        assert(srcClock_Hz);
000020  f1bb0f00          CMP      r11,#0
000024  d000              BEQ      |L16.40|
000026  e004              B        |L16.50|
                  |L16.40|
000028  22be              MOVS     r2,#0xbe
00002a  a160              ADR      r1,|L16.428|
00002c  a069              ADR      r0,|L16.468|
00002e  f7fffffe          BL       __aeabi_assert
                  |L16.50|
;;;191        assert(pwmFreq_Hz);
000032  f1b90f00          CMP      r9,#0
000036  d000              BEQ      |L16.58|
000038  e004              B        |L16.68|
                  |L16.58|
00003a  22bf              MOVS     r2,#0xbf
00003c  a15b              ADR      r1,|L16.428|
00003e  a068              ADR      r0,|L16.480|
000040  f7fffffe          BL       __aeabi_assert
                  |L16.68|
;;;192    
;;;193        uint32_t period, pulsePeriod = 0;
000044  2000              MOVS     r0,#0
000046  9004              STR      r0,[sp,#0x10]
;;;194        uint32_t sctClock = srcClock_Hz / (((base->CTRL & SCT_CTRL_PRE_L_MASK) >> SCT_CTRL_PRE_L_SHIFT) + 1);
000048  6860              LDR      r0,[r4,#4]
00004a  f3c01047          UBFX     r0,r0,#5,#8
00004e  1c40              ADDS     r0,r0,#1
000050  fbbbfaf0          UDIV     r10,r11,r0
;;;195        uint32_t periodEvent, pulseEvent;
;;;196        uint32_t reg;
;;;197    
;;;198        /* This function will create 2 events, return an error if we do not have enough events available */
;;;199        if ((s_currentEvent + 2) > FSL_FEATURE_SCT_NUMBER_OF_EVENTS)
000054  4865              LDR      r0,|L16.492|
000056  6800              LDR      r0,[r0,#0]  ; s_currentEvent
000058  1c80              ADDS     r0,r0,#2
00005a  280a              CMP      r0,#0xa
00005c  d903              BLS      |L16.102|
;;;200        {
;;;201            return kStatus_Fail;
00005e  2001              MOVS     r0,#1
                  |L16.96|
;;;202        }
;;;203    
;;;204        if (pwmParams->dutyCyclePercent == 0)
;;;205        {
;;;206            return kStatus_Fail;
;;;207        }
;;;208    
;;;209        /* Set unify bit to operate in 32-bit counter mode */
;;;210        base->CONFIG |= SCT_CONFIG_UNIFY_MASK;
;;;211    
;;;212        /* Use bi-directional mode for center-aligned PWM */
;;;213        if (mode == kSCTIMER_CenterAlignedPwm)
;;;214        {
;;;215            base->CTRL |= SCT_CTRL_BIDIR_L_MASK;
;;;216        }
;;;217    
;;;218        /* Calculate PWM period match value */
;;;219        if (mode == kSCTIMER_EdgeAlignedPwm)
;;;220        {
;;;221            period = (sctClock / pwmFreq_Hz) - 1;
;;;222        }
;;;223        else
;;;224        {
;;;225            period = sctClock / (pwmFreq_Hz * 2);
;;;226        }
;;;227    
;;;228        /* Calculate pulse width match value */
;;;229        pulsePeriod = (period * pwmParams->dutyCyclePercent) / 100;
;;;230    
;;;231        /* For 100% dutycyle, make pulse period greater than period so the event will never occur */
;;;232        if (pwmParams->dutyCyclePercent >= 100)
;;;233        {
;;;234            pulsePeriod = period + 2;
;;;235        }
;;;236    
;;;237        /* Schedule an event when we reach the PWM period */
;;;238        SCTIMER_CreateAndScheduleEvent(base, kSCTIMER_MatchEventOnly, period, 0, kSCTIMER_Counter_L, &periodEvent);
;;;239    
;;;240        /* Schedule an event when we reach the pulse width */
;;;241        SCTIMER_CreateAndScheduleEvent(base, kSCTIMER_MatchEventOnly, pulsePeriod, 0, kSCTIMER_Counter_L, &pulseEvent);
;;;242    
;;;243        /* Reset the counter when we reach the PWM period */
;;;244        SCTIMER_SetupCounterLimitAction(base, kSCTIMER_Counter_L, periodEvent);
;;;245    
;;;246        /* Return the period event to the user */
;;;247        *event = periodEvent;
;;;248    
;;;249        /* For high-true level */
;;;250        if (pwmParams->level == kSCTIMER_HighTrue)
;;;251        {
;;;252            /* Set the initial output level to low which is the inactive state */
;;;253            base->OUTPUT &= ~(1U << pwmParams->output);
;;;254    
;;;255            if (mode == kSCTIMER_EdgeAlignedPwm)
;;;256            {
;;;257                /* Set the output when we reach the PWM period */
;;;258                SCTIMER_SetupOutputSetAction(base, pwmParams->output, periodEvent);
;;;259                /* Clear the output when we reach the PWM pulse value */
;;;260                SCTIMER_SetupOutputClearAction(base, pwmParams->output, pulseEvent);
;;;261            }
;;;262            else
;;;263            {
;;;264                /* Clear the output when we reach the PWM pulse event */
;;;265                SCTIMER_SetupOutputClearAction(base, pwmParams->output, pulseEvent);
;;;266                /* Reverse output when down counting */
;;;267                reg = base->OUTPUTDIRCTRL;
;;;268                reg &= ~(SCT_OUTPUTDIRCTRL_SETCLR0_MASK << (2 * pwmParams->output));
;;;269                reg |= (1U << (2 * pwmParams->output));
;;;270                base->OUTPUTDIRCTRL = reg;
;;;271            }
;;;272        }
;;;273        /* For low-true level */
;;;274        else
;;;275        {
;;;276            /* Set the initial output level to high which is the inactive state */
;;;277            base->OUTPUT |= (1U << pwmParams->output);
;;;278    
;;;279            if (mode == kSCTIMER_EdgeAlignedPwm)
;;;280            {
;;;281                /* Clear the output when we reach the PWM period */
;;;282                SCTIMER_SetupOutputClearAction(base, pwmParams->output, periodEvent);
;;;283                /* Set the output when we reach the PWM pulse value */
;;;284                SCTIMER_SetupOutputSetAction(base, pwmParams->output, pulseEvent);
;;;285            }
;;;286            else
;;;287            {
;;;288                /* Set the output when we reach the PWM pulse event */
;;;289                SCTIMER_SetupOutputSetAction(base, pwmParams->output, pulseEvent);
;;;290                /* Reverse output when down counting */
;;;291                reg = base->OUTPUTDIRCTRL;
;;;292                reg &= ~(SCT_OUTPUTDIRCTRL_SETCLR0_MASK << (2 * pwmParams->output));
;;;293                reg |= (1U << (2 * pwmParams->output));
;;;294                base->OUTPUTDIRCTRL = reg;
;;;295            }
;;;296        }
;;;297    
;;;298        return kStatus_Success;
;;;299    }
000060  b005              ADD      sp,sp,#0x14
000062  e8bd8ff0          POP      {r4-r11,pc}
                  |L16.102|
000066  78a8              LDRB     r0,[r5,#2]            ;204
000068  b908              CBNZ     r0,|L16.110|
00006a  2001              MOVS     r0,#1                 ;206
00006c  e7f8              B        |L16.96|
                  |L16.110|
00006e  6820              LDR      r0,[r4,#0]            ;210
000070  f0400001          ORR      r0,r0,#1              ;210
000074  6020              STR      r0,[r4,#0]            ;210
000076  2f01              CMP      r7,#1                 ;213
000078  d103              BNE      |L16.130|
00007a  6860              LDR      r0,[r4,#4]            ;215
00007c  f0400010          ORR      r0,r0,#0x10           ;215
000080  6060              STR      r0,[r4,#4]            ;215
                  |L16.130|
000082  b927              CBNZ     r7,|L16.142|
000084  fbbaf0f9          UDIV     r0,r10,r9             ;221
000088  f1a00801          SUB      r8,r0,#1              ;221
00008c  e003              B        |L16.150|
                  |L16.142|
00008e  ea4f0049          LSL      r0,r9,#1              ;225
000092  fbbaf8f0          UDIV     r8,r10,r0             ;225
                  |L16.150|
000096  78a8              LDRB     r0,[r5,#2]            ;229
000098  fb00f008          MUL      r0,r0,r8              ;229
00009c  2164              MOVS     r1,#0x64              ;229
00009e  fbb0f0f1          UDIV     r0,r0,r1              ;229
0000a2  9004              STR      r0,[sp,#0x10]         ;229
0000a4  78a8              LDRB     r0,[r5,#2]            ;232
0000a6  2864              CMP      r0,#0x64              ;232
0000a8  db02              BLT      |L16.176|
0000aa  f1080002          ADD      r0,r8,#2              ;234
0000ae  9004              STR      r0,[sp,#0x10]         ;234
                  |L16.176|
0000b0  a803              ADD      r0,sp,#0xc            ;238
0000b2  2100              MOVS     r1,#0                 ;238
0000b4  460b              MOV      r3,r1                 ;238
0000b6  4642              MOV      r2,r8                 ;238
0000b8  e9cd1000          STRD     r1,r0,[sp,#0]         ;238
0000bc  f44f5180          MOV      r1,#0x1000            ;238
0000c0  4620              MOV      r0,r4                 ;238
0000c2  f7fffffe          BL       SCTIMER_CreateAndScheduleEvent
0000c6  a802              ADD      r0,sp,#8              ;241
0000c8  2100              MOVS     r1,#0                 ;241
0000ca  460b              MOV      r3,r1                 ;241
0000cc  e9cd1000          STRD     r1,r0,[sp,#0]         ;241
0000d0  f44f5180          MOV      r1,#0x1000            ;241
0000d4  4620              MOV      r0,r4                 ;241
0000d6  9a04              LDR      r2,[sp,#0x10]         ;241
0000d8  f7fffffe          BL       SCTIMER_CreateAndScheduleEvent
0000dc  2100              MOVS     r1,#0                 ;244
0000de  9803              LDR      r0,[sp,#0xc]          ;244
0000e0  6822              LDR      r2,[r4,#0]            ;244
0000e2  f0020201          AND      r2,r2,#1              ;244
0000e6  b902              CBNZ     r2,|L16.234|
0000e8  b931              CBNZ     r1,|L16.248|
                  |L16.234|
0000ea  68a2              LDR      r2,[r4,#8]            ;244
0000ec  2301              MOVS     r3,#1                 ;244
0000ee  4083              LSLS     r3,r3,r0              ;244
0000f0  b29b              UXTH     r3,r3                 ;244
0000f2  431a              ORRS     r2,r2,r3              ;244
0000f4  60a2              STR      r2,[r4,#8]            ;244
0000f6  e008              B        |L16.266|
                  |L16.248|
0000f8  68a2              LDR      r2,[r4,#8]            ;244
0000fa  2301              MOVS     r3,#1                 ;244
0000fc  4083              LSLS     r3,r3,r0              ;244
0000fe  f8dfc0f0          LDR      r12,|L16.496|
000102  ea0c4303          AND      r3,r12,r3,LSL #16     ;244
000106  431a              ORRS     r2,r2,r3              ;244
000108  60a2              STR      r2,[r4,#8]            ;244
                  |L16.266|
00010a  bf00              NOP                            ;244
00010c  9903              LDR      r1,[sp,#0xc]          ;247
00010e  980f              LDR      r0,[sp,#0x3c]         ;247
000110  6001              STR      r1,[r0,#0]            ;247
000112  7868              LDRB     r0,[r5,#1]            ;250
000114  2801              CMP      r0,#1                 ;250
000116  d123              BNE      |L16.352|
000118  6d20              LDR      r0,[r4,#0x50]         ;253
00011a  782a              LDRB     r2,[r5,#0]            ;253
00011c  2101              MOVS     r1,#1                 ;253
00011e  4091              LSLS     r1,r1,r2              ;253
000120  4388              BICS     r0,r0,r1              ;253
000122  6520              STR      r0,[r4,#0x50]         ;253
000124  b957              CBNZ     r7,|L16.316|
000126  7829              LDRB     r1,[r5,#0]            ;258
000128  4620              MOV      r0,r4                 ;258
00012a  9a03              LDR      r2,[sp,#0xc]          ;258
00012c  f7fffffe          BL       SCTIMER_SetupOutputSetAction
000130  7829              LDRB     r1,[r5,#0]            ;260
000132  4620              MOV      r0,r4                 ;260
000134  9a02              LDR      r2,[sp,#8]            ;260
000136  f7fffffe          BL       SCTIMER_SetupOutputClearAction
00013a  e034              B        |L16.422|
                  |L16.316|
00013c  7829              LDRB     r1,[r5,#0]            ;265
00013e  4620              MOV      r0,r4                 ;265
000140  9a02              LDR      r2,[sp,#8]            ;265
000142  f7fffffe          BL       SCTIMER_SetupOutputClearAction
000146  6d66              LDR      r6,[r4,#0x54]         ;267
000148  7828              LDRB     r0,[r5,#0]            ;268
00014a  0041              LSLS     r1,r0,#1              ;268
00014c  2003              MOVS     r0,#3                 ;268
00014e  4088              LSLS     r0,r0,r1              ;268
000150  4386              BICS     r6,r6,r0              ;268
000152  7828              LDRB     r0,[r5,#0]            ;269
000154  0041              LSLS     r1,r0,#1              ;269
000156  2001              MOVS     r0,#1                 ;269
000158  4088              LSLS     r0,r0,r1              ;269
00015a  4306              ORRS     r6,r6,r0              ;269
00015c  6566              STR      r6,[r4,#0x54]         ;270
00015e  e022              B        |L16.422|
                  |L16.352|
000160  6d20              LDR      r0,[r4,#0x50]         ;277
000162  782a              LDRB     r2,[r5,#0]            ;277
000164  2101              MOVS     r1,#1                 ;277
000166  4091              LSLS     r1,r1,r2              ;277
000168  4308              ORRS     r0,r0,r1              ;277
00016a  6520              STR      r0,[r4,#0x50]         ;277
00016c  b957              CBNZ     r7,|L16.388|
00016e  7829              LDRB     r1,[r5,#0]            ;282
000170  4620              MOV      r0,r4                 ;282
000172  9a03              LDR      r2,[sp,#0xc]          ;282
000174  f7fffffe          BL       SCTIMER_SetupOutputClearAction
000178  7829              LDRB     r1,[r5,#0]            ;284
00017a  4620              MOV      r0,r4                 ;284
00017c  9a02              LDR      r2,[sp,#8]            ;284
00017e  f7fffffe          BL       SCTIMER_SetupOutputSetAction
000182  e010              B        |L16.422|
                  |L16.388|
000184  7829              LDRB     r1,[r5,#0]            ;289
000186  4620              MOV      r0,r4                 ;289
000188  9a02              LDR      r2,[sp,#8]            ;289
00018a  f7fffffe          BL       SCTIMER_SetupOutputSetAction
00018e  6d66              LDR      r6,[r4,#0x54]         ;291
000190  7828              LDRB     r0,[r5,#0]            ;292
000192  0041              LSLS     r1,r0,#1              ;292
000194  2003              MOVS     r0,#3                 ;292
000196  4088              LSLS     r0,r0,r1              ;292
000198  4386              BICS     r6,r6,r0              ;292
00019a  7828              LDRB     r0,[r5,#0]            ;293
00019c  0041              LSLS     r1,r0,#1              ;293
00019e  2001              MOVS     r0,#1                 ;293
0001a0  4088              LSLS     r0,r0,r1              ;293
0001a2  4306              ORRS     r6,r6,r0              ;293
0001a4  6566              STR      r6,[r4,#0x54]         ;294
                  |L16.422|
0001a6  2000              MOVS     r0,#0                 ;298
0001a8  e75a              B        |L16.96|
;;;300    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L16.428|
0001ac  5352435c          DCB      "SRC\\Drivers\\fsl_sctimer.c",0
0001b0  44726976
0001b4  6572735c
0001b8  66736c5f
0001bc  73637469
0001c0  6d65722e
0001c4  6300    
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L16.456|
0001c8  70776d50          DCB      "pwmParams",0
0001cc  6172616d
0001d0  7300    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L16.468|
0001d4  73726343          DCB      "srcClock_Hz",0
0001d8  6c6f636b
0001dc  5f487a00
                  |L16.480|
0001e0  70776d46          DCB      "pwmFreq_Hz",0
0001e4  7265715f
0001e8  487a00  
0001eb  00                DCB      0
                  |L16.492|
                          DCD      s_currentEvent
                  |L16.496|
                          DCD      0xffff0000

                          AREA ||i.SCTIMER_UpdatePwmDutycycle||, CODE, READONLY, ALIGN=2

                  SCTIMER_UpdatePwmDutycycle PROC
;;;300    
;;;301    void SCTIMER_UpdatePwmDutycycle(SCT_Type *base, sctimer_out_t output, uint8_t dutyCyclePercent, uint32_t event)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;302    
;;;303    {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;304        assert(dutyCyclePercent > 0);
00000c  2d00              CMP      r5,#0
00000e  dd00              BLE      |L17.18|
000010  e005              B        |L17.30|
                  |L17.18|
000012  f44f7298          MOV      r2,#0x130
000016  a128              ADR      r1,|L17.184|
000018  a02e              ADR      r0,|L17.212|
00001a  f7fffffe          BL       __aeabi_assert
                  |L17.30|
;;;305    
;;;306        uint32_t periodMatchReg, pulseMatchReg;
;;;307        uint32_t pulsePeriod = 0, period;
00001e  f04f0a00          MOV      r10,#0
;;;308    
;;;309        /* Retrieve the match register number for the PWM period */
;;;310        periodMatchReg = base->EVENT[event].CTRL & SCT_EVENT_CTRL_MATCHSEL_MASK;
000022  f5047040          ADD      r0,r4,#0x300
000026  eb0000c6          ADD      r0,r0,r6,LSL #3
00002a  6840              LDR      r0,[r0,#4]
00002c  f000090f          AND      r9,r0,#0xf
;;;311    
;;;312        /* Retrieve the match register number for the PWM pulse period */
;;;313        pulseMatchReg = base->EVENT[event + 1].CTRL & SCT_EVENT_CTRL_MATCHSEL_MASK;
000030  f5047040          ADD      r0,r4,#0x300
000034  1c71              ADDS     r1,r6,#1
000036  eb0000c1          ADD      r0,r0,r1,LSL #3
00003a  6840              LDR      r0,[r0,#4]
00003c  f000070f          AND      r7,r0,#0xf
;;;314    
;;;315        period = base->SCTMATCH[periodMatchReg];
000040  f5047080          ADD      r0,r4,#0x100
000044  f8508029          LDR      r8,[r0,r9,LSL #2]
;;;316    
;;;317        /* Calculate pulse width match value */
;;;318        pulsePeriod = (period * dutyCyclePercent) / 100;
000048  fb08f005          MUL      r0,r8,r5
00004c  2164              MOVS     r1,#0x64
00004e  fbb0faf1          UDIV     r10,r0,r1
;;;319    
;;;320        /* For 100% dutycyle, make pulse period greater than period so the event will never occur */
;;;321        if (dutyCyclePercent >= 100)
000052  2d64              CMP      r5,#0x64
000054  db01              BLT      |L17.90|
;;;322        {
;;;323            pulsePeriod = period + 2;
000056  f1080a02          ADD      r10,r8,#2
                  |L17.90|
;;;324        }
;;;325    
;;;326        /* Stop the counter before updating match register */
;;;327        SCTIMER_StopTimer(base, kSCTIMER_Counter_L);
00005a  2000              MOVS     r0,#0
00005c  6821              LDR      r1,[r4,#0]
00005e  f0010101          AND      r1,r1,#1
000062  b901              CBNZ     r1,|L17.102|
000064  b920              CBNZ     r0,|L17.112|
                  |L17.102|
000066  6861              LDR      r1,[r4,#4]
000068  f0410104          ORR      r1,r1,#4
00006c  6061              STR      r1,[r4,#4]
00006e  e003              B        |L17.120|
                  |L17.112|
000070  6861              LDR      r1,[r4,#4]
000072  f4412180          ORR      r1,r1,#0x40000
000076  6061              STR      r1,[r4,#4]
                  |L17.120|
000078  bf00              NOP      
;;;328    
;;;329        /* Update dutycycle */
;;;330        base->SCTMATCH[pulseMatchReg] = SCT_SCTMATCH_MATCHn_L(pulsePeriod);
00007a  fa1ff18a          UXTH     r1,r10
00007e  f5047080          ADD      r0,r4,#0x100
000082  f8401027          STR      r1,[r0,r7,LSL #2]
;;;331        base->SCTMATCHREL[pulseMatchReg] = SCT_SCTMATCHREL_RELOADn_L(pulsePeriod);
000086  fa1ff18a          UXTH     r1,r10
00008a  f5047000          ADD      r0,r4,#0x200
00008e  f8401027          STR      r1,[r0,r7,LSL #2]
;;;332    
;;;333        /* Restart the counter */
;;;334        SCTIMER_StartTimer(base, kSCTIMER_Counter_L);
000092  2000              MOVS     r0,#0
000094  6821              LDR      r1,[r4,#0]
000096  f0010101          AND      r1,r1,#1
00009a  b901              CBNZ     r1,|L17.158|
00009c  b920              CBNZ     r0,|L17.168|
                  |L17.158|
00009e  6861              LDR      r1,[r4,#4]
0000a0  f0210104          BIC      r1,r1,#4
0000a4  6061              STR      r1,[r4,#4]
0000a6  e003              B        |L17.176|
                  |L17.168|
0000a8  6861              LDR      r1,[r4,#4]
0000aa  f4212180          BIC      r1,r1,#0x40000
0000ae  6061              STR      r1,[r4,#4]
                  |L17.176|
0000b0  bf00              NOP      
;;;335    }
0000b2  e8bd9ff0          POP      {r4-r12,pc}
;;;336    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L17.184|
0000b8  5352435c          DCB      "SRC\\Drivers\\fsl_sctimer.c",0
0000bc  44726976
0000c0  6572735c
0000c4  66736c5f
0000c8  73637469
0000cc  6d65722e
0000d0  6300    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L17.212|
0000d4  64757479          DCB      "dutyCyclePercent > 0",0
0000d8  4379636c
0000dc  65506572
0000e0  63656e74
0000e4  203e2030
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_eventCallback
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_sctBases
                          DCD      0x40085000
                  s_sctClocks
000004  0102              DCW      0x0102
000006  0000              DCB      0x00,0x00
                  s_sctResets
                          DCD      0x00010002

                          AREA ||.data||, DATA, ALIGN=2

                  s_currentEvent
                          DCD      0x00000000
                  s_currentState
                          DCD      0x00000000
                  s_currentMatch
                          DCD      0x00000000
                  s_sctimerIsr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_sctimer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_sctimer_c_a5f84a41____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_fsl_sctimer_c_a5f84a41____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_sctimer_c_a5f84a41____REVSH|
#line 402
|__asm___13_fsl_sctimer_c_a5f84a41____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_sctimer_c_a5f84a41____RRX|
#line 587
|__asm___13_fsl_sctimer_c_a5f84a41____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
