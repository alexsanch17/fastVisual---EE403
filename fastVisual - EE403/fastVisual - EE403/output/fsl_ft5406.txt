; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_ft5406.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_ft5406.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_ft5406.crf SRC\System\fsl_ft5406.c]
                          THUMB

                          AREA ||i.FT5406_Denit||, CODE, READONLY, ALIGN=2

                  FT5406_Denit PROC
;;;113    
;;;114    status_t FT5406_Denit(ft5406_handle_t *handle)
000000  b510              PUSH     {r4,lr}
;;;115    {
000002  4604              MOV      r4,r0
;;;116        assert(handle);
000004  b104              CBZ      r4,|L1.8|
000006  e004              B        |L1.18|
                  |L1.8|
000008  2274              MOVS     r2,#0x74
00000a  a105              ADR      r1,|L1.32|
00000c  a00a              ADR      r0,|L1.56|
00000e  f7fffffe          BL       __aeabi_assert
                  |L1.18|
;;;117    
;;;118        if (!handle)
000012  b90c              CBNZ     r4,|L1.24|
;;;119        {
;;;120            return kStatus_InvalidArgument;
000014  2004              MOVS     r0,#4
                  |L1.22|
;;;121        }
;;;122    
;;;123        handle->base = NULL;
;;;124        return kStatus_Success;
;;;125    }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  2000              MOVS     r0,#0                 ;123
00001a  6020              STR      r0,[r4,#0]            ;123
00001c  bf00              NOP                            ;124
00001e  e7fa              B        |L1.22|
;;;126    
                          ENDP

                  |L1.32|
000020  5352435c          DCB      "SRC\\System\\fsl_ft5406.c",0
000024  53797374
000028  656d5c66
00002c  736c5f66
000030  74353430
000034  362e6300
                  |L1.56|
000038  68616e64          DCB      "handle",0
00003c  6c6500  
00003f  00                DCB      0

                          AREA ||i.FT5406_GetMultiTouch||, CODE, READONLY, ALIGN=1

                  FT5406_GetMultiTouch PROC
;;;172    
;;;173    status_t FT5406_GetMultiTouch(ft5406_handle_t *handle, int *touch_count, touch_point_t touch_array[FT5406_MAX_TOUCHES])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;174    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;175        status_t status;
;;;176    
;;;177        status = FT5406_ReadTouchData(handle);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FT5406_ReadTouchData
000010  4606              MOV      r6,r0
;;;178    
;;;179        if (status == kStatus_Success)
000012  2e00              CMP      r6,#0
000014  d164              BNE      |L2.224|
;;;180        {
;;;181            ft5406_touch_data_t *touch_data = (ft5406_touch_data_t *)(void *)(handle->touch_buf);
000016  f107011c          ADD      r1,r7,#0x1c
;;;182            int i;
;;;183    
;;;184            /* Decode number of touches */
;;;185            if (touch_count)
00001a  b10d              CBZ      r5,|L2.32|
;;;186            {
;;;187                *touch_count = touch_data->TD_STATUS;
00001c  784a              LDRB     r2,[r1,#1]
00001e  602a              STR      r2,[r5,#0]
                  |L2.32|
;;;188            }
;;;189    
;;;190            /* Decode valid touch points */
;;;191            for (i = 0; i < touch_data->TD_STATUS; i++)
000020  2000              MOVS     r0,#0
000022  e03f              B        |L2.164|
                  |L2.36|
;;;192            {
;;;193                touch_array[i].TOUCH_ID = TOUCH_POINT_GET_ID(touch_data->TOUCH[i]);
000024  eb000340          ADD      r3,r0,r0,LSL #1
000028  1c8a              ADDS     r2,r1,#2
00002a  eb020243          ADD      r2,r2,r3,LSL #1
00002e  7892              LDRB     r2,[r2,#2]
000030  1112              ASRS     r2,r2,#4
000032  eb000340          ADD      r3,r0,r0,LSL #1
000036  eb040343          ADD      r3,r4,r3,LSL #1
00003a  705a              STRB     r2,[r3,#1]
;;;194                touch_array[i].TOUCH_EVENT = TOUCH_POINT_GET_EVENT(touch_data->TOUCH[i]);
00003c  eb000340          ADD      r3,r0,r0,LSL #1
000040  1c8a              ADDS     r2,r1,#2
000042  f8122013          LDRB     r2,[r2,r3,LSL #1]
000046  1192              ASRS     r2,r2,#6
000048  eb000340          ADD      r3,r0,r0,LSL #1
00004c  f8042013          STRB     r2,[r4,r3,LSL #1]
;;;195                touch_array[i].TOUCH_X = TOUCH_POINT_GET_X(touch_data->TOUCH[i]);
000050  eb000340          ADD      r3,r0,r0,LSL #1
000054  1c8a              ADDS     r2,r1,#2
000056  eb020243          ADD      r2,r2,r3,LSL #1
00005a  7853              LDRB     r3,[r2,#1]
00005c  eb000c40          ADD      r12,r0,r0,LSL #1
000060  1c8a              ADDS     r2,r1,#2
000062  f812201c          LDRB     r2,[r2,r12,LSL #1]
000066  f002020f          AND      r2,r2,#0xf
00006a  ea432202          ORR      r2,r3,r2,LSL #8
00006e  eb000340          ADD      r3,r0,r0,LSL #1
000072  eb040343          ADD      r3,r4,r3,LSL #1
000076  805a              STRH     r2,[r3,#2]
;;;196                touch_array[i].TOUCH_Y = TOUCH_POINT_GET_Y(touch_data->TOUCH[i]);
000078  eb000340          ADD      r3,r0,r0,LSL #1
00007c  1c8a              ADDS     r2,r1,#2
00007e  eb020243          ADD      r2,r2,r3,LSL #1
000082  78d3              LDRB     r3,[r2,#3]
000084  eb000c40          ADD      r12,r0,r0,LSL #1
000088  1c8a              ADDS     r2,r1,#2
00008a  eb02024c          ADD      r2,r2,r12,LSL #1
00008e  7892              LDRB     r2,[r2,#2]
000090  f002020f          AND      r2,r2,#0xf
000094  ea432202          ORR      r2,r3,r2,LSL #8
000098  eb000340          ADD      r3,r0,r0,LSL #1
00009c  eb040343          ADD      r3,r4,r3,LSL #1
0000a0  809a              STRH     r2,[r3,#4]
0000a2  1c40              ADDS     r0,r0,#1              ;191
                  |L2.164|
0000a4  784a              LDRB     r2,[r1,#1]            ;191
0000a6  4282              CMP      r2,r0                 ;191
0000a8  dcbc              BGT      |L2.36|
;;;197            }
;;;198    
;;;199            /* Clear vacant elements of touch_array */
;;;200            for (; i < FT5406_MAX_TOUCHES; i++)
0000aa  e016              B        |L2.218|
                  |L2.172|
;;;201            {
;;;202                touch_array[i].TOUCH_ID = 0;
0000ac  2200              MOVS     r2,#0
0000ae  eb000340          ADD      r3,r0,r0,LSL #1
0000b2  eb040343          ADD      r3,r4,r3,LSL #1
0000b6  705a              STRB     r2,[r3,#1]
;;;203                touch_array[i].TOUCH_EVENT = kTouch_Reserved;
0000b8  2203              MOVS     r2,#3
0000ba  eb000340          ADD      r3,r0,r0,LSL #1
0000be  f8042013          STRB     r2,[r4,r3,LSL #1]
;;;204                touch_array[i].TOUCH_X = 0;
0000c2  2200              MOVS     r2,#0
0000c4  eb000340          ADD      r3,r0,r0,LSL #1
0000c8  eb040343          ADD      r3,r4,r3,LSL #1
0000cc  805a              STRH     r2,[r3,#2]
;;;205                touch_array[i].TOUCH_Y = 0;
0000ce  eb000340          ADD      r3,r0,r0,LSL #1
0000d2  eb040343          ADD      r3,r4,r3,LSL #1
0000d6  809a              STRH     r2,[r3,#4]
0000d8  1c40              ADDS     r0,r0,#1              ;200
                  |L2.218|
0000da  2805              CMP      r0,#5                 ;200
0000dc  d3e6              BCC      |L2.172|
;;;206            }
;;;207        }
0000de  bf00              NOP      
                  |L2.224|
;;;208    
;;;209        return status;
0000e0  4630              MOV      r0,r6
;;;210    }
0000e2  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.FT5406_GetSingleTouch||, CODE, READONLY, ALIGN=1

                  FT5406_GetSingleTouch PROC
;;;138    
;;;139    status_t FT5406_GetSingleTouch(ft5406_handle_t *handle, touch_event_t *touch_event, int *touch_x, int *touch_y)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;140    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;141        status_t status;
;;;142        touch_event_t touch_event_local;
;;;143    
;;;144        status = FT5406_ReadTouchData(handle);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FT5406_ReadTouchData
000012  4607              MOV      r7,r0
;;;145    
;;;146        if (status == kStatus_Success)
000014  b9e7              CBNZ     r7,|L3.80|
;;;147        {
;;;148            ft5406_touch_data_t *touch_data = (ft5406_touch_data_t *)(void *)(handle->touch_buf);
000016  f108001c          ADD      r0,r8,#0x1c
;;;149    
;;;150            if (touch_event == NULL)
00001a  b904              CBNZ     r4,|L3.30|
;;;151            {
;;;152                touch_event = &touch_event_local;
00001c  466c              MOV      r4,sp
                  |L3.30|
;;;153            }
;;;154            *touch_event = TOUCH_POINT_GET_EVENT(touch_data->TOUCH[0]);
00001e  7881              LDRB     r1,[r0,#2]
000020  1189              ASRS     r1,r1,#6
000022  7021              STRB     r1,[r4,#0]
;;;155    
;;;156            /* Update coordinates only if there is touch detected */
;;;157            if ((*touch_event == kTouch_Down) || (*touch_event == kTouch_Contact))
000024  7821              LDRB     r1,[r4,#0]
000026  b111              CBZ      r1,|L3.46|
000028  7821              LDRB     r1,[r4,#0]
00002a  2902              CMP      r1,#2
00002c  d10f              BNE      |L3.78|
                  |L3.46|
;;;158            {
;;;159                if (touch_x)
00002e  b135              CBZ      r5,|L3.62|
;;;160                {
;;;161                    *touch_x = TOUCH_POINT_GET_X(touch_data->TOUCH[0]);
000030  78c1              LDRB     r1,[r0,#3]
000032  7882              LDRB     r2,[r0,#2]
000034  f002020f          AND      r2,r2,#0xf
000038  ea412102          ORR      r1,r1,r2,LSL #8
00003c  6029              STR      r1,[r5,#0]
                  |L3.62|
;;;162                }
;;;163                if (touch_y)
00003e  b136              CBZ      r6,|L3.78|
;;;164                {
;;;165                    *touch_y = TOUCH_POINT_GET_Y(touch_data->TOUCH[0]);
000040  7942              LDRB     r2,[r0,#5]
000042  7901              LDRB     r1,[r0,#4]
000044  f001010f          AND      r1,r1,#0xf
000048  ea422101          ORR      r1,r2,r1,LSL #8
00004c  6031              STR      r1,[r6,#0]
                  |L3.78|
;;;166                }
;;;167            }
;;;168        }
00004e  bf00              NOP      
                  |L3.80|
;;;169    
;;;170        return status;
000050  4638              MOV      r0,r7
;;;171    }
000052  e8bd83f8          POP      {r3-r9,pc}
;;;172    
                          ENDP


                          AREA ||i.FT5406_Init||, CODE, READONLY, ALIGN=2

                  FT5406_Init PROC
;;;56     
;;;57     status_t FT5406_Init(ft5406_handle_t *handle, I2C_Type *base)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;58     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;59         i2c_master_transfer_t *xfer = &(handle->xfer);
000008  1d2c              ADDS     r4,r5,#4
;;;60         status_t status;
;;;61         uint8_t mode;
;;;62     
;;;63         assert(handle);
00000a  b105              CBZ      r5,|L4.14|
00000c  e004              B        |L4.24|
                  |L4.14|
00000e  223f              MOVS     r2,#0x3f
000010  a125              ADR      r1,|L4.168|
000012  a02b              ADR      r0,|L4.192|
000014  f7fffffe          BL       __aeabi_assert
                  |L4.24|
;;;64         assert(base);
000018  b106              CBZ      r6,|L4.28|
00001a  e004              B        |L4.38|
                  |L4.28|
00001c  2240              MOVS     r2,#0x40
00001e  a122              ADR      r1,|L4.168|
000020  a029              ADR      r0,|L4.200|
000022  f7fffffe          BL       __aeabi_assert
                  |L4.38|
;;;65     
;;;66     	
;;;67     	 i2c_master_config_t masterConfig;
;;;68     
;;;69         I2C_MasterGetDefaultConfig(&masterConfig);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       I2C_MasterGetDefaultConfig
;;;70     
;;;71         /* Change the default baudrate configuration */
;;;72         masterConfig.baudRate_Bps = 100000;
00002c  4828              LDR      r0,|L4.208|
00002e  9001              STR      r0,[sp,#4]
;;;73     
;;;74     	 CLOCK_AttachClk(kFRO12M_to_FLEXCOMM2);
000030  f44f7087          MOV      r0,#0x10e
000034  f7fffffe          BL       CLOCK_AttachClk
;;;75     	
;;;76         /* Initialize the I2C master peripheral */
;;;77         I2C_MasterInit(base, &masterConfig, 12000000);
000038  4a26              LDR      r2,|L4.212|
00003a  4669              MOV      r1,sp
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       I2C_MasterInit
;;;78     	
;;;79         if (!handle || !base)
000042  b105              CBZ      r5,|L4.70|
000044  b91e              CBNZ     r6,|L4.78|
                  |L4.70|
;;;80         {
;;;81             return kStatus_InvalidArgument;
000046  2004              MOVS     r0,#4
                  |L4.72|
;;;82         }
;;;83     
;;;84         handle->base = base;
;;;85     
;;;86         /* clear transfer structure and buffer */
;;;87         memset(xfer, 0, sizeof(*xfer));
;;;88         memset(handle->touch_buf, 0, FT5406_TOUCH_DATA_LEN);
;;;89     
;;;90         /* set device mode to normal operation */
;;;91         mode = 0;
;;;92         xfer->slaveAddress = 0x38;
;;;93         xfer->direction = kI2C_Write;
;;;94         xfer->subaddress = 0;
;;;95         xfer->subaddressSize = 1;
;;;96         xfer->data = &mode;
;;;97         xfer->dataSize = 1;
;;;98         xfer->flags = kI2C_TransferDefaultFlag;
;;;99     
;;;100        status = I2C_MasterTransferBlocking(handle->base, &handle->xfer);
;;;101    
;;;102        /* prepare transfer structure for reading touch data */
;;;103        xfer->slaveAddress = 0x38;
;;;104        xfer->direction = kI2C_Read;
;;;105        xfer->subaddress = 1;
;;;106        xfer->subaddressSize = 1;
;;;107        xfer->data = handle->touch_buf;
;;;108        xfer->dataSize = FT5406_TOUCH_DATA_LEN;
;;;109        xfer->flags = kI2C_TransferDefaultFlag;
;;;110    
;;;111        return status;
;;;112    }
000048  b004              ADD      sp,sp,#0x10
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.78|
00004e  602e              STR      r6,[r5,#0]            ;84
000050  2118              MOVS     r1,#0x18              ;87
000052  4620              MOV      r0,r4                 ;87
000054  f7fffffe          BL       __aeabi_memclr4
000058  2120              MOVS     r1,#0x20              ;88
00005a  f105001c          ADD      r0,r5,#0x1c           ;88
00005e  f7fffffe          BL       __aeabi_memclr4
000062  2000              MOVS     r0,#0                 ;91
000064  9003              STR      r0,[sp,#0xc]          ;91
000066  2038              MOVS     r0,#0x38              ;92
000068  80a0              STRH     r0,[r4,#4]            ;92
00006a  2000              MOVS     r0,#0                 ;93
00006c  71a0              STRB     r0,[r4,#6]            ;93
00006e  60a0              STR      r0,[r4,#8]            ;94
000070  2001              MOVS     r0,#1                 ;95
000072  60e0              STR      r0,[r4,#0xc]          ;95
000074  a803              ADD      r0,sp,#0xc            ;96
000076  6120              STR      r0,[r4,#0x10]         ;96
000078  2001              MOVS     r0,#1                 ;97
00007a  6160              STR      r0,[r4,#0x14]         ;97
00007c  2000              MOVS     r0,#0                 ;98
00007e  6020              STR      r0,[r4,#0]            ;98
000080  1d29              ADDS     r1,r5,#4              ;100
000082  6828              LDR      r0,[r5,#0]            ;100
000084  f7fffffe          BL       I2C_MasterTransferBlocking
000088  4607              MOV      r7,r0                 ;100
00008a  2038              MOVS     r0,#0x38              ;103
00008c  80a0              STRH     r0,[r4,#4]            ;103
00008e  2001              MOVS     r0,#1                 ;104
000090  71a0              STRB     r0,[r4,#6]            ;104
000092  60a0              STR      r0,[r4,#8]            ;105
000094  60e0              STR      r0,[r4,#0xc]          ;106
000096  f105001c          ADD      r0,r5,#0x1c           ;107
00009a  6120              STR      r0,[r4,#0x10]         ;107
00009c  2020              MOVS     r0,#0x20              ;108
00009e  6160              STR      r0,[r4,#0x14]         ;108
0000a0  2000              MOVS     r0,#0                 ;109
0000a2  6020              STR      r0,[r4,#0]            ;109
0000a4  4638              MOV      r0,r7                 ;111
0000a6  e7cf              B        |L4.72|
;;;113    
                          ENDP

                  |L4.168|
0000a8  5352435c          DCB      "SRC\\System\\fsl_ft5406.c",0
0000ac  53797374
0000b0  656d5c66
0000b4  736c5f66
0000b8  74353430
0000bc  362e6300
                  |L4.192|
0000c0  68616e64          DCB      "handle",0
0000c4  6c6500  
0000c7  00                DCB      0
                  |L4.200|
0000c8  62617365          DCB      "base",0
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L4.208|
                          DCD      0x000186a0
                  |L4.212|
                          DCD      0x00b71b00

                          AREA ||i.FT5406_ReadTouchData||, CODE, READONLY, ALIGN=2

                  FT5406_ReadTouchData PROC
;;;126    
;;;127    status_t FT5406_ReadTouchData(ft5406_handle_t *handle)
000000  b510              PUSH     {r4,lr}
;;;128    {
000002  4604              MOV      r4,r0
;;;129        assert(handle);
000004  b104              CBZ      r4,|L5.8|
000006  e004              B        |L5.18|
                  |L5.8|
000008  2281              MOVS     r2,#0x81
00000a  a106              ADR      r1,|L5.36|
00000c  a00b              ADR      r0,|L5.60|
00000e  f7fffffe          BL       __aeabi_assert
                  |L5.18|
;;;130    
;;;131        if (!handle)
000012  b90c              CBNZ     r4,|L5.24|
;;;132        {
;;;133            return kStatus_InvalidArgument;
000014  2004              MOVS     r0,#4
                  |L5.22|
;;;134        }
;;;135    
;;;136        return I2C_MasterTransferBlocking(handle->base, &handle->xfer);
;;;137    }
000016  bd10              POP      {r4,pc}
                  |L5.24|
000018  1d21              ADDS     r1,r4,#4              ;136
00001a  6820              LDR      r0,[r4,#0]            ;136
00001c  f7fffffe          BL       I2C_MasterTransferBlocking
000020  e7f9              B        |L5.22|
;;;138    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
000024  5352435c          DCB      "SRC\\System\\fsl_ft5406.c",0
000028  53797374
00002c  656d5c66
000030  736c5f66
000034  74353430
000038  362e6300
                  |L5.60|
00003c  68616e64          DCB      "handle",0
000040  6c6500  
000043  00                DCB      0

;*** Start embedded assembler ***

#line 1 "SRC\\System\\fsl_ft5406.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ft5406_c_07a511c6____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_fsl_ft5406_c_07a511c6____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ft5406_c_07a511c6____REVSH|
#line 402
|__asm___12_fsl_ft5406_c_07a511c6____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ft5406_c_07a511c6____RRX|
#line 587
|__asm___12_fsl_ft5406_c_07a511c6____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
