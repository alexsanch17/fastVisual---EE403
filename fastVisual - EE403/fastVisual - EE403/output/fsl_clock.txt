; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_clock.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_clock.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_clock.crf SRC\Drivers\fsl_clock.c]
                          THUMB

                          AREA ||i.CLOCK_AttachClk||, CODE, READONLY, ALIGN=2

                  CLOCK_AttachClk PROC
;;;168    /* Clock Selection for IP */
;;;169    void CLOCK_AttachClk(clock_attach_id_t connection)
000000  b5f0              PUSH     {r4-r7,lr}
;;;170    {
;;;171        bool final_descriptor = false;
000002  2400              MOVS     r4,#0
;;;172        uint8_t mux;
;;;173        uint8_t pos;
;;;174        uint32_t i;
;;;175        volatile uint32_t *pClkSel;
;;;176    
;;;177        pClkSel = &(SYSCON->MAINCLKSELA);
000004  4d0f              LDR      r5,|L1.68|
;;;178    
;;;179        for (i = 0U; (i <= 2U) && (!final_descriptor); i++)
000006  2300              MOVS     r3,#0
000008  e016              B        |L1.56|
                  |L1.10|
;;;180        {
;;;181            connection = (clock_attach_id_t)(connection >> (i * 12U)); /*!<  pick up next descriptor */
00000a  eb030643          ADD      r6,r3,r3,LSL #1
00000e  00b6              LSLS     r6,r6,#2
000010  40f0              LSRS     r0,r0,r6
;;;182            mux = (uint8_t)connection;
000012  b2c1              UXTB     r1,r0
;;;183            if (connection)
000014  b170              CBZ      r0,|L1.52|
;;;184            {
;;;185                pos = ((connection & 0xf00U) >> 8U) - 1U;
000016  f3c02603          UBFX     r6,r0,#8,#4
00001a  1e76              SUBS     r6,r6,#1
00001c  b2f2              UXTB     r2,r6
;;;186                if (mux == CM_ASYNCAPB)
00001e  291f              CMP      r1,#0x1f
000020  d105              BNE      |L1.46|
;;;187                {
;;;188                    SYSCON->ASYNCAPBCTRL = SYSCON_ASYNCAPBCTRL_ENABLE(1);
000022  2601              MOVS     r6,#1
000024  07b7              LSLS     r7,r6,#30
000026  64fe              STR      r6,[r7,#0x4c]
;;;189                    ASYNC_SYSCON->ASYNCAPBCLKSELA = pos;
000028  4e07              LDR      r6,|L1.72|
00002a  6232              STR      r2,[r6,#0x20]
00002c  e003              B        |L1.54|
                  |L1.46|
;;;190                }
;;;191                else
;;;192                {
;;;193                    pClkSel[mux] = pos;
00002e  f8452021          STR      r2,[r5,r1,LSL #2]
000032  e000              B        |L1.54|
                  |L1.52|
;;;194                }
;;;195            }
;;;196            else
;;;197            {
;;;198                final_descriptor = true;
000034  2401              MOVS     r4,#1
                  |L1.54|
000036  1c5b              ADDS     r3,r3,#1              ;179
                  |L1.56|
000038  2b02              CMP      r3,#2                 ;179
00003a  d801              BHI      |L1.64|
00003c  2c00              CMP      r4,#0                 ;179
00003e  d0e4              BEQ      |L1.10|
                  |L1.64|
;;;199            }
;;;200        }
;;;201    }
000040  bdf0              POP      {r4-r7,pc}
;;;202    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x40000280
                  |L1.72|
                          DCD      0x40040000

                          AREA ||i.CLOCK_DisableClock||, CODE, READONLY, ALIGN=2

                  CLOCK_DisableClock PROC
;;;719    
;;;720    static inline void CLOCK_DisableClock(clock_ip_name_t clk)
000000  0a01              LSRS     r1,r0,#8
;;;721    {
;;;722        uint32_t index = CLK_GATE_ABSTRACT_REG_OFFSET(clk);
;;;723        if (index < 3)
000002  2903              CMP      r1,#3
000004  d205              BCS      |L2.18|
;;;724        {
;;;725            SYSCON->AHBCLKCTRLCLR[index] = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
000006  2201              MOVS     r2,#1
000008  4082              LSLS     r2,r2,r0
00000a  4b06              LDR      r3,|L2.36|
00000c  f8432021          STR      r2,[r3,r1,LSL #2]
000010  e006              B        |L2.32|
                  |L2.18|
;;;726        }
;;;727        else
;;;728        {
;;;729            ASYNC_SYSCON->ASYNCAPBCLKCTRLCLR = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
000012  2201              MOVS     r2,#1
000014  4082              LSLS     r2,r2,r0
000016  4b04              LDR      r3,|L2.40|
000018  619a              STR      r2,[r3,#0x18]
;;;730            SYSCON->ASYNCAPBCTRL = SYSCON_ASYNCAPBCTRL_ENABLE(0);
00001a  2200              MOVS     r2,#0
00001c  031b              LSLS     r3,r3,#12
00001e  64da              STR      r2,[r3,#0x4c]
                  |L2.32|
;;;731    
;;;732        }
;;;733    }
000020  4770              BX       lr
;;;734    /**
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x40000240
                  |L2.40|
                          DCD      0x40040000

                          AREA ||i.CLOCK_EnableClock||, CODE, READONLY, ALIGN=2

                  CLOCK_EnableClock PROC
;;;705    
;;;706    static inline void CLOCK_EnableClock(clock_ip_name_t clk)
000000  0a01              LSRS     r1,r0,#8
;;;707    {
;;;708        uint32_t index = CLK_GATE_ABSTRACT_REG_OFFSET(clk);
;;;709        if (index < 3)
000002  2903              CMP      r1,#3
000004  d205              BCS      |L3.18|
;;;710        {
;;;711            SYSCON->AHBCLKCTRLSET[index] = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
000006  2201              MOVS     r2,#1
000008  4082              LSLS     r2,r2,r0
00000a  4b05              LDR      r3,|L3.32|
00000c  f8432021          STR      r2,[r3,r1,LSL #2]
000010  e005              B        |L3.30|
                  |L3.18|
;;;712        }
;;;713        else
;;;714        {
;;;715            SYSCON->ASYNCAPBCTRL = SYSCON_ASYNCAPBCTRL_ENABLE(1);
000012  2201              MOVS     r2,#1
000014  0793              LSLS     r3,r2,#30
000016  64da              STR      r2,[r3,#0x4c]
;;;716            ASYNC_SYSCON->ASYNCAPBCLKCTRLSET = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
000018  4082              LSLS     r2,r2,r0
00001a  4b02              LDR      r3,|L3.36|
00001c  615a              STR      r2,[r3,#0x14]
                  |L3.30|
;;;717        }
;;;718    }
00001e  4770              BX       lr
;;;719    
                          ENDP

                  |L3.32|
                          DCD      0x40000220
                  |L3.36|
                          DCD      0x40040000

                          AREA ||i.CLOCK_EnableUsbfs0DeviceClock||, CODE, READONLY, ALIGN=2

                  CLOCK_EnableUsbfs0DeviceClock PROC
;;;1773   /* Enable USB DEVICE FULL SPEED clock */
;;;1774   bool CLOCK_EnableUsbfs0DeviceClock(clock_usb_src_t src, uint32_t freq)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1775   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1776       bool ret = true;
000006  2601              MOVS     r6,#1
;;;1777   
;;;1778       CLOCK_DisableClock(kCLOCK_Usbd0);
000008  f2401019          MOV      r0,#0x119
00000c  f7fffffe          BL       CLOCK_DisableClock
;;;1779   
;;;1780       if (kCLOCK_UsbSrcFro == src)
000010  2c03              CMP      r4,#3
000012  d121              BNE      |L4.88|
;;;1781       {
;;;1782           switch (freq)
000014  4823              LDR      r0,|L4.164|
000016  4428              ADD      r0,r0,r5
000018  b140              CBZ      r0,|L4.44|
00001a  4922              LDR      r1,|L4.164|
00001c  4408              ADD      r0,r0,r1
00001e  b958              CBNZ     r0,|L4.56|
;;;1783           {
;;;1784               case 96000000U:
;;;1785                   CLOCK_SetClkDiv(kCLOCK_DivUsb0Clk, 2, false); /*!< Div by 2 to get 48MHz, no divider reset */
000020  2200              MOVS     r2,#0
000022  2102              MOVS     r1,#2
000024  2026              MOVS     r0,#0x26
000026  f7fffffe          BL       CLOCK_SetClkDiv
;;;1786                   break;
00002a  e007              B        |L4.60|
                  |L4.44|
;;;1787               
;;;1788               case 48000000U:
;;;1789                   CLOCK_SetClkDiv(kCLOCK_DivUsb0Clk, 1, false); /*!< Div by 1 to get 48MHz, no divider reset */
00002c  2200              MOVS     r2,#0
00002e  2101              MOVS     r1,#1
000030  2026              MOVS     r0,#0x26
000032  f7fffffe          BL       CLOCK_SetClkDiv
;;;1790                   break;
000036  e001              B        |L4.60|
                  |L4.56|
;;;1791               
;;;1792               default:
;;;1793                   ret = false;
000038  2600              MOVS     r6,#0
;;;1794                   break;
00003a  bf00              NOP      
                  |L4.60|
00003c  bf00              NOP                            ;1786
;;;1795           }
;;;1796           /* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
;;;1797           SYSCON->FROCTRL = (SYSCON->FROCTRL & ~((0x01U << 15U) | (0xFU << 26U))) | SYSCON_FROCTRL_HSPDCLK_MASK |
00003e  481a              LDR      r0,|L4.168|
000040  6800              LDR      r0,[r0,#0]
000042  491a              LDR      r1,|L4.172|
000044  4008              ANDS     r0,r0,r1
000046  f0404082          ORR      r0,r0,#0x41000000
00004a  4917              LDR      r1,|L4.168|
00004c  6008              STR      r0,[r1,#0]
;;;1798                             SYSCON_FROCTRL_USBCLKADJ_MASK;
;;;1799           /* Select FRO 96 or 48 MHz */
;;;1800           CLOCK_AttachClk(kFRO_HF_to_USB0_CLK);
00004e  f44f7085          MOV      r0,#0x10a
000052  f7fffffe          BL       CLOCK_AttachClk
000056  e01b              B        |L4.144|
                  |L4.88|
;;;1801       }
;;;1802       else
;;;1803       {
;;;1804           /*Set the USB PLL as the Usb0 CLK*/
;;;1805           POWER_DisablePD(kPDRUNCFG_PD_USB_PLL);
000058  f2401001          MOV      r0,#0x101
00005c  f7fffffe          BL       POWER_DisablePD
;;;1806       
;;;1807           usb_pll_setup_t pll_setup = { 0x3FU, 0x01U, 0x03U, false, false, false, 12000000U };
000060  4a13              LDR      r2,|L4.176|
000062  ca07              LDM      r2,{r0-r2}
000064  e88d0007          STM      sp,{r0-r2}
;;;1808   
;;;1809           CLOCK_SetUsbPLLFreq(&pll_setup);
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       CLOCK_SetUsbPLLFreq
;;;1810           CLOCK_SetClkDiv(kCLOCK_DivUsb0Clk,1U, false);
00006e  2200              MOVS     r2,#0
000070  2101              MOVS     r1,#1
000072  2026              MOVS     r0,#0x26
000074  f7fffffe          BL       CLOCK_SetClkDiv
;;;1811           CLOCK_AttachClk(kUSB_PLL_to_USB0_CLK);
000078  f240300a          MOV      r0,#0x30a
00007c  f7fffffe          BL       CLOCK_AttachClk
;;;1812           uint32_t delay = 100000;
000080  4f0c              LDR      r7,|L4.180|
;;;1813           while (delay --)
000082  e000              B        |L4.134|
                  |L4.132|
;;;1814           {
;;;1815               __asm("nop");
000084  bf00              NOP      
                  |L4.134|
000086  1e38              SUBS     r0,r7,#0              ;1813
000088  f1a70701          SUB      r7,r7,#1              ;1813
00008c  d1fa              BNE      |L4.132|
;;;1816           }
;;;1817       }
00008e  bf00              NOP      
                  |L4.144|
;;;1818       CLOCK_EnableClock(kCLOCK_Usbd0);
000090  f2401019          MOV      r0,#0x119
000094  f7fffffe          BL       CLOCK_EnableClock
;;;1819       CLOCK_EnableClock(kCLOCK_UsbRam1);
000098  f2402006          MOV      r0,#0x206
00009c  f7fffffe          BL       CLOCK_EnableClock
;;;1820       
;;;1821       return ret;
0000a0  4630              MOV      r0,r6
;;;1822   }
0000a2  bdfe              POP      {r1-r7,pc}
;;;1823   
                          ENDP

                  |L4.164|
                          DCD      0xfd239400
                  |L4.168|
                          DCD      0x40000500
                  |L4.172|
                          DCD      0xc3ff7fff
                  |L4.176|
                          DCD      ||.constdata||+0x2c
                  |L4.180|
                          DCD      0x000186a0

                          AREA ||i.CLOCK_EnableUsbfs0HostClock||, CODE, READONLY, ALIGN=2

                  CLOCK_EnableUsbfs0HostClock PROC
;;;1824   /* Enable USB HOST FULL SPEED clock */
;;;1825   bool CLOCK_EnableUsbfs0HostClock(clock_usb_src_t src, uint32_t freq)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1826   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1827       bool ret = true;
000006  2601              MOVS     r6,#1
;;;1828   
;;;1829       CLOCK_DisableClock(kCLOCK_Usbhmr0);
000008  f44f7004          MOV      r0,#0x210
00000c  f7fffffe          BL       CLOCK_DisableClock
;;;1830       CLOCK_DisableClock(kCLOCK_Usbhsl0);
000010  f2402011          MOV      r0,#0x211
000014  f7fffffe          BL       CLOCK_DisableClock
;;;1831   
;;;1832       if (kCLOCK_UsbSrcFro == src)
000018  2c03              CMP      r4,#3
00001a  d121              BNE      |L5.96|
;;;1833       {
;;;1834           switch (freq)
00001c  4825              LDR      r0,|L5.180|
00001e  4428              ADD      r0,r0,r5
000020  b140              CBZ      r0,|L5.52|
000022  4924              LDR      r1,|L5.180|
000024  4408              ADD      r0,r0,r1
000026  b958              CBNZ     r0,|L5.64|
;;;1835           {
;;;1836               case 96000000U:
;;;1837                   CLOCK_SetClkDiv(kCLOCK_DivUsb0Clk, 2, false); /*!< Div by 2 to get 48MHz, no divider reset */
000028  2200              MOVS     r2,#0
00002a  2102              MOVS     r1,#2
00002c  2026              MOVS     r0,#0x26
00002e  f7fffffe          BL       CLOCK_SetClkDiv
;;;1838                   break;
000032  e007              B        |L5.68|
                  |L5.52|
;;;1839               
;;;1840               case 48000000U:
;;;1841                   CLOCK_SetClkDiv(kCLOCK_DivUsb0Clk, 1, false); /*!< Div by 1 to get 48MHz, no divider reset */
000034  2200              MOVS     r2,#0
000036  2101              MOVS     r1,#1
000038  2026              MOVS     r0,#0x26
00003a  f7fffffe          BL       CLOCK_SetClkDiv
;;;1842                   break;
00003e  e001              B        |L5.68|
                  |L5.64|
;;;1843               
;;;1844               default:
;;;1845                   ret = false;
000040  2600              MOVS     r6,#0
;;;1846                   break;
000042  bf00              NOP      
                  |L5.68|
000044  bf00              NOP                            ;1838
;;;1847           }
;;;1848           /* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
;;;1849           SYSCON->FROCTRL = (SYSCON->FROCTRL & ~((0x01U << 15U) | (0xFU << 26U))) | SYSCON_FROCTRL_HSPDCLK_MASK |
000046  481c              LDR      r0,|L5.184|
000048  6800              LDR      r0,[r0,#0]
00004a  491c              LDR      r1,|L5.188|
00004c  4008              ANDS     r0,r0,r1
00004e  f0404082          ORR      r0,r0,#0x41000000
000052  4919              LDR      r1,|L5.184|
000054  6008              STR      r0,[r1,#0]
;;;1850                             SYSCON_FROCTRL_USBCLKADJ_MASK;
;;;1851           /* Select FRO 96 or 48 MHz */
;;;1852           CLOCK_AttachClk(kFRO_HF_to_USB0_CLK);
000056  f44f7085          MOV      r0,#0x10a
00005a  f7fffffe          BL       CLOCK_AttachClk
00005e  e01b              B        |L5.152|
                  |L5.96|
;;;1853       }
;;;1854       else
;;;1855       {
;;;1856           /*Set the USB PLL as the Usb0 CLK*/
;;;1857           POWER_DisablePD(kPDRUNCFG_PD_USB_PLL);
000060  f2401001          MOV      r0,#0x101
000064  f7fffffe          BL       POWER_DisablePD
;;;1858       
;;;1859           usb_pll_setup_t pll_setup = { 0x3FU, 0x01U, 0x03U, false, false, false, 12000000U };
000068  4a15              LDR      r2,|L5.192|
00006a  ca07              LDM      r2,{r0-r2}
00006c  e88d0007          STM      sp,{r0-r2}
;;;1860   
;;;1861           CLOCK_SetUsbPLLFreq(&pll_setup);
000070  4668              MOV      r0,sp
000072  f7fffffe          BL       CLOCK_SetUsbPLLFreq
;;;1862           CLOCK_SetClkDiv(kCLOCK_DivUsb0Clk,1U, false);
000076  2200              MOVS     r2,#0
000078  2101              MOVS     r1,#1
00007a  2026              MOVS     r0,#0x26
00007c  f7fffffe          BL       CLOCK_SetClkDiv
;;;1863           CLOCK_AttachClk(kUSB_PLL_to_USB0_CLK);
000080  f240300a          MOV      r0,#0x30a
000084  f7fffffe          BL       CLOCK_AttachClk
;;;1864           uint32_t delay = 100000;
000088  4f0e              LDR      r7,|L5.196|
;;;1865           while (delay --)
00008a  e000              B        |L5.142|
                  |L5.140|
;;;1866           {
;;;1867               __asm("nop");
00008c  bf00              NOP      
                  |L5.142|
00008e  1e38              SUBS     r0,r7,#0              ;1865
000090  f1a70701          SUB      r7,r7,#1              ;1865
000094  d1fa              BNE      |L5.140|
;;;1868           }
;;;1869       }
000096  bf00              NOP      
                  |L5.152|
;;;1870       CLOCK_EnableClock(kCLOCK_Usbhmr0);
000098  f44f7004          MOV      r0,#0x210
00009c  f7fffffe          BL       CLOCK_EnableClock
;;;1871       CLOCK_EnableClock(kCLOCK_Usbhsl0);
0000a0  f2402011          MOV      r0,#0x211
0000a4  f7fffffe          BL       CLOCK_EnableClock
;;;1872       CLOCK_EnableClock(kCLOCK_UsbRam1); 
0000a8  f2402006          MOV      r0,#0x206
0000ac  f7fffffe          BL       CLOCK_EnableClock
;;;1873   
;;;1874       return ret;
0000b0  4630              MOV      r0,r6
;;;1875   }
0000b2  bdfe              POP      {r1-r7,pc}
;;;1876   
                          ENDP

                  |L5.180|
                          DCD      0xfd239400
                  |L5.184|
                          DCD      0x40000500
                  |L5.188|
                          DCD      0xc3ff7fff
                  |L5.192|
                          DCD      ||.constdata||+0x38
                  |L5.196|
                          DCD      0x000186a0

                          AREA ||i.CLOCK_EnableUsbhs0DeviceClock||, CODE, READONLY, ALIGN=2

                  CLOCK_EnableUsbhs0DeviceClock PROC
;;;1877   /* Enable USB DEVICE HIGH SPEED clock */
;;;1878   bool CLOCK_EnableUsbhs0DeviceClock(clock_usb_src_t src, uint32_t freq)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1879   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1880       bool ret = true;
000006  2701              MOVS     r7,#1
;;;1881       uint32_t delay;
;;;1882       CLOCK_DisableClock(kCLOCK_Usbd1);
000008  f2402005          MOV      r0,#0x205
00000c  f7fffffe          BL       CLOCK_DisableClock
;;;1883       /* Power on the VD5 for USB PHY */    
;;;1884       POWER_SetUsbPhy();
000010  f7fffffe          BL       POWER_SetUsbPhy
;;;1885       if (kCLOCK_UsbSrcFro == src)
000014  2d03              CMP      r5,#3
000016  d121              BNE      |L6.92|
;;;1886       {
;;;1887           switch (freq)
000018  4827              LDR      r0,|L6.184|
00001a  4430              ADD      r0,r0,r6
00001c  b140              CBZ      r0,|L6.48|
00001e  4926              LDR      r1,|L6.184|
000020  4408              ADD      r0,r0,r1
000022  b958              CBNZ     r0,|L6.60|
;;;1888           {
;;;1889               case 96000000U:
;;;1890                   CLOCK_SetClkDiv(kCLOCK_DivUsb1Clk, 2, false); /*!< Div by 2 to get 48MHz, no divider reset */
000024  2200              MOVS     r2,#0
000026  2102              MOVS     r1,#2
000028  2027              MOVS     r0,#0x27
00002a  f7fffffe          BL       CLOCK_SetClkDiv
;;;1891                   break;
00002e  e007              B        |L6.64|
                  |L6.48|
;;;1892               
;;;1893               case 48000000U:
;;;1894                   CLOCK_SetClkDiv(kCLOCK_DivUsb1Clk, 1, false); /*!< Div by 1 to get 48MHz, no divider reset */
000030  2200              MOVS     r2,#0
000032  2101              MOVS     r1,#1
000034  2027              MOVS     r0,#0x27
000036  f7fffffe          BL       CLOCK_SetClkDiv
;;;1895                   break;
00003a  e001              B        |L6.64|
                  |L6.60|
;;;1896               
;;;1897               default:
;;;1898                   ret = false;
00003c  2700              MOVS     r7,#0
;;;1899                   break;
00003e  bf00              NOP      
                  |L6.64|
000040  bf00              NOP                            ;1891
;;;1900           }
;;;1901           /* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
;;;1902           SYSCON->FROCTRL = (SYSCON->FROCTRL & ~((0x01U << 15U) | (0xFU << 26U))) | SYSCON_FROCTRL_HSPDCLK_MASK |
000042  481e              LDR      r0,|L6.188|
000044  6800              LDR      r0,[r0,#0]
000046  491e              LDR      r1,|L6.192|
000048  4008              ANDS     r0,r0,r1
00004a  f0404082          ORR      r0,r0,#0x41000000
00004e  491b              LDR      r1,|L6.188|
000050  6008              STR      r0,[r1,#0]
;;;1903                             SYSCON_FROCTRL_USBCLKADJ_MASK;
;;;1904           /* Select FRO 96 or 48 MHz */
;;;1905           CLOCK_AttachClk(kFRO_HF_to_USB1_CLK);
000052  f240100b          MOV      r0,#0x10b
000056  f7fffffe          BL       CLOCK_AttachClk
00005a  e017              B        |L6.140|
                  |L6.92|
;;;1906       }
;;;1907       else
;;;1908       {    
;;;1909           delay = 100000;
00005c  4c19              LDR      r4,|L6.196|
;;;1910           while (delay --)
00005e  e000              B        |L6.98|
                  |L6.96|
;;;1911           {
;;;1912               __asm("nop");
000060  bf00              NOP      
                  |L6.98|
000062  1e20              SUBS     r0,r4,#0              ;1910
000064  f1a40401          SUB      r4,r4,#1              ;1910
000068  d1fa              BNE      |L6.96|
;;;1913           }    
;;;1914           usb_pll_setup_t pll_setup = { 0x3FU, 0x01U, 0x03U, false, false, false, 12000000U };
00006a  4a17              LDR      r2,|L6.200|
00006c  ca07              LDM      r2,{r0-r2}
00006e  e88d0007          STM      sp,{r0-r2}
;;;1915         
;;;1916           CLOCK_SetUsbPLLFreq(&pll_setup);
000072  4668              MOV      r0,sp
000074  f7fffffe          BL       CLOCK_SetUsbPLLFreq
;;;1917           
;;;1918           /* Select USB PLL output as USB clock src */
;;;1919           CLOCK_SetClkDiv(kCLOCK_DivUsb1Clk,1U, false);
000078  2200              MOVS     r2,#0
00007a  2101              MOVS     r1,#1
00007c  2027              MOVS     r0,#0x27
00007e  f7fffffe          BL       CLOCK_SetClkDiv
;;;1920           CLOCK_AttachClk(kUSB_PLL_to_USB1_CLK);  
000082  f240300b          MOV      r0,#0x30b
000086  f7fffffe          BL       CLOCK_AttachClk
;;;1921       }
00008a  bf00              NOP      
                  |L6.140|
;;;1922   
;;;1923       delay = 100000;
00008c  4c0d              LDR      r4,|L6.196|
;;;1924       while (delay --)
00008e  e000              B        |L6.146|
                  |L6.144|
;;;1925       {
;;;1926           __asm("nop");
000090  bf00              NOP      
                  |L6.146|
000092  1e20              SUBS     r0,r4,#0              ;1924
000094  f1a40401          SUB      r4,r4,#1              ;1924
000098  d1fa              BNE      |L6.144|
;;;1927       }
;;;1928       /* Enable USB1D and USB1RAM */
;;;1929       CLOCK_EnableClock(kCLOCK_Usbd1);
00009a  f2402005          MOV      r0,#0x205
00009e  f7fffffe          BL       CLOCK_EnableClock
;;;1930       CLOCK_EnableClock(kCLOCK_UsbRam1); 
0000a2  f2402006          MOV      r0,#0x206
0000a6  f7fffffe          BL       CLOCK_EnableClock
;;;1931       POWER_DisablePD(kPDRUNCFG_PD_USB1_PHY); /* Turn on power for USB PHY */
0000aa  f44f7080          MOV      r0,#0x100
0000ae  f7fffffe          BL       POWER_DisablePD
;;;1932       return ret;
0000b2  4638              MOV      r0,r7
;;;1933   }
0000b4  bdfe              POP      {r1-r7,pc}
;;;1934   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
                          DCD      0xfd239400
                  |L6.188|
                          DCD      0x40000500
                  |L6.192|
                          DCD      0xc3ff7fff
                  |L6.196|
                          DCD      0x000186a0
                  |L6.200|
                          DCD      ||.constdata||+0x44

                          AREA ||i.CLOCK_EnableUsbhs0HostClock||, CODE, READONLY, ALIGN=2

                  CLOCK_EnableUsbhs0HostClock PROC
;;;1936   /* Enable USB HOST HIGH SPEED clock */
;;;1937   bool CLOCK_EnableUsbhs0HostClock(clock_usb_src_t src, uint32_t freq)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1938   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1939       bool ret = true;
000006  2701              MOVS     r7,#1
;;;1940       uint32_t delay;
;;;1941       CLOCK_DisableClock(kCLOCK_Usbh1);
000008  f44f7001          MOV      r0,#0x204
00000c  f7fffffe          BL       CLOCK_DisableClock
;;;1942       /* Power on the VD5 for USB PHY */    
;;;1943       POWER_SetUsbPhy();
000010  f7fffffe          BL       POWER_SetUsbPhy
;;;1944       if (kCLOCK_UsbSrcFro == src)
000014  2d03              CMP      r5,#3
000016  d121              BNE      |L7.92|
;;;1945       {
;;;1946           switch (freq)
000018  4827              LDR      r0,|L7.184|
00001a  4430              ADD      r0,r0,r6
00001c  b140              CBZ      r0,|L7.48|
00001e  4926              LDR      r1,|L7.184|
000020  4408              ADD      r0,r0,r1
000022  b958              CBNZ     r0,|L7.60|
;;;1947           {
;;;1948               case 96000000U:
;;;1949                   CLOCK_SetClkDiv(kCLOCK_DivUsb1Clk, 2, false); /*!< Div by 2 to get 48MHz, no divider reset */
000024  2200              MOVS     r2,#0
000026  2102              MOVS     r1,#2
000028  2027              MOVS     r0,#0x27
00002a  f7fffffe          BL       CLOCK_SetClkDiv
;;;1950                   break;
00002e  e007              B        |L7.64|
                  |L7.48|
;;;1951               
;;;1952               case 48000000U:
;;;1953                   CLOCK_SetClkDiv(kCLOCK_DivUsb1Clk, 1, false); /*!< Div by 1 to get 48MHz, no divider reset */
000030  2200              MOVS     r2,#0
000032  2101              MOVS     r1,#1
000034  2027              MOVS     r0,#0x27
000036  f7fffffe          BL       CLOCK_SetClkDiv
;;;1954                   break;
00003a  e001              B        |L7.64|
                  |L7.60|
;;;1955               
;;;1956               default:
;;;1957                   ret = false;
00003c  2700              MOVS     r7,#0
;;;1958                   break;
00003e  bf00              NOP      
                  |L7.64|
000040  bf00              NOP                            ;1950
;;;1959           }
;;;1960           /* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
;;;1961           SYSCON->FROCTRL = (SYSCON->FROCTRL & ~((0x01U << 15U) | (0xFU << 26U))) | SYSCON_FROCTRL_HSPDCLK_MASK |
000042  481e              LDR      r0,|L7.188|
000044  6800              LDR      r0,[r0,#0]
000046  491e              LDR      r1,|L7.192|
000048  4008              ANDS     r0,r0,r1
00004a  f0404082          ORR      r0,r0,#0x41000000
00004e  491b              LDR      r1,|L7.188|
000050  6008              STR      r0,[r1,#0]
;;;1962                             SYSCON_FROCTRL_USBCLKADJ_MASK;
;;;1963           /* Select FRO 96 or 48 MHz */
;;;1964           CLOCK_AttachClk(kFRO_HF_to_USB1_CLK);
000052  f240100b          MOV      r0,#0x10b
000056  f7fffffe          BL       CLOCK_AttachClk
00005a  e017              B        |L7.140|
                  |L7.92|
;;;1965       }
;;;1966       else
;;;1967       {
;;;1968           delay = 100000;
00005c  4c19              LDR      r4,|L7.196|
;;;1969           while (delay --)
00005e  e000              B        |L7.98|
                  |L7.96|
;;;1970           {
;;;1971               __asm("nop");
000060  bf00              NOP      
                  |L7.98|
000062  1e20              SUBS     r0,r4,#0              ;1969
000064  f1a40401          SUB      r4,r4,#1              ;1969
000068  d1fa              BNE      |L7.96|
;;;1972           }    
;;;1973           usb_pll_setup_t pll_setup = { 0x3FU, 0x01U, 0x03U, false, false, false, 12000000U };
00006a  4a17              LDR      r2,|L7.200|
00006c  ca07              LDM      r2,{r0-r2}
00006e  e88d0007          STM      sp,{r0-r2}
;;;1974   
;;;1975           CLOCK_SetUsbPLLFreq(&pll_setup);
000072  4668              MOV      r0,sp
000074  f7fffffe          BL       CLOCK_SetUsbPLLFreq
;;;1976           
;;;1977           /* Select USB PLL output as USB clock src */
;;;1978           CLOCK_SetClkDiv(kCLOCK_DivUsb1Clk,1U, false);
000078  2200              MOVS     r2,#0
00007a  2101              MOVS     r1,#1
00007c  2027              MOVS     r0,#0x27
00007e  f7fffffe          BL       CLOCK_SetClkDiv
;;;1979           CLOCK_AttachClk(kUSB_PLL_to_USB1_CLK);
000082  f240300b          MOV      r0,#0x30b
000086  f7fffffe          BL       CLOCK_AttachClk
;;;1980       }
00008a  bf00              NOP      
                  |L7.140|
;;;1981   
;;;1982       delay = 100000;
00008c  4c0d              LDR      r4,|L7.196|
;;;1983       while (delay --)
00008e  e000              B        |L7.146|
                  |L7.144|
;;;1984       {
;;;1985           __asm("nop");
000090  bf00              NOP      
                  |L7.146|
000092  1e20              SUBS     r0,r4,#0              ;1983
000094  f1a40401          SUB      r4,r4,#1              ;1983
000098  d1fa              BNE      |L7.144|
;;;1986       }
;;;1987       /* Enable USBh1 and USB1RAM */
;;;1988       CLOCK_EnableClock(kCLOCK_Usbh1);
00009a  f44f7001          MOV      r0,#0x204
00009e  f7fffffe          BL       CLOCK_EnableClock
;;;1989       CLOCK_EnableClock(kCLOCK_UsbRam1); 
0000a2  f2402006          MOV      r0,#0x206
0000a6  f7fffffe          BL       CLOCK_EnableClock
;;;1990       POWER_DisablePD(kPDRUNCFG_PD_USB1_PHY); /* Turn on power for USB PHY */
0000aa  f44f7080          MOV      r0,#0x100
0000ae  f7fffffe          BL       POWER_DisablePD
;;;1991       return ret;
0000b2  4638              MOV      r0,r7
;;;1992   }
0000b4  bdfe              POP      {r1-r7,pc}
                          ENDP

0000b6  0000              DCW      0x0000
                  |L7.184|
                          DCD      0xfd239400
                  |L7.188|
                          DCD      0x40000500
                  |L7.192|
                          DCD      0xc3ff7fff
                  |L7.196|
                          DCD      0x000186a0
                  |L7.200|
                          DCD      ||.constdata||+0x50

                          AREA ||i.CLOCK_Enable_SysOsc||, CODE, READONLY, ALIGN=2

                  CLOCK_Enable_SysOsc PROC
;;;970    */
;;;971    __STATIC_INLINE  void CLOCK_Enable_SysOsc(bool enable)
000000  b168              CBZ      r0,|L8.30|
;;;972    {
;;;973        if(enable)
;;;974        {
;;;975            SYSCON->PDRUNCFGCLR[0] |= SYSCON_PDRUNCFG_PDEN_VD2_ANA_MASK;
000002  490c              LDR      r1,|L8.52|
000004  6809              LDR      r1,[r1,#0]
000006  f4417100          ORR      r1,r1,#0x200
00000a  4a0a              LDR      r2,|L8.52|
00000c  6011              STR      r1,[r2,#0]
;;;976            SYSCON->PDRUNCFGCLR[1] |= SYSCON_PDRUNCFG_PDEN_SYSOSC_MASK;
00000e  1d11              ADDS     r1,r2,#4
000010  6809              LDR      r1,[r1,#0]
000012  f0410208          ORR      r2,r1,#8
000016  4907              LDR      r1,|L8.52|
000018  1d09              ADDS     r1,r1,#4
00001a  600a              STR      r2,[r1,#0]
00001c  e008              B        |L8.48|
                  |L8.30|
;;;977        }
;;;978        
;;;979        else
;;;980        {
;;;981            SYSCON->PDRUNCFGSET[0] = SYSCON_PDRUNCFG_PDEN_VD2_ANA_MASK; 
00001e  f44f7100          MOV      r1,#0x200
000022  4a04              LDR      r2,|L8.52|
000024  3a10              SUBS     r2,r2,#0x10
000026  6011              STR      r1,[r2,#0]
;;;982            SYSCON->PDRUNCFGSET[1] = SYSCON_PDRUNCFG_PDEN_SYSOSC_MASK;
000028  2208              MOVS     r2,#8
00002a  4902              LDR      r1,|L8.52|
00002c  390c              SUBS     r1,r1,#0xc
00002e  600a              STR      r2,[r1,#0]
                  |L8.48|
;;;983    
;;;984        }
;;;985    }
000030  4770              BX       lr
;;;986    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      0x40000630

                          AREA ||i.CLOCK_GetAdcClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetAdcClkFreq PROC
;;;282    /* Get ADC Clk */
;;;283    uint32_t CLOCK_GetAdcClkFreq(void)
000000  b500              PUSH     {lr}
;;;284    {
;;;285        return (SYSCON->ADCCLKSEL == 0U) ? CLOCK_GetFroHfFreq():
000002  4811              LDR      r0,|L9.72|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L9.14|
000008  f7fffffe          BL       CLOCK_GetFroHfFreq
                  |L9.12|
;;;286               (SYSCON->ADCCLKSEL == 1U) ? CLOCK_GetPllOutFreq():
;;;287               (SYSCON->ADCCLKSEL == 2U) ? CLOCK_GetUsbPllOutFreq():
;;;288               (SYSCON->ADCCLKSEL == 3U) ? CLOCK_GetAudioPllOutFreq():
;;;289               (SYSCON->ADCCLKSEL == 7U) ? 0U:0U;
;;;290    }
00000c  bd00              POP      {pc}
                  |L9.14|
00000e  480e              LDR      r0,|L9.72|
000010  6800              LDR      r0,[r0,#0]            ;286
000012  2801              CMP      r0,#1                 ;286
000014  d102              BNE      |L9.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L9.12|
                  |L9.28|
00001c  480a              LDR      r0,|L9.72|
00001e  6800              LDR      r0,[r0,#0]            ;287
000020  2802              CMP      r0,#2                 ;287
000022  d102              BNE      |L9.42|
000024  f7fffffe          BL       CLOCK_GetUsbPllOutFreq
000028  e7f0              B        |L9.12|
                  |L9.42|
00002a  4807              LDR      r0,|L9.72|
00002c  6800              LDR      r0,[r0,#0]            ;288
00002e  2803              CMP      r0,#3                 ;288
000030  d102              BNE      |L9.56|
000032  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
000036  e7e9              B        |L9.12|
                  |L9.56|
000038  4803              LDR      r0,|L9.72|
00003a  6800              LDR      r0,[r0,#0]            ;289
00003c  2807              CMP      r0,#7                 ;289
00003e  d101              BNE      |L9.68|
000040  2000              MOVS     r0,#0                 ;289
000042  e7e3              B        |L9.12|
                  |L9.68|
000044  2000              MOVS     r0,#0                 ;289
000046  e7e1              B        |L9.12|
;;;291    
                          ENDP

                  |L9.72|
                          DCD      0x400002a4

                          AREA ||i.CLOCK_GetAsyncApbClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetAsyncApbClkFreq PROC
;;;433    /* Get ASYNC APB Clk */
;;;434    uint32_t CLOCK_GetAsyncApbClkFreq(void)
000000  b510              PUSH     {r4,lr}
;;;435    {
;;;436        async_clock_src_t clkSrc;
;;;437        uint32_t clkRate;
;;;438    
;;;439        clkSrc = CLOCK_GetAsyncApbClkSrc();
000002  bf00              NOP      
000004  4908              LDR      r1,|L10.40|
000006  6a09              LDR      r1,[r1,#0x20]
000008  f0010103          AND      r1,r1,#3
00000c  460c              MOV      r4,r1
;;;440    
;;;441        switch (clkSrc)
00000e  b114              CBZ      r4,|L10.22|
000010  2c01              CMP      r4,#1
000012  d105              BNE      |L10.32|
000014  e002              B        |L10.28|
                  |L10.22|
;;;442        {
;;;443            case kCLOCK_AsyncMainClk:
;;;444                clkRate = CLOCK_GetCoreSysClkFreq();
000016  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
;;;445                break;
00001a  e003              B        |L10.36|
                  |L10.28|
;;;446            case kCLOCK_AsyncFro12Mhz:
;;;447                clkRate = CLK_FRO_12MHZ;
00001c  4803              LDR      r0,|L10.44|
;;;448                break;
00001e  e001              B        |L10.36|
                  |L10.32|
;;;449            default:
;;;450                clkRate = 0U;
000020  2000              MOVS     r0,#0
;;;451                break;
000022  bf00              NOP      
                  |L10.36|
000024  bf00              NOP                            ;445
;;;452        }
;;;453    
;;;454        return clkRate;
;;;455    }
000026  bd10              POP      {r4,pc}
;;;456    
                          ENDP

                  |L10.40|
                          DCD      0x40040000
                  |L10.44|
                          DCD      0x00b71b00

                          AREA ||i.CLOCK_GetAudioPLLInClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetAudioPLLInClockRate PROC
;;;1151   /* Return Audio PLL input clock rate */
;;;1152   uint32_t CLOCK_GetAudioPLLInClockRate(void)
000000  b500              PUSH     {lr}
;;;1153   {
;;;1154       uint32_t clkRate = 0U;
000002  2100              MOVS     r1,#0
;;;1155   
;;;1156       switch ((SYSCON->AUDPLLCLKSEL & SYSCON_AUDPLLCLKSEL_SEL_MASK))
000004  4809              LDR      r0,|L11.44|
000006  6800              LDR      r0,[r0,#0]
000008  f0000007          AND      r0,r0,#7
00000c  b110              CBZ      r0,|L11.20|
00000e  2801              CMP      r0,#1
000010  d106              BNE      |L11.32|
000012  e001              B        |L11.24|
                  |L11.20|
;;;1157       {
;;;1158           case 0x00U:
;;;1159               clkRate = CLK_FRO_12MHZ;
000014  4906              LDR      r1,|L11.48|
;;;1160               break;
000016  e005              B        |L11.36|
                  |L11.24|
;;;1161   
;;;1162           case 0x01U:
;;;1163               clkRate = CLOCK_GetExtClkFreq();
000018  f7fffffe          BL       CLOCK_GetExtClkFreq
00001c  4601              MOV      r1,r0
;;;1164               break;
00001e  e001              B        |L11.36|
                  |L11.32|
;;;1165               
;;;1166           default:
;;;1167               clkRate = 0U;
000020  2100              MOVS     r1,#0
;;;1168               break;
000022  bf00              NOP      
                  |L11.36|
000024  bf00              NOP                            ;1160
;;;1169       }
;;;1170   
;;;1171       return clkRate;
000026  4608              MOV      r0,r1
;;;1172   }
000028  bd00              POP      {pc}
;;;1173   
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40000298
                  |L11.48|
                          DCD      0x00b71b00

                          AREA ||i.CLOCK_GetAudioPLLOutClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetAudioPLLOutClockRate PROC
;;;1302   /* Return AUDIO PLL output clock rate */
;;;1303   uint32_t CLOCK_GetAudioPLLOutClockRate(bool recompute)
000000  b530              PUSH     {r4,r5,lr}
;;;1304   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;1305       pll_setup_t Setup;
;;;1306       uint32_t rate;
;;;1307   
;;;1308       if ((recompute) || (s_Audio_Pll_Freq == 0U))
000006  b914              CBNZ     r4,|L12.14|
000008  480c              LDR      r0,|L12.60|
00000a  6800              LDR      r0,[r0,#0]  ; s_Audio_Pll_Freq
00000c  b988              CBNZ     r0,|L12.50|
                  |L12.14|
;;;1309       {
;;;1310           Setup.syspllctrl = SYSCON->AUDPLLCTRL;
00000e  480c              LDR      r0,|L12.64|
000010  6800              LDR      r0,[r0,#0]
000012  9001              STR      r0,[sp,#4]
;;;1311           Setup.syspllndec = SYSCON->AUDPLLNDEC;
000014  480a              LDR      r0,|L12.64|
000016  3008              ADDS     r0,r0,#8
000018  6800              LDR      r0,[r0,#0]
00001a  9002              STR      r0,[sp,#8]
;;;1312           Setup.syspllpdec = SYSCON->AUDPLLPDEC;
00001c  4808              LDR      r0,|L12.64|
00001e  300c              ADDS     r0,r0,#0xc
000020  6800              LDR      r0,[r0,#0]
000022  9003              STR      r0,[sp,#0xc]
;;;1313           Setup.syspllmdec = SYSCON->AUDPLLMDEC;
000024  4806              LDR      r0,|L12.64|
000026  3010              ADDS     r0,r0,#0x10
000028  6800              LDR      r0,[r0,#0]
00002a  9004              STR      r0,[sp,#0x10]
;;;1314   
;;;1315           CLOCK_GetAudioPLLOutFromSetupUpdate(&Setup);
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       CLOCK_GetAudioPLLOutFromSetupUpdate
                  |L12.50|
;;;1316       }
;;;1317   
;;;1318       rate = s_Audio_Pll_Freq;
000032  4802              LDR      r0,|L12.60|
000034  6805              LDR      r5,[r0,#0]  ; s_Audio_Pll_Freq
;;;1319       return rate;
000036  4628              MOV      r0,r5
;;;1320   }
000038  b007              ADD      sp,sp,#0x1c
00003a  bd30              POP      {r4,r5,pc}
;;;1321   
                          ENDP

                  |L12.60|
                          DCD      s_Audio_Pll_Freq
                  |L12.64|
                          DCD      0x400005a0

                          AREA ||i.CLOCK_GetAudioPLLOutFromSetup||, CODE, READONLY, ALIGN=1

                  CLOCK_GetAudioPLLOutFromSetup PROC
;;;1231   /* Return Audio PLL output clock rate from setup structure */
;;;1232   uint32_t CLOCK_GetAudioPLLOutFromSetup(pll_setup_t *pSetup)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1233   {
000004  4604              MOV      r4,r0
;;;1234       uint32_t prediv, postdiv, mMult, inPllRate;
;;;1235       uint64_t workRate;
;;;1236   
;;;1237       inPllRate = CLOCK_GetAudioPLLInClockRate();
000006  f7fffffe          BL       CLOCK_GetAudioPLLInClockRate
00000a  4607              MOV      r7,r0
;;;1238       if ((pSetup->syspllctrl & (1UL << SYSCON_SYSPLLCTRL_BYPASS_SHIFT)) == 0U)
00000c  8820              LDRH     r0,[r4,#0]
00000e  f4004000          AND      r0,r0,#0x8000
000012  b9f0              CBNZ     r0,|L13.82|
;;;1239       {
;;;1240           /* PLL is not in bypass mode, get pre-divider, post-divider, and M divider */
;;;1241           prediv = findPllPreDiv(pSetup->syspllctrl, pSetup->syspllndec);
000014  e9d40100          LDRD     r0,r1,[r4,#0]
000018  f7fffffe          BL       findPllPreDiv
00001c  4681              MOV      r9,r0
;;;1242           postdiv = findPllPostDiv(pSetup->syspllctrl, pSetup->syspllpdec);
00001e  68a1              LDR      r1,[r4,#8]
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       findPllPostDiv
000026  4680              MOV      r8,r0
;;;1243   
;;;1244           /* Adjust input clock */
;;;1245           inPllRate = inPllRate / prediv;
000028  fbb7f7f9          UDIV     r7,r7,r9
;;;1246   
;;;1247           /* MDEC used for rate */
;;;1248           mMult = findPllMMult(pSetup->syspllctrl, pSetup->syspllmdec);
00002c  68e1              LDR      r1,[r4,#0xc]
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       findPllMMult
000034  4682              MOV      r10,r0
;;;1249           workRate = (uint64_t)inPllRate * (uint64_t)mMult;
000036  fba7500a          UMULL    r5,r0,r7,r10
00003a  4606              MOV      r6,r0
;;;1250   
;;;1251           workRate = workRate / ((uint64_t)postdiv);
00003c  4642              MOV      r2,r8
00003e  2300              MOVS     r3,#0
000040  4628              MOV      r0,r5
000042  4631              MOV      r1,r6
000044  f7fffffe          BL       __aeabi_uldivmod
000048  4605              MOV      r5,r0
;;;1252           workRate = workRate * 2U; /* SYS PLL hardware cco is divide by 2 before to M-DIVIDER*/
00004a  2002              MOVS     r0,#2
00004c  fba55100          UMULL    r5,r1,r5,r0
000050  e000              B        |L13.84|
                  |L13.82|
;;;1253       }
;;;1254       else
;;;1255       {
;;;1256           /* In bypass mode */
;;;1257           workRate = (uint64_t)inPllRate;
000052  463d              MOV      r5,r7
                  |L13.84|
;;;1258       }
;;;1259   
;;;1260       return (uint32_t)workRate;
000054  4628              MOV      r0,r5
;;;1261   }
000056  e8bd87f0          POP      {r4-r10,pc}
;;;1262   
                          ENDP


                          AREA ||i.CLOCK_GetAudioPLLOutFromSetupUpdate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetAudioPLLOutFromSetupUpdate PROC
;;;1108   /* Update AUDIO PLL rate variable */
;;;1109   static void CLOCK_GetAudioPLLOutFromSetupUpdate(pll_setup_t *pSetup)
000000  b510              PUSH     {r4,lr}
;;;1110   {
000002  4604              MOV      r4,r0
;;;1111       s_Audio_Pll_Freq = CLOCK_GetAudioPLLOutFromSetup(pSetup);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLOCK_GetAudioPLLOutFromSetup
00000a  4901              LDR      r1,|L14.16|
00000c  6008              STR      r0,[r1,#0]  ; s_Audio_Pll_Freq
;;;1112   }
00000e  bd10              POP      {r4,pc}
;;;1113   
                          ENDP

                  |L14.16|
                          DCD      s_Audio_Pll_Freq

                          AREA ||i.CLOCK_GetAudioPllOutFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetAudioPllOutFreq PROC
;;;398    /* Get AUDIO PLL Clk */
;;;399    uint32_t CLOCK_GetAudioPllOutFreq(void)
000000  4801              LDR      r0,|L15.8|
;;;400    {
;;;401        return s_Audio_Pll_Freq;
000002  6800              LDR      r0,[r0,#0]  ; s_Audio_Pll_Freq
;;;402    }
000004  4770              BX       lr
;;;403    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      s_Audio_Pll_Freq

                          AREA ||i.CLOCK_GetClockOutClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetClockOutClkFreq PROC
;;;258    /* Get CLOCK OUT Clk */
;;;259    uint32_t CLOCK_GetClockOutClkFreq(void)
000000  b500              PUSH     {lr}
;;;260    {
;;;261        return (SYSCON->CLKOUTSELA == 0U) ? CLOCK_GetCoreSysClkFreq():
000002  481c              LDR      r0,|L16.116|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L16.14|
000008  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
                  |L16.12|
;;;262               (SYSCON->CLKOUTSELA == 1U) ? CLOCK_GetExtClkFreq():
;;;263               (SYSCON->CLKOUTSELA == 2U) ? CLOCK_GetWdtOscFreq():
;;;264               (SYSCON->CLKOUTSELA == 3U) ? CLOCK_GetFroHfFreq():
;;;265               (SYSCON->CLKOUTSELA == 4U) ? CLOCK_GetPllOutFreq():
;;;266               (SYSCON->CLKOUTSELA == 5U) ? CLOCK_GetUsbPllOutFreq():
;;;267               (SYSCON->CLKOUTSELA == 6U) ? CLOCK_GetAudioPllOutFreq():
;;;268               (SYSCON->CLKOUTSELA == 7U) ? CLOCK_GetOsc32KFreq():0U;
;;;269    }
00000c  bd00              POP      {pc}
                  |L16.14|
00000e  4819              LDR      r0,|L16.116|
000010  6800              LDR      r0,[r0,#0]            ;262
000012  2801              CMP      r0,#1                 ;262
000014  d102              BNE      |L16.28|
000016  f7fffffe          BL       CLOCK_GetExtClkFreq
00001a  e7f7              B        |L16.12|
                  |L16.28|
00001c  4815              LDR      r0,|L16.116|
00001e  6800              LDR      r0,[r0,#0]            ;263
000020  2802              CMP      r0,#2                 ;263
000022  d102              BNE      |L16.42|
000024  f7fffffe          BL       CLOCK_GetWdtOscFreq
000028  e7f0              B        |L16.12|
                  |L16.42|
00002a  4812              LDR      r0,|L16.116|
00002c  6800              LDR      r0,[r0,#0]            ;264
00002e  2803              CMP      r0,#3                 ;264
000030  d102              BNE      |L16.56|
000032  f7fffffe          BL       CLOCK_GetFroHfFreq
000036  e7e9              B        |L16.12|
                  |L16.56|
000038  480e              LDR      r0,|L16.116|
00003a  6800              LDR      r0,[r0,#0]            ;265
00003c  2804              CMP      r0,#4                 ;265
00003e  d102              BNE      |L16.70|
000040  f7fffffe          BL       CLOCK_GetPllOutFreq
000044  e7e2              B        |L16.12|
                  |L16.70|
000046  480b              LDR      r0,|L16.116|
000048  6800              LDR      r0,[r0,#0]            ;266
00004a  2805              CMP      r0,#5                 ;266
00004c  d102              BNE      |L16.84|
00004e  f7fffffe          BL       CLOCK_GetUsbPllOutFreq
000052  e7db              B        |L16.12|
                  |L16.84|
000054  4807              LDR      r0,|L16.116|
000056  6800              LDR      r0,[r0,#0]            ;267
000058  2806              CMP      r0,#6                 ;267
00005a  d102              BNE      |L16.98|
00005c  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
000060  e7d4              B        |L16.12|
                  |L16.98|
000062  4804              LDR      r0,|L16.116|
000064  6800              LDR      r0,[r0,#0]            ;268
000066  2807              CMP      r0,#7                 ;268
000068  d102              BNE      |L16.112|
00006a  f7fffffe          BL       CLOCK_GetOsc32KFreq
00006e  e7cd              B        |L16.12|
                  |L16.112|
000070  2000              MOVS     r0,#0                 ;268
000072  e7cb              B        |L16.12|
;;;270    
                          ENDP

                  |L16.116|
                          DCD      0x40000288

                          AREA ||i.CLOCK_GetCoreSysClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetCoreSysClkFreq PROC
;;;416    /* Get MAIN Clk */
;;;417    uint32_t CLOCK_GetCoreSysClkFreq(void)
000000  b500              PUSH     {lr}
;;;418    {
;;;419        return ((SYSCON->MAINCLKSELB == 0U) && (SYSCON->MAINCLKSELA == 0U)) ? CLOCK_GetFro12MFreq() :
000002  481d              LDR      r0,|L17.120|
000004  6800              LDR      r0,[r0,#0]
000006  b930              CBNZ     r0,|L17.22|
000008  481b              LDR      r0,|L17.120|
00000a  1f00              SUBS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
00000e  b910              CBNZ     r0,|L17.22|
000010  f7fffffe          BL       CLOCK_GetFro12MFreq
                  |L17.20|
;;;420               ((SYSCON->MAINCLKSELB == 0U) && (SYSCON->MAINCLKSELA == 1U)) ? CLOCK_GetExtClkFreq() :
;;;421               ((SYSCON->MAINCLKSELB == 0U) && (SYSCON->MAINCLKSELA == 2U)) ? CLOCK_GetWdtOscFreq() :
;;;422               ((SYSCON->MAINCLKSELB == 0U) && (SYSCON->MAINCLKSELA == 3U)) ? CLOCK_GetFroHfFreq() :
;;;423               (SYSCON->MAINCLKSELB == 2U) ? CLOCK_GetPllOutFreq() :
;;;424               (SYSCON->MAINCLKSELB == 3U) ? CLOCK_GetOsc32KFreq() : 0U;
;;;425    }
000014  bd00              POP      {pc}
                  |L17.22|
000016  4818              LDR      r0,|L17.120|
000018  6800              LDR      r0,[r0,#0]            ;420
00001a  b938              CBNZ     r0,|L17.44|
00001c  4816              LDR      r0,|L17.120|
00001e  1f00              SUBS     r0,r0,#4              ;420
000020  6800              LDR      r0,[r0,#0]            ;420
000022  2801              CMP      r0,#1                 ;420
000024  d102              BNE      |L17.44|
000026  f7fffffe          BL       CLOCK_GetExtClkFreq
00002a  e7f3              B        |L17.20|
                  |L17.44|
00002c  4812              LDR      r0,|L17.120|
00002e  6800              LDR      r0,[r0,#0]            ;421
000030  b938              CBNZ     r0,|L17.66|
000032  4811              LDR      r0,|L17.120|
000034  1f00              SUBS     r0,r0,#4              ;421
000036  6800              LDR      r0,[r0,#0]            ;421
000038  2802              CMP      r0,#2                 ;421
00003a  d102              BNE      |L17.66|
00003c  f7fffffe          BL       CLOCK_GetWdtOscFreq
000040  e7e8              B        |L17.20|
                  |L17.66|
000042  480d              LDR      r0,|L17.120|
000044  6800              LDR      r0,[r0,#0]            ;422
000046  b938              CBNZ     r0,|L17.88|
000048  480b              LDR      r0,|L17.120|
00004a  1f00              SUBS     r0,r0,#4              ;422
00004c  6800              LDR      r0,[r0,#0]            ;422
00004e  2803              CMP      r0,#3                 ;422
000050  d102              BNE      |L17.88|
000052  f7fffffe          BL       CLOCK_GetFroHfFreq
000056  e7dd              B        |L17.20|
                  |L17.88|
000058  4807              LDR      r0,|L17.120|
00005a  6800              LDR      r0,[r0,#0]            ;423
00005c  2802              CMP      r0,#2                 ;423
00005e  d102              BNE      |L17.102|
000060  f7fffffe          BL       CLOCK_GetPllOutFreq
000064  e7d6              B        |L17.20|
                  |L17.102|
000066  4804              LDR      r0,|L17.120|
000068  6800              LDR      r0,[r0,#0]            ;424
00006a  2803              CMP      r0,#3                 ;424
00006c  d102              BNE      |L17.116|
00006e  f7fffffe          BL       CLOCK_GetOsc32KFreq
000072  e7cf              B        |L17.20|
                  |L17.116|
000074  2000              MOVS     r0,#0                 ;424
000076  e7cd              B        |L17.20|
;;;426    
                          ENDP

                  |L17.120|
                          DCD      0x40000284

                          AREA ||i.CLOCK_GetExtClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetExtClkFreq PROC
;;;361    /* Get EXT OSC Clk */
;;;362    uint32_t CLOCK_GetExtClkFreq(void)
000000  4800              LDR      r0,|L18.4|
;;;363    {
;;;364        return g_Ext_Clk_Freq;
;;;365    }
000002  4770              BX       lr
;;;366    
                          ENDP

                  |L18.4|
                          DCD      0x00b71b00

                          AREA ||i.CLOCK_GetFRGInputClock||, CODE, READONLY, ALIGN=2

                  CLOCK_GetFRGInputClock PROC
;;;467    /* Get FRG Clk */
;;;468    uint32_t CLOCK_GetFRGInputClock(void)
000000  b500              PUSH     {lr}
;;;469    {
;;;470        return (SYSCON->FRGCLKSEL == 0U) ? CLOCK_GetCoreSysClkFreq() : 
000002  480e              LDR      r0,|L19.60|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L19.14|
000008  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
                  |L19.12|
;;;471               (SYSCON->FRGCLKSEL == 1U) ? CLOCK_GetPllOutFreq() :
;;;472               (SYSCON->FRGCLKSEL == 2U) ? CLOCK_GetFro12MFreq() : 
;;;473               (SYSCON->FRGCLKSEL == 3U) ? CLOCK_GetFroHfFreq() : 0U;
;;;474    }
00000c  bd00              POP      {pc}
                  |L19.14|
00000e  480b              LDR      r0,|L19.60|
000010  6800              LDR      r0,[r0,#0]            ;471
000012  2801              CMP      r0,#1                 ;471
000014  d102              BNE      |L19.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L19.12|
                  |L19.28|
00001c  4807              LDR      r0,|L19.60|
00001e  6800              LDR      r0,[r0,#0]            ;472
000020  2802              CMP      r0,#2                 ;472
000022  d102              BNE      |L19.42|
000024  f7fffffe          BL       CLOCK_GetFro12MFreq
000028  e7f0              B        |L19.12|
                  |L19.42|
00002a  4804              LDR      r0,|L19.60|
00002c  6800              LDR      r0,[r0,#0]            ;473
00002e  2803              CMP      r0,#3                 ;473
000030  d102              BNE      |L19.56|
000032  f7fffffe          BL       CLOCK_GetFroHfFreq
000036  e7e9              B        |L19.12|
                  |L19.56|
000038  2000              MOVS     r0,#0                 ;473
00003a  e7e7              B        |L19.12|
;;;475    
                          ENDP

                  |L19.60|
                          DCD      0x400002e8

                          AREA ||i.CLOCK_GetFlexCommClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetFlexCommClkFreq PROC
;;;457    /* Get FLEXCOMM Clk */
;;;458    uint32_t CLOCK_GetFlexCommClkFreq(uint32_t id)
000000  b510              PUSH     {r4,lr}
;;;459    {
000002  4604              MOV      r4,r0
;;;460        return (SYSCON->FCLKSEL[id] == 0U) ? CLOCK_GetFro12MFreq() : 
000004  4814              LDR      r0,|L20.88|
000006  f8500024          LDR      r0,[r0,r4,LSL #2]
00000a  b910              CBNZ     r0,|L20.18|
00000c  f7fffffe          BL       CLOCK_GetFro12MFreq
                  |L20.16|
;;;461               (SYSCON->FCLKSEL[id] == 1U) ? CLOCK_GetFroHfFreq() :
;;;462               (SYSCON->FCLKSEL[id] == 2U) ? CLOCK_GetPllOutFreq() :
;;;463               (SYSCON->FCLKSEL[id] == 3U) ? CLOCK_GetI2SMClkFreq() :
;;;464               (SYSCON->FCLKSEL[id] == 4U) ? CLOCK_GetFreq(kCLOCK_Frg) : 0U;
;;;465    }
000010  bd10              POP      {r4,pc}
                  |L20.18|
000012  4811              LDR      r0,|L20.88|
000014  f8500024          LDR      r0,[r0,r4,LSL #2]     ;461
000018  2801              CMP      r0,#1                 ;461
00001a  d102              BNE      |L20.34|
00001c  f7fffffe          BL       CLOCK_GetFroHfFreq
000020  e7f6              B        |L20.16|
                  |L20.34|
000022  480d              LDR      r0,|L20.88|
000024  f8500024          LDR      r0,[r0,r4,LSL #2]     ;462
000028  2802              CMP      r0,#2                 ;462
00002a  d102              BNE      |L20.50|
00002c  f7fffffe          BL       CLOCK_GetPllOutFreq
000030  e7ee              B        |L20.16|
                  |L20.50|
000032  4809              LDR      r0,|L20.88|
000034  f8500024          LDR      r0,[r0,r4,LSL #2]     ;463
000038  2803              CMP      r0,#3                 ;463
00003a  d102              BNE      |L20.66|
00003c  f7fffffe          BL       CLOCK_GetI2SMClkFreq
000040  e7e6              B        |L20.16|
                  |L20.66|
000042  4805              LDR      r0,|L20.88|
000044  f8500024          LDR      r0,[r0,r4,LSL #2]     ;464
000048  2804              CMP      r0,#4                 ;464
00004a  d103              BNE      |L20.84|
00004c  2015              MOVS     r0,#0x15              ;464
00004e  f7fffffe          BL       CLOCK_GetFreq
000052  e7dd              B        |L20.16|
                  |L20.84|
000054  2000              MOVS     r0,#0                 ;464
000056  e7db              B        |L20.16|
;;;466    
                          ENDP

                  |L20.88|
                          DCD      0x400002b0

                          AREA ||i.CLOCK_GetFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetFreq PROC
;;;495    /* Set IP Clk */
;;;496    uint32_t CLOCK_GetFreq(clock_name_t clockName)
000000  b570              PUSH     {r4-r6,lr}
;;;497    {
000002  4605              MOV      r5,r0
;;;498        uint32_t freq;
;;;499        switch (clockName)
000004  2d23              CMP      r5,#0x23
000006  d270              BCS      |L21.234|
000008  e8dff005          TBB      [pc,r5]
00000c  12161f5b          DCB      0x12,0x16,0x1f,0x5b
000010  29333d47          DCB      0x29,0x33,0x3d,0x47
000014  6f51cfd9          DCB      0x6f,0x51,0xcf,0xd9
000018  f2f0efee          DCB      0xf2,0xf0,0xef,0xee
00001c  5f63676f          DCB      0x5f,0x63,0x67,0x6f
000020  6b7092cb          DCB      0x6b,0x70,0x92,0xcb
000024  edecebea          DCB      0xed,0xec,0xeb,0xea
000028  e9e8e7e6          DCB      0xe9,0xe8,0xe7,0xe6
00002c  e5e4e300          DCB      0xe5,0xe4,0xe3,0x00
;;;500        {
;;;501            case kCLOCK_CoreSysClk:
;;;502                freq = CLOCK_GetCoreSysClkFreq();
000030  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
000034  4604              MOV      r4,r0
;;;503                break;
000036  e142              B        |L21.702|
;;;504            case kCLOCK_BusClk:
;;;505                freq = CLOCK_GetCoreSysClkFreq() / ((SYSCON->AHBCLKDIV & 0xffU) + 1U);
000038  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
00003c  49a1              LDR      r1,|L21.708|
00003e  6809              LDR      r1,[r1,#0]
000040  b2c9              UXTB     r1,r1
000042  1c49              ADDS     r1,r1,#1
000044  fbb0f4f1          UDIV     r4,r0,r1
;;;506                break;
000048  e139              B        |L21.702|
;;;507            case kCLOCK_ClockOut:
;;;508                freq = CLOCK_GetClockOutClkFreq() / ((SYSCON->CLKOUTDIV & 0xffU) + 1U);
00004a  f7fffffe          BL       CLOCK_GetClockOutClkFreq
00004e  499d              LDR      r1,|L21.708|
000050  1d09              ADDS     r1,r1,#4
000052  6809              LDR      r1,[r1,#0]
000054  b2c9              UXTB     r1,r1
000056  1c49              ADDS     r1,r1,#1
000058  fbb0f4f1          UDIV     r4,r0,r1
;;;509                break;
00005c  e12f              B        |L21.702|
;;;510            case kCLOCK_SpiFi:
;;;511                freq = CLOCK_GetSpifiClkFreq() / ((SYSCON->SPIFICLKDIV & 0xffU) + 1U );
00005e  f7fffffe          BL       CLOCK_GetSpifiClkFreq
000062  4998              LDR      r1,|L21.708|
000064  3110              ADDS     r1,r1,#0x10
000066  6809              LDR      r1,[r1,#0]
000068  b2c9              UXTB     r1,r1
00006a  1c49              ADDS     r1,r1,#1
00006c  fbb0f4f1          UDIV     r4,r0,r1
;;;512                break;
000070  e125              B        |L21.702|
;;;513            case kCLOCK_Adc:
;;;514                freq = CLOCK_GetAdcClkFreq() / ((SYSCON->ADCCLKDIV & 0xffU) + 1U );
000072  f7fffffe          BL       CLOCK_GetAdcClkFreq
000076  4993              LDR      r1,|L21.708|
000078  3114              ADDS     r1,r1,#0x14
00007a  6809              LDR      r1,[r1,#0]
00007c  b2c9              UXTB     r1,r1
00007e  1c49              ADDS     r1,r1,#1
000080  fbb0f4f1          UDIV     r4,r0,r1
;;;515                break;
000084  e11b              B        |L21.702|
;;;516            case kCLOCK_Usb0:
;;;517                freq = CLOCK_GetUsb0ClkFreq() / ((SYSCON->USB0CLKDIV & 0xffU) + 1U );
000086  f7fffffe          BL       CLOCK_GetUsb0ClkFreq
00008a  498e              LDR      r1,|L21.708|
00008c  3118              ADDS     r1,r1,#0x18
00008e  6809              LDR      r1,[r1,#0]
000090  b2c9              UXTB     r1,r1
000092  1c49              ADDS     r1,r1,#1
000094  fbb0f4f1          UDIV     r4,r0,r1
;;;518                break;
000098  e111              B        |L21.702|
;;;519            case kCLOCK_Usb1:
;;;520                freq = CLOCK_GetUsb1ClkFreq() / ((SYSCON->USB1CLKDIV & 0xffU) + 1U );
00009a  f7fffffe          BL       CLOCK_GetUsb1ClkFreq
00009e  4989              LDR      r1,|L21.708|
0000a0  311c              ADDS     r1,r1,#0x1c
0000a2  6809              LDR      r1,[r1,#0]
0000a4  b2c9              UXTB     r1,r1
0000a6  1c49              ADDS     r1,r1,#1
0000a8  fbb0f4f1          UDIV     r4,r0,r1
;;;521                break;
0000ac  e107              B        |L21.702|
;;;522            case kCLOCK_Mclk:
;;;523                freq = CLOCK_GetMclkClkFreq() / ((SYSCON->MCLKDIV & 0xffU) + 1U );
0000ae  f7fffffe          BL       CLOCK_GetMclkClkFreq
0000b2  4984              LDR      r1,|L21.708|
0000b4  312c              ADDS     r1,r1,#0x2c
0000b6  6809              LDR      r1,[r1,#0]
0000b8  b2c9              UXTB     r1,r1
0000ba  1c49              ADDS     r1,r1,#1
0000bc  fbb0f4f1          UDIV     r4,r0,r1
;;;524                break;
0000c0  e0fd              B        |L21.702|
;;;525            case kCLOCK_FroHf:
;;;526                freq = CLOCK_GetFroHfFreq();
0000c2  f7fffffe          BL       CLOCK_GetFroHfFreq
0000c6  4604              MOV      r4,r0
;;;527                break;
0000c8  e0f9              B        |L21.702|
;;;528            case kCLOCK_Fro12M:
;;;529                freq = CLOCK_GetFro12MFreq();
0000ca  f7fffffe          BL       CLOCK_GetFro12MFreq
0000ce  4604              MOV      r4,r0
;;;530                break;
0000d0  e0f5              B        |L21.702|
;;;531            case kCLOCK_ExtClk:
;;;532                freq = CLOCK_GetExtClkFreq();
0000d2  f7fffffe          BL       CLOCK_GetExtClkFreq
0000d6  4604              MOV      r4,r0
;;;533                break;
0000d8  e0f1              B        |L21.702|
;;;534            case kCLOCK_PllOut:
;;;535                freq = CLOCK_GetPllOutFreq();
0000da  f7fffffe          BL       CLOCK_GetPllOutFreq
0000de  4604              MOV      r4,r0
;;;536                break;
0000e0  e0ed              B        |L21.702|
;;;537            case kClock_WdtOsc:
;;;538                freq = CLOCK_GetWdtOscFreq();
0000e2  f7fffffe          BL       CLOCK_GetWdtOscFreq
0000e6  4604              MOV      r4,r0
;;;539                break;
0000e8  e0e9              B        |L21.702|
                  |L21.234|
0000ea  e0e6              B        |L21.698|
;;;540            case kCLOCK_Frg:
;;;541                freq = (SYSCON->FRGCLKSEL == 0U) ? CLOCK_GetCoreSysClkFreq() : 
0000ec  4875              LDR      r0,|L21.708|
0000ee  3898              SUBS     r0,r0,#0x98
0000f0  6800              LDR      r0,[r0,#0]
0000f2  b910              CBNZ     r0,|L21.250|
0000f4  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
0000f8  e018              B        |L21.300|
                  |L21.250|
;;;542                       (SYSCON->FRGCLKSEL == 1U) ? CLOCK_GetPllOutFreq() :
0000fa  4872              LDR      r0,|L21.708|
0000fc  3898              SUBS     r0,r0,#0x98
0000fe  6800              LDR      r0,[r0,#0]
000100  2801              CMP      r0,#1
000102  d102              BNE      |L21.266|
000104  f7fffffe          BL       CLOCK_GetPllOutFreq
000108  e010              B        |L21.300|
                  |L21.266|
;;;543                       (SYSCON->FRGCLKSEL == 2U) ? CLOCK_GetFro12MFreq() :
00010a  486e              LDR      r0,|L21.708|
00010c  3898              SUBS     r0,r0,#0x98
00010e  6800              LDR      r0,[r0,#0]
000110  2802              CMP      r0,#2
000112  d102              BNE      |L21.282|
000114  f7fffffe          BL       CLOCK_GetFro12MFreq
000118  e008              B        |L21.300|
                  |L21.282|
;;;544                       (SYSCON->FRGCLKSEL == 3U) ? CLOCK_GetFroHfFreq() : 0U;
00011a  486a              LDR      r0,|L21.708|
00011c  3898              SUBS     r0,r0,#0x98
00011e  6800              LDR      r0,[r0,#0]
000120  2803              CMP      r0,#3
000122  d102              BNE      |L21.298|
000124  f7fffffe          BL       CLOCK_GetFroHfFreq
000128  e000              B        |L21.300|
                  |L21.298|
00012a  2000              MOVS     r0,#0
                  |L21.300|
00012c  4604              MOV      r4,r0
;;;545                break;
00012e  e0c6              B        |L21.702|
;;;546            case kCLOCK_Dmic:
;;;547                freq = (SYSCON->DMICCLKSEL == 0U) ? CLOCK_GetFro12MFreq() : 
000130  4864              LDR      r0,|L21.708|
000132  3894              SUBS     r0,r0,#0x94
000134  6800              LDR      r0,[r0,#0]
000136  b910              CBNZ     r0,|L21.318|
000138  f7fffffe          BL       CLOCK_GetFro12MFreq
00013c  e028              B        |L21.400|
                  |L21.318|
;;;548                       (SYSCON->DMICCLKSEL == 1U) ? CLOCK_GetFroHfFreq() :
00013e  4861              LDR      r0,|L21.708|
000140  3894              SUBS     r0,r0,#0x94
000142  6800              LDR      r0,[r0,#0]
000144  2801              CMP      r0,#1
000146  d102              BNE      |L21.334|
000148  f7fffffe          BL       CLOCK_GetFroHfFreq
00014c  e020              B        |L21.400|
                  |L21.334|
;;;549                       (SYSCON->DMICCLKSEL == 2U) ? CLOCK_GetPllOutFreq() :
00014e  485d              LDR      r0,|L21.708|
000150  3894              SUBS     r0,r0,#0x94
000152  6800              LDR      r0,[r0,#0]
000154  2802              CMP      r0,#2
000156  d102              BNE      |L21.350|
000158  f7fffffe          BL       CLOCK_GetPllOutFreq
00015c  e018              B        |L21.400|
                  |L21.350|
;;;550                       (SYSCON->DMICCLKSEL == 3U) ? CLOCK_GetI2SMClkFreq() :
00015e  4859              LDR      r0,|L21.708|
000160  3894              SUBS     r0,r0,#0x94
000162  6800              LDR      r0,[r0,#0]
000164  2803              CMP      r0,#3
000166  d102              BNE      |L21.366|
000168  f7fffffe          BL       CLOCK_GetI2SMClkFreq
00016c  e010              B        |L21.400|
                  |L21.366|
;;;551                       (SYSCON->DMICCLKSEL == 4U) ? CLOCK_GetCoreSysClkFreq() :
00016e  4855              LDR      r0,|L21.708|
000170  3894              SUBS     r0,r0,#0x94
000172  6800              LDR      r0,[r0,#0]
000174  2804              CMP      r0,#4
000176  d102              BNE      |L21.382|
000178  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
00017c  e008              B        |L21.400|
                  |L21.382|
;;;552                       (SYSCON->DMICCLKSEL == 5U) ? CLOCK_GetWdtOscFreq() : 0U;
00017e  4851              LDR      r0,|L21.708|
000180  3894              SUBS     r0,r0,#0x94
000182  6800              LDR      r0,[r0,#0]
000184  2805              CMP      r0,#5
000186  d102              BNE      |L21.398|
000188  f7fffffe          BL       CLOCK_GetWdtOscFreq
00018c  e000              B        |L21.400|
                  |L21.398|
00018e  2000              MOVS     r0,#0
                  |L21.400|
000190  4604              MOV      r4,r0
;;;553                freq = freq / ((SYSCON->DMICCLKDIV & 0xffU) + 1U);
000192  484c              LDR      r0,|L21.708|
000194  3028              ADDS     r0,r0,#0x28
000196  6800              LDR      r0,[r0,#0]
000198  b2c0              UXTB     r0,r0
00019a  1c40              ADDS     r0,r0,#1
00019c  fbb4f4f0          UDIV     r4,r4,r0
;;;554                break;
0001a0  e08d              B        |L21.702|
;;;555    
;;;556            case kCLOCK_AsyncApbClk:
;;;557                freq = CLOCK_GetAsyncApbClkFreq();
0001a2  f7fffffe          BL       CLOCK_GetAsyncApbClkFreq
0001a6  4604              MOV      r4,r0
;;;558                break;
0001a8  e089              B        |L21.702|
;;;559            case kCLOCK_Sct:
;;;560                freq = CLOCK_GetSctClkFreq() / ((SYSCON->SCTCLKDIV & 0xffU) + 1U);
0001aa  f7fffffe          BL       CLOCK_GetSctClkFreq
0001ae  4945              LDR      r1,|L21.708|
0001b0  3134              ADDS     r1,r1,#0x34
0001b2  6809              LDR      r1,[r1,#0]
0001b4  b2c9              UXTB     r1,r1
0001b6  1c49              ADDS     r1,r1,#1
0001b8  fbb0f4f1          UDIV     r4,r0,r1
;;;561                break;
0001bc  e07f              B        |L21.702|
;;;562            case kCLOCK_SDio:
;;;563                freq = CLOCK_GetSdioClkFreq() / ((SYSCON->SDIOCLKDIV & 0xffU) + 1U);
0001be  f7fffffe          BL       CLOCK_GetSdioClkFreq
0001c2  4940              LDR      r1,|L21.708|
0001c4  313c              ADDS     r1,r1,#0x3c
0001c6  6809              LDR      r1,[r1,#0]
0001c8  b2c9              UXTB     r1,r1
0001ca  1c49              ADDS     r1,r1,#1
0001cc  fbb0f4f1          UDIV     r4,r0,r1
;;;564                break;
0001d0  e075              B        |L21.702|
0001d2  e06d              B        |L21.688|
0001d4  e067              B        |L21.678|
0001d6  e061              B        |L21.668|
0001d8  e05b              B        |L21.658|
0001da  e055              B        |L21.648|
0001dc  e04f              B        |L21.638|
0001de  e049              B        |L21.628|
0001e0  e043              B        |L21.618|
0001e2  e03d              B        |L21.608|
0001e4  e037              B        |L21.598|
0001e6  e032              B        |L21.590|
0001e8  e027              B        |L21.570|
0001ea  e01c              B        |L21.550|
0001ec  e011              B        |L21.530|
0001ee  e7ff              B        |L21.496|
                  |L21.496|
;;;565            case kCLOCK_EMC:
;;;566                freq = CLOCK_GetCoreSysClkFreq() / ((SYSCON->AHBCLKDIV & 0xffU) + 1U) / ((SYSCON->EMCCLKDIV & 0xffU) + 1U);
0001f0  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
0001f4  4933              LDR      r1,|L21.708|
0001f6  6809              LDR      r1,[r1,#0]
0001f8  b2c9              UXTB     r1,r1
0001fa  1c49              ADDS     r1,r1,#1
0001fc  fbb0f1f1          UDIV     r1,r0,r1
000200  f04f4080          MOV      r0,#0x40000000
000204  f8d003b8          LDR      r0,[r0,#0x3b8]
000208  b2c0              UXTB     r0,r0
00020a  1c40              ADDS     r0,r0,#1
00020c  fbb1f4f0          UDIV     r4,r1,r0
;;;567                break;
000210  e055              B        |L21.702|
                  |L21.530|
;;;568            case kCLOCK_LCD:
;;;569                freq = CLOCK_GetLcdClkFreq() / ((SYSCON->LCDCLKDIV & 0xffU) + 1U);
000212  f7fffffe          BL       CLOCK_GetLcdClkFreq
000216  492b              LDR      r1,|L21.708|
000218  3130              ADDS     r1,r1,#0x30
00021a  6809              LDR      r1,[r1,#0]
00021c  b2c9              UXTB     r1,r1
00021e  1c49              ADDS     r1,r1,#1
000220  fbb0f4f1          UDIV     r4,r0,r1
;;;570                break;
000224  e04b              B        |L21.702|
                  |L21.550|
;;;571            case kCLOCK_MCAN0:
;;;572                freq = CLOCK_GetCoreSysClkFreq() / ((SYSCON->CAN0CLKDIV & 0xffU) + 1U);
000226  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
00022a  4926              LDR      r1,|L21.708|
00022c  3978              SUBS     r1,r1,#0x78
00022e  6809              LDR      r1,[r1,#0]
000230  b2c9              UXTB     r1,r1
000232  1c49              ADDS     r1,r1,#1
000234  fbb0f4f1          UDIV     r4,r0,r1
;;;573                break;
000238  e041              B        |L21.702|
                  |L21.570|
;;;574            case kCLOCK_MCAN1:
;;;575                freq = CLOCK_GetCoreSysClkFreq() / ((SYSCON->CAN1CLKDIV & 0xffU) + 1U);
00023a  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
00023e  4921              LDR      r1,|L21.708|
000240  3974              SUBS     r1,r1,#0x74
000242  6809              LDR      r1,[r1,#0]
000244  b2c9              UXTB     r1,r1
000246  1c49              ADDS     r1,r1,#1
000248  fbb0f4f1          UDIV     r4,r0,r1
;;;576                break;
00024c  e037              B        |L21.702|
                  |L21.590|
;;;577            case kCLOCK_FlexI2S:
;;;578                freq = CLOCK_GetI2SMClkFreq();
00024e  f7fffffe          BL       CLOCK_GetI2SMClkFreq
000252  4604              MOV      r4,r0
;;;579                break;
000254  e033              B        |L21.702|
                  |L21.598|
;;;580            case kCLOCK_Flexcomm0:
;;;581                freq = CLOCK_GetFlexCommClkFreq(0U);
000256  2000              MOVS     r0,#0
000258  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
00025c  4604              MOV      r4,r0
;;;582                break;
00025e  e02e              B        |L21.702|
                  |L21.608|
;;;583            case kCLOCK_Flexcomm1:
;;;584                freq = CLOCK_GetFlexCommClkFreq(1U);
000260  2001              MOVS     r0,#1
000262  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
000266  4604              MOV      r4,r0
;;;585                break;
000268  e029              B        |L21.702|
                  |L21.618|
;;;586            case kCLOCK_Flexcomm2:
;;;587                freq = CLOCK_GetFlexCommClkFreq(2U);
00026a  2002              MOVS     r0,#2
00026c  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
000270  4604              MOV      r4,r0
;;;588                break;
000272  e024              B        |L21.702|
                  |L21.628|
;;;589            case kCLOCK_Flexcomm3:
;;;590                freq = CLOCK_GetFlexCommClkFreq(3U);
000274  2003              MOVS     r0,#3
000276  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
00027a  4604              MOV      r4,r0
;;;591                break;
00027c  e01f              B        |L21.702|
                  |L21.638|
;;;592            case kCLOCK_Flexcomm4:
;;;593                freq = CLOCK_GetFlexCommClkFreq(4U);
00027e  2004              MOVS     r0,#4
000280  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
000284  4604              MOV      r4,r0
;;;594                break;
000286  e01a              B        |L21.702|
                  |L21.648|
;;;595            case kCLOCK_Flexcomm5:
;;;596                freq = CLOCK_GetFlexCommClkFreq(5U);
000288  2005              MOVS     r0,#5
00028a  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
00028e  4604              MOV      r4,r0
;;;597                break;
000290  e015              B        |L21.702|
                  |L21.658|
;;;598            case kCLOCK_Flexcomm6:
;;;599                freq = CLOCK_GetFlexCommClkFreq(6U);
000292  2006              MOVS     r0,#6
000294  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
000298  4604              MOV      r4,r0
;;;600                break;
00029a  e010              B        |L21.702|
                  |L21.668|
;;;601            case kCLOCK_Flexcomm7:
;;;602                freq = CLOCK_GetFlexCommClkFreq(7U);
00029c  2007              MOVS     r0,#7
00029e  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
0002a2  4604              MOV      r4,r0
;;;603                break;
0002a4  e00b              B        |L21.702|
                  |L21.678|
;;;604            case kCLOCK_Flexcomm8:
;;;605                freq = CLOCK_GetFlexCommClkFreq(8U);
0002a6  2008              MOVS     r0,#8
0002a8  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
0002ac  4604              MOV      r4,r0
;;;606                break;
0002ae  e006              B        |L21.702|
                  |L21.688|
;;;607            case kCLOCK_Flexcomm9:
;;;608                freq = CLOCK_GetFlexCommClkFreq(9U);
0002b0  2009              MOVS     r0,#9
0002b2  f7fffffe          BL       CLOCK_GetFlexCommClkFreq
0002b6  4604              MOV      r4,r0
;;;609                break;
0002b8  e001              B        |L21.702|
                  |L21.698|
;;;610            default:
;;;611                freq = 0U;
0002ba  2400              MOVS     r4,#0
;;;612                break;
0002bc  bf00              NOP      
                  |L21.702|
0002be  bf00              NOP                            ;503
;;;613        }
;;;614    
;;;615        return freq;
0002c0  4620              MOV      r0,r4
;;;616    }
0002c2  bd70              POP      {r4-r6,pc}
;;;617    
                          ENDP

                  |L21.708|
                          DCD      0x40000380

                          AREA ||i.CLOCK_GetFro12MFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetFro12MFreq PROC
;;;355    /* Get FRO 12M Clk */
;;;356    uint32_t CLOCK_GetFro12MFreq(void)
000000  4804              LDR      r0,|L22.20|
;;;357    {
;;;358        return (SYSCON->PDRUNCFG[0] & SYSCON_PDRUNCFG_PDEN_FRO_MASK) ? 0U : 12000000U;
000002  6800              LDR      r0,[r0,#0]
000004  f0000010          AND      r0,r0,#0x10
000008  b108              CBZ      r0,|L22.14|
00000a  2000              MOVS     r0,#0
                  |L22.12|
;;;359    }
00000c  4770              BX       lr
                  |L22.14|
00000e  4802              LDR      r0,|L22.24|
000010  e7fc              B        |L22.12|
;;;360    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40000610
                  |L22.24|
                          DCD      0x00b71b00

                          AREA ||i.CLOCK_GetFroHfFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetFroHfFreq PROC
;;;383    /* Get HF FRO Clk */
;;;384    uint32_t CLOCK_GetFroHfFreq(void)
000000  480b              LDR      r0,|L23.48|
;;;385    {
;;;386        return (SYSCON->PDRUNCFG[0] & SYSCON_PDRUNCFG_PDEN_FRO_MASK) ? 0 : !(SYSCON->FROCTRL & SYSCON_FROCTRL_HSPDCLK_MASK) ?
000002  6800              LDR      r0,[r0,#0]
000004  f0000010          AND      r0,r0,#0x10
000008  b108              CBZ      r0,|L23.14|
00000a  2000              MOVS     r0,#0
                  |L23.12|
;;;387                                                            0 :
;;;388                                                            (SYSCON->FROCTRL & SYSCON_FROCTRL_SEL_MASK) ? 96000000U :
;;;389                                                                                                          48000000U;
;;;390    }
00000c  4770              BX       lr
                  |L23.14|
00000e  4809              LDR      r0,|L23.52|
000010  6800              LDR      r0,[r0,#0]            ;386
000012  f0004080          AND      r0,r0,#0x40000000     ;386
000016  b908              CBNZ     r0,|L23.28|
000018  2000              MOVS     r0,#0                 ;387
00001a  e7f7              B        |L23.12|
                  |L23.28|
00001c  4805              LDR      r0,|L23.52|
00001e  6800              LDR      r0,[r0,#0]            ;388
000020  f4004080          AND      r0,r0,#0x4000         ;388
000024  b108              CBZ      r0,|L23.42|
000026  4804              LDR      r0,|L23.56|
000028  e7f0              B        |L23.12|
                  |L23.42|
00002a  4804              LDR      r0,|L23.60|
00002c  e7ee              B        |L23.12|
;;;391    
                          ENDP

00002e  0000              DCW      0x0000
                  |L23.48|
                          DCD      0x40000610
                  |L23.52|
                          DCD      0x40000500
                  |L23.56|
                          DCD      0x05b8d800
                  |L23.60|
                          DCD      0x02dc6c00

                          AREA ||i.CLOCK_GetI2SMClkFreq||, CODE, READONLY, ALIGN=1

                  CLOCK_GetI2SMClkFreq PROC
;;;427    /* Get I2S MCLK Clk */
;;;428    uint32_t CLOCK_GetI2SMClkFreq(void)
000000  2000              MOVS     r0,#0
;;;429    {
;;;430        return g_I2S_Mclk_Freq;
;;;431    }
000002  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.CLOCK_GetLcdClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetLcdClkFreq PROC
;;;340    /* Get LCD Clk */
;;;341    uint32_t CLOCK_GetLcdClkFreq(void)
000000  b500              PUSH     {lr}
;;;342    {
;;;343        return (SYSCON->LCDCLKSEL == 0U) ? CLOCK_GetCoreSysClkFreq():
000002  480e              LDR      r0,|L25.60|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L25.14|
000008  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
                  |L25.12|
;;;344               (SYSCON->LCDCLKSEL == 1U) ? CLOCK_GetLcdClkIn():
;;;345               (SYSCON->LCDCLKSEL == 2U) ? CLOCK_GetFroHfFreq():
;;;346               (SYSCON->LCDCLKSEL == 3U) ? 0U:0U;
;;;347    }
00000c  bd00              POP      {pc}
                  |L25.14|
00000e  480b              LDR      r0,|L25.60|
000010  6800              LDR      r0,[r0,#0]            ;344
000012  2801              CMP      r0,#1                 ;344
000014  d102              BNE      |L25.28|
000016  f7fffffe          BL       CLOCK_GetLcdClkIn
00001a  e7f7              B        |L25.12|
                  |L25.28|
00001c  4807              LDR      r0,|L25.60|
00001e  6800              LDR      r0,[r0,#0]            ;345
000020  2802              CMP      r0,#2                 ;345
000022  d102              BNE      |L25.42|
000024  f7fffffe          BL       CLOCK_GetFroHfFreq
000028  e7f0              B        |L25.12|
                  |L25.42|
00002a  4804              LDR      r0,|L25.60|
00002c  6800              LDR      r0,[r0,#0]            ;346
00002e  2803              CMP      r0,#3                 ;346
000030  d101              BNE      |L25.54|
000032  2000              MOVS     r0,#0                 ;346
000034  e7ea              B        |L25.12|
                  |L25.54|
000036  2000              MOVS     r0,#0                 ;346
000038  e7e8              B        |L25.12|
;;;348    
                          ENDP

00003a  0000              DCW      0x0000
                  |L25.60|
                          DCD      0x400002f4

                          AREA ||i.CLOCK_GetLcdClkIn||, CODE, READONLY, ALIGN=1

                  CLOCK_GetLcdClkIn PROC
;;;349    /* Get LCD CLK IN Clk */
;;;350    uint32_t CLOCK_GetLcdClkIn(void)
000000  2000              MOVS     r0,#0
;;;351    {
;;;352      return g_Lcd_Clk_In_Freq;
;;;353    }
000002  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.CLOCK_GetMclkClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetMclkClkFreq PROC
;;;311    /* Get MCLK Clk */
;;;312    uint32_t CLOCK_GetMclkClkFreq(void)
000000  b500              PUSH     {lr}
;;;313    {
;;;314        return (SYSCON->MCLKCLKSEL == 0U) ? CLOCK_GetFroHfFreq() / ((SYSCON->FROHFCLKDIV & 0xffu) + 1U):
000002  480e              LDR      r0,|L27.60|
000004  6800              LDR      r0,[r0,#0]
000006  b948              CBNZ     r0,|L27.28|
000008  f7fffffe          BL       CLOCK_GetFroHfFreq
00000c  490b              LDR      r1,|L27.60|
00000e  31a8              ADDS     r1,r1,#0xa8
000010  6809              LDR      r1,[r1,#0]
000012  b2c9              UXTB     r1,r1
000014  1c49              ADDS     r1,r1,#1
000016  fbb0f0f1          UDIV     r0,r0,r1
                  |L27.26|
;;;315               (SYSCON->MCLKCLKSEL == 1U) ? CLOCK_GetAudioPllOutFreq():
;;;316               (SYSCON->MCLKCLKSEL == 7U) ? 0U:0U;
;;;317    }
00001a  bd00              POP      {pc}
                  |L27.28|
00001c  4807              LDR      r0,|L27.60|
00001e  6800              LDR      r0,[r0,#0]            ;315
000020  2801              CMP      r0,#1                 ;315
000022  d102              BNE      |L27.42|
000024  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
000028  e7f7              B        |L27.26|
                  |L27.42|
00002a  4804              LDR      r0,|L27.60|
00002c  6800              LDR      r0,[r0,#0]            ;316
00002e  2807              CMP      r0,#7                 ;316
000030  d101              BNE      |L27.54|
000032  2000              MOVS     r0,#0                 ;316
000034  e7f1              B        |L27.26|
                  |L27.54|
000036  2000              MOVS     r0,#0                 ;316
000038  e7ef              B        |L27.26|
;;;318    
                          ENDP

00003a  0000              DCW      0x0000
                  |L27.60|
                          DCD      0x400002e0

                          AREA ||i.CLOCK_GetOsc32KFreq||, CODE, READONLY, ALIGN=1

                  CLOCK_GetOsc32KFreq PROC
;;;410    /* Get RTC OSC Clk */
;;;411    uint32_t CLOCK_GetOsc32KFreq(void)
000000  f44f4000          MOV      r0,#0x8000
;;;412    {
;;;413        return CLK_RTC_32K_CLK;               /* Needs to be corrected to check that RTC Clock is enabled */
;;;414    }
000004  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.CLOCK_GetPllConfig||, CODE, READONLY, ALIGN=2

                  CLOCK_GetPllConfig PROC
;;;987    /* Set PLL output based on desired output rate */
;;;988    static pll_error_t CLOCK_GetPllConfig(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;989        uint32_t finHz, uint32_t foutHz, pll_setup_t *pSetup, bool useFeedbackDiv2)
;;;990    {
000004  b089              SUB      sp,sp,#0x24
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;991        uint32_t nDivOutHz, fccoHz, multFccoDiv;
;;;992        uint32_t pllPreDivider, pllMultiplier, pllPostDivider;
;;;993        uint32_t pllDirectInput, pllDirectOutput;
;;;994        uint32_t pllSelP, pllSelI, pllSelR, uplimoff;
;;;995    
;;;996        /* Baseline parameters (no input or output dividers) */
;;;997        pllPreDivider = 1U;  /* 1 implies pre-divider will be disabled */
00000c  2001              MOVS     r0,#1
00000e  9007              STR      r0,[sp,#0x1c]
;;;998        pllPostDivider = 0U; /* 0 implies post-divider will be disabled */
000010  f04f0b00          MOV      r11,#0
;;;999        pllDirectOutput = 1U;
000014  9005              STR      r0,[sp,#0x14]
;;;1000       multFccoDiv = 2U;
000016  f04f0902          MOV      r9,#2
;;;1001   
;;;1002       /* Verify output rate parameter */
;;;1003       if (foutHz > PLL_MAX_CCO_FREQ_MHZ)
00001a  4844              LDR      r0,|L29.300|
00001c  4286              CMP      r6,r0
00001e  d903              BLS      |L29.40|
;;;1004       {
;;;1005           /* Maximum PLL output with post divider=1 cannot go above this frequency */
;;;1006           return kStatus_PLL_OutputTooHigh;
000020  2002              MOVS     r0,#2
                  |L29.34|
;;;1007       }
;;;1008       if (foutHz < (PLL_MIN_CCO_FREQ_MHZ / (PVALMAX << 1U)))
;;;1009       {
;;;1010           /* Minmum PLL output with maximum post divider cannot go below this frequency */
;;;1011           return kStatus_PLL_OutputTooLow;
;;;1012       }
;;;1013   
;;;1014       /* Verify input rate parameter */
;;;1015       if (finHz < PLL_LOWER_IN_LIMIT)
;;;1016       {
;;;1017           /* Input clock into the PLL cannot be lower than this */
;;;1018           return kStatus_PLL_InputTooLow;
;;;1019       }
;;;1020   
;;;1021       /* Find the optimal CCO frequency for the output and input that
;;;1022          will keep it inside the PLL CCO range. This may require
;;;1023          tweaking the post-divider for the PLL. */
;;;1024       fccoHz = foutHz;
;;;1025       while (fccoHz < PLL_MIN_CCO_FREQ_MHZ)
;;;1026       {
;;;1027           /* CCO output is less than minimum CCO range, so the CCO output
;;;1028              needs to be bumped up and the post-divider is used to bring
;;;1029              the PLL output back down. */
;;;1030           pllPostDivider++;
;;;1031           if (pllPostDivider > PVALMAX)
;;;1032           {
;;;1033               return kStatus_PLL_OutsideIntLimit;
;;;1034           }
;;;1035   
;;;1036           /* Target CCO goes up, PLL output goes down */
;;;1037           fccoHz = foutHz * (pllPostDivider * 2U);
;;;1038           pllDirectOutput = 0U;
;;;1039       }
;;;1040   
;;;1041       /* Determine if a pre-divider is needed to get the best frequency */
;;;1042       if ((finHz > PLL_LOWER_IN_LIMIT) && (fccoHz >= finHz))
;;;1043       {
;;;1044           uint32_t a = FindGreatestCommonDivisor(fccoHz, (multFccoDiv * finHz));
;;;1045   
;;;1046           if (a > 20000U)
;;;1047           {
;;;1048               a = (multFccoDiv * finHz) / a;
;;;1049               if ((a != 0U) && (a < PLL_MAX_N_DIV))
;;;1050               {
;;;1051                   pllPreDivider = a;
;;;1052               }
;;;1053           }
;;;1054       }
;;;1055   
;;;1056       /* Bypass pre-divider hardware if pre-divider is 1 */
;;;1057       if (pllPreDivider > 1U)
;;;1058       {
;;;1059           pllDirectInput = 0U;
;;;1060       }
;;;1061       else
;;;1062       {
;;;1063           pllDirectInput = 1U;
;;;1064       }
;;;1065   
;;;1066       /* Determine PLL multipler */
;;;1067       nDivOutHz = (finHz / pllPreDivider);
;;;1068       pllMultiplier = (fccoHz / nDivOutHz) / multFccoDiv;
;;;1069   
;;;1070       /* Find optimal values for filter */
;;;1071       /* Will bumping up M by 1 get us closer to the desired CCO frequency? */
;;;1072       if ((nDivOutHz * ((multFccoDiv * pllMultiplier * 2U) + 1U)) < (fccoHz * 2U))
;;;1073       {
;;;1074           pllMultiplier++;
;;;1075       }
;;;1076   
;;;1077       /* Setup filtering */
;;;1078       pllFindSel(pllMultiplier, &pllSelP, &pllSelI, &pllSelR);
;;;1079       uplimoff = 0U;
;;;1080   
;;;1081       /* Get encoded value for M (mult) and use manual filter, disable SS mode */
;;;1082       pSetup->syspllmdec =
;;;1083           PLL_MDEC_VAL_SET(pllEncodeM(pllMultiplier)) ;
;;;1084   
;;;1085       /* Get encoded values for N (prediv) and P (postdiv) */
;;;1086       pSetup->syspllndec = PLL_NDEC_VAL_SET(pllEncodeN(pllPreDivider));
;;;1087       pSetup->syspllpdec = PLL_PDEC_VAL_SET(pllEncodeP(pllPostDivider));
;;;1088   
;;;1089       /* PLL control */
;;;1090       pSetup->syspllctrl = (pllSelR << SYSCON_SYSPLLCTRL_SELR_SHIFT) |                  /* Filter coefficient */
;;;1091                            (pllSelI << SYSCON_SYSPLLCTRL_SELI_SHIFT) |                  /* Filter coefficient */
;;;1092                            (pllSelP << SYSCON_SYSPLLCTRL_SELP_SHIFT) |                  /* Filter coefficient */
;;;1093                            (0 << SYSCON_SYSPLLCTRL_BYPASS_SHIFT) |                      /* PLL bypass mode disabled */
;;;1094                            (uplimoff << SYSCON_SYSPLLCTRL_UPLIMOFF_SHIFT) |             /* SS/fractional mode disabled */
;;;1095                            (pllDirectInput << SYSCON_SYSPLLCTRL_DIRECTI_SHIFT) | /* Bypass pre-divider? */
;;;1096                            (pllDirectOutput << SYSCON_SYSPLLCTRL_DIRECTO_SHIFT); /* Bypass post-divider? */
;;;1097   
;;;1098       return kStatus_PLL_Success;
;;;1099   }
000022  b009              ADD      sp,sp,#0x24
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L29.40|
000028  4841              LDR      r0,|L29.304|
00002a  4286              CMP      r6,r0                 ;1008
00002c  d201              BCS      |L29.50|
00002e  2001              MOVS     r0,#1                 ;1011
000030  e7f7              B        |L29.34|
                  |L29.50|
000032  f5b46f7a          CMP      r4,#0xfa0             ;1015
000036  d201              BCS      |L29.60|
000038  2003              MOVS     r0,#3                 ;1018
00003a  e7f2              B        |L29.34|
                  |L29.60|
00003c  4635              MOV      r5,r6                 ;1024
00003e  e00c              B        |L29.90|
                  |L29.64|
000040  f10b0b01          ADD      r11,r11,#1            ;1030
000044  f1bb0f20          CMP      r11,#0x20             ;1031
000048  d901              BLS      |L29.78|
00004a  2005              MOVS     r0,#5                 ;1033
00004c  e7e9              B        |L29.34|
                  |L29.78|
00004e  ea4f004b          LSL      r0,r11,#1             ;1037
000052  fb00f506          MUL      r5,r0,r6              ;1037
000056  2000              MOVS     r0,#0                 ;1038
000058  9005              STR      r0,[sp,#0x14]         ;1038
                  |L29.90|
00005a  4836              LDR      r0,|L29.308|
00005c  4285              CMP      r5,r0                 ;1025
00005e  d3ef              BCC      |L29.64|
000060  f5b46f7a          CMP      r4,#0xfa0             ;1042
000064  d918              BLS      |L29.152|
000066  42a5              CMP      r5,r4                 ;1042
000068  d316              BCC      |L29.152|
00006a  fb09f104          MUL      r1,r9,r4              ;1044
00006e  4628              MOV      r0,r5                 ;1044
000070  f7fffffe          BL       FindGreatestCommonDivisor
000074  4680              MOV      r8,r0                 ;1044
000076  f6446020          MOV      r0,#0x4e20            ;1046
00007a  4580              CMP      r8,r0                 ;1046
00007c  d90b              BLS      |L29.150|
00007e  fb09f004          MUL      r0,r9,r4              ;1048
000082  fbb0f8f8          UDIV     r8,r0,r8              ;1048
000086  f1b80f00          CMP      r8,#0                 ;1049
00008a  d004              BEQ      |L29.150|
00008c  f1b80fff          CMP      r8,#0xff              ;1049
000090  d801              BHI      |L29.150|
000092  f8cd801c          STR      r8,[sp,#0x1c]         ;1051
                  |L29.150|
000096  bf00              NOP                            ;1054
                  |L29.152|
000098  9807              LDR      r0,[sp,#0x1c]         ;1057
00009a  2801              CMP      r0,#1                 ;1057
00009c  d902              BLS      |L29.164|
00009e  2000              MOVS     r0,#0                 ;1059
0000a0  9006              STR      r0,[sp,#0x18]         ;1059
0000a2  e001              B        |L29.168|
                  |L29.164|
0000a4  2001              MOVS     r0,#1                 ;1063
0000a6  9006              STR      r0,[sp,#0x18]         ;1063
                  |L29.168|
0000a8  9807              LDR      r0,[sp,#0x1c]         ;1067
0000aa  fbb4f0f0          UDIV     r0,r4,r0              ;1067
0000ae  9008              STR      r0,[sp,#0x20]         ;1067
0000b0  9808              LDR      r0,[sp,#0x20]         ;1068
0000b2  fbb5f0f0          UDIV     r0,r5,r0              ;1068
0000b6  fbb0faf9          UDIV     r10,r0,r9             ;1068
0000ba  fb09f00a          MUL      r0,r9,r10             ;1072
0000be  2101              MOVS     r1,#1                 ;1072
0000c0  eb010140          ADD      r1,r1,r0,LSL #1       ;1072
0000c4  9808              LDR      r0,[sp,#0x20]         ;1072
0000c6  4348              MULS     r0,r1,r0              ;1072
0000c8  ebb00f45          CMP      r0,r5,LSL #1          ;1072
0000cc  d201              BCS      |L29.210|
0000ce  f10a0a01          ADD      r10,r10,#1            ;1074
                  |L29.210|
0000d2  ab02              ADD      r3,sp,#8              ;1078
0000d4  aa03              ADD      r2,sp,#0xc            ;1078
0000d6  a904              ADD      r1,sp,#0x10           ;1078
0000d8  4650              MOV      r0,r10                ;1078
0000da  f7fffffe          BL       pllFindSel
0000de  2000              MOVS     r0,#0                 ;1079
0000e0  9001              STR      r0,[sp,#4]            ;1079
0000e2  4650              MOV      r0,r10                ;1082
0000e4  f7fffffe          BL       pllEncodeM
0000e8  f3c00010          UBFX     r0,r0,#0,#17          ;1082
0000ec  60f8              STR      r0,[r7,#0xc]          ;1082
0000ee  9807              LDR      r0,[sp,#0x1c]         ;1086
0000f0  f7fffffe          BL       pllEncodeN
0000f4  f3c00009          UBFX     r0,r0,#0,#10          ;1086
0000f8  6078              STR      r0,[r7,#4]            ;1086
0000fa  4658              MOV      r0,r11                ;1087
0000fc  f7fffffe          BL       pllEncodeP
000100  f3c00009          UBFX     r0,r0,#0,#10          ;1087
000104  60b8              STR      r0,[r7,#8]            ;1087
000106  e9dd0102          LDRD     r0,r1,[sp,#8]         ;1090
00010a  ea401001          ORR      r0,r0,r1,LSL #4       ;1090
00010e  9904              LDR      r1,[sp,#0x10]         ;1090
000110  ea402181          ORR      r1,r0,r1,LSL #10      ;1090
000114  9801              LDR      r0,[sp,#4]            ;1090
000116  ea414140          ORR      r1,r1,r0,LSL #17      ;1090
00011a  9806              LDR      r0,[sp,#0x18]         ;1090
00011c  ea4141c0          ORR      r1,r1,r0,LSL #19      ;1090
000120  9805              LDR      r0,[sp,#0x14]         ;1090
000122  ea415000          ORR      r0,r1,r0,LSL #20      ;1090
000126  6038              STR      r0,[r7,#0]            ;1090
000128  2000              MOVS     r0,#0                 ;1098
00012a  e77a              B        |L29.34|
;;;1100   
                          ENDP

                  |L29.300|
                          DCD      0x20c85580
                  |L29.304|
                          DCD      0x004190ab
                  |L29.308|
                          DCD      0x10642ac0

                          AREA ||i.CLOCK_GetPllOutFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetPllOutFreq PROC
;;;392    /* Get SYSTEM PLL Clk */
;;;393    uint32_t CLOCK_GetPllOutFreq(void)
000000  4801              LDR      r0,|L30.8|
;;;394    {
;;;395        return s_Pll_Freq;
000002  6800              LDR      r0,[r0,#0]  ; s_Pll_Freq
;;;396    }
000004  4770              BX       lr
;;;397    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      s_Pll_Freq

                          AREA ||i.CLOCK_GetSctClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetSctClkFreq PROC
;;;319    /* Get SCTIMER Clk */
;;;320    uint32_t CLOCK_GetSctClkFreq(void)
000000  b500              PUSH     {lr}
;;;321    {
;;;322        return (SYSCON->SCTCLKSEL == 0U) ? CLOCK_GetCoreSysClkFreq():
000002  4811              LDR      r0,|L31.72|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L31.14|
000008  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
                  |L31.12|
;;;323               (SYSCON->SCTCLKSEL == 1U) ? CLOCK_GetPllOutFreq():
;;;324               (SYSCON->SCTCLKSEL == 2U) ? CLOCK_GetFroHfFreq():
;;;325               (SYSCON->SCTCLKSEL == 3U) ? CLOCK_GetAudioPllOutFreq():
;;;326               (SYSCON->SCTCLKSEL == 7U) ? 0U:0U;
;;;327    }
00000c  bd00              POP      {pc}
                  |L31.14|
00000e  480e              LDR      r0,|L31.72|
000010  6800              LDR      r0,[r0,#0]            ;323
000012  2801              CMP      r0,#1                 ;323
000014  d102              BNE      |L31.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L31.12|
                  |L31.28|
00001c  480a              LDR      r0,|L31.72|
00001e  6800              LDR      r0,[r0,#0]            ;324
000020  2802              CMP      r0,#2                 ;324
000022  d102              BNE      |L31.42|
000024  f7fffffe          BL       CLOCK_GetFroHfFreq
000028  e7f0              B        |L31.12|
                  |L31.42|
00002a  4807              LDR      r0,|L31.72|
00002c  6800              LDR      r0,[r0,#0]            ;325
00002e  2803              CMP      r0,#3                 ;325
000030  d102              BNE      |L31.56|
000032  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
000036  e7e9              B        |L31.12|
                  |L31.56|
000038  4803              LDR      r0,|L31.72|
00003a  6800              LDR      r0,[r0,#0]            ;326
00003c  2807              CMP      r0,#7                 ;326
00003e  d101              BNE      |L31.68|
000040  2000              MOVS     r0,#0                 ;326
000042  e7e3              B        |L31.12|
                  |L31.68|
000044  2000              MOVS     r0,#0                 ;326
000046  e7e1              B        |L31.12|
;;;328    
                          ENDP

                  |L31.72|
                          DCD      0x400002f0

                          AREA ||i.CLOCK_GetSdioClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetSdioClkFreq PROC
;;;329    /* Get SDIO Clk */
;;;330    uint32_t CLOCK_GetSdioClkFreq(void)
000000  b500              PUSH     {lr}
;;;331    {
;;;332        return (SYSCON->SDIOCLKSEL == 0U) ? CLOCK_GetCoreSysClkFreq():
000002  4815              LDR      r0,|L32.88|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L32.14|
000008  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
                  |L32.12|
;;;333               (SYSCON->SDIOCLKSEL == 1U) ? CLOCK_GetPllOutFreq():
;;;334               (SYSCON->SDIOCLKSEL == 2U) ? CLOCK_GetUsbPllOutFreq():
;;;335               (SYSCON->SDIOCLKSEL == 3U) ? CLOCK_GetFroHfFreq():
;;;336               (SYSCON->SDIOCLKSEL == 4U) ? CLOCK_GetAudioPllOutFreq():
;;;337               (SYSCON->SDIOCLKSEL == 7U) ? 0U:0U;
;;;338    }
00000c  bd00              POP      {pc}
                  |L32.14|
00000e  4812              LDR      r0,|L32.88|
000010  6800              LDR      r0,[r0,#0]            ;333
000012  2801              CMP      r0,#1                 ;333
000014  d102              BNE      |L32.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L32.12|
                  |L32.28|
00001c  480e              LDR      r0,|L32.88|
00001e  6800              LDR      r0,[r0,#0]            ;334
000020  2802              CMP      r0,#2                 ;334
000022  d102              BNE      |L32.42|
000024  f7fffffe          BL       CLOCK_GetUsbPllOutFreq
000028  e7f0              B        |L32.12|
                  |L32.42|
00002a  480b              LDR      r0,|L32.88|
00002c  6800              LDR      r0,[r0,#0]            ;335
00002e  2803              CMP      r0,#3                 ;335
000030  d102              BNE      |L32.56|
000032  f7fffffe          BL       CLOCK_GetFroHfFreq
000036  e7e9              B        |L32.12|
                  |L32.56|
000038  4807              LDR      r0,|L32.88|
00003a  6800              LDR      r0,[r0,#0]            ;336
00003c  2804              CMP      r0,#4                 ;336
00003e  d102              BNE      |L32.70|
000040  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
000044  e7e2              B        |L32.12|
                  |L32.70|
000046  4804              LDR      r0,|L32.88|
000048  6800              LDR      r0,[r0,#0]            ;337
00004a  2807              CMP      r0,#7                 ;337
00004c  d101              BNE      |L32.82|
00004e  2000              MOVS     r0,#0                 ;337
000050  e7dc              B        |L32.12|
                  |L32.82|
000052  2000              MOVS     r0,#0                 ;337
000054  e7da              B        |L32.12|
;;;339    
                          ENDP

000056  0000              DCW      0x0000
                  |L32.88|
                          DCD      0x400002f8

                          AREA ||i.CLOCK_GetSpifiClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetSpifiClkFreq PROC
;;;271    /* Get SPIFI Clk */
;;;272    uint32_t CLOCK_GetSpifiClkFreq(void)
000000  b500              PUSH     {lr}
;;;273    {
;;;274        return (SYSCON->SPIFICLKSEL == 0U) ? CLOCK_GetCoreSysClkFreq():
000002  4815              LDR      r0,|L33.88|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L33.14|
000008  f7fffffe          BL       CLOCK_GetCoreSysClkFreq
                  |L33.12|
;;;275               (SYSCON->SPIFICLKSEL == 1U) ? CLOCK_GetPllOutFreq():
;;;276               (SYSCON->SPIFICLKSEL == 2U) ? CLOCK_GetUsbPllOutFreq():
;;;277               (SYSCON->SPIFICLKSEL == 3U) ? CLOCK_GetFroHfFreq():
;;;278               (SYSCON->SPIFICLKSEL == 4U) ? CLOCK_GetAudioPllOutFreq():
;;;279               (SYSCON->SPIFICLKSEL == 7U) ? 0U:0U;
;;;280    }
00000c  bd00              POP      {pc}
                  |L33.14|
00000e  4812              LDR      r0,|L33.88|
000010  6800              LDR      r0,[r0,#0]            ;275
000012  2801              CMP      r0,#1                 ;275
000014  d102              BNE      |L33.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L33.12|
                  |L33.28|
00001c  480e              LDR      r0,|L33.88|
00001e  6800              LDR      r0,[r0,#0]            ;276
000020  2802              CMP      r0,#2                 ;276
000022  d102              BNE      |L33.42|
000024  f7fffffe          BL       CLOCK_GetUsbPllOutFreq
000028  e7f0              B        |L33.12|
                  |L33.42|
00002a  480b              LDR      r0,|L33.88|
00002c  6800              LDR      r0,[r0,#0]            ;277
00002e  2803              CMP      r0,#3                 ;277
000030  d102              BNE      |L33.56|
000032  f7fffffe          BL       CLOCK_GetFroHfFreq
000036  e7e9              B        |L33.12|
                  |L33.56|
000038  4807              LDR      r0,|L33.88|
00003a  6800              LDR      r0,[r0,#0]            ;278
00003c  2804              CMP      r0,#4                 ;278
00003e  d102              BNE      |L33.70|
000040  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
000044  e7e2              B        |L33.12|
                  |L33.70|
000046  4804              LDR      r0,|L33.88|
000048  6800              LDR      r0,[r0,#0]            ;279
00004a  2807              CMP      r0,#7                 ;279
00004c  d101              BNE      |L33.82|
00004e  2000              MOVS     r0,#0                 ;279
000050  e7dc              B        |L33.12|
                  |L33.82|
000052  2000              MOVS     r0,#0                 ;279
000054  e7da              B        |L33.12|
;;;281    
                          ENDP

000056  0000              DCW      0x0000
                  |L33.88|
                          DCD      0x400002a0

                          AREA ||i.CLOCK_GetSystemPLLInClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetSystemPLLInClockRate PROC
;;;1120   /* Return System PLL input clock rate */
;;;1121   uint32_t CLOCK_GetSystemPLLInClockRate(void)
000000  b510              PUSH     {r4,lr}
;;;1122   {
;;;1123       uint32_t clkRate = 0U;
000002  2400              MOVS     r4,#0
;;;1124   
;;;1125       switch ((SYSCON->SYSPLLCLKSEL & SYSCON_SYSPLLCLKSEL_SEL_MASK))
000004  480f              LDR      r0,|L34.68|
000006  6800              LDR      r0,[r0,#0]
000008  f0000007          AND      r0,r0,#7
00000c  b130              CBZ      r0,|L34.28|
00000e  2801              CMP      r0,#1
000010  d006              BEQ      |L34.32|
000012  2802              CMP      r0,#2
000014  d008              BEQ      |L34.40|
000016  2803              CMP      r0,#3
000018  d10e              BNE      |L34.56|
00001a  e009              B        |L34.48|
                  |L34.28|
;;;1126       {
;;;1127           case 0x00U:
;;;1128               clkRate = CLK_FRO_12MHZ;
00001c  4c0a              LDR      r4,|L34.72|
;;;1129               break;
00001e  e00d              B        |L34.60|
                  |L34.32|
;;;1130   
;;;1131           case 0x01U:
;;;1132               clkRate = CLOCK_GetExtClkFreq();
000020  f7fffffe          BL       CLOCK_GetExtClkFreq
000024  4604              MOV      r4,r0
;;;1133               break;
000026  e009              B        |L34.60|
                  |L34.40|
;;;1134   
;;;1135           case 0x02U:
;;;1136               clkRate = CLOCK_GetWdtOscFreq();
000028  f7fffffe          BL       CLOCK_GetWdtOscFreq
00002c  4604              MOV      r4,r0
;;;1137               break;
00002e  e005              B        |L34.60|
                  |L34.48|
;;;1138   
;;;1139           case 0x03U:
;;;1140               clkRate = CLOCK_GetOsc32KFreq();
000030  f7fffffe          BL       CLOCK_GetOsc32KFreq
000034  4604              MOV      r4,r0
;;;1141               break;
000036  e001              B        |L34.60|
                  |L34.56|
;;;1142   
;;;1143           default:
;;;1144               clkRate = 0U;
000038  2400              MOVS     r4,#0
;;;1145               break;
00003a  bf00              NOP      
                  |L34.60|
00003c  bf00              NOP                            ;1129
;;;1146       }
;;;1147   
;;;1148       return clkRate;
00003e  4620              MOV      r0,r4
;;;1149   }
000040  bd10              POP      {r4,pc}
;;;1150   
                          ENDP

000042  0000              DCW      0x0000
                  |L34.68|
                          DCD      0x40000290
                  |L34.72|
                          DCD      0x00b71b00

                          AREA ||i.CLOCK_GetSystemPLLOutClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetSystemPLLOutClockRate PROC
;;;1281   /* Return System PLL output clock rate */
;;;1282   uint32_t CLOCK_GetSystemPLLOutClockRate(bool recompute)
000000  b530              PUSH     {r4,r5,lr}
;;;1283   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;1284       pll_setup_t Setup;
;;;1285       uint32_t rate;
;;;1286   
;;;1287       if ((recompute) || (s_Pll_Freq == 0U))
000006  b914              CBNZ     r4,|L35.14|
000008  480c              LDR      r0,|L35.60|
00000a  6800              LDR      r0,[r0,#0]  ; s_Pll_Freq
00000c  b988              CBNZ     r0,|L35.50|
                  |L35.14|
;;;1288       {
;;;1289           Setup.syspllctrl = SYSCON->SYSPLLCTRL;
00000e  480c              LDR      r0,|L35.64|
000010  6800              LDR      r0,[r0,#0]
000012  9001              STR      r0,[sp,#4]
;;;1290           Setup.syspllndec = SYSCON->SYSPLLNDEC;
000014  480a              LDR      r0,|L35.64|
000016  3008              ADDS     r0,r0,#8
000018  6800              LDR      r0,[r0,#0]
00001a  9002              STR      r0,[sp,#8]
;;;1291           Setup.syspllpdec = SYSCON->SYSPLLPDEC;
00001c  4808              LDR      r0,|L35.64|
00001e  300c              ADDS     r0,r0,#0xc
000020  6800              LDR      r0,[r0,#0]
000022  9003              STR      r0,[sp,#0xc]
;;;1292           Setup.syspllmdec = SYSCON->SYSPLLMDEC;
000024  4806              LDR      r0,|L35.64|
000026  3010              ADDS     r0,r0,#0x10
000028  6800              LDR      r0,[r0,#0]
00002a  9004              STR      r0,[sp,#0x10]
;;;1293   
;;;1294           CLOCK_GetSystemPLLOutFromSetupUpdate(&Setup);
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       CLOCK_GetSystemPLLOutFromSetupUpdate
                  |L35.50|
;;;1295       }
;;;1296   
;;;1297       rate = s_Pll_Freq;
000032  4802              LDR      r0,|L35.60|
000034  6805              LDR      r5,[r0,#0]  ; s_Pll_Freq
;;;1298   
;;;1299       return rate;
000036  4628              MOV      r0,r5
;;;1300   }
000038  b007              ADD      sp,sp,#0x1c
00003a  bd30              POP      {r4,r5,pc}
;;;1301   
                          ENDP

                  |L35.60|
                          DCD      s_Pll_Freq
                  |L35.64|
                          DCD      0x40000580

                          AREA ||i.CLOCK_GetSystemPLLOutFromSetup||, CODE, READONLY, ALIGN=1

                  CLOCK_GetSystemPLLOutFromSetup PROC
;;;1174   /* Return System PLL output clock rate from setup structure */
;;;1175   uint32_t CLOCK_GetSystemPLLOutFromSetup(pll_setup_t *pSetup)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1176   {
000004  4604              MOV      r4,r0
;;;1177       uint32_t prediv, postdiv, mMult, inPllRate;
;;;1178       uint64_t workRate;
;;;1179   
;;;1180       inPllRate = CLOCK_GetSystemPLLInClockRate();
000006  f7fffffe          BL       CLOCK_GetSystemPLLInClockRate
00000a  4607              MOV      r7,r0
;;;1181       if ((pSetup->syspllctrl & (1UL << SYSCON_SYSPLLCTRL_BYPASS_SHIFT)) == 0U)
00000c  8820              LDRH     r0,[r4,#0]
00000e  f4004000          AND      r0,r0,#0x8000
000012  b9f0              CBNZ     r0,|L36.82|
;;;1182       {
;;;1183           /* PLL is not in bypass mode, get pre-divider, post-divider, and M divider */
;;;1184           prediv = findPllPreDiv(pSetup->syspllctrl, pSetup->syspllndec);
000014  e9d40100          LDRD     r0,r1,[r4,#0]
000018  f7fffffe          BL       findPllPreDiv
00001c  4681              MOV      r9,r0
;;;1185           postdiv = findPllPostDiv(pSetup->syspllctrl, pSetup->syspllpdec);
00001e  68a1              LDR      r1,[r4,#8]
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       findPllPostDiv
000026  4680              MOV      r8,r0
;;;1186   
;;;1187           /* Adjust input clock */
;;;1188           inPllRate = inPllRate / prediv;
000028  fbb7f7f9          UDIV     r7,r7,r9
;;;1189   
;;;1190           /* MDEC used for rate */
;;;1191           mMult = findPllMMult(pSetup->syspllctrl, pSetup->syspllmdec);
00002c  68e1              LDR      r1,[r4,#0xc]
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       findPllMMult
000034  4682              MOV      r10,r0
;;;1192           workRate = (uint64_t)inPllRate * (uint64_t)mMult;
000036  fba7500a          UMULL    r5,r0,r7,r10
00003a  4606              MOV      r6,r0
;;;1193   
;;;1194           workRate = workRate / ((uint64_t)postdiv);
00003c  4642              MOV      r2,r8
00003e  2300              MOVS     r3,#0
000040  4628              MOV      r0,r5
000042  4631              MOV      r1,r6
000044  f7fffffe          BL       __aeabi_uldivmod
000048  4605              MOV      r5,r0
;;;1195           workRate = workRate * 2U; /* SYS PLL hardware cco is divide by 2 before to M-DIVIDER*/
00004a  2002              MOVS     r0,#2
00004c  fba55100          UMULL    r5,r1,r5,r0
000050  e000              B        |L36.84|
                  |L36.82|
;;;1196   
;;;1197       }
;;;1198       else
;;;1199       {
;;;1200           /* In bypass mode */
;;;1201           workRate = (uint64_t)inPllRate;
000052  463d              MOV      r5,r7
                  |L36.84|
;;;1202       }
;;;1203   
;;;1204       return (uint32_t)workRate;
000054  4628              MOV      r0,r5
;;;1205   }
000056  e8bd87f0          POP      {r4-r10,pc}
;;;1206   
                          ENDP


                          AREA ||i.CLOCK_GetSystemPLLOutFromSetupUpdate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetSystemPLLOutFromSetupUpdate PROC
;;;1102   /* Update SYSTEM PLL rate variable */
;;;1103   static void CLOCK_GetSystemPLLOutFromSetupUpdate(pll_setup_t *pSetup)
000000  b510              PUSH     {r4,lr}
;;;1104   {
000002  4604              MOV      r4,r0
;;;1105       s_Pll_Freq = CLOCK_GetSystemPLLOutFromSetup(pSetup);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLOCK_GetSystemPLLOutFromSetup
00000a  4901              LDR      r1,|L37.16|
00000c  6008              STR      r0,[r1,#0]  ; s_Pll_Freq
;;;1106   }
00000e  bd10              POP      {r4,pc}
;;;1107   
                          ENDP

                  |L37.16|
                          DCD      s_Pll_Freq

                          AREA ||i.CLOCK_GetUsb0ClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetUsb0ClkFreq PROC
;;;292    /* Get USB0 Clk */
;;;293    uint32_t CLOCK_GetUsb0ClkFreq(void)
000000  b500              PUSH     {lr}
;;;294    {
;;;295        return (SYSCON->USB0CLKSEL == 0U) ? CLOCK_GetFroHfFreq():
000002  480e              LDR      r0,|L38.60|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L38.14|
000008  f7fffffe          BL       CLOCK_GetFroHfFreq
                  |L38.12|
;;;296               (SYSCON->USB0CLKSEL == 1U) ? CLOCK_GetPllOutFreq():
;;;297               (SYSCON->USB0CLKSEL == 2U) ? CLOCK_GetUsbPllOutFreq():
;;;298               (SYSCON->USB0CLKSEL == 7U) ? 0U:0U;
;;;299    }
00000c  bd00              POP      {pc}
                  |L38.14|
00000e  480b              LDR      r0,|L38.60|
000010  6800              LDR      r0,[r0,#0]            ;296
000012  2801              CMP      r0,#1                 ;296
000014  d102              BNE      |L38.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L38.12|
                  |L38.28|
00001c  4807              LDR      r0,|L38.60|
00001e  6800              LDR      r0,[r0,#0]            ;297
000020  2802              CMP      r0,#2                 ;297
000022  d102              BNE      |L38.42|
000024  f7fffffe          BL       CLOCK_GetUsbPllOutFreq
000028  e7f0              B        |L38.12|
                  |L38.42|
00002a  4804              LDR      r0,|L38.60|
00002c  6800              LDR      r0,[r0,#0]            ;298
00002e  2807              CMP      r0,#7                 ;298
000030  d101              BNE      |L38.54|
000032  2000              MOVS     r0,#0                 ;298
000034  e7ea              B        |L38.12|
                  |L38.54|
000036  2000              MOVS     r0,#0                 ;298
000038  e7e8              B        |L38.12|
;;;300    
                          ENDP

00003a  0000              DCW      0x0000
                  |L38.60|
                          DCD      0x400002a8

                          AREA ||i.CLOCK_GetUsb1ClkFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetUsb1ClkFreq PROC
;;;301    /* Get USB1 Clk */
;;;302    uint32_t CLOCK_GetUsb1ClkFreq(void)
000000  b500              PUSH     {lr}
;;;303    {
;;;304    
;;;305        return (SYSCON->USB1CLKSEL == 0U) ? CLOCK_GetFroHfFreq():
000002  480e              LDR      r0,|L39.60|
000004  6800              LDR      r0,[r0,#0]
000006  b910              CBNZ     r0,|L39.14|
000008  f7fffffe          BL       CLOCK_GetFroHfFreq
                  |L39.12|
;;;306               (SYSCON->USB1CLKSEL == 1U) ? CLOCK_GetPllOutFreq():
;;;307               (SYSCON->USB1CLKSEL == 2U) ? CLOCK_GetUsbPllOutFreq():
;;;308               (SYSCON->USB1CLKSEL == 7U) ? 0U:0U;
;;;309    }
00000c  bd00              POP      {pc}
                  |L39.14|
00000e  480b              LDR      r0,|L39.60|
000010  6800              LDR      r0,[r0,#0]            ;306
000012  2801              CMP      r0,#1                 ;306
000014  d102              BNE      |L39.28|
000016  f7fffffe          BL       CLOCK_GetPllOutFreq
00001a  e7f7              B        |L39.12|
                  |L39.28|
00001c  4807              LDR      r0,|L39.60|
00001e  6800              LDR      r0,[r0,#0]            ;307
000020  2802              CMP      r0,#2                 ;307
000022  d102              BNE      |L39.42|
000024  f7fffffe          BL       CLOCK_GetUsbPllOutFreq
000028  e7f0              B        |L39.12|
                  |L39.42|
00002a  4804              LDR      r0,|L39.60|
00002c  6800              LDR      r0,[r0,#0]            ;308
00002e  2807              CMP      r0,#7                 ;308
000030  d101              BNE      |L39.54|
000032  2000              MOVS     r0,#0                 ;308
000034  e7ea              B        |L39.12|
                  |L39.54|
000036  2000              MOVS     r0,#0                 ;308
000038  e7e8              B        |L39.12|
;;;310    
                          ENDP

00003a  0000              DCW      0x0000
                  |L39.60|
                          DCD      0x400002ac

                          AREA ||i.CLOCK_GetUsbPLLOutClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetUsbPLLOutClockRate PROC
;;;1322   /* Return USB PLL output clock rate */
;;;1323   uint32_t CLOCK_GetUsbPLLOutClockRate(bool recompute)
000000  b53e              PUSH     {r1-r5,lr}
;;;1324   {
000002  4604              MOV      r4,r0
;;;1325       usb_pll_setup_t Setup;
;;;1326       uint32_t rate;
;;;1327   
;;;1328       if ((recompute) || (s_Usb_Pll_Freq == 0U))
000004  b914              CBNZ     r4,|L40.12|
000006  4818              LDR      r0,|L40.104|
000008  6800              LDR      r0,[r0,#0]  ; s_Usb_Pll_Freq
00000a  bb48              CBNZ     r0,|L40.96|
                  |L40.12|
;;;1329       {
;;;1330           Setup.msel = (SYSCON->USBPLLCTRL >> SYSCON_USBPLLCTRL_MSEL_SHIFT) & SYSCON_USBPLLCTRL_MSEL_MASK;
00000c  4817              LDR      r0,|L40.108|
00000e  6800              LDR      r0,[r0,#0]
000010  b2c0              UXTB     r0,r0
000012  f88d0000          STRB     r0,[sp,#0]
;;;1331           Setup.psel = (SYSCON->USBPLLCTRL >> SYSCON_USBPLLCTRL_PSEL_SHIFT) & SYSCON_USBPLLCTRL_PSEL_MASK;
000016  4815              LDR      r0,|L40.108|
000018  6800              LDR      r0,[r0,#0]
00001a  2100              MOVS     r1,#0
00001c  ea012010          AND      r0,r1,r0,LSR #8
000020  f88d0001          STRB     r0,[sp,#1]
;;;1332           Setup.nsel = (SYSCON->USBPLLCTRL >> SYSCON_USBPLLCTRL_NSEL_SHIFT) & SYSCON_USBPLLCTRL_NSEL_MASK;
000024  4811              LDR      r0,|L40.108|
000026  6800              LDR      r0,[r0,#0]
000028  ea012090          AND      r0,r1,r0,LSR #10
00002c  f88d0002          STRB     r0,[sp,#2]
;;;1333           Setup.fbsel = (SYSCON->USBPLLCTRL >> SYSCON_USBPLLCTRL_BYPASSCCODIV2_SHIFT) & SYSCON_USBPLLCTRL_BYPASSCCODIV2_MASK;
000030  480e              LDR      r0,|L40.108|
000032  6800              LDR      r0,[r0,#0]
000034  0b80              LSRS     r0,r0,#14
000036  f3c03080          UBFX     r0,r0,#14,#1
00003a  f88d0005          STRB     r0,[sp,#5]
;;;1334           Setup.bypass = (SYSCON->USBPLLCTRL >> SYSCON_USBPLLCTRL_BYPASS_SHIFT) & SYSCON_USBPLLCTRL_BYPASS_MASK;
00003e  480b              LDR      r0,|L40.108|
000040  6800              LDR      r0,[r0,#0]
000042  0b40              LSRS     r0,r0,#13
000044  f3c03040          UBFX     r0,r0,#13,#1
000048  f88d0004          STRB     r0,[sp,#4]
;;;1335           Setup.direct = (SYSCON->USBPLLCTRL >> SYSCON_USBPLLCTRL_DIRECT_SHIFT) & SYSCON_USBPLLCTRL_DIRECT_MASK; 
00004c  4807              LDR      r0,|L40.108|
00004e  6800              LDR      r0,[r0,#0]
000050  0b00              LSRS     r0,r0,#12
000052  f3c03000          UBFX     r0,r0,#12,#1
000056  f88d0003          STRB     r0,[sp,#3]
;;;1336           CLOCK_GetUsbPLLOutFromSetupUpdate(&Setup);
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       CLOCK_GetUsbPLLOutFromSetupUpdate
                  |L40.96|
;;;1337       }
;;;1338   
;;;1339       rate = s_Usb_Pll_Freq;
000060  4801              LDR      r0,|L40.104|
000062  6805              LDR      r5,[r0,#0]  ; s_Usb_Pll_Freq
;;;1340       return rate;
000064  4628              MOV      r0,r5
;;;1341   }
000066  bd3e              POP      {r1-r5,pc}
;;;1342   
                          ENDP

                  |L40.104|
                          DCD      s_Usb_Pll_Freq
                  |L40.108|
                          DCD      0x4000051c

                          AREA ||i.CLOCK_GetUsbPLLOutFromSetup||, CODE, READONLY, ALIGN=1

                  CLOCK_GetUsbPLLOutFromSetup PROC
;;;1207   /* Return Usb PLL output clock rate from setup structure */
;;;1208   uint32_t CLOCK_GetUsbPLLOutFromSetup(const usb_pll_setup_t *pSetup)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1209   {
000002  4603              MOV      r3,r0
;;;1210       uint32_t nsel, psel, msel, inPllRate;
;;;1211       uint64_t workRate;
;;;1212       inPllRate = CLOCK_GetExtClkFreq();
000004  f7fffffe          BL       CLOCK_GetExtClkFreq
000008  4607              MOV      r7,r0
;;;1213       msel = pSetup->msel;
00000a  781e              LDRB     r6,[r3,#0]
;;;1214       psel = pSetup->psel;
00000c  785c              LDRB     r4,[r3,#1]
;;;1215       nsel = pSetup->nsel;
00000e  789d              LDRB     r5,[r3,#2]
;;;1216   
;;;1217       if (pSetup->fbsel == 1U)
000010  7958              LDRB     r0,[r3,#5]
000012  2801              CMP      r0,#1
000014  d106              BNE      |L41.36|
;;;1218          {   
;;;1219              /*integer_mode: Fout = M*(Fin/N),  Fcco = 2*P*M*(Fin/N) */
;;;1220              workRate = (inPllRate) * (msel + 1U) / (nsel + 1U);
000016  1c70              ADDS     r0,r6,#1
000018  4378              MULS     r0,r7,r0
00001a  f1050c01          ADD      r12,r5,#1
00001e  fbb0f1fc          UDIV     r1,r0,r12
000022  e01f              B        |L41.100|
                  |L41.36|
;;;1221          }
;;;1222          else
;;;1223          {
;;;1224              /* non integer_mode: Fout = M*(Fin/N)/(2*P), Fcco = M * (Fin/N) */
;;;1225              workRate = (inPllRate / (nsel + 1U)) * (msel + 1U) / (2U * SWITCH_USB_PSEL(psel));
000024  1c68              ADDS     r0,r5,#1
000026  fbb7f0f0          UDIV     r0,r7,r0
00002a  f1060c01          ADD      r12,r6,#1
00002e  fb00f00c          MUL      r0,r0,r12
000032  b914              CBNZ     r4,|L41.58|
000034  f04f0c01          MOV      r12,#1
000038  e010              B        |L41.92|
                  |L41.58|
00003a  2c01              CMP      r4,#1
00003c  d102              BNE      |L41.68|
00003e  f04f0c02          MOV      r12,#2
000042  e00b              B        |L41.92|
                  |L41.68|
000044  2c02              CMP      r4,#2
000046  d102              BNE      |L41.78|
000048  f04f0c04          MOV      r12,#4
00004c  e006              B        |L41.92|
                  |L41.78|
00004e  2c03              CMP      r4,#3
000050  d102              BNE      |L41.88|
000052  f04f0c08          MOV      r12,#8
000056  e001              B        |L41.92|
                  |L41.88|
000058  f04f0c00          MOV      r12,#0
                  |L41.92|
00005c  ea4f0c4c          LSL      r12,r12,#1
000060  fbb0f1fc          UDIV     r1,r0,r12
                  |L41.100|
;;;1226          }
;;;1227      
;;;1228       return (uint32_t)workRate;
000064  4608              MOV      r0,r1
;;;1229   }
000066  bdf0              POP      {r4-r7,pc}
;;;1230   
                          ENDP


                          AREA ||i.CLOCK_GetUsbPLLOutFromSetupUpdate||, CODE, READONLY, ALIGN=2

                  CLOCK_GetUsbPLLOutFromSetupUpdate PROC
;;;1114   /* Update USB PLL rate variable */
;;;1115   static void CLOCK_GetUsbPLLOutFromSetupUpdate(const usb_pll_setup_t *pSetup)
000000  b500              PUSH     {lr}
;;;1116   {
000002  4602              MOV      r2,r0
;;;1117       s_Usb_Pll_Freq = CLOCK_GetUsbPLLOutFromSetup(pSetup);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       CLOCK_GetUsbPLLOutFromSetup
00000a  4901              LDR      r1,|L42.16|
00000c  6008              STR      r0,[r1,#0]  ; s_Usb_Pll_Freq
;;;1118   }
00000e  bd00              POP      {pc}
;;;1119   
                          ENDP

                  |L42.16|
                          DCD      s_Usb_Pll_Freq

                          AREA ||i.CLOCK_GetUsbPllOutFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetUsbPllOutFreq PROC
;;;404    /* Get USB PLL Clk */
;;;405    uint32_t CLOCK_GetUsbPllOutFreq(void)
000000  4801              LDR      r0,|L43.8|
;;;406    {
;;;407        return s_Usb_Pll_Freq;
000002  6800              LDR      r0,[r0,#0]  ; s_Usb_Pll_Freq
;;;408    }
000004  4770              BX       lr
;;;409    
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      s_Usb_Pll_Freq

                          AREA ||i.CLOCK_GetWdtOscFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_GetWdtOscFreq PROC
;;;367    /* Get WATCH DOG Clk */
;;;368    uint32_t CLOCK_GetWdtOscFreq(void)
000000  480c              LDR      r0,|L44.52|
;;;369    {
;;;370        uint8_t freq_sel, div_sel;
;;;371        if (SYSCON->PDRUNCFG[0] & SYSCON_PDRUNCFG_PDEN_WDT_OSC_MASK)
000002  6800              LDR      r0,[r0,#0]
000004  f4001080          AND      r0,r0,#0x100000
000008  b108              CBZ      r0,|L44.14|
;;;372        {
;;;373            return 0U;
00000a  2000              MOVS     r0,#0
                  |L44.12|
;;;374        }
;;;375        else
;;;376        {
;;;377            div_sel = ((SYSCON->WDTOSCCTRL & 0x1f) + 1) << 1;
;;;378            freq_sel = wdtFreqLookup[((SYSCON->WDTOSCCTRL & SYSCON_WDTOSCCTRL_FREQSEL_MASK) >> SYSCON_WDTOSCCTRL_FREQSEL_SHIFT)];
;;;379            return ((uint32_t) freq_sel * 50000U)/((uint32_t)div_sel);
;;;380        }
;;;381    }
00000c  4770              BX       lr
                  |L44.14|
00000e  480a              LDR      r0,|L44.56|
000010  6800              LDR      r0,[r0,#0]            ;377
000012  f000001f          AND      r0,r0,#0x1f           ;377
000016  1c40              ADDS     r0,r0,#1              ;377
000018  0041              LSLS     r1,r0,#1              ;377
00001a  4807              LDR      r0,|L44.56|
00001c  6800              LDR      r0,[r0,#0]            ;378
00001e  f3c01044          UBFX     r0,r0,#5,#5           ;378
000022  4b06              LDR      r3,|L44.60|
000024  5c1a              LDRB     r2,[r3,r0]            ;378
000026  f24c3050          MOV      r0,#0xc350            ;379
00002a  4350              MULS     r0,r2,r0              ;379
00002c  fbb0f0f1          UDIV     r0,r0,r1              ;379
000030  e7ec              B        |L44.12|
;;;382    
                          ENDP

000032  0000              DCW      0x0000
                  |L44.52|
                          DCD      0x40000610
                  |L44.56|
                          DCD      0x40000508
                  |L44.60|
                          DCD      wdtFreqLookup

                          AREA ||i.CLOCK_SetClkDiv||, CODE, READONLY, ALIGN=2

                  CLOCK_SetClkDiv PROC
;;;203    /* Set IP Clock Divider */
;;;204    void CLOCK_SetClkDiv(clock_div_name_t div_name, uint32_t divided_by_value, bool reset)
000000  b510              PUSH     {r4,lr}
;;;205    {
000002  4613              MOV      r3,r2
;;;206        volatile uint32_t *pClkDiv;
;;;207    
;;;208        pClkDiv = &(SYSCON->SYSTICKCLKDIV);
000004  4a07              LDR      r2,|L45.36|
;;;209        if (reset)
000006  b11b              CBZ      r3,|L45.16|
;;;210        {
;;;211            pClkDiv[div_name] = 1U << 29U;
000008  f04f5400          MOV      r4,#0x20000000
00000c  f8424020          STR      r4,[r2,r0,LSL #2]
                  |L45.16|
;;;212        }
;;;213        if (divided_by_value == 0U) /*!<  halt */
000010  b921              CBNZ     r1,|L45.28|
;;;214        {
;;;215            pClkDiv[div_name] = 1U << 30U;
000012  f04f4480          MOV      r4,#0x40000000
000016  f8424020          STR      r4,[r2,r0,LSL #2]
00001a  e002              B        |L45.34|
                  |L45.28|
;;;216        }
;;;217        else
;;;218        {
;;;219            pClkDiv[div_name] = (divided_by_value - 1U);
00001c  1e4c              SUBS     r4,r1,#1
00001e  f8424020          STR      r4,[r2,r0,LSL #2]
                  |L45.34|
;;;220        }
;;;221    }
000022  bd10              POP      {r4,pc}
;;;222    
                          ENDP

                  |L45.36|
                          DCD      0x40000300

                          AREA ||i.CLOCK_SetFLASHAccessCycles||, CODE, READONLY, ALIGN=2

                  CLOCK_SetFLASHAccessCycles PROC
;;;754     */
;;;755    static inline void CLOCK_SetFLASHAccessCycles(clock_flashtim_t clks)
000000  4a04              LDR      r2,|L46.20|
;;;756    {
;;;757        uint32_t tmp;
;;;758    
;;;759        tmp = SYSCON->FLASHCFG & ~(SYSCON_FLASHCFG_FLASHTIM_MASK);
000002  6812              LDR      r2,[r2,#0]
000004  f4224170          BIC      r1,r2,#0xf000
;;;760    
;;;761        /* Don't alter lower bits */
;;;762        SYSCON->FLASHCFG = tmp | ((uint32_t)clks << SYSCON_FLASHCFG_FLASHTIM_SHIFT);
000008  ea413200          ORR      r2,r1,r0,LSL #12
00000c  4b01              LDR      r3,|L46.20|
00000e  601a              STR      r2,[r3,#0]
;;;763    }
000010  4770              BX       lr
;;;764    
                          ENDP

000012  0000              DCW      0x0000
                  |L46.20|
                          DCD      0x40000400

                          AREA ||i.CLOCK_SetFLASHAccessCyclesForFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_SetFLASHAccessCyclesForFreq PROC
;;;618    /* Set the FLASH wait states for the passed frequency */
;;;619    void CLOCK_SetFLASHAccessCyclesForFreq(uint32_t iFreq)
000000  b510              PUSH     {r4,lr}
;;;620    {
000002  4604              MOV      r4,r0
;;;621        if (iFreq <= 12000000U)
000004  481d              LDR      r0,|L47.124|
000006  4284              CMP      r4,r0
000008  d803              BHI      |L47.18|
;;;622        {
;;;623            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash1Cycle);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
000010  e033              B        |L47.122|
                  |L47.18|
;;;624        }
;;;625        else if (iFreq <= 24000000U)
000012  481b              LDR      r0,|L47.128|
000014  4284              CMP      r4,r0
000016  d803              BHI      |L47.32|
;;;626        {
;;;627            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash2Cycle);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
00001e  e02c              B        |L47.122|
                  |L47.32|
;;;628        }
;;;629        else if (iFreq <= 36000000U)
000020  4818              LDR      r0,|L47.132|
000022  4284              CMP      r4,r0
000024  d803              BHI      |L47.46|
;;;630        {
;;;631            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash3Cycle);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
00002c  e025              B        |L47.122|
                  |L47.46|
;;;632        }
;;;633        else if (iFreq <= 60000000U)
00002e  4816              LDR      r0,|L47.136|
000030  4284              CMP      r4,r0
000032  d803              BHI      |L47.60|
;;;634        {
;;;635            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash4Cycle);
000034  2003              MOVS     r0,#3
000036  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
00003a  e01e              B        |L47.122|
                  |L47.60|
;;;636        }
;;;637        else if (iFreq <= 96000000U)
00003c  4813              LDR      r0,|L47.140|
00003e  4284              CMP      r4,r0
000040  d803              BHI      |L47.74|
;;;638        {
;;;639            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash5Cycle);
000042  2004              MOVS     r0,#4
000044  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
000048  e017              B        |L47.122|
                  |L47.74|
;;;640        }
;;;641        else if (iFreq <= 120000000U)
00004a  4811              LDR      r0,|L47.144|
00004c  4284              CMP      r4,r0
00004e  d803              BHI      |L47.88|
;;;642        {
;;;643            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash6Cycle);
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
000056  e010              B        |L47.122|
                  |L47.88|
;;;644        }
;;;645        else if (iFreq <= 144000000U)
000058  480e              LDR      r0,|L47.148|
00005a  4284              CMP      r4,r0
00005c  d803              BHI      |L47.102|
;;;646        {
;;;647            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash7Cycle);
00005e  2006              MOVS     r0,#6
000060  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
000064  e009              B        |L47.122|
                  |L47.102|
;;;648        }
;;;649        else if (iFreq <= 168000000U)
000066  480c              LDR      r0,|L47.152|
000068  4284              CMP      r4,r0
00006a  d803              BHI      |L47.116|
;;;650        {
;;;651            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash8Cycle);
00006c  2007              MOVS     r0,#7
00006e  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
000072  e002              B        |L47.122|
                  |L47.116|
;;;652        }
;;;653        else
;;;654        {
;;;655            CLOCK_SetFLASHAccessCycles(kCLOCK_Flash9Cycle);
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       CLOCK_SetFLASHAccessCycles
                  |L47.122|
;;;656        }
;;;657    }
00007a  bd10              POP      {r4,pc}
;;;658    
                          ENDP

                  |L47.124|
                          DCD      0x00b71b00
                  |L47.128|
                          DCD      0x016e3600
                  |L47.132|
                          DCD      0x02255100
                  |L47.136|
                          DCD      0x03938700
                  |L47.140|
                          DCD      0x05b8d800
                  |L47.144|
                          DCD      0x07270e00
                  |L47.148|
                          DCD      0x08954400
                  |L47.152|
                          DCD      0x0a037a00

                          AREA ||i.CLOCK_SetFRGClock||, CODE, READONLY, ALIGN=2

                  CLOCK_SetFRGClock PROC
;;;476    /* Set FRG Clk */
;;;477    uint32_t CLOCK_SetFRGClock(uint32_t freq)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;478    {
000004  4604              MOV      r4,r0
;;;479        uint32_t input = CLOCK_GetFRGInputClock();
000006  f7fffffe          BL       CLOCK_GetFRGInputClock
00000a  4605              MOV      r5,r0
;;;480        uint32_t mul;
;;;481    
;;;482        if ((freq > 48000000) || (freq > input) || (input / freq >= 2))
00000c  480f              LDR      r0,|L48.76|
00000e  4284              CMP      r4,r0
000010  d805              BHI      |L48.30|
000012  42ac              CMP      r4,r5
000014  d803              BHI      |L48.30|
000016  fbb5f0f4          UDIV     r0,r5,r4
00001a  2802              CMP      r0,#2
00001c  d302              BCC      |L48.36|
                  |L48.30|
;;;483        {
;;;484            /* FRG output frequency should be less than equal to 48MHz */
;;;485            return 0;
00001e  2000              MOVS     r0,#0
                  |L48.32|
;;;486        }
;;;487        else
;;;488        {
;;;489            mul = ((uint64_t)(input - freq) * 256) / ((uint64_t)freq);
;;;490            SYSCON->FRGCTRL = (mul << SYSCON_FRGCTRL_MULT_SHIFT) | SYSCON_FRGCTRL_DIV_MASK;
;;;491            return 1;
;;;492        }
;;;493    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L48.36|
000024  1b28              SUBS     r0,r5,r4              ;489
000026  f44f7180          MOV      r1,#0x100             ;489
00002a  fba07001          UMULL    r7,r0,r0,r1           ;489
00002e  4601              MOV      r1,r0                 ;489
000030  4622              MOV      r2,r4                 ;489
000032  2300              MOVS     r3,#0                 ;489
000034  4638              MOV      r0,r7                 ;489
000036  f7fffffe          BL       __aeabi_uldivmod
00003a  4606              MOV      r6,r0                 ;489
00003c  20ff              MOVS     r0,#0xff              ;490
00003e  ea402006          ORR      r0,r0,r6,LSL #8       ;490
000042  4903              LDR      r1,|L48.80|
000044  6008              STR      r0,[r1,#0]            ;490
000046  2001              MOVS     r0,#1                 ;491
000048  e7ea              B        |L48.32|
;;;494    
                          ENDP

00004a  0000              DCW      0x0000
                  |L48.76|
                          DCD      0x02dc6c00
                  |L48.80|
                          DCD      0x400003a0

                          AREA ||i.CLOCK_SetPLLFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_SetPLLFreq PROC
;;;1530   /* Setup PLL Frequency from pre-calculated value */
;;;1531   pll_error_t CLOCK_SetPLLFreq(const pll_setup_t *pSetup)
000000  b538              PUSH     {r3-r5,lr}
;;;1532   {
000002  4604              MOV      r4,r0
;;;1533       /* Enable power VD3 for PLLs */
;;;1534       POWER_SetPLL();
000004  f7fffffe          BL       POWER_SetPLL
;;;1535       /* Power off PLL during setup changes */
;;;1536       POWER_EnablePD(kPDRUNCFG_PD_SYS_PLL0);
000008  2016              MOVS     r0,#0x16
00000a  f7fffffe          BL       POWER_EnablePD
;;;1537   
;;;1538       /* Write PLL setup data */
;;;1539       SYSCON->SYSPLLCTRL = pSetup->syspllctrl;
00000e  492c              LDR      r1,|L49.192|
000010  6820              LDR      r0,[r4,#0]
000012  6008              STR      r0,[r1,#0]
;;;1540       SYSCON->SYSPLLNDEC = pSetup->syspllndec;
000014  492a              LDR      r1,|L49.192|
000016  3108              ADDS     r1,r1,#8
000018  6860              LDR      r0,[r4,#4]
00001a  6008              STR      r0,[r1,#0]
;;;1541       SYSCON->SYSPLLNDEC = pSetup->syspllndec | (1U << SYSCON_SYSPLLNDEC_NREQ_SHIFT); /* latch */
00001c  6860              LDR      r0,[r4,#4]
00001e  f4406080          ORR      r0,r0,#0x400
000022  6008              STR      r0,[r1,#0]
;;;1542       SYSCON->SYSPLLPDEC = pSetup->syspllpdec;
000024  1d09              ADDS     r1,r1,#4
000026  68a0              LDR      r0,[r4,#8]
000028  6008              STR      r0,[r1,#0]
;;;1543       SYSCON->SYSPLLPDEC = pSetup->syspllpdec | (1U << SYSCON_SYSPLLPDEC_PREQ_SHIFT); /* latch */
00002a  68a0              LDR      r0,[r4,#8]
00002c  f0400080          ORR      r0,r0,#0x80
000030  6008              STR      r0,[r1,#0]
;;;1544       SYSCON->SYSPLLMDEC = pSetup->syspllmdec;
000032  1d09              ADDS     r1,r1,#4
000034  68e0              LDR      r0,[r4,#0xc]
000036  6008              STR      r0,[r1,#0]
;;;1545       SYSCON->SYSPLLMDEC = pSetup->syspllmdec | (1U << SYSCON_SYSPLLMDEC_MREQ_SHIFT); /* latch */
000038  68e0              LDR      r0,[r4,#0xc]
00003a  f4403000          ORR      r0,r0,#0x20000
00003e  6008              STR      r0,[r1,#0]
;;;1546   
;;;1547       /* Flags for lock or power on */
;;;1548       if ((pSetup->flags & (PLL_SETUPFLAG_POWERUP | PLL_SETUPFLAG_WAITLOCK)) != 0)
000040  7d20              LDRB     r0,[r4,#0x14]
000042  f0000003          AND      r0,r0,#3
000046  b340              CBZ      r0,|L49.154|
;;;1549       {
;;;1550           /* If turning the PLL back on, perform the following sequence to accelerate PLL lock */
;;;1551           volatile uint32_t delayX;
;;;1552           uint32_t maxCCO = (1U << 18U) | 0x5dd2U; /* CCO = 1.6Ghz + MDEC enabled*/
000048  481e              LDR      r0,|L49.196|
;;;1553           uint32_t curSSCTRL = SYSCON->SYSPLLMDEC & ~(1U << 17U);
00004a  460a              MOV      r2,r1
00004c  6812              LDR      r2,[r2,#0]
00004e  f4223100          BIC      r1,r2,#0x20000
;;;1554   
;;;1555           /* Initialize  and power up PLL */
;;;1556           SYSCON->SYSPLLMDEC = maxCCO;
000052  4a1b              LDR      r2,|L49.192|
000054  3210              ADDS     r2,r2,#0x10
000056  6010              STR      r0,[r2,#0]
;;;1557           SYSCON->PDRUNCFGCLR[0] = SYSCON_PDRUNCFG_PDEN_SYS_PLL_MASK;
000058  f44f0280          MOV      r2,#0x400000
00005c  4b18              LDR      r3,|L49.192|
00005e  33b0              ADDS     r3,r3,#0xb0
000060  601a              STR      r2,[r3,#0]
;;;1558   
;;;1559           /* Set mreq to activate */
;;;1560           SYSCON->SYSPLLMDEC = maxCCO | (1U << 17U);
000062  f4403200          ORR      r2,r0,#0x20000
000066  4b16              LDR      r3,|L49.192|
000068  3310              ADDS     r3,r3,#0x10
00006a  601a              STR      r2,[r3,#0]
;;;1561   
;;;1562           /* Delay for 72 uSec @ 12Mhz */
;;;1563           for (delayX = 0U; delayX < 172U; ++delayX)
00006c  2200              MOVS     r2,#0
00006e  9200              STR      r2,[sp,#0]
000070  e002              B        |L49.120|
                  |L49.114|
000072  9a00              LDR      r2,[sp,#0]
000074  1c52              ADDS     r2,r2,#1
000076  9200              STR      r2,[sp,#0]
                  |L49.120|
000078  9a00              LDR      r2,[sp,#0]
00007a  2aac              CMP      r2,#0xac
00007c  d3f9              BCC      |L49.114|
;;;1564           {
;;;1565           }
;;;1566   
;;;1567           /* clear mreq to prepare for restoring mreq */
;;;1568           SYSCON->SYSPLLMDEC = curSSCTRL;
00007e  4a10              LDR      r2,|L49.192|
000080  3210              ADDS     r2,r2,#0x10
000082  6011              STR      r1,[r2,#0]
;;;1569   
;;;1570           /* set original value back and activate */
;;;1571           SYSCON->SYSPLLMDEC = curSSCTRL | (1U << 17U);
000084  f4413200          ORR      r2,r1,#0x20000
000088  4b0d              LDR      r3,|L49.192|
00008a  3310              ADDS     r3,r3,#0x10
00008c  601a              STR      r2,[r3,#0]
;;;1572   
;;;1573           /* Enable peripheral states by setting low */
;;;1574           SYSCON->PDRUNCFGCLR[0] = SYSCON_PDRUNCFG_PDEN_SYS_PLL_MASK;
00008e  f44f0280          MOV      r2,#0x400000
000092  4b0b              LDR      r3,|L49.192|
000094  33b0              ADDS     r3,r3,#0xb0
000096  601a              STR      r2,[r3,#0]
;;;1575       }
000098  bf00              NOP      
                  |L49.154|
;;;1576       if ((pSetup->flags & PLL_SETUPFLAG_WAITLOCK) != 0U)
00009a  7d20              LDRB     r0,[r4,#0x14]
00009c  f0000002          AND      r0,r0,#2
0000a0  b140              CBZ      r0,|L49.180|
;;;1577       {
;;;1578           while (CLOCK_IsSystemPLLLocked() == false)
0000a2  bf00              NOP      
                  |L49.164|
0000a4  bf00              NOP      
0000a6  4806              LDR      r0,|L49.192|
0000a8  1d00              ADDS     r0,r0,#4
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0000001          AND      r0,r0,#1
0000b0  2800              CMP      r0,#0
0000b2  d0f7              BEQ      |L49.164|
                  |L49.180|
;;;1579           {
;;;1580           }
;;;1581       }
;;;1582   
;;;1583       /* Update current programmed PLL rate var */
;;;1584       s_Pll_Freq = pSetup->pllRate;
0000b4  4904              LDR      r1,|L49.200|
0000b6  6920              LDR      r0,[r4,#0x10]
0000b8  6008              STR      r0,[r1,#0]  ; s_Pll_Freq
;;;1585   
;;;1586       return kStatus_PLL_Success;
0000ba  2000              MOVS     r0,#0
;;;1587   }
0000bc  bd38              POP      {r3-r5,pc}
;;;1588   
                          ENDP

0000be  0000              DCW      0x0000
                  |L49.192|
                          DCD      0x40000580
                  |L49.196|
                          DCD      0x00045dd2
                  |L49.200|
                          DCD      s_Pll_Freq

                          AREA ||i.CLOCK_SetStoredAudioPLLClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_SetStoredAudioPLLClockRate PROC
;;;1269   /* Set the current Audio PLL Rate */
;;;1270   void CLOCK_SetStoredAudioPLLClockRate(uint32_t rate)
000000  4901              LDR      r1,|L50.8|
;;;1271   {
;;;1272       s_Audio_Pll_Freq = rate;
000002  6008              STR      r0,[r1,#0]  ; s_Audio_Pll_Freq
;;;1273   }
000004  4770              BX       lr
;;;1274   
                          ENDP

000006  0000              DCW      0x0000
                  |L50.8|
                          DCD      s_Audio_Pll_Freq

                          AREA ||i.CLOCK_SetStoredPLLClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_SetStoredPLLClockRate PROC
;;;1263   /* Set the current PLL Rate */
;;;1264   void CLOCK_SetStoredPLLClockRate(uint32_t rate)
000000  4901              LDR      r1,|L51.8|
;;;1265   {
;;;1266       s_Pll_Freq = rate;
000002  6008              STR      r0,[r1,#0]  ; s_Pll_Freq
;;;1267   }
000004  4770              BX       lr
;;;1268   
                          ENDP

000006  0000              DCW      0x0000
                  |L51.8|
                          DCD      s_Pll_Freq

                          AREA ||i.CLOCK_SetStoredUsbPLLClockRate||, CODE, READONLY, ALIGN=2

                  CLOCK_SetStoredUsbPLLClockRate PROC
;;;1275   /* Set the current Usb PLL Rate */
;;;1276   void CLOCK_SetStoredUsbPLLClockRate(uint32_t rate)
000000  4901              LDR      r1,|L52.8|
;;;1277   {
;;;1278       s_Usb_Pll_Freq = rate;
000002  6008              STR      r0,[r1,#0]  ; s_Usb_Pll_Freq
;;;1279   }
000004  4770              BX       lr
;;;1280   
                          ENDP

000006  0000              DCW      0x0000
                  |L52.8|
                          DCD      s_Usb_Pll_Freq

                          AREA ||i.CLOCK_SetUsbPLLFreq||, CODE, READONLY, ALIGN=2

                  CLOCK_SetUsbPLLFreq PROC
;;;1589   /* Setup USB PLL Frequency from pre-calculated value */
;;;1590   pll_error_t CLOCK_SetUsbPLLFreq(const usb_pll_setup_t *pSetup)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1591   {       
000004  4604              MOV      r4,r0
;;;1592       uint32_t usbpllctrl, fccoHz;
;;;1593       uint8_t msel, psel, nsel;
;;;1594       bool pllDirectInput, pllDirectOutput, pllfbsel;
;;;1595       volatile uint32_t delayX;
;;;1596   
;;;1597       msel = pSetup->msel;
000006  7827              LDRB     r7,[r4,#0]
;;;1598       psel = pSetup->psel;
000008  7866              LDRB     r6,[r4,#1]
;;;1599       nsel = pSetup->nsel;
00000a  f8948002          LDRB     r8,[r4,#2]
;;;1600       pllDirectInput = pSetup->direct;
00000e  f894b003          LDRB     r11,[r4,#3]
;;;1601       pllDirectOutput = pSetup->bypass;
000012  7920              LDRB     r0,[r4,#4]
000014  9001              STR      r0,[sp,#4]
;;;1602       pllfbsel = pSetup->fbsel;
000016  f894a005          LDRB     r10,[r4,#5]
;;;1603       
;;;1604       /* Input clock into the PLL cannot be lower than this */
;;;1605       if (pSetup->inputRate < USB_PLL_LOWER_IN_LIMIT )
00001a  493c              LDR      r1,|L53.268|
00001c  68a0              LDR      r0,[r4,#8]
00001e  4288              CMP      r0,r1
000020  d202              BCS      |L53.40|
;;;1606       {
;;;1607           return kStatus_PLL_InputTooLow;
000022  2003              MOVS     r0,#3
                  |L53.36|
;;;1608       }
;;;1609       
;;;1610       if (pllfbsel == 1U)
;;;1611       {   
;;;1612           /*integer_mode: Fout = M*(Fin/N),  Fcco = 2*P*M*(Fin/N) */
;;;1613           fccoHz = (pSetup->inputRate / (nsel + 1U)) * 2 * (msel + 1U) * SWITCH_USB_PSEL(psel) ;
;;;1614           
;;;1615           /* USB PLL CCO out rate cannot be lower than this */        
;;;1616           if (fccoHz < USB_PLL_MIN_CCO_FREQ_MHZ)
;;;1617           {       
;;;1618               return kStatus_PLL_CCOTooLow;
;;;1619           }
;;;1620           /* USB PLL CCO out rate cannot be Higher than this */
;;;1621           if (fccoHz > USB_PLL_MAX_CCO_FREQ_MHZ)
;;;1622           { 
;;;1623               return kStatus_PLL_CCOTooHigh;
;;;1624           }
;;;1625       }
;;;1626       else
;;;1627       {
;;;1628           /* non integer_mode: Fout = M*(Fin/N)/(2*P), Fcco = M * (Fin/N) */
;;;1629           fccoHz = pSetup->inputRate / (nsel + 1U) * (msel + 1U);
;;;1630           
;;;1631           /* USB PLL CCO out rate cannot be lower than this */        
;;;1632           if (fccoHz < USB_PLL_MIN_CCO_FREQ_MHZ)
;;;1633           {       
;;;1634               return kStatus_PLL_CCOTooLow;
;;;1635           }
;;;1636           /* USB PLL CCO out rate cannot be Higher than this */
;;;1637           if (fccoHz > USB_PLL_MAX_CCO_FREQ_MHZ)
;;;1638           { 
;;;1639               return kStatus_PLL_CCOTooHigh;
;;;1640           }       
;;;1641       }
;;;1642       
;;;1643       /* If configure the USB HOST clock, VD5 power for USB PHY should be enable 
;;;1644          before the the PLL is working */
;;;1645       /* Turn on the ext clock for usb pll input */
;;;1646       CLOCK_Enable_SysOsc(true);
;;;1647       
;;;1648       /* Enable power VD3 for PLLs */
;;;1649       POWER_SetPLL();
;;;1650       
;;;1651       /* Power on the VD5 for USB PHY */    
;;;1652       POWER_SetUsbPhy();
;;;1653   
;;;1654       /* Power off USB PLL during setup changes */
;;;1655       POWER_EnablePD(kPDRUNCFG_PD_USB_PLL);
;;;1656         
;;;1657       /* Write USB PLL setup data */
;;;1658       usbpllctrl = USB_PLL_NSEL_VAL_SET(nsel)  |                  /* NSEL VALUE */
;;;1659                    USB_PLL_PSEL_VAL_SET(psel)  |                  /* PSEL VALUE */
;;;1660                    USB_PLL_MSEL_VAL_SET(msel)  |                  /* MSEL VALUE */
;;;1661                    (uint32_t)pllDirectInput << SYSCON_USBPLLCTRL_BYPASS_SHIFT  |            /* BYPASS DISABLE */
;;;1662                    (uint32_t)pllDirectOutput << SYSCON_USBPLLCTRL_DIRECT_SHIFT |            /* DIRECTO DISABLE */
;;;1663                    (uint32_t)pllfbsel << SYSCON_USBPLLCTRL_BYPASSCCODIV2_SHIFT;             /* CCODIV2 BYPASSED */   
;;;1664       
;;;1665       SYSCON->USBPLLCTRL = usbpllctrl;
;;;1666       
;;;1667       POWER_DisablePD(kPDRUNCFG_PD_USB_PLL);
;;;1668     
;;;1669       /* Delay for 72 uSec @ 12Mhz for the usb pll to lock */
;;;1670       for (delayX = 0U; delayX < 172U; ++delayX)
;;;1671       {
;;;1672       }
;;;1673       
;;;1674       while (CLOCK_IsUsbPLLLocked() == false)
;;;1675       {
;;;1676       }
;;;1677       CLOCK_GetUsbPLLOutFromSetupUpdate(pSetup);
;;;1678       return kStatus_PLL_Success;
;;;1679   }
000024  e8bd9ffc          POP      {r2-r12,pc}
                  |L53.40|
000028  f1ba0f01          CMP      r10,#1                ;1610
00002c  d123              BNE      |L53.118|
00002e  f1080001          ADD      r0,r8,#1              ;1613
000032  68a1              LDR      r1,[r4,#8]            ;1613
000034  fbb1f0f0          UDIV     r0,r1,r0              ;1613
000038  0040              LSLS     r0,r0,#1              ;1613
00003a  1c79              ADDS     r1,r7,#1              ;1613
00003c  4348              MULS     r0,r1,r0              ;1613
00003e  b90e              CBNZ     r6,|L53.68|
000040  2101              MOVS     r1,#1                 ;1613
000042  e00c              B        |L53.94|
                  |L53.68|
000044  2e01              CMP      r6,#1                 ;1613
000046  d101              BNE      |L53.76|
000048  2102              MOVS     r1,#2                 ;1613
00004a  e008              B        |L53.94|
                  |L53.76|
00004c  2e02              CMP      r6,#2                 ;1613
00004e  d101              BNE      |L53.84|
000050  2104              MOVS     r1,#4                 ;1613
000052  e004              B        |L53.94|
                  |L53.84|
000054  2e03              CMP      r6,#3                 ;1613
000056  d101              BNE      |L53.92|
000058  2108              MOVS     r1,#8                 ;1613
00005a  e000              B        |L53.94|
                  |L53.92|
00005c  2100              MOVS     r1,#0                 ;1613
                  |L53.94|
00005e  fb00f501          MUL      r5,r0,r1              ;1613
000062  482b              LDR      r0,|L53.272|
000064  4285              CMP      r5,r0                 ;1616
000066  d201              BCS      |L53.108|
000068  2006              MOVS     r0,#6                 ;1618
00006a  e7db              B        |L53.36|
                  |L53.108|
00006c  4829              LDR      r0,|L53.276|
00006e  4285              CMP      r5,r0                 ;1621
000070  d913              BLS      |L53.154|
000072  2007              MOVS     r0,#7                 ;1623
000074  e7d6              B        |L53.36|
                  |L53.118|
000076  f1080001          ADD      r0,r8,#1              ;1629
00007a  68a1              LDR      r1,[r4,#8]            ;1629
00007c  fbb1f0f0          UDIV     r0,r1,r0              ;1629
000080  1c79              ADDS     r1,r7,#1              ;1629
000082  fb00f501          MUL      r5,r0,r1              ;1629
000086  4822              LDR      r0,|L53.272|
000088  4285              CMP      r5,r0                 ;1632
00008a  d201              BCS      |L53.144|
00008c  2006              MOVS     r0,#6                 ;1634
00008e  e7c9              B        |L53.36|
                  |L53.144|
000090  4820              LDR      r0,|L53.276|
000092  4285              CMP      r5,r0                 ;1637
000094  d901              BLS      |L53.154|
000096  2007              MOVS     r0,#7                 ;1639
000098  e7c4              B        |L53.36|
                  |L53.154|
00009a  2001              MOVS     r0,#1                 ;1646
00009c  f7fffffe          BL       CLOCK_Enable_SysOsc
0000a0  f7fffffe          BL       POWER_SetPLL
0000a4  f7fffffe          BL       POWER_SetUsbPhy
0000a8  f2401001          MOV      r0,#0x101             ;1655
0000ac  f7fffffe          BL       POWER_EnablePD
0000b0  ea4f7088          LSL      r0,r8,#30             ;1658
0000b4  0d00              LSRS     r0,r0,#20             ;1658
0000b6  f0060103          AND      r1,r6,#3              ;1658
0000ba  ea402001          ORR      r0,r0,r1,LSL #8       ;1658
0000be  b2f9              UXTB     r1,r7                 ;1658
0000c0  4308              ORRS     r0,r0,r1              ;1658
0000c2  ea40314b          ORR      r1,r0,r11,LSL #13     ;1658
0000c6  9801              LDR      r0,[sp,#4]            ;1658
0000c8  ea413000          ORR      r0,r1,r0,LSL #12      ;1658
0000cc  ea40398a          ORR      r9,r0,r10,LSL #14     ;1658
0000d0  4811              LDR      r0,|L53.280|
0000d2  f8c09000          STR      r9,[r0,#0]            ;1665
0000d6  f2401001          MOV      r0,#0x101             ;1667
0000da  f7fffffe          BL       POWER_DisablePD
0000de  2000              MOVS     r0,#0                 ;1670
0000e0  9000              STR      r0,[sp,#0]            ;1670
0000e2  e002              B        |L53.234|
                  |L53.228|
0000e4  9800              LDR      r0,[sp,#0]            ;1670
0000e6  1c40              ADDS     r0,r0,#1              ;1670
0000e8  9000              STR      r0,[sp,#0]            ;1670
                  |L53.234|
0000ea  9800              LDR      r0,[sp,#0]            ;1670
0000ec  28ac              CMP      r0,#0xac              ;1670
0000ee  d3f9              BCC      |L53.228|
0000f0  bf00              NOP                            ;1674
                  |L53.242|
0000f2  bf00              NOP                            ;1674
0000f4  4808              LDR      r0,|L53.280|
0000f6  1d00              ADDS     r0,r0,#4              ;1674
0000f8  6800              LDR      r0,[r0,#0]            ;1674
0000fa  f0000001          AND      r0,r0,#1              ;1674
0000fe  2800              CMP      r0,#0                 ;1674
000100  d0f7              BEQ      |L53.242|
000102  4620              MOV      r0,r4                 ;1677
000104  f7fffffe          BL       CLOCK_GetUsbPLLOutFromSetupUpdate
000108  2000              MOVS     r0,#0                 ;1678
00010a  e78b              B        |L53.36|
;;;1680   
                          ENDP

                  |L53.268|
                          DCD      0x000f4240
                  |L53.272|
                          DCD      0x094c5f00
                  |L53.276|
                          DCD      0x1312d000
                  |L53.280|
                          DCD      0x4000051c

                          AREA ||i.CLOCK_SetupAudioPLLData||, CODE, READONLY, ALIGN=1

                  CLOCK_SetupAudioPLLData PROC
;;;1506   /* Set Audio PLL output based on the passed Audio PLL setup data */
;;;1507   pll_error_t CLOCK_SetupAudioPLLData(pll_config_t *pControl, pll_setup_t *pSetup)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1508   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1509       uint32_t inRate;
;;;1510       pll_error_t pllError;
;;;1511   
;;;1512       /* Determine input rate for the PLL */
;;;1513       if ((pControl->flags & PLL_CONFIGFLAG_USEINRATE) != 0U)
000008  7a20              LDRB     r0,[r4,#8]
00000a  f0000001          AND      r0,r0,#1
00000e  b108              CBZ      r0,|L54.20|
;;;1514       {
;;;1515           inRate = pControl->inputRate;
000010  6866              LDR      r6,[r4,#4]
000012  e002              B        |L54.26|
                  |L54.20|
;;;1516       }
;;;1517       else
;;;1518       {
;;;1519           inRate = CLOCK_GetAudioPLLInClockRate();
000014  f7fffffe          BL       CLOCK_GetAudioPLLInClockRate
000018  4606              MOV      r6,r0
                  |L54.26|
;;;1520       }
;;;1521   
;;;1522       /* PLL flag options */
;;;1523       pllError = CLOCK_GetPllConfig(inRate, pControl->desiredRate, pSetup, false);
00001a  2300              MOVS     r3,#0
00001c  462a              MOV      r2,r5
00001e  4630              MOV      r0,r6
000020  6821              LDR      r1,[r4,#0]
000022  f7fffffe          BL       CLOCK_GetPllConfig
000026  4607              MOV      r7,r0
;;;1524       pSetup->pllRate = pControl->desiredRate;
000028  6820              LDR      r0,[r4,#0]
00002a  6128              STR      r0,[r5,#0x10]
;;;1525       return pllError;
00002c  4638              MOV      r0,r7
;;;1526   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1527   
                          ENDP


                          AREA ||i.CLOCK_SetupAudioPLLPrec||, CODE, READONLY, ALIGN=2

                  CLOCK_SetupAudioPLLPrec PROC
;;;1439   /* Set AUDIO PLL output from AUDIO PLL setup structure */
;;;1440   pll_error_t CLOCK_SetupAudioPLLPrec(pll_setup_t *pSetup, uint32_t flagcfg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1441   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1442       if (SYSCON->AUDPLLCLKSEL & SYSCON_AUDPLLCLKSEL_SEL_MASK == 0x01U)
000006  4833              LDR      r0,|L55.212|
000008  6800              LDR      r0,[r0,#0]
00000a  2000              MOVS     r0,#0
00000c  b110              CBZ      r0,|L55.20|
;;;1443       {
;;;1444          /* Turn on the ext clock if system pll input select clk_in */
;;;1445          CLOCK_Enable_SysOsc(true);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       CLOCK_Enable_SysOsc
                  |L55.20|
;;;1446       }
;;;1447       /* Enable power VD3 for PLLs */
;;;1448       POWER_SetPLL();
000014  f7fffffe          BL       POWER_SetPLL
;;;1449       /* Power off PLL during setup changes */
;;;1450       POWER_EnablePD(kPDRUNCFG_PD_AUDIO_PLL);
000018  f44f7081          MOV      r0,#0x102
00001c  f7fffffe          BL       POWER_EnablePD
;;;1451   
;;;1452       pSetup->flags = flagcfg;
000020  6165              STR      r5,[r4,#0x14]
;;;1453   
;;;1454       /* Write PLL setup data */
;;;1455       SYSCON->AUDPLLCTRL = pSetup->syspllctrl;
000022  492d              LDR      r1,|L55.216|
000024  6820              LDR      r0,[r4,#0]
000026  6008              STR      r0,[r1,#0]
;;;1456       SYSCON->AUDPLLNDEC = pSetup->syspllndec;
000028  492b              LDR      r1,|L55.216|
00002a  3108              ADDS     r1,r1,#8
00002c  6860              LDR      r0,[r4,#4]
00002e  6008              STR      r0,[r1,#0]
;;;1457       SYSCON->AUDPLLNDEC = pSetup->syspllndec | (1U << SYSCON_SYSPLLNDEC_NREQ_SHIFT); /* latch */
000030  6860              LDR      r0,[r4,#4]
000032  f4406080          ORR      r0,r0,#0x400
000036  6008              STR      r0,[r1,#0]
;;;1458       SYSCON->AUDPLLPDEC = pSetup->syspllpdec;
000038  1d09              ADDS     r1,r1,#4
00003a  68a0              LDR      r0,[r4,#8]
00003c  6008              STR      r0,[r1,#0]
;;;1459       SYSCON->AUDPLLPDEC = pSetup->syspllpdec | (1U << SYSCON_SYSPLLPDEC_PREQ_SHIFT); /* latch */
00003e  68a0              LDR      r0,[r4,#8]
000040  f0400080          ORR      r0,r0,#0x80
000044  6008              STR      r0,[r1,#0]
;;;1460       SYSCON->AUDPLLMDEC = pSetup->syspllmdec;
000046  1d09              ADDS     r1,r1,#4
000048  68e0              LDR      r0,[r4,#0xc]
00004a  6008              STR      r0,[r1,#0]
;;;1461       SYSCON->AUDPLLMDEC = pSetup->syspllmdec | (1U << SYSCON_SYSPLLMDEC_MREQ_SHIFT); /* latch */
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  f4403000          ORR      r0,r0,#0x20000
000052  6008              STR      r0,[r1,#0]
;;;1462       SYSCON->AUDPLLFRAC = SYSCON_AUDPLLFRAC_SEL_EXT(1); /* disable fractional function */
000054  f44f0000          MOV      r0,#0x800000
000058  1d09              ADDS     r1,r1,#4
00005a  6008              STR      r0,[r1,#0]
;;;1463   
;;;1464       /* Flags for lock or power on */
;;;1465       if ((pSetup->flags & (PLL_SETUPFLAG_POWERUP | PLL_SETUPFLAG_WAITLOCK)) != 0U)
00005c  7d20              LDRB     r0,[r4,#0x14]
00005e  f0000003          AND      r0,r0,#3
000062  b328              CBZ      r0,|L55.176|
;;;1466       {
;;;1467           /* If turning the PLL back on, perform the following sequence to accelerate PLL lock */
;;;1468           volatile uint32_t delayX;
;;;1469           uint32_t maxCCO = (1U << 18U) | 0x5dd2U; /* CCO = 1.6Ghz + MDEC enabled*/
000064  4f1d              LDR      r7,|L55.220|
;;;1470           uint32_t curSSCTRL = SYSCON->AUDPLLMDEC & ~(1U << 17U);
000066  1f08              SUBS     r0,r1,#4
000068  6800              LDR      r0,[r0,#0]
00006a  f4203600          BIC      r6,r0,#0x20000
;;;1471   
;;;1472           /* Initialize  and power up PLL */
;;;1473           SYSCON->AUDPLLMDEC = maxCCO;
00006e  1f08              SUBS     r0,r1,#4
000070  6007              STR      r7,[r0,#0]
;;;1474           POWER_DisablePD(kPDRUNCFG_PD_AUDIO_PLL);
000072  f44f7081          MOV      r0,#0x102
000076  f7fffffe          BL       POWER_DisablePD
;;;1475   
;;;1476           /* Set mreq to activate */
;;;1477           SYSCON->AUDPLLMDEC = maxCCO | (1U << 17U);
00007a  f4473000          ORR      r0,r7,#0x20000
00007e  4916              LDR      r1,|L55.216|
000080  3110              ADDS     r1,r1,#0x10
000082  6008              STR      r0,[r1,#0]
;;;1478   
;;;1479           /* Delay for 72 uSec @ 12Mhz */
;;;1480           for (delayX = 0U; delayX < 172U; ++delayX)
000084  2000              MOVS     r0,#0
000086  9000              STR      r0,[sp,#0]
000088  e002              B        |L55.144|
                  |L55.138|
00008a  9800              LDR      r0,[sp,#0]
00008c  1c40              ADDS     r0,r0,#1
00008e  9000              STR      r0,[sp,#0]
                  |L55.144|
000090  9800              LDR      r0,[sp,#0]
000092  28ac              CMP      r0,#0xac
000094  d3f9              BCC      |L55.138|
;;;1481           {
;;;1482           }
;;;1483   
;;;1484           /* clear mreq to prepare for restoring mreq */
;;;1485           SYSCON->AUDPLLMDEC = curSSCTRL;
000096  4810              LDR      r0,|L55.216|
000098  3010              ADDS     r0,r0,#0x10
00009a  6006              STR      r6,[r0,#0]
;;;1486   
;;;1487           /* set original value back and activate */
;;;1488           SYSCON->AUDPLLMDEC = curSSCTRL | (1U << 17U);
00009c  f4463000          ORR      r0,r6,#0x20000
0000a0  490d              LDR      r1,|L55.216|
0000a2  3110              ADDS     r1,r1,#0x10
0000a4  6008              STR      r0,[r1,#0]
;;;1489   
;;;1490           /* Enable peripheral states by setting low */
;;;1491           POWER_DisablePD(kPDRUNCFG_PD_AUDIO_PLL);
0000a6  f44f7081          MOV      r0,#0x102
0000aa  f7fffffe          BL       POWER_DisablePD
;;;1492       }
0000ae  bf00              NOP      
                  |L55.176|
;;;1493       if ((pSetup->flags & PLL_SETUPFLAG_WAITLOCK) != 0U)
0000b0  7d20              LDRB     r0,[r4,#0x14]
0000b2  f0000002          AND      r0,r0,#2
0000b6  b140              CBZ      r0,|L55.202|
;;;1494       {
;;;1495           while (CLOCK_IsAudioPLLLocked() == false)
0000b8  bf00              NOP      
                  |L55.186|
0000ba  bf00              NOP      
0000bc  4806              LDR      r0,|L55.216|
0000be  1d00              ADDS     r0,r0,#4
0000c0  6800              LDR      r0,[r0,#0]
0000c2  f0000001          AND      r0,r0,#1
0000c6  2800              CMP      r0,#0
0000c8  d0f7              BEQ      |L55.186|
                  |L55.202|
;;;1496           {
;;;1497           }
;;;1498       }
;;;1499   
;;;1500       /* Update current programmed PLL rate var */
;;;1501       CLOCK_GetAudioPLLOutFromSetupUpdate(pSetup);
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       CLOCK_GetAudioPLLOutFromSetupUpdate
;;;1502   
;;;1503       return kStatus_PLL_Success;
0000d0  2000              MOVS     r0,#0
;;;1504   }
0000d2  bdf8              POP      {r3-r7,pc}
;;;1505   
                          ENDP

                  |L55.212|
                          DCD      0x40000298
                  |L55.216|
                          DCD      0x400005a0
                  |L55.220|
                          DCD      0x00045dd2

                          AREA ||i.CLOCK_SetupFROClocking||, CODE, READONLY, ALIGN=2

                  CLOCK_SetupFROClocking PROC
;;;223    /* Set FRO Clocking */
;;;224    status_t CLOCK_SetupFROClocking(uint32_t iFreq)
000000  b570              PUSH     {r4-r6,lr}
;;;225    {
000002  4604              MOV      r4,r0
;;;226        uint32_t usb_adj;
;;;227        if ((iFreq != 12000000U) && (iFreq != 48000000U) && (iFreq != 96000000U))
000004  4821              LDR      r0,|L56.140|
000006  4284              CMP      r4,r0
000008  d007              BEQ      |L56.26|
00000a  0080              LSLS     r0,r0,#2
00000c  4284              CMP      r4,r0
00000e  d004              BEQ      |L56.26|
000010  0040              LSLS     r0,r0,#1
000012  4284              CMP      r4,r0
000014  d001              BEQ      |L56.26|
;;;228        {
;;;229            return kStatus_Fail;
000016  2001              MOVS     r0,#1
                  |L56.24|
;;;230        }
;;;231        /* Power up the FRO and set this as the base clock */
;;;232        POWER_DisablePD(kPDRUNCFG_PD_FRO_EN);
;;;233        /* back up the value of whether USB adj is selected, in which case we will have a value of 1 else 0 */
;;;234        usb_adj = ((SYSCON->FROCTRL) & SYSCON_FROCTRL_USBCLKADJ_MASK) >> SYSCON_FROCTRL_USBCLKADJ_SHIFT;
;;;235        if (iFreq > 12000000U)
;;;236        {
;;;237            if (iFreq == 96000000U)
;;;238            {
;;;239                SYSCON->FROCTRL = ((SYSCON_FROCTRL_TRIM_MASK | SYSCON_FROCTRL_FREQTRIM_MASK) & *INDEX_SECTOR_TRIM96) |
;;;240                                    SYSCON_FROCTRL_SEL(1) | SYSCON_FROCTRL_WRTRIM(1) | SYSCON_FROCTRL_USBCLKADJ(usb_adj) |
;;;241                                    SYSCON_FROCTRL_HSPDCLK(1);
;;;242            }
;;;243            else
;;;244            {
;;;245                SYSCON->FROCTRL = ((SYSCON_FROCTRL_TRIM_MASK | SYSCON_FROCTRL_FREQTRIM_MASK) & *INDEX_SECTOR_TRIM48) |
;;;246                                    SYSCON_FROCTRL_SEL(0) | SYSCON_FROCTRL_WRTRIM(1) | SYSCON_FROCTRL_USBCLKADJ(usb_adj) |
;;;247                                    SYSCON_FROCTRL_HSPDCLK(1);
;;;248            }
;;;249        }
;;;250        else
;;;251        {
;;;252            SYSCON->FROCTRL &= ~SYSCON_FROCTRL_HSPDCLK(1);
;;;253        }
;;;254    
;;;255        return 0U;
;;;256    }
000018  bd70              POP      {r4-r6,pc}
                  |L56.26|
00001a  2004              MOVS     r0,#4                 ;232
00001c  f7fffffe          BL       POWER_DisablePD
000020  481b              LDR      r0,|L56.144|
000022  6800              LDR      r0,[r0,#0]            ;234
000024  f3c06500          UBFX     r5,r0,#24,#1          ;234
000028  4818              LDR      r0,|L56.140|
00002a  4284              CMP      r4,r0                 ;235
00002c  d925              BLS      |L56.122|
00002e  00c0              LSLS     r0,r0,#3              ;237
000030  4284              CMP      r4,r0                 ;237
000032  d111              BNE      |L56.88|
000034  4817              LDR      r0,|L56.148|
000036  6800              LDR      r0,[r0,#0]            ;239
000038  4917              LDR      r1,|L56.152|
00003a  4008              ANDS     r0,r0,r1              ;239
00003c  f4404080          ORR      r0,r0,#0x4000         ;239
000040  f0404000          ORR      r0,r0,#0x80000000     ;239
000044  f04f7180          MOV      r1,#0x1000000         ;239
000048  ea016105          AND      r1,r1,r5,LSL #24      ;239
00004c  4308              ORRS     r0,r0,r1              ;239
00004e  f0404080          ORR      r0,r0,#0x40000000     ;239
000052  490f              LDR      r1,|L56.144|
000054  6008              STR      r0,[r1,#0]            ;239
000056  e016              B        |L56.134|
                  |L56.88|
000058  480e              LDR      r0,|L56.148|
00005a  1f00              SUBS     r0,r0,#4              ;245
00005c  6800              LDR      r0,[r0,#0]            ;245
00005e  490e              LDR      r1,|L56.152|
000060  4008              ANDS     r0,r0,r1              ;245
000062  f0404000          ORR      r0,r0,#0x80000000     ;245
000066  f04f7180          MOV      r1,#0x1000000         ;245
00006a  ea016105          AND      r1,r1,r5,LSL #24      ;245
00006e  4308              ORRS     r0,r0,r1              ;245
000070  f0404080          ORR      r0,r0,#0x40000000     ;245
000074  4906              LDR      r1,|L56.144|
000076  6008              STR      r0,[r1,#0]            ;245
000078  e005              B        |L56.134|
                  |L56.122|
00007a  4805              LDR      r0,|L56.144|
00007c  6800              LDR      r0,[r0,#0]            ;252
00007e  f0204080          BIC      r0,r0,#0x40000000     ;252
000082  4903              LDR      r1,|L56.144|
000084  6008              STR      r0,[r1,#0]            ;252
                  |L56.134|
000086  2000              MOVS     r0,#0                 ;255
000088  e7c6              B        |L56.24|
;;;257    
                          ENDP

00008a  0000              DCW      0x0000
                  |L56.140|
                          DCD      0x00b71b00
                  |L56.144|
                          DCD      0x40000500
                  |L56.148|
                          DCD      0x0100044c
                  |L56.152|
                          DCD      0x00ff3fff

                          AREA ||i.CLOCK_SetupPLLData||, CODE, READONLY, ALIGN=1

                  CLOCK_SetupPLLData PROC
;;;1343   /* Set PLL output based on the passed PLL setup data */
;;;1344   pll_error_t CLOCK_SetupPLLData(pll_config_t *pControl, pll_setup_t *pSetup)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1345   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1346       uint32_t inRate;
;;;1347       pll_error_t pllError;
;;;1348   
;;;1349       /* Determine input rate for the PLL */
;;;1350       if ((pControl->flags & PLL_CONFIGFLAG_USEINRATE) != 0U)
000008  7a20              LDRB     r0,[r4,#8]
00000a  f0000001          AND      r0,r0,#1
00000e  b108              CBZ      r0,|L57.20|
;;;1351       {
;;;1352           inRate = pControl->inputRate;
000010  6866              LDR      r6,[r4,#4]
000012  e002              B        |L57.26|
                  |L57.20|
;;;1353       }
;;;1354       else
;;;1355       {
;;;1356           inRate = CLOCK_GetSystemPLLInClockRate();
000014  f7fffffe          BL       CLOCK_GetSystemPLLInClockRate
000018  4606              MOV      r6,r0
                  |L57.26|
;;;1357       }
;;;1358   
;;;1359       /* PLL flag options */
;;;1360       pllError = CLOCK_GetPllConfig(inRate, pControl->desiredRate, pSetup, false);
00001a  2300              MOVS     r3,#0
00001c  462a              MOV      r2,r5
00001e  4630              MOV      r0,r6
000020  6821              LDR      r1,[r4,#0]
000022  f7fffffe          BL       CLOCK_GetPllConfig
000026  4607              MOV      r7,r0
;;;1361       pSetup->pllRate = pControl->desiredRate;
000028  6820              LDR      r0,[r4,#0]
00002a  6128              STR      r0,[r5,#0x10]
;;;1362       return pllError;
00002c  4638              MOV      r0,r7
;;;1363   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1364   
                          ENDP


                          AREA ||i.CLOCK_SetupSystemPLLMult||, CODE, READONLY, ALIGN=2

                  CLOCK_SetupSystemPLLMult PROC
;;;1681   /* Set System PLL clock based on the input frequency and multiplier */
;;;1682   void CLOCK_SetupSystemPLLMult(uint32_t multiply_by, uint32_t input_freq)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1683   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1684       uint32_t cco_freq = input_freq * multiply_by;
000008  fb07f004          MUL      r0,r7,r4
00000c  9001              STR      r0,[sp,#4]
;;;1685       uint32_t pdec = 1U;
00000e  2601              MOVS     r6,#1
;;;1686       uint32_t selr;
;;;1687       uint32_t seli;
;;;1688       uint32_t selp;
;;;1689       uint32_t mdec, ndec;
;;;1690   
;;;1691       uint32_t directo = SYSCON_SYSPLLCTRL_DIRECTO_SHIFT;
000010  2014              MOVS     r0,#0x14
000012  9000              STR      r0,[sp,#0]
;;;1692   
;;;1693       while (cco_freq < 275000000U)
000014  e004              B        |L58.32|
                  |L58.22|
;;;1694       {
;;;1695           multiply_by <<= 1U; /* double value in each iteration */
000016  0064              LSLS     r4,r4,#1
;;;1696           pdec <<= 1U;        /* correspondingly double pdec to cancel effect of double msel */
000018  0076              LSLS     r6,r6,#1
;;;1697           cco_freq = input_freq * multiply_by;
00001a  fb07f004          MUL      r0,r7,r4
00001e  9001              STR      r0,[sp,#4]
                  |L58.32|
000020  4937              LDR      r1,|L58.256|
000022  9801              LDR      r0,[sp,#4]            ;1693
000024  4288              CMP      r0,r1                 ;1693
000026  d3f6              BCC      |L58.22|
;;;1698       }
;;;1699       selr = 0U;
000028  f04f0900          MOV      r9,#0
;;;1700       if (multiply_by < 60U)
00002c  2c3c              CMP      r4,#0x3c
00002e  d206              BCS      |L58.62|
;;;1701       {
;;;1702           seli = (multiply_by & 0x3cU) + 4U;
000030  f004003c          AND      r0,r4,#0x3c
000034  1d05              ADDS     r5,r0,#4
;;;1703           selp = (multiply_by >> 1U) + 1U;
000036  2001              MOVS     r0,#1
000038  eb000854          ADD      r8,r0,r4,LSR #1
00003c  e01c              B        |L58.120|
                  |L58.62|
;;;1704       }
;;;1705       else
;;;1706       {
;;;1707           selp = 31U;
00003e  f04f081f          MOV      r8,#0x1f
;;;1708           if (multiply_by > 16384U)
000042  f5b44f80          CMP      r4,#0x4000
000046  d901              BLS      |L58.76|
;;;1709           {
;;;1710               seli = 1U;
000048  2501              MOVS     r5,#1
00004a  e015              B        |L58.120|
                  |L58.76|
;;;1711           }
;;;1712           else if (multiply_by > 8192U)
00004c  f5b45f00          CMP      r4,#0x2000
000050  d901              BLS      |L58.86|
;;;1713           {
;;;1714               seli = 2U;
000052  2502              MOVS     r5,#2
000054  e010              B        |L58.120|
                  |L58.86|
;;;1715           }
;;;1716           else if (multiply_by > 2048U)
000056  f5b46f00          CMP      r4,#0x800
00005a  d901              BLS      |L58.96|
;;;1717           {
;;;1718               seli = 4U;
00005c  2504              MOVS     r5,#4
00005e  e00b              B        |L58.120|
                  |L58.96|
;;;1719           }
;;;1720           else if (multiply_by >= 501U)
000060  f5b47ffa          CMP      r4,#0x1f4
000064  d901              BLS      |L58.106|
;;;1721           {
;;;1722               seli = 8U;
000066  2508              MOVS     r5,#8
000068  e006              B        |L58.120|
                  |L58.106|
;;;1723           }
;;;1724           else
;;;1725           {
;;;1726               seli = 4U * (1024U / (multiply_by + 9U));
00006a  f1040009          ADD      r0,r4,#9
00006e  f44f6180          MOV      r1,#0x400
000072  fbb1f0f0          UDIV     r0,r1,r0
000076  0085              LSLS     r5,r0,#2
                  |L58.120|
;;;1727           }
;;;1728       }
;;;1729   
;;;1730       if (pdec > 1U)
000078  2e01              CMP      r6,#1
00007a  d920              BLS      |L58.190|
;;;1731       {
;;;1732           directo = 0U;     /* use post divider */
00007c  2000              MOVS     r0,#0
00007e  9000              STR      r0,[sp,#0]
;;;1733           pdec = pdec / 2U; /* Account for minus 1 encoding */
000080  0876              LSRS     r6,r6,#1
;;;1734                             /* Translate P value */
;;;1735           switch (pdec)
000082  2e08              CMP      r6,#8
000084  d012              BEQ      |L58.172|
000086  dc06              BGT      |L58.150|
000088  2e01              CMP      r6,#1
00008a  d009              BEQ      |L58.160|
00008c  2e02              CMP      r6,#2
00008e  d009              BEQ      |L58.164|
000090  2e04              CMP      r6,#4
000092  d111              BNE      |L58.184|
000094  e008              B        |L58.168|
                  |L58.150|
000096  2e10              CMP      r6,#0x10
000098  d00a              BEQ      |L58.176|
00009a  2e20              CMP      r6,#0x20
00009c  d10c              BNE      |L58.184|
00009e  e009              B        |L58.180|
                  |L58.160|
;;;1736           {
;;;1737               case 1U:
;;;1738                   pdec = 0x62U; /* 1  * 2 */
0000a0  2662              MOVS     r6,#0x62
;;;1739                   break;
0000a2  e00b              B        |L58.188|
                  |L58.164|
;;;1740               case 2U:
;;;1741                   pdec = 0x42U; /* 2  * 2 */
0000a4  2642              MOVS     r6,#0x42
;;;1742                   break;
0000a6  e009              B        |L58.188|
                  |L58.168|
;;;1743               case 4U:
;;;1744                   pdec = 0x02U; /* 4  * 2 */
0000a8  2602              MOVS     r6,#2
;;;1745                   break;
0000aa  e007              B        |L58.188|
                  |L58.172|
;;;1746               case 8U:
;;;1747                   pdec = 0x0bU; /* 8  * 2 */
0000ac  260b              MOVS     r6,#0xb
;;;1748                   break;
0000ae  e005              B        |L58.188|
                  |L58.176|
;;;1749               case 16U:
;;;1750                   pdec = 0x11U; /* 16 * 2 */
0000b0  2611              MOVS     r6,#0x11
;;;1751                   break;
0000b2  e003              B        |L58.188|
                  |L58.180|
;;;1752               case 32U:
;;;1753                   pdec = 0x08U; /* 32 * 2 */
0000b4  2608              MOVS     r6,#8
;;;1754                   break;
0000b6  e001              B        |L58.188|
                  |L58.184|
;;;1755               default:
;;;1756                   pdec = 0x08U;
0000b8  2608              MOVS     r6,#8
;;;1757                   break;
0000ba  bf00              NOP      
                  |L58.188|
0000bc  bf00              NOP                            ;1739
                  |L58.190|
;;;1758           }
;;;1759       }
;;;1760   
;;;1761       mdec = PLL_MDEC_VAL_SET(pllEncodeM(multiply_by));
0000be  4620              MOV      r0,r4
0000c0  f7fffffe          BL       pllEncodeM
0000c4  f3c00a10          UBFX     r10,r0,#0,#17
;;;1762       ndec = 0x302U; /* pre divide by 1 (hardcoded) */
0000c8  f2403b02          MOV      r11,#0x302
;;;1763   
;;;1764       SYSCON->SYSPLLCTRL = directo |
0000cc  9800              LDR      r0,[sp,#0]
0000ce  ea400009          ORR      r0,r0,r9
0000d2  ea401005          ORR      r0,r0,r5,LSL #4
0000d6  ea402088          ORR      r0,r0,r8,LSL #10
0000da  490a              LDR      r1,|L58.260|
0000dc  6008              STR      r0,[r1,#0]
;;;1765                            (selr << SYSCON_SYSPLLCTRL_SELR_SHIFT) | (seli << SYSCON_SYSPLLCTRL_SELI_SHIFT) |
;;;1766                            (selp << SYSCON_SYSPLLCTRL_SELP_SHIFT);
;;;1767       SYSCON->SYSPLLPDEC = pdec | (1U << 7U);  /* set Pdec value and assert preq */
0000de  f0460080          ORR      r0,r6,#0x80
0000e2  4908              LDR      r1,|L58.260|
0000e4  310c              ADDS     r1,r1,#0xc
0000e6  6008              STR      r0,[r1,#0]
;;;1768       SYSCON->SYSPLLNDEC = ndec | (1U << 10U); /* set Pdec value and assert preq */
0000e8  f44b6080          ORR      r0,r11,#0x400
0000ec  1f09              SUBS     r1,r1,#4
0000ee  6008              STR      r0,[r1,#0]
;;;1769       SYSCON->SYSPLLMDEC =
0000f0  f44a20c0          ORR      r0,r10,#0x60000
0000f4  4903              LDR      r1,|L58.260|
0000f6  3110              ADDS     r1,r1,#0x10
0000f8  6008              STR      r0,[r1,#0]
;;;1770           (1U << 18U) | (1U << 17U) | mdec; /* select non sscg MDEC value, assert mreq and select mdec value */
;;;1771   }
0000fa  e8bd9ffc          POP      {r2-r12,pc}
;;;1772   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L58.256|
                          DCD      0x10642ac0
                  |L58.260|
                          DCD      0x40000580

                          AREA ||i.CLOCK_SetupSystemPLLPrec||, CODE, READONLY, ALIGN=2

                  CLOCK_SetupSystemPLLPrec PROC
;;;1365   /* Set PLL output from PLL setup structure */
;;;1366   pll_error_t CLOCK_SetupSystemPLLPrec(pll_setup_t *pSetup, uint32_t flagcfg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1367   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1368       if (SYSCON->SYSPLLCLKSEL & SYSCON_SYSPLLCLKSEL_SEL_MASK == 0x01U)
000006  4835              LDR      r0,|L59.220|
000008  6800              LDR      r0,[r0,#0]
00000a  2000              MOVS     r0,#0
00000c  b110              CBZ      r0,|L59.20|
;;;1369       {
;;;1370          /* Turn on the ext clock if system pll input select clk_in */
;;;1371          CLOCK_Enable_SysOsc(true);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       CLOCK_Enable_SysOsc
                  |L59.20|
;;;1372       }
;;;1373       /* Enable power for PLLs */
;;;1374       POWER_SetPLL();
000014  f7fffffe          BL       POWER_SetPLL
;;;1375       /* Power off PLL during setup changes */
;;;1376       POWER_EnablePD(kPDRUNCFG_PD_SYS_PLL0);
000018  2016              MOVS     r0,#0x16
00001a  f7fffffe          BL       POWER_EnablePD
;;;1377       /*!< Set FLASH waitstates for core */
;;;1378       CLOCK_SetFLASHAccessCyclesForFreq(pSetup->pllRate);
00001e  6920              LDR      r0,[r4,#0x10]
000020  f7fffffe          BL       CLOCK_SetFLASHAccessCyclesForFreq
;;;1379       pSetup->flags = flagcfg;
000024  6165              STR      r5,[r4,#0x14]
;;;1380   
;;;1381       /* Write PLL setup data */
;;;1382       SYSCON->SYSPLLCTRL = pSetup->syspllctrl;
000026  492e              LDR      r1,|L59.224|
000028  6820              LDR      r0,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
;;;1383       SYSCON->SYSPLLNDEC = pSetup->syspllndec;
00002c  492c              LDR      r1,|L59.224|
00002e  3108              ADDS     r1,r1,#8
000030  6860              LDR      r0,[r4,#4]
000032  6008              STR      r0,[r1,#0]
;;;1384       SYSCON->SYSPLLNDEC = pSetup->syspllndec | (1U << SYSCON_SYSPLLNDEC_NREQ_SHIFT); /* latch */
000034  6860              LDR      r0,[r4,#4]
000036  f4406080          ORR      r0,r0,#0x400
00003a  6008              STR      r0,[r1,#0]
;;;1385       SYSCON->SYSPLLPDEC = pSetup->syspllpdec;
00003c  1d09              ADDS     r1,r1,#4
00003e  68a0              LDR      r0,[r4,#8]
000040  6008              STR      r0,[r1,#0]
;;;1386       SYSCON->SYSPLLPDEC = pSetup->syspllpdec | (1U << SYSCON_SYSPLLPDEC_PREQ_SHIFT); /* latch */
000042  68a0              LDR      r0,[r4,#8]
000044  f0400080          ORR      r0,r0,#0x80
000048  6008              STR      r0,[r1,#0]
;;;1387       SYSCON->SYSPLLMDEC = pSetup->syspllmdec;
00004a  1d09              ADDS     r1,r1,#4
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  6008              STR      r0,[r1,#0]
;;;1388       SYSCON->SYSPLLMDEC = pSetup->syspllmdec | (1U << SYSCON_SYSPLLMDEC_MREQ_SHIFT); /* latch */
000050  68e0              LDR      r0,[r4,#0xc]
000052  f4403000          ORR      r0,r0,#0x20000
000056  6008              STR      r0,[r1,#0]
;;;1389   
;;;1390       /* Flags for lock or power on */
;;;1391       if ((pSetup->flags & (PLL_SETUPFLAG_POWERUP | PLL_SETUPFLAG_WAITLOCK)) != 0U)
000058  7d20              LDRB     r0,[r4,#0x14]
00005a  f0000003          AND      r0,r0,#3
00005e  b318              CBZ      r0,|L59.168|
;;;1392       {
;;;1393           /* If turning the PLL back on, perform the following sequence to accelerate PLL lock */
;;;1394           volatile uint32_t delayX;
;;;1395           uint32_t maxCCO = (1U << 18U) | 0x5dd2U; /* CCO = 1.6Ghz + MDEC enabled*/
000060  4e20              LDR      r6,|L59.228|
;;;1396           uint32_t curSSCTRL = SYSCON->SYSPLLMDEC & ~(1U << 17U);
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  f4203700          BIC      r7,r0,#0x20000
;;;1397   
;;;1398           /* Initialize  and power up PLL */
;;;1399           SYSCON->SYSPLLMDEC = maxCCO;
00006a  4608              MOV      r0,r1
00006c  6006              STR      r6,[r0,#0]
;;;1400           POWER_DisablePD(kPDRUNCFG_PD_SYS_PLL0);
00006e  2016              MOVS     r0,#0x16
000070  f7fffffe          BL       POWER_DisablePD
;;;1401   
;;;1402           /* Set mreq to activate */
;;;1403           SYSCON->SYSPLLMDEC = maxCCO | (1U << 17U);
000074  f4463000          ORR      r0,r6,#0x20000
000078  4919              LDR      r1,|L59.224|
00007a  3110              ADDS     r1,r1,#0x10
00007c  6008              STR      r0,[r1,#0]
;;;1404   
;;;1405           /* Delay for 72 uSec @ 12Mhz */
;;;1406           for (delayX = 0U; delayX < 172U; ++delayX)
00007e  2000              MOVS     r0,#0
000080  9000              STR      r0,[sp,#0]
000082  e002              B        |L59.138|
                  |L59.132|
000084  9800              LDR      r0,[sp,#0]
000086  1c40              ADDS     r0,r0,#1
000088  9000              STR      r0,[sp,#0]
                  |L59.138|
00008a  9800              LDR      r0,[sp,#0]
00008c  28ac              CMP      r0,#0xac
00008e  d3f9              BCC      |L59.132|
;;;1407           {
;;;1408           }
;;;1409   
;;;1410           /* clear mreq to prepare for restoring mreq */
;;;1411           SYSCON->SYSPLLMDEC = curSSCTRL;
000090  4813              LDR      r0,|L59.224|
000092  3010              ADDS     r0,r0,#0x10
000094  6007              STR      r7,[r0,#0]
;;;1412   
;;;1413           /* set original value back and activate */
;;;1414           SYSCON->SYSPLLMDEC = curSSCTRL | (1U << 17U);
000096  f4473000          ORR      r0,r7,#0x20000
00009a  4911              LDR      r1,|L59.224|
00009c  3110              ADDS     r1,r1,#0x10
00009e  6008              STR      r0,[r1,#0]
;;;1415   
;;;1416           /* Enable peripheral states by setting low */
;;;1417           POWER_DisablePD(kPDRUNCFG_PD_SYS_PLL0);
0000a0  2016              MOVS     r0,#0x16
0000a2  f7fffffe          BL       POWER_DisablePD
;;;1418       }
0000a6  bf00              NOP      
                  |L59.168|
;;;1419       if ((pSetup->flags & PLL_SETUPFLAG_WAITLOCK) != 0U)
0000a8  7d20              LDRB     r0,[r4,#0x14]
0000aa  f0000002          AND      r0,r0,#2
0000ae  b140              CBZ      r0,|L59.194|
;;;1420       {
;;;1421           while (CLOCK_IsSystemPLLLocked() == false)
0000b0  bf00              NOP      
                  |L59.178|
0000b2  bf00              NOP      
0000b4  480a              LDR      r0,|L59.224|
0000b6  1d00              ADDS     r0,r0,#4
0000b8  6800              LDR      r0,[r0,#0]
0000ba  f0000001          AND      r0,r0,#1
0000be  2800              CMP      r0,#0
0000c0  d0f7              BEQ      |L59.178|
                  |L59.194|
;;;1422           {
;;;1423           }
;;;1424       }
;;;1425   
;;;1426       /* Update current programmed PLL rate var */
;;;1427       CLOCK_GetSystemPLLOutFromSetupUpdate(pSetup);
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       CLOCK_GetSystemPLLOutFromSetupUpdate
;;;1428   
;;;1429       /* System voltage adjustment, occurs prior to setting main system clock */
;;;1430       if ((pSetup->flags & PLL_SETUPFLAG_ADGVOLT) != 0U)
0000c8  7d20              LDRB     r0,[r4,#0x14]
0000ca  f0000004          AND      r0,r0,#4
0000ce  b118              CBZ      r0,|L59.216|
;;;1431       {
;;;1432           POWER_SetVoltageForFreq(s_Pll_Freq);
0000d0  4805              LDR      r0,|L59.232|
0000d2  6800              LDR      r0,[r0,#0]  ; s_Pll_Freq
0000d4  f7fffffe          BL       POWER_SetVoltageForFreq
                  |L59.216|
;;;1433       }
;;;1434   
;;;1435       return kStatus_PLL_Success;
0000d8  2000              MOVS     r0,#0
;;;1436   }
0000da  bdf8              POP      {r3-r7,pc}
;;;1437   
                          ENDP

                  |L59.220|
                          DCD      0x40000290
                  |L59.224|
                          DCD      0x40000580
                  |L59.228|
                          DCD      0x00045dd2
                  |L59.232|
                          DCD      s_Pll_Freq

                          AREA ||i.FindGreatestCommonDivisor||, CODE, READONLY, ALIGN=1

                  FindGreatestCommonDivisor PROC
;;;972    /* Find greatest common divisor between m and n */
;;;973    static uint32_t FindGreatestCommonDivisor(uint32_t m, uint32_t n)
000000  e005              B        |L60.14|
                  |L60.2|
;;;974    {
;;;975        uint32_t tmp;
;;;976    
;;;977        while (n != 0U)
;;;978        {
;;;979            tmp = n;
000002  460a              MOV      r2,r1
;;;980            n = m % n;
000004  fbb0f3f1          UDIV     r3,r0,r1
000008  fb010113          MLS      r1,r1,r3,r0
;;;981            m = tmp;
00000c  4610              MOV      r0,r2
                  |L60.14|
00000e  2900              CMP      r1,#0                 ;977
000010  d1f7              BNE      |L60.2|
;;;982        }
;;;983    
;;;984        return m;
;;;985    }
000012  4770              BX       lr
;;;986    
                          ENDP


                          AREA ||i.POWER_DisablePD||, CODE, READONLY, ALIGN=2

                  POWER_DisablePD PROC
;;;118     */
;;;119    static inline void POWER_DisablePD(pd_bit_t en)
000000  2101              MOVS     r1,#1
;;;120    {
;;;121        /* PDRUNCFGCLR */
;;;122        SYSCON->PDRUNCFGCLR[(en >> 8UL)] = (1UL << (en & 0xffU));
000002  4081              LSLS     r1,r1,r0
000004  4a02              LDR      r2,|L61.16|
000006  0a03              LSRS     r3,r0,#8
000008  f8421023          STR      r1,[r2,r3,LSL #2]
;;;123    }
00000c  4770              BX       lr
;;;124    
                          ENDP

00000e  0000              DCW      0x0000
                  |L61.16|
                          DCD      0x40000630

                          AREA ||i.POWER_EnablePD||, CODE, READONLY, ALIGN=2

                  POWER_EnablePD PROC
;;;106     */
;;;107    static inline void POWER_EnablePD(pd_bit_t en)
000000  2101              MOVS     r1,#1
;;;108    {
;;;109        /* PDRUNCFGSET */
;;;110        SYSCON->PDRUNCFGSET[(en >> 8UL)] = (1UL << (en & 0xffU));
000002  4081              LSLS     r1,r1,r0
000004  4a02              LDR      r2,|L62.16|
000006  0a03              LSRS     r3,r0,#8
000008  f8421023          STR      r1,[r2,r3,LSL #2]
;;;111    }
00000c  4770              BX       lr
;;;112    
                          ENDP

00000e  0000              DCW      0x0000
                  |L62.16|
                          DCD      0x40000620

                          AREA ||i.findPllMMult||, CODE, READONLY, ALIGN=1

                  findPllMMult PROC
;;;956    /* Get multiplier (M) from PLL MDEC and BYPASS_FBDIV2 settings */
;;;957    static uint32_t findPllMMult(uint32_t ctrlReg, uint32_t mDecReg)
000000  b570              PUSH     {r4-r6,lr}
;;;958    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;959        uint32_t mMult = 1U;
000006  2501              MOVS     r5,#1
;;;960    
;;;961        /* Decode MDEC value to get (M) multiplier */
;;;962        mMult = pllDecodeM(mDecReg & 0x1FFFFU);
000008  f3c40010          UBFX     r0,r4,#0,#17
00000c  f7fffffe          BL       pllDecodeM
000010  4605              MOV      r5,r0
;;;963    
;;;964        if (mMult == 0U)
000012  b905              CBNZ     r5,|L63.22|
;;;965        {
;;;966            mMult = 1U;
000014  2501              MOVS     r5,#1
                  |L63.22|
;;;967        }
;;;968    
;;;969        return mMult;
000016  4628              MOV      r0,r5
;;;970    }
000018  bd70              POP      {r4-r6,pc}
;;;971    
                          ENDP


                          AREA ||i.findPllPostDiv||, CODE, READONLY, ALIGN=1

                  findPllPostDiv PROC
;;;936    /* Get postdivider (P) from PLL PDEC setting */
;;;937    static uint32_t findPllPostDiv(uint32_t ctrlReg, uint32_t pDecReg)
000000  b570              PUSH     {r4-r6,lr}
;;;938    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;939        uint32_t postDiv = 1U;
000006  2601              MOVS     r6,#1
;;;940    
;;;941        /* Direct input is not used? */
;;;942        if ((ctrlReg & SYSCON_SYSPLLCTRL_DIRECTO_SHIFT) == 0U)
000008  f0040014          AND      r0,r4,#0x14
00000c  b930              CBNZ     r0,|L64.28|
;;;943        {
;;;944            /* Decode PDEC value to get (P) post divider */
;;;945            postDiv = 2U * pllDecodeP(pDecReg & 0x7FU);
00000e  f005007f          AND      r0,r5,#0x7f
000012  f7fffffe          BL       pllDecodeP
000016  0046              LSLS     r6,r0,#1
;;;946            if (postDiv == 0U)
000018  b906              CBNZ     r6,|L64.28|
;;;947            {
;;;948                postDiv = 2U;
00001a  2602              MOVS     r6,#2
                  |L64.28|
;;;949            }
;;;950        }
;;;951    
;;;952        /* Adjusted by 1, directo is used to bypass */
;;;953        return postDiv;
00001c  4630              MOV      r0,r6
;;;954    }
00001e  bd70              POP      {r4-r6,pc}
;;;955    
                          ENDP


                          AREA ||i.findPllPreDiv||, CODE, READONLY, ALIGN=1

                  findPllPreDiv PROC
;;;916    /* Get predivider (N) from PLL NDEC setting */
;;;917    static uint32_t findPllPreDiv(uint32_t ctrlReg, uint32_t nDecReg)
000000  b570              PUSH     {r4-r6,lr}
;;;918    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;919        uint32_t preDiv = 1;
000006  2601              MOVS     r6,#1
;;;920    
;;;921        /* Direct input is not used? */
;;;922        if ((ctrlReg & (1UL << SYSCON_SYSPLLCTRL_DIRECTI_SHIFT)) == 0U)
000008  f4042000          AND      r0,r4,#0x80000
00000c  b930              CBNZ     r0,|L65.28|
;;;923        {
;;;924            /* Decode NDEC value to get (N) pre divider */
;;;925            preDiv = pllDecodeN(nDecReg & 0x3FFU);
00000e  f3c50009          UBFX     r0,r5,#0,#10
000012  f7fffffe          BL       pllDecodeN
000016  4606              MOV      r6,r0
;;;926            if (preDiv == 0U)
000018  b906              CBNZ     r6,|L65.28|
;;;927            {
;;;928                preDiv = 1U;
00001a  2601              MOVS     r6,#1
                  |L65.28|
;;;929            }
;;;930        }
;;;931    
;;;932        /* Adjusted by 1, directi is used to bypass */
;;;933        return preDiv;
00001c  4630              MOV      r0,r6
;;;934    }
00001e  bd70              POP      {r4-r6,pc}
;;;935    
                          ENDP


                          AREA ||i.pllDecodeM||, CODE, READONLY, ALIGN=2

                  pllDecodeM PROC
;;;831    /* Find decoded M value for raw MDEC value */
;;;832    static uint32_t pllDecodeM(uint32_t MDEC)
000000  b530              PUSH     {r4,r5,lr}
;;;833    {
000002  4603              MOV      r3,r0
;;;834        uint32_t m, i, x;
;;;835    
;;;836        /* Find MDec */
;;;837        switch (MDEC)
000004  f5a33480          SUB      r4,r3,#0x10000
000008  1ee4              SUBS     r4,r4,#3
00000a  b14c              CBZ      r4,|L66.32|
00000c  f5b44f00          CMP      r4,#0x8000
000010  d004              BEQ      |L66.28|
000012  4d11              LDR      r5,|L66.88|
000014  442c              ADD      r4,r4,r5
000016  b92c              CBNZ     r4,|L66.36|
;;;838        {
;;;839            case 0xFFFFFU:
;;;840                m = 0U;
000018  2000              MOVS     r0,#0
;;;841                break;
00001a  e01b              B        |L66.84|
                  |L66.28|
;;;842    
;;;843            case 0x18003U:
;;;844                m = 1U;
00001c  2001              MOVS     r0,#1
;;;845                break;
00001e  e019              B        |L66.84|
                  |L66.32|
;;;846    
;;;847            case 0x10003U:
;;;848                m = 2U;
000020  2002              MOVS     r0,#2
;;;849                break;
000022  e017              B        |L66.84|
                  |L66.36|
;;;850    
;;;851            default:
;;;852                x = 0x04000U;
000024  f44f4180          MOV      r1,#0x4000
;;;853                m = 0xFFFFFFFFU;
000028  f04f30ff          MOV      r0,#0xffffffff
;;;854                for (i = MVALMAX; ((i >= 3U) && (m == 0xFFFFFFFFU)); i--)
00002c  004a              LSLS     r2,r1,#1
00002e  e00b              B        |L66.72|
                  |L66.48|
;;;855                {
;;;856                    x = (((x ^ (x >> 1U)) & 1) << 14U) | ((x >> 1U) & 0x3FFFU);
000030  ea810451          EOR      r4,r1,r1,LSR #1
000034  f0040401          AND      r4,r4,#1
000038  f3c1054d          UBFX     r5,r1,#1,#14
00003c  ea453184          ORR      r1,r5,r4,LSL #14
;;;857                    if ((x & (PLL_MDEC_VAL_M >> PLL_MDEC_VAL_P)) == MDEC)
000040  4299              CMP      r1,r3
000042  d100              BNE      |L66.70|
;;;858                    {
;;;859                        /* Decoded value of MDEC */
;;;860                        m = i;
000044  4610              MOV      r0,r2
                  |L66.70|
000046  1e52              SUBS     r2,r2,#1              ;854
                  |L66.72|
000048  2a03              CMP      r2,#3                 ;854
00004a  d302              BCC      |L66.82|
00004c  1c44              ADDS     r4,r0,#1              ;854
00004e  2c00              CMP      r4,#0                 ;854
000050  d0ee              BEQ      |L66.48|
                  |L66.82|
;;;861                    }
;;;862                }
;;;863                break;
000052  bf00              NOP      
                  |L66.84|
000054  bf00              NOP                            ;841
;;;864        }
;;;865    
;;;866        return m;
;;;867    }
000056  bd30              POP      {r4,r5,pc}
;;;868    
                          ENDP

                  |L66.88|
                          DCD      0xfff10004

                          AREA ||i.pllDecodeN||, CODE, READONLY, ALIGN=1

                  pllDecodeN PROC
;;;691    /* Find decoded N value for raw NDEC value */
;;;692    static uint32_t pllDecodeN(uint32_t NDEC)
000000  b530              PUSH     {r4,r5,lr}
;;;693    {
000002  4603              MOV      r3,r0
;;;694        uint32_t n, x, i;
;;;695    
;;;696        /* Find NDec */
;;;697        switch (NDEC)
000004  f2a32402          SUB      r4,r3,#0x202
000008  b14c              CBZ      r4,|L67.30|
00000a  f5b47f80          CMP      r4,#0x100
00000e  d004              BEQ      |L67.26|
000010  f6a454fd          SUB      r4,r4,#0xdfd
000014  b92c              CBNZ     r4,|L67.34|
;;;698        {
;;;699            case 0xFFFU:
;;;700                n = 0U;
000016  2000              MOVS     r0,#0
;;;701                break;
000018  e01e              B        |L67.88|
                  |L67.26|
;;;702    
;;;703            case 0x302U:
;;;704                n = 1U;
00001a  2001              MOVS     r0,#1
;;;705                break;
00001c  e01c              B        |L67.88|
                  |L67.30|
;;;706    
;;;707            case 0x202U:
;;;708                n = 2U;
00001e  2002              MOVS     r0,#2
;;;709                break;
000020  e01a              B        |L67.88|
                  |L67.34|
;;;710    
;;;711            default:
;;;712                x = 0x080U;
000022  2180              MOVS     r1,#0x80
;;;713                n = 0xFFFFFFFFU;
000024  f04f30ff          MOV      r0,#0xffffffff
;;;714                for (i = NVALMAX; ((i >= 3U) && (n == 0xFFFFFFFFU)); i--)
000028  004a              LSLS     r2,r1,#1
00002a  e00f              B        |L67.76|
                  |L67.44|
;;;715                {
;;;716                    x = (((x ^ (x >> 2U) ^ (x >> 3U) ^ (x >> 4U)) & 1U) << 7U) | ((x >> 1U) & 0x7FU);
00002c  ea810491          EOR      r4,r1,r1,LSR #2
000030  ea8404d1          EOR      r4,r4,r1,LSR #3
000034  ea841411          EOR      r4,r4,r1,LSR #4
000038  f0040401          AND      r4,r4,#1
00003c  f3c10546          UBFX     r5,r1,#1,#7
000040  ea4511c4          ORR      r1,r5,r4,LSL #7
;;;717                    if ((x & (PLL_NDEC_VAL_M >> PLL_NDEC_VAL_P)) == NDEC)
000044  4299              CMP      r1,r3
000046  d100              BNE      |L67.74|
;;;718                    {
;;;719                        /* Decoded value of NDEC */
;;;720                        n = i;
000048  4610              MOV      r0,r2
                  |L67.74|
00004a  1e52              SUBS     r2,r2,#1              ;714
                  |L67.76|
00004c  2a03              CMP      r2,#3                 ;714
00004e  d302              BCC      |L67.86|
000050  1c44              ADDS     r4,r0,#1              ;714
000052  2c00              CMP      r4,#0                 ;714
000054  d0ea              BEQ      |L67.44|
                  |L67.86|
;;;721                    }
;;;722                }
;;;723                break;
000056  bf00              NOP      
                  |L67.88|
000058  bf00              NOP                            ;701
;;;724        }
;;;725    
;;;726        return n;
;;;727    }
00005a  bd30              POP      {r4,r5,pc}
;;;728    
                          ENDP


                          AREA ||i.pllDecodeP||, CODE, READONLY, ALIGN=1

                  pllDecodeP PROC
;;;761    /* Find decoded P value for raw PDEC value */
;;;762    static uint32_t pllDecodeP(uint32_t PDEC)
000000  b530              PUSH     {r4,r5,lr}
;;;763    {
000002  4603              MOV      r3,r0
;;;764        uint32_t p, x, i;
;;;765    
;;;766        /* Find PDec */
;;;767        switch (PDEC)
000004  2b42              CMP      r3,#0x42
000006  d007              BEQ      |L68.24|
000008  2b62              CMP      r3,#0x62
00000a  d003              BEQ      |L68.20|
00000c  2bff              CMP      r3,#0xff
00000e  d105              BNE      |L68.28|
;;;768        {
;;;769            case 0xFFU:
;;;770                p = 0U;
000010  2000              MOVS     r0,#0
;;;771                break;
000012  e01a              B        |L68.74|
                  |L68.20|
;;;772    
;;;773            case 0x62U:
;;;774                p = 1U;
000014  2001              MOVS     r0,#1
;;;775                break;
000016  e018              B        |L68.74|
                  |L68.24|
;;;776    
;;;777            case 0x42U:
;;;778                p = 2U;
000018  2002              MOVS     r0,#2
;;;779                break;
00001a  e016              B        |L68.74|
                  |L68.28|
;;;780    
;;;781            default:
;;;782                x = 0x10U;
00001c  2110              MOVS     r1,#0x10
;;;783                p = 0xFFFFFFFFU;
00001e  f04f30ff          MOV      r0,#0xffffffff
;;;784                for (i = PVALMAX; ((i >= 3U) && (p == 0xFFFFFFFFU)); i--)
000022  2220              MOVS     r2,#0x20
000024  e00b              B        |L68.62|
                  |L68.38|
;;;785                {
;;;786                    x = (((x ^ (x >> 2U)) & 1U) << 4U) | ((x >> 1U) & 0xFU);
000026  ea810491          EOR      r4,r1,r1,LSR #2
00002a  f0040401          AND      r4,r4,#1
00002e  f3c10543          UBFX     r5,r1,#1,#4
000032  ea451104          ORR      r1,r5,r4,LSL #4
;;;787                    if ((x & (PLL_PDEC_VAL_M >> PLL_PDEC_VAL_P)) == PDEC)
000036  4299              CMP      r1,r3
000038  d100              BNE      |L68.60|
;;;788                    {
;;;789                        /* Decoded value of PDEC */
;;;790                        p = i;
00003a  4610              MOV      r0,r2
                  |L68.60|
00003c  1e52              SUBS     r2,r2,#1              ;784
                  |L68.62|
00003e  2a03              CMP      r2,#3                 ;784
000040  d302              BCC      |L68.72|
000042  1c44              ADDS     r4,r0,#1              ;784
000044  2c00              CMP      r4,#0                 ;784
000046  d0ee              BEQ      |L68.38|
                  |L68.72|
;;;791                    }
;;;792                }
;;;793                break;
000048  bf00              NOP      
                  |L68.74|
00004a  bf00              NOP                            ;771
;;;794        }
;;;795    
;;;796        return p;
;;;797    }
00004c  bd30              POP      {r4,r5,pc}
;;;798    
                          ENDP


                          AREA ||i.pllEncodeM||, CODE, READONLY, ALIGN=2

                  pllEncodeM PROC
;;;799    /* Find encoded MDEC value for raw M value, max M = MVALMAX */
;;;800    static uint32_t pllEncodeM(uint32_t M)
000000  b510              PUSH     {r4,lr}
;;;801    {
000002  4602              MOV      r2,r0
;;;802        uint32_t i, x;
;;;803    
;;;804        /* Find MDec */
;;;805        switch (M)
000004  b122              CBZ      r2,|L69.16|
000006  2a01              CMP      r2,#1
000008  d004              BEQ      |L69.20|
00000a  2a02              CMP      r2,#2
00000c  d106              BNE      |L69.28|
00000e  e003              B        |L69.24|
                  |L69.16|
;;;806        {
;;;807            case 0U:
;;;808                x = 0xFFFFFU;
000010  490d              LDR      r1,|L69.72|
;;;809                break;
000012  e014              B        |L69.62|
                  |L69.20|
;;;810    
;;;811            case 1U:
;;;812                x = 0x18003U;
000014  490d              LDR      r1,|L69.76|
;;;813                break;
000016  e012              B        |L69.62|
                  |L69.24|
;;;814    
;;;815            case 2U:
;;;816                x = 0x10003U;
000018  490d              LDR      r1,|L69.80|
;;;817                break;
00001a  e010              B        |L69.62|
                  |L69.28|
;;;818    
;;;819            default:
;;;820                x = 0x04000U;
00001c  f44f4180          MOV      r1,#0x4000
;;;821                for (i = M; i <= MVALMAX; i++)
000020  4613              MOV      r3,r2
000022  e008              B        |L69.54|
                  |L69.36|
;;;822                {
;;;823                    x = (((x ^ (x >> 1U)) & 1U) << 14U) | ((x >> 1U) & 0x3FFFU);
000024  ea810051          EOR      r0,r1,r1,LSR #1
000028  f0000001          AND      r0,r0,#1
00002c  f3c1044d          UBFX     r4,r1,#1,#14
000030  ea443180          ORR      r1,r4,r0,LSL #14
000034  1c5b              ADDS     r3,r3,#1              ;821
                  |L69.54|
000036  f5b34f00          CMP      r3,#0x8000            ;821
00003a  d9f3              BLS      |L69.36|
;;;824                }
;;;825                break;
00003c  bf00              NOP      
                  |L69.62|
00003e  bf00              NOP                            ;809
;;;826        }
;;;827    
;;;828        return x & (PLL_MDEC_VAL_M >> PLL_MDEC_VAL_P);
000040  f3c10010          UBFX     r0,r1,#0,#17
;;;829    }
000044  bd10              POP      {r4,pc}
;;;830    
                          ENDP

000046  0000              DCW      0x0000
                  |L69.72|
                          DCD      0x000fffff
                  |L69.76|
                          DCD      0x00018003
                  |L69.80|
                          DCD      0x00010003

                          AREA ||i.pllEncodeN||, CODE, READONLY, ALIGN=1

                  pllEncodeN PROC
;;;659    /* Find encoded NDEC value for raw N value, max N = NVALMAX */
;;;660    static uint32_t pllEncodeN(uint32_t N)
000000  b510              PUSH     {r4,lr}
;;;661    {
000002  4602              MOV      r2,r0
;;;662        uint32_t x, i;
;;;663    
;;;664        /* Find NDec */
;;;665        switch (N)
000004  b122              CBZ      r2,|L70.16|
000006  2a01              CMP      r2,#1
000008  d005              BEQ      |L70.22|
00000a  2a02              CMP      r2,#2
00000c  d109              BNE      |L70.34|
00000e  e005              B        |L70.28|
                  |L70.16|
;;;666        {
;;;667            case 0U:
;;;668                x = 0xFFFU;
000010  f64071ff          MOV      r1,#0xfff
;;;669                break;
000014  e019              B        |L70.74|
                  |L70.22|
;;;670    
;;;671            case 1U:
;;;672                x = 0x302U;
000016  f2403102          MOV      r1,#0x302
;;;673                break;
00001a  e016              B        |L70.74|
                  |L70.28|
;;;674    
;;;675            case 2U:
;;;676                x = 0x202U;
00001c  f2402102          MOV      r1,#0x202
;;;677                break;
000020  e013              B        |L70.74|
                  |L70.34|
;;;678    
;;;679            default:
;;;680                x = 0x080U;
000022  2180              MOVS     r1,#0x80
;;;681                for (i = N; i <= NVALMAX; i++)
000024  4613              MOV      r3,r2
000026  e00c              B        |L70.66|
                  |L70.40|
;;;682                {
;;;683                    x = (((x ^ (x >> 2U) ^ (x >> 3U) ^ (x >> 4U)) & 1U) << 7U) | ((x >> 1U) & 0x7FU);
000028  ea810091          EOR      r0,r1,r1,LSR #2
00002c  ea8000d1          EOR      r0,r0,r1,LSR #3
000030  ea801011          EOR      r0,r0,r1,LSR #4
000034  f0000001          AND      r0,r0,#1
000038  f3c10446          UBFX     r4,r1,#1,#7
00003c  ea4411c0          ORR      r1,r4,r0,LSL #7
000040  1c5b              ADDS     r3,r3,#1              ;681
                  |L70.66|
000042  f5b37f80          CMP      r3,#0x100             ;681
000046  d9ef              BLS      |L70.40|
;;;684                }
;;;685                break;
000048  bf00              NOP      
                  |L70.74|
00004a  bf00              NOP                            ;669
;;;686        }
;;;687    
;;;688        return x & (PLL_NDEC_VAL_M >> PLL_NDEC_VAL_P);
00004c  f3c10009          UBFX     r0,r1,#0,#10
;;;689    }
000050  bd10              POP      {r4,pc}
;;;690    
                          ENDP


                          AREA ||i.pllEncodeP||, CODE, READONLY, ALIGN=1

                  pllEncodeP PROC
;;;729    /* Find encoded PDEC value for raw P value, max P = PVALMAX */
;;;730    static uint32_t pllEncodeP(uint32_t P)
000000  b510              PUSH     {r4,lr}
;;;731    {
000002  4602              MOV      r2,r0
;;;732        uint32_t x, i;
;;;733    
;;;734        /* Find PDec */
;;;735        switch (P)
000004  b122              CBZ      r2,|L71.16|
000006  2a01              CMP      r2,#1
000008  d004              BEQ      |L71.20|
00000a  2a02              CMP      r2,#2
00000c  d106              BNE      |L71.28|
00000e  e003              B        |L71.24|
                  |L71.16|
;;;736        {
;;;737            case 0U:
;;;738                x = 0xFFU;
000010  21ff              MOVS     r1,#0xff
;;;739                break;
000012  e012              B        |L71.58|
                  |L71.20|
;;;740    
;;;741            case 1U:
;;;742                x = 0x62U;
000014  2162              MOVS     r1,#0x62
;;;743                break;
000016  e010              B        |L71.58|
                  |L71.24|
;;;744    
;;;745            case 2U:
;;;746                x = 0x42U;
000018  2142              MOVS     r1,#0x42
;;;747                break;
00001a  e00e              B        |L71.58|
                  |L71.28|
;;;748    
;;;749            default:
;;;750                x = 0x10U;
00001c  2110              MOVS     r1,#0x10
;;;751                for (i = P; i <= PVALMAX; i++)
00001e  4613              MOV      r3,r2
000020  e008              B        |L71.52|
                  |L71.34|
;;;752                {
;;;753                    x = (((x ^ (x >> 2U)) & 1U) << 4U) | ((x >> 1U) & 0xFU);
000022  ea810091          EOR      r0,r1,r1,LSR #2
000026  f0000001          AND      r0,r0,#1
00002a  f3c10443          UBFX     r4,r1,#1,#4
00002e  ea441100          ORR      r1,r4,r0,LSL #4
000032  1c5b              ADDS     r3,r3,#1              ;751
                  |L71.52|
000034  2b20              CMP      r3,#0x20              ;751
000036  d9f4              BLS      |L71.34|
;;;754                }
;;;755                break;
000038  bf00              NOP      
                  |L71.58|
00003a  bf00              NOP                            ;739
;;;756        }
;;;757    
;;;758        return x & (PLL_PDEC_VAL_M >> PLL_PDEC_VAL_P);
00003c  f3c10009          UBFX     r0,r1,#0,#10
;;;759    }
000040  bd10              POP      {r4,pc}
;;;760    
                          ENDP


                          AREA ||i.pllFindSel||, CODE, READONLY, ALIGN=1

                  pllFindSel PROC
;;;869    /* Find SELP, SELI, and SELR values for raw M value, max M = MVALMAX */
;;;870    static void pllFindSel(uint32_t M, uint32_t *pSelP, uint32_t *pSelI, uint32_t *pSelR)
000000  b530              PUSH     {r4,r5,lr}
;;;871    {
;;;872        /* bandwidth: compute selP from Multiplier */
;;;873        if (M < 60U)
000002  283c              CMP      r0,#0x3c
000004  d204              BCS      |L72.16|
;;;874        {
;;;875            *pSelP = (M >> 1U) + 1U;
000006  2401              MOVS     r4,#1
000008  eb040450          ADD      r4,r4,r0,LSR #1
00000c  600c              STR      r4,[r1,#0]
00000e  e001              B        |L72.20|
                  |L72.16|
;;;876        }
;;;877        else
;;;878        {
;;;879            *pSelP = PVALMAX - 1U;
000010  241f              MOVS     r4,#0x1f
000012  600c              STR      r4,[r1,#0]
                  |L72.20|
;;;880        }
;;;881    
;;;882        /* bandwidth: compute selI from Multiplier */
;;;883        if (M > 16384U)
000014  f5b04f80          CMP      r0,#0x4000
000018  d902              BLS      |L72.32|
;;;884        {
;;;885            *pSelI = 1U;
00001a  2401              MOVS     r4,#1
00001c  6014              STR      r4,[r2,#0]
00001e  e020              B        |L72.98|
                  |L72.32|
;;;886        }
;;;887        else if (M > 8192U)
000020  f5b05f00          CMP      r0,#0x2000
000024  d902              BLS      |L72.44|
;;;888        {
;;;889            *pSelI = 2U;
000026  2402              MOVS     r4,#2
000028  6014              STR      r4,[r2,#0]
00002a  e01a              B        |L72.98|
                  |L72.44|
;;;890        }
;;;891        else if (M > 2048U)
00002c  f5b06f00          CMP      r0,#0x800
000030  d902              BLS      |L72.56|
;;;892        {
;;;893            *pSelI = 4U;
000032  2404              MOVS     r4,#4
000034  6014              STR      r4,[r2,#0]
000036  e014              B        |L72.98|
                  |L72.56|
;;;894        }
;;;895        else if (M >= 501U)
000038  f5b07ffa          CMP      r0,#0x1f4
00003c  d902              BLS      |L72.68|
;;;896        {
;;;897            *pSelI = 8U;
00003e  2408              MOVS     r4,#8
000040  6014              STR      r4,[r2,#0]
000042  e00e              B        |L72.98|
                  |L72.68|
;;;898        }
;;;899        else if (M >= 60U)
000044  283c              CMP      r0,#0x3c
000046  d308              BCC      |L72.90|
;;;900        {
;;;901            *pSelI = 4U * (1024U / (M + 9U));
000048  f1000409          ADD      r4,r0,#9
00004c  f44f6580          MOV      r5,#0x400
000050  fbb5f4f4          UDIV     r4,r5,r4
000054  00a4              LSLS     r4,r4,#2
000056  6014              STR      r4,[r2,#0]
000058  e003              B        |L72.98|
                  |L72.90|
;;;902        }
;;;903        else
;;;904        {
;;;905            *pSelI = (M & 0x3CU) + 4U;
00005a  f000043c          AND      r4,r0,#0x3c
00005e  1d24              ADDS     r4,r4,#4
000060  6014              STR      r4,[r2,#0]
                  |L72.98|
;;;906        }
;;;907    
;;;908        if (*pSelI > ((0x3FUL << SYSCON_SYSPLLCTRL_SELI_SHIFT) >> SYSCON_SYSPLLCTRL_SELI_SHIFT))
000062  6814              LDR      r4,[r2,#0]
000064  2c3f              CMP      r4,#0x3f
000066  d901              BLS      |L72.108|
;;;909        {
;;;910            *pSelI = ((0x3FUL << SYSCON_SYSPLLCTRL_SELI_SHIFT) >> SYSCON_SYSPLLCTRL_SELI_SHIFT);
000068  243f              MOVS     r4,#0x3f
00006a  6014              STR      r4,[r2,#0]
                  |L72.108|
;;;911        }
;;;912    
;;;913        *pSelR = 0U;
00006c  2400              MOVS     r4,#0
00006e  601c              STR      r4,[r3,#0]
;;;914    }
000070  bd30              POP      {r4,r5,pc}
;;;915    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_I2S_Mclk_Freq
                          DCD      0x00000000
                  g_Ext_Clk_Freq
                          DCD      0x00b71b00
                  g_Lcd_Clk_In_Freq
                          DCD      0x00000000
                  wdtFreqLookup
00000c  00080c0f          DCB      0x00,0x08,0x0c,0x0f
000010  1214181a          DCB      0x12,0x14,0x18,0x1a
000014  1c1e2022          DCB      0x1c,0x1e,0x20,0x22
000018  24262829          DCB      0x24,0x26,0x28,0x29
00001c  2a2c2d2e          DCB      0x2a,0x2c,0x2d,0x2e
000020  30313234          DCB      0x30,0x31,0x32,0x34
000024  35363839          DCB      0x35,0x36,0x38,0x39
000028  3a3b3c3d          DCB      0x3a,0x3b,0x3c,0x3d
00002c  3f010300          DCB      0x3f,0x01,0x03,0x00
000030  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00b71b00
000038  3f010300          DCB      0x3f,0x01,0x03,0x00
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00b71b00
000044  3f010300          DCB      0x3f,0x01,0x03,0x00
000048  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00b71b00
000050  3f010300          DCB      0x3f,0x01,0x03,0x00
000054  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00b71b00

                          AREA ||.data||, DATA, ALIGN=2

                  s_Pll_Freq
                          DCD      0x00000000
                  s_Usb_Pll_Freq
                          DCD      0x00000000
                  s_Audio_Pll_Freq
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_clock.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_fsl_clock_c_2767c4c0____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_fsl_clock_c_2767c4c0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_fsl_clock_c_2767c4c0____REVSH|
#line 402
|__asm___11_fsl_clock_c_2767c4c0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_fsl_clock_c_2767c4c0____RRX|
#line 587
|__asm___11_fsl_clock_c_2767c4c0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
