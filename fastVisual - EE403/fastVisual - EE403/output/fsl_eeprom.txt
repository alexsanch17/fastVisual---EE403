; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_eeprom.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_eeprom.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_eeprom.crf SRC\Drivers\fsl_eeprom.c]
                          THUMB

                          AREA ||i.EEPROM_ClearInterruptFlag||, CODE, READONLY, ALIGN=1

                  EEPROM_ClearInterruptFlag PROC
;;;222     */
;;;223    static inline void EEPROM_ClearInterruptFlag(EEPROM_Type *base, uint32_t mask)
000000  f8c01fe8          STR      r1,[r0,#0xfe8]
;;;224    {
;;;225        base->INTSTATCLR = mask;
;;;226    }
000004  4770              BX       lr
;;;227    
                          ENDP


                          AREA ||i.EEPROM_Deinit||, CODE, READONLY, ALIGN=2

                  EEPROM_Deinit PROC
;;;128    
;;;129    void EEPROM_Deinit(EEPROM_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4605              MOV      r5,r0
;;;131    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;132        /* Enable the SAI clock */
;;;133        CLOCK_DisableClock(s_eepromClock[EEPROM_GetInstance(base)]);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       EEPROM_GetInstance
00000a  490a              LDR      r1,|L2.52|
00000c  f8314010          LDRH     r4,[r1,r0,LSL #1]
000010  0a20              LSRS     r0,r4,#8
000012  2803              CMP      r0,#3
000014  d205              BCS      |L2.34|
000016  2101              MOVS     r1,#1
000018  40a1              LSLS     r1,r1,r4
00001a  4a07              LDR      r2,|L2.56|
00001c  f8421020          STR      r1,[r2,r0,LSL #2]
000020  e006              B        |L2.48|
                  |L2.34|
000022  2101              MOVS     r1,#1
000024  40a1              LSLS     r1,r1,r4
000026  4a05              LDR      r2,|L2.60|
000028  6191              STR      r1,[r2,#0x18]
00002a  2100              MOVS     r1,#0
00002c  0312              LSLS     r2,r2,#12
00002e  64d1              STR      r1,[r2,#0x4c]
                  |L2.48|
000030  bf00              NOP      
;;;134    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;135    }
000032  bd70              POP      {r4-r6,pc}
;;;136    
                          ENDP

                  |L2.52|
                          DCD      s_eepromClock
                  |L2.56|
                          DCD      0x40000240
                  |L2.60|
                          DCD      0x40040000

                          AREA ||i.EEPROM_GetDefaultConfig||, CODE, READONLY, ALIGN=1

                  EEPROM_GetDefaultConfig PROC
;;;81     
;;;82     void EEPROM_GetDefaultConfig(eeprom_config_t *config)
000000  2101              MOVS     r1,#1
;;;83     {
;;;84         config->autoProgram = kEEPROM_AutoProgramWriteWord;
000002  7001              STRB     r1,[r0,#0]
;;;85         config->writeWaitPhase1 = 0x5U;
000004  2105              MOVS     r1,#5
000006  70c1              STRB     r1,[r0,#3]
;;;86         config->writeWaitPhase2 = 0x9U;
000008  2109              MOVS     r1,#9
00000a  7101              STRB     r1,[r0,#4]
;;;87         config->writeWaitPhase3 = 0x3U;
00000c  2103              MOVS     r1,#3
00000e  7141              STRB     r1,[r0,#5]
;;;88         config->readWaitPhase1 = 0xFU;
000010  210f              MOVS     r1,#0xf
000012  7041              STRB     r1,[r0,#1]
;;;89         config->readWaitPhase2 = 0x8U;
000014  2108              MOVS     r1,#8
000016  7081              STRB     r1,[r0,#2]
;;;90         config->lockTimingParam = false;
000018  2100              MOVS     r1,#0
00001a  7181              STRB     r1,[r0,#6]
;;;91     }
00001c  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.EEPROM_GetInstance||, CODE, READONLY, ALIGN=2

                  EEPROM_GetInstance PROC
;;;63      ******************************************************************************/
;;;64     static uint32_t EEPROM_GetInstance(EEPROM_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {
000002  4605              MOV      r5,r0
;;;66         uint32_t instance;
;;;67     
;;;68         /* Find the instance index from base address mappings. */
;;;69         for (instance = 0; instance < FSL_FEATURE_SOC_EEPROM_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L4.22|
                  |L4.8|
;;;70         {
;;;71             if (s_eepromBases[instance] == base)
000008  4809              LDR      r0,|L4.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L4.20|
;;;72             {
;;;73                 break;
000012  e002              B        |L4.26|
                  |L4.20|
000014  1c64              ADDS     r4,r4,#1              ;69
                  |L4.22|
000016  2c00              CMP      r4,#0                 ;69
000018  d0f6              BEQ      |L4.8|
                  |L4.26|
00001a  bf00              NOP      
;;;74             }
;;;75         }
;;;76     
;;;77         assert(instance < FSL_FEATURE_SOC_EEPROM_COUNT);
00001c  b904              CBNZ     r4,|L4.32|
00001e  e004              B        |L4.42|
                  |L4.32|
000020  224d              MOVS     r2,#0x4d
000022  a104              ADR      r1,|L4.52|
000024  a00a              ADR      r0,|L4.80|
000026  f7fffffe          BL       __aeabi_assert
                  |L4.42|
;;;78     
;;;79         return instance;
00002a  4620              MOV      r0,r4
;;;80     }
00002c  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      s_eepromBases
                  |L4.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_eeprom.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  65657072
000048  6f6d2e63
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L4.80|
000050  696e7374          DCB      "instance < FSL_FEATURE_SOC_EEPROM_COUNT",0
000054  616e6365
000058  203c2046
00005c  534c5f46
000060  45415455
000064  52455f53
000068  4f435f45
00006c  4550524f
000070  4d5f434f
000074  554e5400

                          AREA ||i.EEPROM_Init||, CODE, READONLY, ALIGN=2

                  EEPROM_Init PROC
;;;92     
;;;93     void EEPROM_Init(EEPROM_Type *base, const eeprom_config_t *config, uint32_t sourceClock_Hz)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;94     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;95         assert(config);
00000a  b104              CBZ      r4,|L5.14|
00000c  e004              B        |L5.24|
                  |L5.14|
00000e  225f              MOVS     r2,#0x5f
000010  a12f              ADR      r1,|L5.208|
000012  a036              ADR      r0,|L5.236|
000014  f7fffffe          BL       __aeabi_assert
                  |L5.24|
;;;96     
;;;97         uint32_t clockDiv = 0;
000018  f04f0800          MOV      r8,#0
;;;98     
;;;99     #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;100        /* Enable the SAI clock */
;;;101        CLOCK_EnableClock(s_eepromClock[EEPROM_GetInstance(base)]);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       EEPROM_GetInstance
000022  4934              LDR      r1,|L5.244|
000024  f8316010          LDRH     r6,[r1,r0,LSL #1]
000028  0a30              LSRS     r0,r6,#8
00002a  2803              CMP      r0,#3
00002c  d205              BCS      |L5.58|
00002e  2101              MOVS     r1,#1
000030  40b1              LSLS     r1,r1,r6
000032  4a31              LDR      r2,|L5.248|
000034  f8421020          STR      r1,[r2,r0,LSL #2]
000038  e005              B        |L5.70|
                  |L5.58|
00003a  2101              MOVS     r1,#1
00003c  078a              LSLS     r2,r1,#30
00003e  64d1              STR      r1,[r2,#0x4c]
000040  40b1              LSLS     r1,r1,r6
000042  4a2e              LDR      r2,|L5.252|
000044  6151              STR      r1,[r2,#0x14]
                  |L5.70|
000046  bf00              NOP      
;;;102    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;103    
;;;104        /* Set the clock divider */
;;;105        clockDiv = sourceClock_Hz / FSL_FEATURE_EEPROM_INTERNAL_FREQ;
000048  482d              LDR      r0,|L5.256|
00004a  fbb7f8f0          UDIV     r8,r7,r0
;;;106        if ((sourceClock_Hz % FSL_FEATURE_EEPROM_INTERNAL_FREQ) > (FSL_FEATURE_EEPROM_INTERNAL_FREQ / 2U))
00004e  fbb7f1f0          UDIV     r1,r7,r0
000052  fb007011          MLS      r0,r0,r1,r7
000056  492b              LDR      r1,|L5.260|
000058  4288              CMP      r0,r1
00005a  d901              BLS      |L5.96|
;;;107        {
;;;108            clockDiv += 1U;
00005c  f1080801          ADD      r8,r8,#1
                  |L5.96|
;;;109        }
;;;110        base->CLKDIV = clockDiv - 1U;
000060  f1a80001          SUB      r0,r8,#1
000064  6168              STR      r0,[r5,#0x14]
;;;111    
;;;112        /* Set the auto program feature */
;;;113        EEPROM_SetAutoProgram(base, config->autoProgram);
000066  7821              LDRB     r1,[r4,#0]
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       EEPROM_SetAutoProgram
;;;114    
;;;115        /* Set time delay parameter */
;;;116        base->RWSTATE =
00006e  7860              LDRB     r0,[r4,#1]
000070  1e40              SUBS     r0,r0,#1
000072  f44f417f          MOV      r1,#0xff00
000076  ea012000          AND      r0,r1,r0,LSL #8
00007a  78a1              LDRB     r1,[r4,#2]
00007c  1e49              SUBS     r1,r1,#1
00007e  b2c9              UXTB     r1,r1
000080  4308              ORRS     r0,r0,r1
000082  60a8              STR      r0,[r5,#8]
;;;117            EEPROM_RWSTATE_RPHASE1(config->readWaitPhase1 - 1U) | EEPROM_RWSTATE_RPHASE2(config->readWaitPhase2 - 1U);
;;;118        base->WSTATE = EEPROM_WSTATE_PHASE1(config->writeWaitPhase1 - 1U) |
000084  78e0              LDRB     r0,[r4,#3]
000086  1e40              SUBS     r0,r0,#1
000088  f44f017f          MOV      r1,#0xff0000
00008c  ea014000          AND      r0,r1,r0,LSL #16
000090  7921              LDRB     r1,[r4,#4]
000092  1e49              SUBS     r1,r1,#1
000094  f44f427f          MOV      r2,#0xff00
000098  ea022101          AND      r1,r2,r1,LSL #8
00009c  4308              ORRS     r0,r0,r1
00009e  7961              LDRB     r1,[r4,#5]
0000a0  1e49              SUBS     r1,r1,#1
0000a2  b2c9              UXTB     r1,r1
0000a4  4308              ORRS     r0,r0,r1
0000a6  6128              STR      r0,[r5,#0x10]
;;;119                       EEPROM_WSTATE_PHASE2(config->writeWaitPhase2 - 1U) |
;;;120                       EEPROM_WSTATE_PHASE3(config->writeWaitPhase3 - 1U);
;;;121        base->WSTATE |= EEPROM_WSTATE_LCK_PARWEP(config->lockTimingParam);
0000a8  6928              LDR      r0,[r5,#0x10]
0000aa  79a1              LDRB     r1,[r4,#6]
0000ac  05d2              LSLS     r2,r2,#23
0000ae  ea0271c1          AND      r1,r2,r1,LSL #31
0000b2  4308              ORRS     r0,r0,r1
0000b4  6128              STR      r0,[r5,#0x10]
;;;122     
;;;123        /* Clear the remaining write operation  */
;;;124        base->CMD = FSL_FEATURE_EEPROM_PROGRAM_CMD;
0000b6  2006              MOVS     r0,#6
0000b8  6028              STR      r0,[r5,#0]
;;;125        while ((EEPROM_GetInterruptStatus(base) & kEEPROM_ProgramFinishInterruptEnable) == 0U)
0000ba  bf00              NOP      
                  |L5.188|
0000bc  bf00              NOP      
0000be  f8d50fe0          LDR      r0,[r5,#0xfe0]
0000c2  f0000004          AND      r0,r0,#4
0000c6  2800              CMP      r0,#0
0000c8  d0f8              BEQ      |L5.188|
;;;126        {}
;;;127    }
0000ca  e8bd81f0          POP      {r4-r8,pc}
;;;128    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L5.208|
0000d0  5352435c          DCB      "SRC\\Drivers\\fsl_eeprom.c",0
0000d4  44726976
0000d8  6572735c
0000dc  66736c5f
0000e0  65657072
0000e4  6f6d2e63
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L5.236|
0000ec  636f6e66          DCB      "config",0
0000f0  696700  
0000f3  00                DCB      0
                  |L5.244|
                          DCD      s_eepromClock
                  |L5.248|
                          DCD      0x40000220
                  |L5.252|
                          DCD      0x40040000
                  |L5.256|
                          DCD      0x0016e360
                  |L5.260|
                          DCD      0x000b71b0

                          AREA ||i.EEPROM_SetAutoProgram||, CODE, READONLY, ALIGN=1

                  EEPROM_SetAutoProgram PROC
;;;132     */
;;;133    static inline void EEPROM_SetAutoProgram(EEPROM_Type *base, eeprom_auto_program_t autoProgram)
000000  60c1              STR      r1,[r0,#0xc]
;;;134    {
;;;135        base->AUTOPROG = autoProgram;
;;;136    }
000002  4770              BX       lr
;;;137    
                          ENDP


                          AREA ||i.EEPROM_WritePage||, CODE, READONLY, ALIGN=2

                  EEPROM_WritePage PROC
;;;170    
;;;171    status_t EEPROM_WritePage(EEPROM_Type *base, uint32_t pageNum, uint32_t *data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;172    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;173        uint32_t i = 0;
00000a  2600              MOVS     r6,#0
;;;174        uint32_t *addr = NULL;
00000c  46b0              MOV      r8,r6
;;;175    
;;;176        if ((pageNum > FSL_FEATURE_EEPROM_PAGE_COUNT) || (!data))
00000e  2d80              CMP      r5,#0x80
000010  d800              BHI      |L7.20|
000012  b917              CBNZ     r7,|L7.26|
                  |L7.20|
;;;177        {
;;;178            return kStatus_InvalidArgument;
000014  2004              MOVS     r0,#4
                  |L7.22|
;;;179        }
;;;180    
;;;181        /* Set auto program settings */
;;;182        if (base->AUTOPROG != kEEPROM_AutoProgramDisable)
;;;183        {
;;;184            EEPROM_SetAutoProgram(base, kEEPROM_AutoProgramLastWord);
;;;185        }
;;;186    
;;;187        EEPROM_ClearInterruptFlag(base, kEEPROM_ProgramFinishInterruptEnable);
;;;188    
;;;189        addr = (uint32_t *)(FSL_FEATURE_EEPROM_BASE_ADDRESS + pageNum * (FSL_FEATURE_EEPROM_SIZE/FSL_FEATURE_EEPROM_PAGE_COUNT));
;;;190        for (i = 0; i < (FSL_FEATURE_EEPROM_SIZE/FSL_FEATURE_EEPROM_PAGE_COUNT) / 4U; i++)
;;;191        {
;;;192            addr[i] = data[i];
;;;193        }
;;;194    
;;;195        if (base->AUTOPROG == kEEPROM_AutoProgramDisable)
;;;196        {
;;;197            base->CMD = FSL_FEATURE_EEPROM_PROGRAM_CMD;
;;;198        }
;;;199    
;;;200        /* Waiting for operation finished */
;;;201        while ((EEPROM_GetInterruptStatus(base) & kEEPROM_ProgramFinishInterruptEnable) == 0U)
;;;202        {}
;;;203    
;;;204        return kStatus_Success;
;;;205    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  68e0              LDR      r0,[r4,#0xc]          ;182
00001c  b118              CBZ      r0,|L7.38|
00001e  2102              MOVS     r1,#2                 ;184
000020  4620              MOV      r0,r4                 ;184
000022  f7fffffe          BL       EEPROM_SetAutoProgram
                  |L7.38|
000026  2104              MOVS     r1,#4                 ;187
000028  4620              MOV      r0,r4                 ;187
00002a  f7fffffe          BL       EEPROM_ClearInterruptFlag
00002e  480d              LDR      r0,|L7.100|
000030  eb0018c5          ADD      r8,r0,r5,LSL #7       ;189
000034  2600              MOVS     r6,#0                 ;190
000036  e004              B        |L7.66|
                  |L7.56|
000038  f8570026          LDR      r0,[r7,r6,LSL #2]     ;192
00003c  f8480026          STR      r0,[r8,r6,LSL #2]     ;192
000040  1c76              ADDS     r6,r6,#1              ;190
                  |L7.66|
000042  2e20              CMP      r6,#0x20              ;190
000044  d3f8              BCC      |L7.56|
000046  68e0              LDR      r0,[r4,#0xc]          ;195
000048  b908              CBNZ     r0,|L7.78|
00004a  2006              MOVS     r0,#6                 ;197
00004c  6020              STR      r0,[r4,#0]            ;197
                  |L7.78|
00004e  bf00              NOP                            ;201
                  |L7.80|
000050  bf00              NOP                            ;201
000052  f8d40fe0          LDR      r0,[r4,#0xfe0]        ;201
000056  f0000004          AND      r0,r0,#4              ;201
00005a  2800              CMP      r0,#0                 ;201
00005c  d0f8              BEQ      |L7.80|
00005e  2000              MOVS     r0,#0                 ;204
000060  e7d9              B        |L7.22|
                          ENDP

000062  0000              DCW      0x0000
                  |L7.100|
                          DCD      0x40108000

                          AREA ||i.EEPROM_WriteWord||, CODE, READONLY, ALIGN=2

                  EEPROM_WriteWord PROC
;;;136    
;;;137    status_t EEPROM_WriteWord(EEPROM_Type *base, uint32_t offset, uint32_t data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;138    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;139        uint32_t *addr = 0;
00000a  2700              MOVS     r7,#0
;;;140    
;;;141        if ((offset % 4U) || (offset > FSL_FEATURE_EEPROM_SIZE))
00000c  f0050003          AND      r0,r5,#3
000010  b910              CBNZ     r0,|L8.24|
000012  f5b54f80          CMP      r5,#0x4000
000016  d902              BLS      |L8.30|
                  |L8.24|
;;;142        {
;;;143            return kStatus_InvalidArgument;
000018  2004              MOVS     r0,#4
                  |L8.26|
;;;144        }
;;;145    
;;;146        /* Set auto program settings */
;;;147        if (base->AUTOPROG != kEEPROM_AutoProgramDisable)
;;;148        {
;;;149            EEPROM_SetAutoProgram(base, kEEPROM_AutoProgramWriteWord);
;;;150        }
;;;151    
;;;152        EEPROM_ClearInterruptFlag(base, kEEPROM_ProgramFinishInterruptEnable);
;;;153    
;;;154        /* Compute the page */
;;;155        addr = (uint32_t *)(FSL_FEATURE_EEPROM_BASE_ADDRESS + offset);
;;;156        *addr = data;
;;;157    
;;;158        /* Check if need to do program erase manually */
;;;159        if (base->AUTOPROG != kEEPROM_AutoProgramWriteWord)
;;;160        {
;;;161            base->CMD = FSL_FEATURE_EEPROM_PROGRAM_CMD;
;;;162        }
;;;163    
;;;164        /* Waiting for operation finished */
;;;165        while ((EEPROM_GetInterruptStatus(base) & kEEPROM_ProgramFinishInterruptEnable) == 0U)
;;;166        {}
;;;167    
;;;168        return kStatus_Success;
;;;169    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.30|
00001e  68e0              LDR      r0,[r4,#0xc]          ;147
000020  b118              CBZ      r0,|L8.42|
000022  2101              MOVS     r1,#1                 ;149
000024  4620              MOV      r0,r4                 ;149
000026  f7fffffe          BL       EEPROM_SetAutoProgram
                  |L8.42|
00002a  2104              MOVS     r1,#4                 ;152
00002c  4620              MOV      r0,r4                 ;152
00002e  f7fffffe          BL       EEPROM_ClearInterruptFlag
000032  4809              LDR      r0,|L8.88|
000034  182f              ADDS     r7,r5,r0              ;155
000036  603e              STR      r6,[r7,#0]            ;156
000038  68e0              LDR      r0,[r4,#0xc]          ;159
00003a  2801              CMP      r0,#1                 ;159
00003c  d001              BEQ      |L8.66|
00003e  2006              MOVS     r0,#6                 ;161
000040  6020              STR      r0,[r4,#0]            ;161
                  |L8.66|
000042  bf00              NOP                            ;165
                  |L8.68|
000044  bf00              NOP                            ;165
000046  f8d40fe0          LDR      r0,[r4,#0xfe0]        ;165
00004a  f0000004          AND      r0,r0,#4              ;165
00004e  2800              CMP      r0,#0                 ;165
000050  d0f8              BEQ      |L8.68|
000052  2000              MOVS     r0,#0                 ;168
000054  e7e1              B        |L8.26|
;;;170    
                          ENDP

000056  0000              DCW      0x0000
                  |L8.88|
                          DCD      0x40108000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_eepromBases
                          DCD      0x40014000
                  s_eepromClock
000004  0009              DCW      0x0009

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_eeprom.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_eeprom_c_5b9cdcb1____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_fsl_eeprom_c_5b9cdcb1____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_eeprom_c_5b9cdcb1____REVSH|
#line 402
|__asm___12_fsl_eeprom_c_5b9cdcb1____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_eeprom_c_5b9cdcb1____RRX|
#line 587
|__asm___12_fsl_eeprom_c_5b9cdcb1____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
