; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_pint.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_pint.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_pint.crf SRC\Drivers\fsl_pint.c]
                          THUMB

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;1671    */
;;;1672   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1673   {
;;;1674     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L1.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1675   }
000010  4770              BX       lr
;;;1676   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0xe000e280

                          AREA ||i.PINT_Deinit||, CODE, READONLY, ALIGN=2

                  PINT_Deinit PROC
;;;273    
;;;274    void PINT_Deinit(PINT_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  4605              MOV      r5,r0
;;;276        uint32_t i;
;;;277    
;;;278        assert(base);
000004  b105              CBZ      r5,|L2.8|
000006  e005              B        |L2.20|
                  |L2.8|
000008  f44f728b          MOV      r2,#0x116
00000c  a112              ADR      r1,|L2.88|
00000e  a018              ADR      r0,|L2.112|
000010  f7fffffe          BL       __aeabi_assert
                  |L2.20|
;;;279    
;;;280        /* Cleanup */
;;;281        PINT_DisableCallback(base);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       PINT_DisableCallback
;;;282        for (i = 0; i < FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS; i++)
00001a  2400              MOVS     r4,#0
00001c  e004              B        |L2.40|
                  |L2.30|
;;;283        {
;;;284            s_pintCallback[i] = NULL;
00001e  2000              MOVS     r0,#0
000020  4915              LDR      r1,|L2.120|
000022  f8410024          STR      r0,[r1,r4,LSL #2]
000026  1c64              ADDS     r4,r4,#1              ;282
                  |L2.40|
000028  2c08              CMP      r4,#8                 ;282
00002a  d3f8              BCC      |L2.30|
;;;285        }
;;;286    
;;;287        /* Reset the peripheral */
;;;288        RESET_PeripheralReset(kPINT_RST_SHIFT_RSTn);
00002c  2012              MOVS     r0,#0x12
00002e  f7fffffe          BL       RESET_PeripheralReset
;;;289    
;;;290        /* Disable the peripheral clock */
;;;291        CLOCK_DisableClock(kCLOCK_Pint);
000032  2012              MOVS     r0,#0x12
000034  0a01              LSRS     r1,r0,#8
000036  2903              CMP      r1,#3
000038  d205              BCS      |L2.70|
00003a  2201              MOVS     r2,#1
00003c  4082              LSLS     r2,r2,r0
00003e  4b0f              LDR      r3,|L2.124|
000040  f8432021          STR      r2,[r3,r1,LSL #2]
000044  e006              B        |L2.84|
                  |L2.70|
000046  2201              MOVS     r2,#1
000048  4082              LSLS     r2,r2,r0
00004a  4b0d              LDR      r3,|L2.128|
00004c  619a              STR      r2,[r3,#0x18]
00004e  2200              MOVS     r2,#0
000050  031b              LSLS     r3,r3,#12
000052  64da              STR      r2,[r3,#0x4c]
                  |L2.84|
000054  bf00              NOP      
;;;292    }
000056  bd70              POP      {r4-r6,pc}
;;;293    
                          ENDP

                  |L2.88|
000058  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
00005c  44726976
000060  6572735c
000064  66736c5f
000068  70696e74
00006c  2e6300  
00006f  00                DCB      0
                  |L2.112|
000070  62617365          DCB      "base",0
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L2.120|
                          DCD      s_pintCallback
                  |L2.124|
                          DCD      0x40000240
                  |L2.128|
                          DCD      0x40040000

                          AREA ||i.PINT_DisableCallback||, CODE, READONLY, ALIGN=2

                  PINT_DisableCallback PROC
;;;259    
;;;260    void PINT_DisableCallback(PINT_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  4605              MOV      r5,r0
;;;262        uint32_t i;
;;;263    
;;;264        assert(base);
000004  b105              CBZ      r5,|L3.8|
000006  e005              B        |L3.20|
                  |L3.8|
000008  f44f7284          MOV      r2,#0x108
00000c  a111              ADR      r1,|L3.84|
00000e  a017              ADR      r0,|L3.108|
000010  f7fffffe          BL       __aeabi_assert
                  |L3.20|
;;;265    
;;;266        for (i = 0; i < FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS; i++)
000014  2400              MOVS     r4,#0
000016  e01a              B        |L3.78|
                  |L3.24|
;;;267        {
;;;268            DisableIRQ(s_pintIRQ[i]);
000018  4916              LDR      r1,|L3.116|
00001a  5708              LDRSB    r0,[r1,r4]
00001c  f1100f80          CMN      r0,#0x80
000020  d100              BNE      |L3.36|
000022  e00a              B        |L3.58|
                  |L3.36|
000024  bf00              NOP      
000026  f000021f          AND      r2,r0,#0x1f
00002a  2101              MOVS     r1,#1
00002c  4091              LSLS     r1,r1,r2
00002e  4a12              LDR      r2,|L3.120|
000030  0943              LSRS     r3,r0,#5
000032  f8421023          STR      r1,[r2,r3,LSL #2]
000036  bf00              NOP      
000038  bf00              NOP      
                  |L3.58|
;;;269            PINT_PinInterruptClrStatus(base, (pint_pin_int_t)i);
00003a  b2e1              UXTB     r1,r4
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;270            NVIC_ClearPendingIRQ(s_pintIRQ[i]);
000042  490c              LDR      r1,|L3.116|
000044  5708              LDRSB    r0,[r1,r4]
000046  f7fffffe          BL       NVIC_ClearPendingIRQ
00004a  1c60              ADDS     r0,r4,#1              ;266
00004c  4604              MOV      r4,r0                 ;266
                  |L3.78|
00004e  2c08              CMP      r4,#8                 ;266
000050  d3e2              BCC      |L3.24|
;;;271        }
;;;272    }
000052  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

                  |L3.84|
000054  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
000058  44726976
00005c  6572735c
000060  66736c5f
000064  70696e74
000068  2e6300  
00006b  00                DCB      0
                  |L3.108|
00006c  62617365          DCB      "base",0
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L3.116|
                          DCD      s_pintIRQ
                  |L3.120|
                          DCD      0xe000e180

                          AREA ||i.PINT_EnableCallback||, CODE, READONLY, ALIGN=2

                  PINT_EnableCallback PROC
;;;244    
;;;245    void PINT_EnableCallback(PINT_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;246    {
000002  4605              MOV      r5,r0
;;;247        uint32_t i;
;;;248    
;;;249        assert(base);
000004  b105              CBZ      r5,|L4.8|
000006  e004              B        |L4.18|
                  |L4.8|
000008  22f9              MOVS     r2,#0xf9
00000a  a114              ADR      r1,|L4.92|
00000c  a019              ADR      r0,|L4.116|
00000e  f7fffffe          BL       __aeabi_assert
                  |L4.18|
;;;250    
;;;251        PINT_PinInterruptClrStatusAll(base);
000012  bf00              NOP      
000014  20ff              MOVS     r0,#0xff
000016  6268              STR      r0,[r5,#0x24]
000018  bf00              NOP      
;;;252        for (i = 0; i < FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS; i++)
00001a  2400              MOVS     r4,#0
00001c  e01b              B        |L4.86|
                  |L4.30|
;;;253        {
;;;254            NVIC_ClearPendingIRQ(s_pintIRQ[i]);
00001e  4917              LDR      r1,|L4.124|
000020  5708              LDRSB    r0,[r1,r4]
000022  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;255            PINT_PinInterruptClrStatus(base, (pint_pin_int_t)i);
000026  b2e1              UXTB     r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;256            EnableIRQ(s_pintIRQ[i]);
00002e  4913              LDR      r1,|L4.124|
000030  5708              LDRSB    r0,[r1,r4]
000032  f1100f80          CMN      r0,#0x80
000036  d100              BNE      |L4.58|
000038  e00c              B        |L4.84|
                  |L4.58|
00003a  bf00              NOP      
00003c  f000021f          AND      r2,r0,#0x1f
000040  2101              MOVS     r1,#1
000042  4091              LSLS     r1,r1,r2
000044  0942              LSRS     r2,r0,#5
000046  0092              LSLS     r2,r2,#2
000048  f10222e0          ADD      r2,r2,#0xe000e000
00004c  f8c21100          STR      r1,[r2,#0x100]
000050  bf00              NOP      
000052  bf00              NOP      
                  |L4.84|
000054  1c64              ADDS     r4,r4,#1              ;252
                  |L4.86|
000056  2c08              CMP      r4,#8                 ;252
000058  d3e1              BCC      |L4.30|
;;;257        }
;;;258    }
00005a  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP

                  |L4.92|
00005c  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
000060  44726976
000064  6572735c
000068  66736c5f
00006c  70696e74
000070  2e6300  
000073  00                DCB      0
                  |L4.116|
000074  62617365          DCB      "base",0
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L4.124|
                          DCD      s_pintIRQ

                          AREA ||i.PINT_Init||, CODE, READONLY, ALIGN=2

                  PINT_Init PROC
;;;46     
;;;47     void PINT_Init(PINT_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  4605              MOV      r5,r0
;;;49         uint32_t i;
;;;50         uint32_t pmcfg;
;;;51     
;;;52         assert(base);
000004  b105              CBZ      r5,|L5.8|
000006  e004              B        |L5.18|
                  |L5.8|
000008  2234              MOVS     r2,#0x34
00000a  a118              ADR      r1,|L5.108|
00000c  a01d              ADR      r0,|L5.132|
00000e  f7fffffe          BL       __aeabi_assert
                  |L5.18|
;;;53     
;;;54         pmcfg = 0;
000012  2600              MOVS     r6,#0
;;;55         for (i = 0; i < FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS; i++)
000014  2400              MOVS     r4,#0
000016  e004              B        |L5.34|
                  |L5.24|
;;;56         {
;;;57             s_pintCallback[i] = NULL;
000018  2000              MOVS     r0,#0
00001a  491c              LDR      r1,|L5.140|
00001c  f8410024          STR      r0,[r1,r4,LSL #2]
000020  1c64              ADDS     r4,r4,#1              ;55
                  |L5.34|
000022  2c08              CMP      r4,#8                 ;55
000024  d3f8              BCC      |L5.24|
;;;58         }
;;;59     
;;;60         /* Disable all bit slices */
;;;61         for (i = 0; i < PINT_PIN_INT_COUNT; i++)
000026  2400              MOVS     r4,#0
000028  e007              B        |L5.58|
                  |L5.42|
;;;62         {
;;;63             pmcfg = pmcfg | (kPINT_PatternMatchNever << (PININT_BITSLICE_CFG_START + (i * 3U)));
00002a  eb040044          ADD      r0,r4,r4,LSL #1
00002e  3008              ADDS     r0,r0,#8
000030  2106              MOVS     r1,#6
000032  fa01f000          LSL      r0,r1,r0
000036  4306              ORRS     r6,r6,r0
000038  1c64              ADDS     r4,r4,#1              ;61
                  |L5.58|
00003a  2c08              CMP      r4,#8                 ;61
00003c  d3f5              BCC      |L5.42|
;;;64         }
;;;65     
;;;66         /* Enable the peripheral clock */
;;;67         CLOCK_EnableClock(kCLOCK_Pint);
00003e  2012              MOVS     r0,#0x12
000040  0a01              LSRS     r1,r0,#8
000042  2903              CMP      r1,#3
000044  d205              BCS      |L5.82|
000046  2201              MOVS     r2,#1
000048  4082              LSLS     r2,r2,r0
00004a  4b11              LDR      r3,|L5.144|
00004c  f8432021          STR      r2,[r3,r1,LSL #2]
000050  e005              B        |L5.94|
                  |L5.82|
000052  2201              MOVS     r2,#1
000054  0793              LSLS     r3,r2,#30
000056  64da              STR      r2,[r3,#0x4c]
000058  4082              LSLS     r2,r2,r0
00005a  4b0e              LDR      r3,|L5.148|
00005c  615a              STR      r2,[r3,#0x14]
                  |L5.94|
00005e  bf00              NOP      
;;;68     
;;;69         /* Reset the peripheral */
;;;70         RESET_PeripheralReset(kPINT_RST_SHIFT_RSTn);
000060  2012              MOVS     r0,#0x12
000062  f7fffffe          BL       RESET_PeripheralReset
;;;71     
;;;72         /* Disable all pattern match bit slices */
;;;73         base->PMCFG = pmcfg;
000066  632e              STR      r6,[r5,#0x30]
;;;74     }
000068  bd70              POP      {r4-r6,pc}
;;;75     
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
00006c  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
000070  44726976
000074  6572735c
000078  66736c5f
00007c  70696e74
000080  2e6300  
000083  00                DCB      0
                  |L5.132|
000084  62617365          DCB      "base",0
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L5.140|
                          DCD      s_pintCallback
                  |L5.144|
                          DCD      0x40000220
                  |L5.148|
                          DCD      0x40040000

                          AREA ||i.PINT_PatternMatchConfig||, CODE, READONLY, ALIGN=2

                  PINT_PatternMatchConfig PROC
;;;166    
;;;167    void PINT_PatternMatchConfig(PINT_Type *base, pint_pmatch_bslice_t bslice, pint_pmatch_cfg_t *cfg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;168    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;169        uint32_t src_shift;
;;;170        uint32_t cfg_shift;
;;;171        uint32_t pmcfg;
;;;172    
;;;173        assert(base);
00000a  b105              CBZ      r5,|L6.14|
00000c  e004              B        |L6.24|
                  |L6.14|
00000e  22ad              MOVS     r2,#0xad
000010  a119              ADR      r1,|L6.120|
000012  a01f              ADR      r0,|L6.144|
000014  f7fffffe          BL       __aeabi_assert
                  |L6.24|
;;;174    
;;;175        src_shift = PININT_BITSLICE_SRC_START + (bslice * 3U);
000018  eb040044          ADD      r0,r4,r4,LSL #1
00001c  f1000808          ADD      r8,r0,#8
;;;176        cfg_shift = PININT_BITSLICE_CFG_START + (bslice * 3U);
000020  eb040044          ADD      r0,r4,r4,LSL #1
000024  f1000908          ADD      r9,r0,#8
;;;177    
;;;178        /* Input source selection for selected bit slice */
;;;179        base->PMSRC = (base->PMSRC & ~(PININT_BITSLICE_SRC_MASK << src_shift)) | (cfg->bs_src << src_shift);
000028  6ae8              LDR      r0,[r5,#0x2c]
00002a  2107              MOVS     r1,#7
00002c  fa01f108          LSL      r1,r1,r8
000030  4388              BICS     r0,r0,r1
000032  7831              LDRB     r1,[r6,#0]
000034  fa01f108          LSL      r1,r1,r8
000038  4308              ORRS     r0,r0,r1
00003a  62e8              STR      r0,[r5,#0x2c]
;;;180    
;;;181        /* Bit slice configuration */
;;;182        pmcfg = base->PMCFG;
00003c  6b2f              LDR      r7,[r5,#0x30]
;;;183        pmcfg = (pmcfg & ~(PININT_BITSLICE_CFG_MASK << cfg_shift)) | (cfg->bs_cfg << cfg_shift);
00003e  2007              MOVS     r0,#7
000040  fa00f109          LSL      r1,r0,r9
000044  ea270001          BIC      r0,r7,r1
000048  7871              LDRB     r1,[r6,#1]
00004a  fa01f109          LSL      r1,r1,r9
00004e  ea400701          ORR      r7,r0,r1
;;;184    
;;;185        /* If end point is true, enable the bits */
;;;186        if (bslice != 7U)
000052  2c07              CMP      r4,#7
000054  d008              BEQ      |L6.104|
;;;187        {
;;;188            if (cfg->end_point)
000056  78b0              LDRB     r0,[r6,#2]
000058  b118              CBZ      r0,|L6.98|
;;;189            {
;;;190                pmcfg |= (0x1U << bslice);
00005a  2001              MOVS     r0,#1
00005c  40a0              LSLS     r0,r0,r4
00005e  4307              ORRS     r7,r7,r0
000060  e002              B        |L6.104|
                  |L6.98|
;;;191            }
;;;192            else
;;;193            {
;;;194                pmcfg &= ~(0x1U << bslice);
000062  2001              MOVS     r0,#1
000064  40a0              LSLS     r0,r0,r4
000066  4387              BICS     r7,r7,r0
                  |L6.104|
;;;195            }
;;;196        }
;;;197    
;;;198        base->PMCFG = pmcfg;
000068  632f              STR      r7,[r5,#0x30]
;;;199    
;;;200        /* Save callback pointer */
;;;201        s_pintCallback[bslice] = cfg->callback;
00006a  490b              LDR      r1,|L6.152|
00006c  6870              LDR      r0,[r6,#4]
00006e  f8410024          STR      r0,[r1,r4,LSL #2]
;;;202    }
000072  e8bd87f0          POP      {r4-r10,pc}
;;;203    
                          ENDP

000076  0000              DCW      0x0000
                  |L6.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  70696e74
00008c  2e6300  
00008f  00                DCB      0
                  |L6.144|
000090  62617365          DCB      "base",0
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L6.152|
                          DCD      s_pintCallback

                          AREA ||i.PINT_PatternMatchGetConfig||, CODE, READONLY, ALIGN=2

                  PINT_PatternMatchGetConfig PROC
;;;203    
;;;204    void PINT_PatternMatchGetConfig(PINT_Type *base, pint_pmatch_bslice_t bslice, pint_pmatch_cfg_t *cfg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;205    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;206        uint32_t src_shift;
;;;207        uint32_t cfg_shift;
;;;208    
;;;209        assert(base);
00000a  b106              CBZ      r6,|L7.14|
00000c  e004              B        |L7.24|
                  |L7.14|
00000e  22d1              MOVS     r2,#0xd1
000010  a117              ADR      r1,|L7.112|
000012  a01d              ADR      r0,|L7.136|
000014  f7fffffe          BL       __aeabi_assert
                  |L7.24|
;;;210    
;;;211        src_shift = PININT_BITSLICE_SRC_START + (bslice * 3U);
000018  eb040044          ADD      r0,r4,r4,LSL #1
00001c  f1000808          ADD      r8,r0,#8
;;;212        cfg_shift = PININT_BITSLICE_CFG_START + (bslice * 3U);
000020  eb040044          ADD      r0,r4,r4,LSL #1
000024  f1000708          ADD      r7,r0,#8
;;;213    
;;;214        cfg->bs_src = (pint_pmatch_input_src_t)((base->PMSRC & (PININT_BITSLICE_SRC_MASK << src_shift)) >> src_shift);
000028  6af0              LDR      r0,[r6,#0x2c]
00002a  2107              MOVS     r1,#7
00002c  fa01f108          LSL      r1,r1,r8
000030  4008              ANDS     r0,r0,r1
000032  fa20f008          LSR      r0,r0,r8
000036  7028              STRB     r0,[r5,#0]
;;;215        cfg->bs_cfg = (pint_pmatch_bslice_cfg_t)((base->PMCFG & (PININT_BITSLICE_CFG_MASK << cfg_shift)) >> cfg_shift);
000038  6b30              LDR      r0,[r6,#0x30]
00003a  2107              MOVS     r1,#7
00003c  40b9              LSLS     r1,r1,r7
00003e  4008              ANDS     r0,r0,r1
000040  40f8              LSRS     r0,r0,r7
000042  7068              STRB     r0,[r5,#1]
;;;216    
;;;217        if (bslice == 7U)
000044  2c07              CMP      r4,#7
000046  d102              BNE      |L7.78|
;;;218        {
;;;219            cfg->end_point = true;
000048  2001              MOVS     r0,#1
00004a  70a8              STRB     r0,[r5,#2]
00004c  e009              B        |L7.98|
                  |L7.78|
;;;220        }
;;;221        else
;;;222        {
;;;223            cfg->end_point = (base->PMCFG & (0x1U << bslice)) >> bslice;
00004e  6b30              LDR      r0,[r6,#0x30]
000050  2101              MOVS     r1,#1
000052  40a1              LSLS     r1,r1,r4
000054  4008              ANDS     r0,r0,r1
000056  40e0              LSRS     r0,r0,r4
000058  b108              CBZ      r0,|L7.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L7.96|
                  |L7.94|
00005e  2000              MOVS     r0,#0
                  |L7.96|
000060  70a8              STRB     r0,[r5,#2]
                  |L7.98|
;;;224        }
;;;225        cfg->callback = s_pintCallback[bslice];
000062  480b              LDR      r0,|L7.144|
000064  f8500024          LDR      r0,[r0,r4,LSL #2]
000068  6068              STR      r0,[r5,#4]
;;;226    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;227    
                          ENDP

00006e  0000              DCW      0x0000
                  |L7.112|
000070  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
000074  44726976
000078  6572735c
00007c  66736c5f
000080  70696e74
000084  2e6300  
000087  00                DCB      0
                  |L7.136|
000088  62617365          DCB      "base",0
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L7.144|
                          DCD      s_pintCallback

                          AREA ||i.PINT_PatternMatchResetDetectLogic||, CODE, READONLY, ALIGN=1

                  PINT_PatternMatchResetDetectLogic PROC
;;;227    
;;;228    uint32_t PINT_PatternMatchResetDetectLogic(PINT_Type *base)
000000  b510              PUSH     {r4,lr}
;;;229    {
000002  4601              MOV      r1,r0
;;;230        uint32_t pmctrl;
;;;231        uint32_t pmstatus;
;;;232        uint32_t pmsrc;
;;;233    
;;;234        pmctrl = PINT->PMCTRL;
000004  f04f2440          MOV      r4,#0x40004000
000008  6aa3              LDR      r3,[r4,#0x28]
;;;235        pmstatus = pmctrl >> PINT_PMCTRL_PMAT_SHIFT;
00000a  0e18              LSRS     r0,r3,#24
;;;236        if (pmstatus)
00000c  b108              CBZ      r0,|L8.18|
;;;237        {
;;;238            /* Reset Pattern match engine detection logic */
;;;239            pmsrc = base->PMSRC;
00000e  6aca              LDR      r2,[r1,#0x2c]
;;;240            base->PMSRC = pmsrc;
000010  62ca              STR      r2,[r1,#0x2c]
                  |L8.18|
;;;241        }
;;;242        return (pmstatus);
;;;243    }
000012  bd10              POP      {r4,pc}
;;;244    
                          ENDP


                          AREA ||i.PINT_PinInterruptClrStatus||, CODE, READONLY, ALIGN=1

                  PINT_PinInterruptClrStatus PROC
;;;235     */
;;;236    static inline void PINT_PinInterruptClrStatus(PINT_Type *base, pint_pin_int_t pintr)
000000  2201              MOVS     r2,#1
;;;237    {
;;;238        base->IST = (1U << pintr);
000002  408a              LSLS     r2,r2,r1
000004  6242              STR      r2,[r0,#0x24]
;;;239    }
000006  4770              BX       lr
;;;240    
                          ENDP


                          AREA ||i.PINT_PinInterruptConfig||, CODE, READONLY, ALIGN=2

                  PINT_PinInterruptConfig PROC
;;;75     
;;;76     void PINT_PinInterruptConfig(PINT_Type *base, pint_pin_int_t intr, pint_pin_enable_t enable, pint_cb_t callback)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;77     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;78         assert(base);
00000c  b105              CBZ      r5,|L10.16|
00000e  e004              B        |L10.26|
                  |L10.16|
000010  224e              MOVS     r2,#0x4e
000012  a11a              ADR      r1,|L10.124|
000014  a01f              ADR      r0,|L10.148|
000016  f7fffffe          BL       __aeabi_assert
                  |L10.26|
;;;79     
;;;80         /* Clear Rise and Fall flags first */
;;;81         PINT_PinInterruptClrRiseFlag(base, intr);
00001a  bf00              NOP      
00001c  2001              MOVS     r0,#1
00001e  40a0              LSLS     r0,r0,r4
000020  61e8              STR      r0,[r5,#0x1c]
000022  bf00              NOP      
;;;82         PINT_PinInterruptClrFallFlag(base, intr);
000024  bf00              NOP      
000026  2001              MOVS     r0,#1
000028  40a0              LSLS     r0,r0,r4
00002a  6228              STR      r0,[r5,#0x20]
00002c  bf00              NOP      
;;;83     
;;;84         /* select level or edge sensitive */
;;;85         base->ISEL = (base->ISEL & ~(1U << intr)) | ((enable & PINT_PIN_INT_LEVEL) ? (1U << intr) : 0U);
00002e  6828              LDR      r0,[r5,#0]
000030  2101              MOVS     r1,#1
000032  40a1              LSLS     r1,r1,r4
000034  4388              BICS     r0,r0,r1
000036  f0060110          AND      r1,r6,#0x10
00003a  b111              CBZ      r1,|L10.66|
00003c  2101              MOVS     r1,#1
00003e  40a1              LSLS     r1,r1,r4
000040  e000              B        |L10.68|
                  |L10.66|
000042  2100              MOVS     r1,#0
                  |L10.68|
000044  4308              ORRS     r0,r0,r1
000046  6028              STR      r0,[r5,#0]
;;;86     
;;;87         /* enable rising or level interrupt */
;;;88         if (enable & (PINT_PIN_INT_LEVEL | PINT_PIN_INT_RISE))
000048  f0060011          AND      r0,r6,#0x11
00004c  b118              CBZ      r0,|L10.86|
;;;89         {
;;;90             base->SIENR = 1U << intr;
00004e  2001              MOVS     r0,#1
000050  40a0              LSLS     r0,r0,r4
000052  60a8              STR      r0,[r5,#8]
000054  e002              B        |L10.92|
                  |L10.86|
;;;91         }
;;;92         else
;;;93         {
;;;94             base->CIENR = 1U << intr;
000056  2001              MOVS     r0,#1
000058  40a0              LSLS     r0,r0,r4
00005a  60e8              STR      r0,[r5,#0xc]
                  |L10.92|
;;;95         }
;;;96     
;;;97         /* Enable falling or select high level */
;;;98         if (enable & PINT_PIN_INT_FALL_OR_HIGH_LEVEL)
00005c  f0060002          AND      r0,r6,#2
000060  b118              CBZ      r0,|L10.106|
;;;99         {
;;;100            base->SIENF = 1U << intr;
000062  2001              MOVS     r0,#1
000064  40a0              LSLS     r0,r0,r4
000066  6168              STR      r0,[r5,#0x14]
000068  e002              B        |L10.112|
                  |L10.106|
;;;101        }
;;;102        else
;;;103        {
;;;104            base->CIENF = 1U << intr;
00006a  2001              MOVS     r0,#1
00006c  40a0              LSLS     r0,r0,r4
00006e  61a8              STR      r0,[r5,#0x18]
                  |L10.112|
;;;105        }
;;;106    
;;;107        s_pintCallback[intr] = callback;
000070  480a              LDR      r0,|L10.156|
000072  f8407024          STR      r7,[r0,r4,LSL #2]
;;;108    }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;109    
                          ENDP

00007a  0000              DCW      0x0000
                  |L10.124|
00007c  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
000080  44726976
000084  6572735c
000088  66736c5f
00008c  70696e74
000090  2e6300  
000093  00                DCB      0
                  |L10.148|
000094  62617365          DCB      "base",0
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L10.156|
                          DCD      s_pintCallback

                          AREA ||i.PINT_PinInterruptGetConfig||, CODE, READONLY, ALIGN=2

                  PINT_PinInterruptGetConfig PROC
;;;109    
;;;110    void PINT_PinInterruptGetConfig(PINT_Type *base, pint_pin_int_t pintr, pint_pin_enable_t *enable, pint_cb_t *callback)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;111    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4699              MOV      r9,r3
;;;112        uint32_t mask;
;;;113        bool level;
;;;114    
;;;115        assert(base);
00000c  b105              CBZ      r5,|L11.16|
00000e  e004              B        |L11.26|
                  |L11.16|
000010  2273              MOVS     r2,#0x73
000012  a119              ADR      r1,|L11.120|
000014  a01e              ADR      r0,|L11.144|
000016  f7fffffe          BL       __aeabi_assert
                  |L11.26|
;;;116    
;;;117        *enable = kPINT_PinIntEnableNone;
00001a  2000              MOVS     r0,#0
00001c  7020              STRB     r0,[r4,#0]
;;;118        level = false;
00001e  4680              MOV      r8,r0
;;;119    
;;;120        mask = 1U << pintr;
000020  2001              MOVS     r0,#1
000022  fa00f607          LSL      r6,r0,r7
;;;121        if (base->ISEL & mask)
000026  6828              LDR      r0,[r5,#0]
000028  4030              ANDS     r0,r0,r6
00002a  b108              CBZ      r0,|L11.48|
;;;122        {
;;;123            /* Pin interrupt is level sensitive */
;;;124            level = true;
00002c  f04f0801          MOV      r8,#1
                  |L11.48|
;;;125        }
;;;126    
;;;127        if (base->IENR & mask)
000030  6868              LDR      r0,[r5,#4]
000032  4030              ANDS     r0,r0,r6
000034  b138              CBZ      r0,|L11.70|
;;;128        {
;;;129            if (level)
000036  f1b80f00          CMP      r8,#0
00003a  d002              BEQ      |L11.66|
;;;130            {
;;;131                /* Level interrupt is enabled */
;;;132                *enable = kPINT_PinIntEnableLowLevel;
00003c  2010              MOVS     r0,#0x10
00003e  7020              STRB     r0,[r4,#0]
000040  e001              B        |L11.70|
                  |L11.66|
;;;133            }
;;;134            else
;;;135            {
;;;136                /* Rising edge interrupt */
;;;137                *enable = kPINT_PinIntEnableRiseEdge;
000042  2001              MOVS     r0,#1
000044  7020              STRB     r0,[r4,#0]
                  |L11.70|
;;;138            }
;;;139        }
;;;140    
;;;141        if (base->IENF & mask)
000046  6928              LDR      r0,[r5,#0x10]
000048  4030              ANDS     r0,r0,r6
00004a  b168              CBZ      r0,|L11.104|
;;;142        {
;;;143            if (level)
00004c  f1b80f00          CMP      r8,#0
000050  d002              BEQ      |L11.88|
;;;144            {
;;;145                /* Level interrupt is active high */
;;;146                *enable = kPINT_PinIntEnableHighLevel;
000052  2012              MOVS     r0,#0x12
000054  7020              STRB     r0,[r4,#0]
000056  e007              B        |L11.104|
                  |L11.88|
;;;147            }
;;;148            else
;;;149            {
;;;150                /* Either falling or both edge */
;;;151                if (*enable == kPINT_PinIntEnableRiseEdge)
000058  7820              LDRB     r0,[r4,#0]
00005a  2801              CMP      r0,#1
00005c  d102              BNE      |L11.100|
;;;152                {
;;;153                    /* Rising and faling edge */
;;;154                    *enable = kPINT_PinIntEnableBothEdges;
00005e  2003              MOVS     r0,#3
000060  7020              STRB     r0,[r4,#0]
000062  e001              B        |L11.104|
                  |L11.100|
;;;155                }
;;;156                else
;;;157                {
;;;158                    /* Falling edge */
;;;159                    *enable = kPINT_PinIntEnableFallEdge;
000064  2002              MOVS     r0,#2
000066  7020              STRB     r0,[r4,#0]
                  |L11.104|
;;;160                }
;;;161            }
;;;162        }
;;;163    
;;;164        *callback = s_pintCallback[pintr];
000068  480b              LDR      r0,|L11.152|
00006a  f8500027          LDR      r0,[r0,r7,LSL #2]
00006e  f8c90000          STR      r0,[r9,#0]
;;;165    }
000072  e8bd87f0          POP      {r4-r10,pc}
;;;166    
                          ENDP

000076  0000              DCW      0x0000
                  |L11.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_pint.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  70696e74
00008c  2e6300  
00008f  00                DCB      0
                  |L11.144|
000090  62617365          DCB      "base",0
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L11.152|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT0_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT0_DriverIRQHandler PROC
;;;294    /* IRQ handler functions overloading weak symbols in the startup */
;;;295    void PIN_INT0_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297        uint32_t pmstatus;
;;;298    
;;;299        /* Reset pattern match detection */
;;;300        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;301        /* Clear Pin interrupt before callback */
;;;302        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt0);
00000c  2100              MOVS     r1,#0
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;303        /* Call user function */
;;;304        if (s_pintCallback[kPINT_PinInt0] != NULL)
000016  4804              LDR      r0,|L12.40|
000018  6800              LDR      r0,[r0,#0]  ; s_pintCallback
00001a  b120              CBZ      r0,|L12.38|
;;;305        {
;;;306            s_pintCallback[kPINT_PinInt0](kPINT_PinInt0, pmstatus);
00001c  4802              LDR      r0,|L12.40|
00001e  4621              MOV      r1,r4
000020  6802              LDR      r2,[r0,#0]  ; s_pintCallback
000022  2000              MOVS     r0,#0
000024  4790              BLX      r2
                  |L12.38|
;;;307        }
;;;308    }
000026  bd10              POP      {r4,pc}
;;;309    
                          ENDP

                  |L12.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT1_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT1_DriverIRQHandler PROC
;;;310    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 1U)
;;;311    void PIN_INT1_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;312    {
;;;313        uint32_t pmstatus;
;;;314    
;;;315        /* Reset pattern match detection */
;;;316        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;317        /* Clear Pin interrupt before callback */
;;;318        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt1);
00000c  2101              MOVS     r1,#1
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;319        /* Call user function */
;;;320        if (s_pintCallback[kPINT_PinInt1] != NULL)
000016  4804              LDR      r0,|L13.40|
000018  6840              LDR      r0,[r0,#4]  ; s_pintCallback
00001a  b120              CBZ      r0,|L13.38|
;;;321        {
;;;322            s_pintCallback[kPINT_PinInt1](kPINT_PinInt1, pmstatus);
00001c  4802              LDR      r0,|L13.40|
00001e  4621              MOV      r1,r4
000020  6842              LDR      r2,[r0,#4]  ; s_pintCallback
000022  2001              MOVS     r0,#1
000024  4790              BLX      r2
                  |L13.38|
;;;323        }
;;;324    }
000026  bd10              POP      {r4,pc}
;;;325    #endif
                          ENDP

                  |L13.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT2_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT2_DriverIRQHandler PROC
;;;327    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 2U)
;;;328    void PIN_INT2_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;329    {
;;;330        uint32_t pmstatus;
;;;331    
;;;332        /* Reset pattern match detection */
;;;333        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;334        /* Clear Pin interrupt before callback */
;;;335        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt2);
00000c  2102              MOVS     r1,#2
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;336        /* Call user function */
;;;337        if (s_pintCallback[kPINT_PinInt2] != NULL)
000016  4804              LDR      r0,|L14.40|
000018  6880              LDR      r0,[r0,#8]  ; s_pintCallback
00001a  b120              CBZ      r0,|L14.38|
;;;338        {
;;;339            s_pintCallback[kPINT_PinInt2](kPINT_PinInt2, pmstatus);
00001c  4802              LDR      r0,|L14.40|
00001e  4621              MOV      r1,r4
000020  6882              LDR      r2,[r0,#8]  ; s_pintCallback
000022  2002              MOVS     r0,#2
000024  4790              BLX      r2
                  |L14.38|
;;;340        }
;;;341    }
000026  bd10              POP      {r4,pc}
;;;342    #endif
                          ENDP

                  |L14.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT3_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT3_DriverIRQHandler PROC
;;;344    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 3U)
;;;345    void PIN_INT3_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;346    {
;;;347        uint32_t pmstatus;
;;;348    
;;;349        /* Reset pattern match detection */
;;;350        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;351        /* Clear Pin interrupt before callback */
;;;352        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt3);
00000c  2103              MOVS     r1,#3
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;353        /* Call user function */
;;;354        if (s_pintCallback[kPINT_PinInt3] != NULL)
000016  4804              LDR      r0,|L15.40|
000018  68c0              LDR      r0,[r0,#0xc]  ; s_pintCallback
00001a  b120              CBZ      r0,|L15.38|
;;;355        {
;;;356            s_pintCallback[kPINT_PinInt3](kPINT_PinInt3, pmstatus);
00001c  4802              LDR      r0,|L15.40|
00001e  4621              MOV      r1,r4
000020  68c2              LDR      r2,[r0,#0xc]  ; s_pintCallback
000022  2003              MOVS     r0,#3
000024  4790              BLX      r2
                  |L15.38|
;;;357        }
;;;358    }
000026  bd10              POP      {r4,pc}
;;;359    #endif
                          ENDP

                  |L15.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT4_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT4_DriverIRQHandler PROC
;;;361    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 4U)
;;;362    void PIN_INT4_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;363    {
;;;364        uint32_t pmstatus;
;;;365    
;;;366        /* Reset pattern match detection */
;;;367        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;368        /* Clear Pin interrupt before callback */
;;;369        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt4);
00000c  2104              MOVS     r1,#4
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;370        /* Call user function */
;;;371        if (s_pintCallback[kPINT_PinInt4] != NULL)
000016  4804              LDR      r0,|L16.40|
000018  6900              LDR      r0,[r0,#0x10]  ; s_pintCallback
00001a  b120              CBZ      r0,|L16.38|
;;;372        {
;;;373            s_pintCallback[kPINT_PinInt4](kPINT_PinInt4, pmstatus);
00001c  4802              LDR      r0,|L16.40|
00001e  4621              MOV      r1,r4
000020  6902              LDR      r2,[r0,#0x10]  ; s_pintCallback
000022  2004              MOVS     r0,#4
000024  4790              BLX      r2
                  |L16.38|
;;;374        }
;;;375    }
000026  bd10              POP      {r4,pc}
;;;376    #endif
                          ENDP

                  |L16.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT5_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT5_DriverIRQHandler PROC
;;;378    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 5U)
;;;379    void PIN_INT5_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;380    {
;;;381        uint32_t pmstatus;
;;;382    
;;;383        /* Reset pattern match detection */
;;;384        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;385        /* Clear Pin interrupt before callback */
;;;386        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt5);
00000c  2105              MOVS     r1,#5
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;387        /* Call user function */
;;;388        if (s_pintCallback[kPINT_PinInt5] != NULL)
000016  4804              LDR      r0,|L17.40|
000018  6940              LDR      r0,[r0,#0x14]  ; s_pintCallback
00001a  b120              CBZ      r0,|L17.38|
;;;389        {
;;;390            s_pintCallback[kPINT_PinInt5](kPINT_PinInt5, pmstatus);
00001c  4802              LDR      r0,|L17.40|
00001e  4621              MOV      r1,r4
000020  6942              LDR      r2,[r0,#0x14]  ; s_pintCallback
000022  2005              MOVS     r0,#5
000024  4790              BLX      r2
                  |L17.38|
;;;391        }
;;;392    }
000026  bd10              POP      {r4,pc}
;;;393    #endif
                          ENDP

                  |L17.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT6_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT6_DriverIRQHandler PROC
;;;395    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 6U)
;;;396    void PIN_INT6_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;397    {
;;;398        uint32_t pmstatus;
;;;399    
;;;400        /* Reset pattern match detection */
;;;401        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;402        /* Clear Pin interrupt before callback */
;;;403        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt6);
00000c  2106              MOVS     r1,#6
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;404        /* Call user function */
;;;405        if (s_pintCallback[kPINT_PinInt6] != NULL)
000016  4804              LDR      r0,|L18.40|
000018  6980              LDR      r0,[r0,#0x18]  ; s_pintCallback
00001a  b120              CBZ      r0,|L18.38|
;;;406        {
;;;407            s_pintCallback[kPINT_PinInt6](kPINT_PinInt6, pmstatus);
00001c  4802              LDR      r0,|L18.40|
00001e  4621              MOV      r1,r4
000020  6982              LDR      r2,[r0,#0x18]  ; s_pintCallback
000022  2006              MOVS     r0,#6
000024  4790              BLX      r2
                  |L18.38|
;;;408        }
;;;409    }
000026  bd10              POP      {r4,pc}
;;;410    #endif
                          ENDP

                  |L18.40|
                          DCD      s_pintCallback

                          AREA ||i.PIN_INT7_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  PIN_INT7_DriverIRQHandler PROC
;;;412    #if (FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS > 7U)
;;;413    void PIN_INT7_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;414    {
;;;415        uint32_t pmstatus;
;;;416    
;;;417        /* Reset pattern match detection */
;;;418        pmstatus = PINT_PatternMatchResetDetectLogic(PINT);
000002  f04f2040          MOV      r0,#0x40004000
000006  f7fffffe          BL       PINT_PatternMatchResetDetectLogic
00000a  4604              MOV      r4,r0
;;;419        /* Clear Pin interrupt before callback */
;;;420        PINT_PinInterruptClrStatus(PINT, kPINT_PinInt7);
00000c  2107              MOVS     r1,#7
00000e  f04f2040          MOV      r0,#0x40004000
000012  f7fffffe          BL       PINT_PinInterruptClrStatus
;;;421        /* Call user function */
;;;422        if (s_pintCallback[kPINT_PinInt7] != NULL)
000016  4804              LDR      r0,|L19.40|
000018  69c0              LDR      r0,[r0,#0x1c]  ; s_pintCallback
00001a  b120              CBZ      r0,|L19.38|
;;;423        {
;;;424            s_pintCallback[kPINT_PinInt7](kPINT_PinInt7, pmstatus);
00001c  4802              LDR      r0,|L19.40|
00001e  4621              MOV      r1,r4
000020  69c2              LDR      r2,[r0,#0x1c]  ; s_pintCallback
000022  2007              MOVS     r0,#7
000024  4790              BLX      r2
                  |L19.38|
;;;425        }
;;;426    }
000026  bd10              POP      {r4,pc}
;;;427    #endif
                          ENDP

                  |L19.40|
                          DCD      s_pintCallback

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_pintCallback
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_pintIRQ
000000  04050607          DCB      0x04,0x05,0x06,0x07
000004  20212223          DCB      0x20,0x21,0x22,0x23

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_pint.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_pint_c_dce30497____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fsl_pint_c_dce30497____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_pint_c_dce30497____REVSH|
#line 402
|__asm___10_fsl_pint_c_dce30497____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_pint_c_dce30497____RRX|
#line 587
|__asm___10_fsl_pint_c_dce30497____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
