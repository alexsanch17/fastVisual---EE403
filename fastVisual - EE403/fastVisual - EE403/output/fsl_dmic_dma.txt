; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_dmic_dma.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_dmic_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_dmic_dma.crf SRC\Drivers\fsl_dmic_dma.c]
                          THUMB

                          AREA ||i.DMIC_TransferAbortReceiveDMA||, CODE, READONLY, ALIGN=2

                  DMIC_TransferAbortReceiveDMA PROC
;;;172    
;;;173    void DMIC_TransferAbortReceiveDMA(DMIC_Type *base, dmic_dma_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;174    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;175        assert(NULL != handle);
000006  b104              CBZ      r4,|L1.10|
000008  e004              B        |L1.20|
                  |L1.10|
00000a  22af              MOVS     r2,#0xaf
00000c  a108              ADR      r1,|L1.48|
00000e  a00f              ADR      r0,|L1.76|
000010  f7fffffe          BL       __aeabi_assert
                  |L1.20|
;;;176        assert(NULL != handle->rxDmaHandle);
000014  6860              LDR      r0,[r4,#4]
000016  b100              CBZ      r0,|L1.26|
000018  e004              B        |L1.36|
                  |L1.26|
00001a  22b0              MOVS     r2,#0xb0
00001c  a104              ADR      r1,|L1.48|
00001e  a00f              ADR      r0,|L1.92|
000020  f7fffffe          BL       __aeabi_assert
                  |L1.36|
;;;177    
;;;178        /* Stop transfer. */
;;;179        DMA_AbortTransfer(handle->rxDmaHandle);
000024  6860              LDR      r0,[r4,#4]
000026  f7fffffe          BL       DMA_AbortTransfer
;;;180        handle->state = kDMIC_Idle;
00002a  2000              MOVS     r0,#0
00002c  7520              STRB     r0,[r4,#0x14]
;;;181    }
00002e  bd70              POP      {r4-r6,pc}
;;;182    
                          ENDP

                  |L1.48|
000030  5352435c          DCB      "SRC\\Drivers\\fsl_dmic_dma.c",0
000034  44726976
000038  6572735c
00003c  66736c5f
000040  646d6963
000044  5f646d61
000048  2e6300  
00004b  00                DCB      0
                  |L1.76|
00004c  4e554c4c          DCB      "NULL != handle",0
000050  20213d20
000054  68616e64
000058  6c6500  
00005b  00                DCB      0
                  |L1.92|
00005c  4e554c4c          DCB      "NULL != handle->rxDmaHandle",0
000060  20213d20
000064  68616e64
000068  6c652d3e
00006c  7278446d
000070  6148616e
000074  646c6500

                          AREA ||i.DMIC_TransferCreateHandleDMA||, CODE, READONLY, ALIGN=2

                  DMIC_TransferCreateHandleDMA PROC
;;;85     
;;;86     status_t DMIC_TransferCreateHandleDMA(DMIC_Type *base,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;87                                           dmic_dma_handle_t *handle,
;;;88                                           dmic_dma_transfer_callback_t callback,
;;;89                                           void *userData,
;;;90                                           dma_handle_t *rxDmaHandle)
;;;91     {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9f08              LDR      r7,[sp,#0x20]
;;;92         int32_t instance = 0;
00000e  2500              MOVS     r5,#0
;;;93     
;;;94         /* check 'base' */
;;;95         assert(!(NULL == base));
000010  b106              CBZ      r6,|L2.20|
000012  e004              B        |L2.30|
                  |L2.20|
000014  225f              MOVS     r2,#0x5f
000016  a11e              ADR      r1,|L2.144|
000018  a024              ADR      r0,|L2.172|
00001a  f7fffffe          BL       __aeabi_assert
                  |L2.30|
;;;96         if (NULL == base)
00001e  b916              CBNZ     r6,|L2.38|
;;;97         {
;;;98             return kStatus_InvalidArgument;
000020  2004              MOVS     r0,#4
                  |L2.34|
;;;99         }
;;;100        /* check 'handle' */
;;;101        assert(!(NULL == handle));
;;;102        if (NULL == handle)
;;;103        {
;;;104            return kStatus_InvalidArgument;
;;;105        }
;;;106        /* check DMIC instance by 'base'*/
;;;107        instance = DMIC_GetInstance(base);
;;;108        assert(!(instance < 0));
;;;109        if (instance < 0)
;;;110        {
;;;111            return kStatus_InvalidArgument;
;;;112        }
;;;113    
;;;114        memset(handle, 0, sizeof(*handle));
;;;115        /* assign 'base' and 'handle' */
;;;116        s_dmaPrivateHandle[instance].base = base;
;;;117        s_dmaPrivateHandle[instance].handle = handle;
;;;118    
;;;119        handle->callback = callback;
;;;120        handle->userData = userData;
;;;121    
;;;122        handle->rxDmaHandle = rxDmaHandle;
;;;123    
;;;124        /* Set DMIC state to idle */
;;;125        handle->state = kDMIC_Idle;
;;;126        /* Configure RX. */
;;;127        if (rxDmaHandle)
;;;128        {
;;;129            DMA_SetCallback(rxDmaHandle, DMIC_TransferReceiveDMACallback, &s_dmaPrivateHandle[instance]);
;;;130        }
;;;131    
;;;132        return kStatus_Success;
;;;133    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L2.38|
000026  b104              CBZ      r4,|L2.42|
000028  e004              B        |L2.52|
                  |L2.42|
00002a  2265              MOVS     r2,#0x65              ;101
00002c  a118              ADR      r1,|L2.144|
00002e  a023              ADR      r0,|L2.188|
000030  f7fffffe          BL       __aeabi_assert
                  |L2.52|
000034  b90c              CBNZ     r4,|L2.58|
000036  2004              MOVS     r0,#4                 ;104
000038  e7f3              B        |L2.34|
                  |L2.58|
00003a  4630              MOV      r0,r6                 ;107
00003c  f7fffffe          BL       DMIC_GetInstance
000040  4605              MOV      r5,r0                 ;107
000042  2d00              CMP      r5,#0                 ;108
000044  db00              BLT      |L2.72|
000046  e004              B        |L2.82|
                  |L2.72|
000048  226c              MOVS     r2,#0x6c              ;108
00004a  a111              ADR      r1,|L2.144|
00004c  a020              ADR      r0,|L2.208|
00004e  f7fffffe          BL       __aeabi_assert
                  |L2.82|
000052  2d00              CMP      r5,#0                 ;109
000054  da01              BGE      |L2.90|
000056  2004              MOVS     r0,#4                 ;111
000058  e7e3              B        |L2.34|
                  |L2.90|
00005a  2118              MOVS     r1,#0x18              ;114
00005c  4620              MOV      r0,r4                 ;114
00005e  f7fffffe          BL       __aeabi_memclr4
000062  481f              LDR      r0,|L2.224|
000064  f8406035          STR      r6,[r0,r5,LSL #3]     ;116
000068  eb0000c5          ADD      r0,r0,r5,LSL #3       ;117
00006c  6044              STR      r4,[r0,#4]            ;117
00006e  f8c48008          STR      r8,[r4,#8]            ;119
000072  f8c4900c          STR      r9,[r4,#0xc]          ;120
000076  6067              STR      r7,[r4,#4]            ;122
000078  2000              MOVS     r0,#0                 ;125
00007a  7520              STRB     r0,[r4,#0x14]         ;125
00007c  b137              CBZ      r7,|L2.140|
00007e  4818              LDR      r0,|L2.224|
000080  eb0002c5          ADD      r2,r0,r5,LSL #3       ;129
000084  4917              LDR      r1,|L2.228|
000086  4638              MOV      r0,r7                 ;129
000088  f7fffffe          BL       DMA_SetCallback
                  |L2.140|
00008c  2000              MOVS     r0,#0                 ;132
00008e  e7c8              B        |L2.34|
;;;134    
                          ENDP

                  |L2.144|
000090  5352435c          DCB      "SRC\\Drivers\\fsl_dmic_dma.c",0
000094  44726976
000098  6572735c
00009c  66736c5f
0000a0  646d6963
0000a4  5f646d61
0000a8  2e6300  
0000ab  00                DCB      0
                  |L2.172|
0000ac  21284e55          DCB      "!(NULL == base)",0
0000b0  4c4c203d
0000b4  3d206261
0000b8  73652900
                  |L2.188|
0000bc  21284e55          DCB      "!(NULL == handle)",0
0000c0  4c4c203d
0000c4  3d206861
0000c8  6e646c65
0000cc  2900    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L2.208|
0000d0  2128696e          DCB      "!(instance < 0)",0
0000d4  7374616e
0000d8  6365203c
0000dc  20302900
                  |L2.224|
                          DCD      s_dmaPrivateHandle
                  |L2.228|
                          DCD      DMIC_TransferReceiveDMACallback

                          AREA ||i.DMIC_TransferGetReceiveCountDMA||, CODE, READONLY, ALIGN=2

                  DMIC_TransferGetReceiveCountDMA PROC
;;;182    
;;;183    status_t DMIC_TransferGetReceiveCountDMA(DMIC_Type *base, dmic_dma_handle_t *handle, uint32_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;185        assert(handle);
000008  b104              CBZ      r4,|L3.12|
00000a  e004              B        |L3.22|
                  |L3.12|
00000c  22b9              MOVS     r2,#0xb9
00000e  a110              ADR      r1,|L3.80|
000010  a016              ADR      r0,|L3.108|
000012  f7fffffe          BL       __aeabi_assert
                  |L3.22|
;;;186        assert(handle->rxDmaHandle);
000016  6860              LDR      r0,[r4,#4]
000018  b100              CBZ      r0,|L3.28|
00001a  e004              B        |L3.38|
                  |L3.28|
00001c  22ba              MOVS     r2,#0xba
00001e  a10c              ADR      r1,|L3.80|
000020  a014              ADR      r0,|L3.116|
000022  f7fffffe          BL       __aeabi_assert
                  |L3.38|
;;;187        assert(count);
000026  b105              CBZ      r5,|L3.42|
000028  e004              B        |L3.52|
                  |L3.42|
00002a  22bb              MOVS     r2,#0xbb
00002c  a108              ADR      r1,|L3.80|
00002e  a016              ADR      r0,|L3.136|
000030  f7fffffe          BL       __aeabi_assert
                  |L3.52|
;;;188    
;;;189        if (kDMIC_Idle == handle->state)
000034  7d20              LDRB     r0,[r4,#0x14]
000036  b908              CBNZ     r0,|L3.60|
;;;190        {
;;;191            return kStatus_NoTransferInProgress;
000038  2006              MOVS     r0,#6
                  |L3.58|
;;;192        }
;;;193    
;;;194        *count = handle->transferSize - DMA_GetRemainingBytes(handle->rxDmaHandle->base, handle->rxDmaHandle->channel);
;;;195    
;;;196        return kStatus_Success;
;;;197    }
00003a  bd70              POP      {r4-r6,pc}
                  |L3.60|
00003c  6862              LDR      r2,[r4,#4]            ;194
00003e  7b11              LDRB     r1,[r2,#0xc]          ;194
000040  6890              LDR      r0,[r2,#8]            ;194
000042  f7fffffe          BL       DMA_GetRemainingBytes
000046  6921              LDR      r1,[r4,#0x10]         ;194
000048  1a08              SUBS     r0,r1,r0              ;194
00004a  6028              STR      r0,[r5,#0]            ;194
00004c  2000              MOVS     r0,#0                 ;196
00004e  e7f4              B        |L3.58|
                          ENDP

                  |L3.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_dmic_dma.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  646d6963
000064  5f646d61
000068  2e6300  
00006b  00                DCB      0
                  |L3.108|
00006c  68616e64          DCB      "handle",0
000070  6c6500  
000073  00                DCB      0
                  |L3.116|
000074  68616e64          DCB      "handle->rxDmaHandle",0
000078  6c652d3e
00007c  7278446d
000080  6148616e
000084  646c6500
                  |L3.136|
000088  636f756e          DCB      "count",0
00008c  7400    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.DMIC_TransferReceiveDMA||, CODE, READONLY, ALIGN=2

                  DMIC_TransferReceiveDMA PROC
;;;134    
;;;135    status_t DMIC_TransferReceiveDMA(DMIC_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;136                                     dmic_dma_handle_t *handle,
;;;137                                     dmic_transfer_t *xfer,
;;;138                                     uint32_t dmic_channel)
;;;139    {
000004  b08a              SUB      sp,sp,#0x28
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
00000a  4615              MOV      r5,r2
00000c  4698              MOV      r8,r3
;;;140        assert(handle);
00000e  b104              CBZ      r4,|L4.18|
000010  e004              B        |L4.28|
                  |L4.18|
000012  228c              MOVS     r2,#0x8c
000014  a123              ADR      r1,|L4.164|
000016  a02a              ADR      r0,|L4.192|
000018  f7fffffe          BL       __aeabi_assert
                  |L4.28|
;;;141        assert(handle->rxDmaHandle);
00001c  6860              LDR      r0,[r4,#4]
00001e  b100              CBZ      r0,|L4.34|
000020  e004              B        |L4.44|
                  |L4.34|
000022  228d              MOVS     r2,#0x8d
000024  a11f              ADR      r1,|L4.164|
000026  a028              ADR      r0,|L4.200|
000028  f7fffffe          BL       __aeabi_assert
                  |L4.44|
;;;142        assert(xfer);
00002c  b105              CBZ      r5,|L4.48|
00002e  e004              B        |L4.58|
                  |L4.48|
000030  228e              MOVS     r2,#0x8e
000032  a11c              ADR      r1,|L4.164|
000034  a029              ADR      r0,|L4.220|
000036  f7fffffe          BL       __aeabi_assert
                  |L4.58|
;;;143        assert(xfer->data);
00003a  6828              LDR      r0,[r5,#0]
00003c  b100              CBZ      r0,|L4.64|
00003e  e004              B        |L4.74|
                  |L4.64|
000040  228f              MOVS     r2,#0x8f
000042  a118              ADR      r1,|L4.164|
000044  a027              ADR      r0,|L4.228|
000046  f7fffffe          BL       __aeabi_assert
                  |L4.74|
;;;144        assert(xfer->dataSize);
00004a  6868              LDR      r0,[r5,#4]
00004c  b100              CBZ      r0,|L4.80|
00004e  e004              B        |L4.90|
                  |L4.80|
000050  2290              MOVS     r2,#0x90
000052  a114              ADR      r1,|L4.164|
000054  a026              ADR      r0,|L4.240|
000056  f7fffffe          BL       __aeabi_assert
                  |L4.90|
;;;145    
;;;146        dma_transfer_config_t xferConfig;
;;;147        status_t status;
;;;148    
;;;149        /* Check if the device is busy. If previous RX not finished.*/
;;;150        if (handle->state == kDMIC_Busy)
00005a  7d20              LDRB     r0,[r4,#0x14]
00005c  2801              CMP      r0,#1
00005e  d102              BNE      |L4.102|
;;;151        {
;;;152            status = kStatus_DMIC_Busy;
000060  f24166a8          MOV      r6,#0x16a8
000064  e01a              B        |L4.156|
                  |L4.102|
;;;153        }
;;;154        else
;;;155        {
;;;156            handle->state = kDMIC_Busy;
000066  2001              MOVS     r0,#1
000068  7520              STRB     r0,[r4,#0x14]
;;;157            handle->transferSize = xfer->dataSize;
00006a  6868              LDR      r0,[r5,#4]
00006c  6120              STR      r0,[r4,#0x10]
;;;158    
;;;159            /* Prepare transfer. */
;;;160            DMA_PrepareTransfer(&xferConfig, (void *)&base->CHANNEL[dmic_channel].FIFO_DATA, xfer->data, sizeof(uint16_t),
00006e  2100              MOVS     r1,#0
000070  2201              MOVS     r2,#1
000072  6868              LDR      r0,[r5,#4]
000074  e9cd2101          STRD     r2,r1,[sp,#4]
000078  9000              STR      r0,[sp,#0]
00007a  eb072008          ADD      r0,r7,r8,LSL #8
00007e  f1000188          ADD      r1,r0,#0x88
000082  2302              MOVS     r3,#2
000084  a803              ADD      r0,sp,#0xc
000086  682a              LDR      r2,[r5,#0]
000088  f7fffffe          BL       DMA_PrepareTransfer
;;;161                                xfer->dataSize, kDMA_PeripheralToMemory, NULL);
;;;162    
;;;163            /* Submit transfer. */
;;;164            DMA_SubmitTransfer(handle->rxDmaHandle, &xferConfig);
00008c  a903              ADD      r1,sp,#0xc
00008e  6860              LDR      r0,[r4,#4]
000090  f7fffffe          BL       DMA_SubmitTransfer
;;;165    
;;;166            DMA_StartTransfer(handle->rxDmaHandle);
000094  6860              LDR      r0,[r4,#4]
000096  f7fffffe          BL       DMA_StartTransfer
;;;167    
;;;168            status = kStatus_Success;
00009a  2600              MOVS     r6,#0
                  |L4.156|
;;;169        }
;;;170        return status;
00009c  4630              MOV      r0,r6
;;;171    }
00009e  b00a              ADD      sp,sp,#0x28
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;172    
                          ENDP

                  |L4.164|
0000a4  5352435c          DCB      "SRC\\Drivers\\fsl_dmic_dma.c",0
0000a8  44726976
0000ac  6572735c
0000b0  66736c5f
0000b4  646d6963
0000b8  5f646d61
0000bc  2e6300  
0000bf  00                DCB      0
                  |L4.192|
0000c0  68616e64          DCB      "handle",0
0000c4  6c6500  
0000c7  00                DCB      0
                  |L4.200|
0000c8  68616e64          DCB      "handle->rxDmaHandle",0
0000cc  6c652d3e
0000d0  7278446d
0000d4  6148616e
0000d8  646c6500
                  |L4.220|
0000dc  78666572          DCB      "xfer",0
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L4.228|
0000e4  78666572          DCB      "xfer->data",0
0000e8  2d3e6461
0000ec  746100  
0000ef  00                DCB      0
                  |L4.240|
0000f0  78666572          DCB      "xfer->dataSize",0
0000f4  2d3e6461
0000f8  74615369
0000fc  7a6500  
0000ff  00                DCB      0

                          AREA ||i.DMIC_TransferReceiveDMACallback||, CODE, READONLY, ALIGN=2

                  DMIC_TransferReceiveDMACallback PROC
;;;70     
;;;71     static void DMIC_TransferReceiveDMACallback(dma_handle_t *handle, void *param, bool transferDone, uint32_t intmode)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;72     {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;73         assert(handle);
00000c  b106              CBZ      r6,|L5.16|
00000e  e004              B        |L5.26|
                  |L5.16|
000010  2249              MOVS     r2,#0x49
000012  a10e              ADR      r1,|L5.76|
000014  a014              ADR      r0,|L5.104|
000016  f7fffffe          BL       __aeabi_assert
                  |L5.26|
;;;74         assert(param);
00001a  b105              CBZ      r5,|L5.30|
00001c  e004              B        |L5.40|
                  |L5.30|
00001e  224a              MOVS     r2,#0x4a
000020  a10a              ADR      r1,|L5.76|
000022  a013              ADR      r0,|L5.112|
000024  f7fffffe          BL       __aeabi_assert
                  |L5.40|
;;;75     
;;;76         dmic_dma_private_handle_t *dmicPrivateHandle = (dmic_dma_private_handle_t *)param;
000028  462c              MOV      r4,r5
;;;77         dmicPrivateHandle->handle->state = kDMIC_Idle;
00002a  2000              MOVS     r0,#0
00002c  6861              LDR      r1,[r4,#4]
00002e  7508              STRB     r0,[r1,#0x14]
;;;78     
;;;79         if (dmicPrivateHandle->handle->callback)
000030  6860              LDR      r0,[r4,#4]
000032  6880              LDR      r0,[r0,#8]
000034  b138              CBZ      r0,|L5.70|
;;;80         {
;;;81             dmicPrivateHandle->handle->callback(dmicPrivateHandle->base, dmicPrivateHandle->handle, kStatus_DMIC_Idle,
000036  6862              LDR      r2,[r4,#4]
000038  4611              MOV      r1,r2
00003a  68d3              LDR      r3,[r2,#0xc]
00003c  6820              LDR      r0,[r4,#0]
00003e  6897              LDR      r7,[r2,#8]
000040  f24162a9          MOV      r2,#0x16a9
000044  47b8              BLX      r7
                  |L5.70|
;;;82                                                 dmicPrivateHandle->handle->userData);
;;;83         }
;;;84     }
000046  e8bd87f0          POP      {r4-r10,pc}
;;;85     
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
00004c  5352435c          DCB      "SRC\\Drivers\\fsl_dmic_dma.c",0
000050  44726976
000054  6572735c
000058  66736c5f
00005c  646d6963
000060  5f646d61
000064  2e6300  
000067  00                DCB      0
                  |L5.104|
000068  68616e64          DCB      "handle",0
00006c  6c6500  
00006f  00                DCB      0
                  |L5.112|
000070  70617261          DCB      "param",0
000074  6d00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  s_dmaPrivateHandle
                          %        8

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_dmic_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_fsl_dmic_dma_c_7b5ce692____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_fsl_dmic_dma_c_7b5ce692____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_fsl_dmic_dma_c_7b5ce692____REVSH|
#line 402
|__asm___14_fsl_dmic_dma_c_7b5ce692____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_fsl_dmic_dma_c_7b5ce692____RRX|
#line 587
|__asm___14_fsl_dmic_dma_c_7b5ce692____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
