; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\board.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\board.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\board.crf SRC\Board\board.c]
                          THUMB

                          AREA ||i.BOARD_InitDebugConsole||, CODE, READONLY, ALIGN=2

                  BOARD_InitDebugConsole PROC
;;;69     /* Initialize debug console. */
;;;70     status_t BOARD_InitDebugConsole(void)
000000  b570              PUSH     {r4-r6,lr}
;;;71     {
;;;72         status_t result;
;;;73         RESET_PeripheralReset(BOARD_DEBUG_UART_RST);
000002  480c              LDR      r0,|L1.52|
000004  f7fffffe          BL       RESET_PeripheralReset
;;;74         result = DbgConsole_Init(BOARD_DEBUG_UART_BASEADDR, BOARD_DEBUG_UART_BAUDRATE, DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM,
000008  2019              MOVS     r0,#0x19
00000a  f7fffffe          BL       CLOCK_GetFreq
00000e  4605              MOV      r5,r0
000010  462b              MOV      r3,r5
000012  2205              MOVS     r2,#5
000014  f44f31e1          MOV      r1,#0x1c200
000018  4807              LDR      r0,|L1.56|
00001a  f7fffffe          BL       DbgConsole_Init
00001e  4604              MOV      r4,r0
;;;75                                  BOARD_DEBUG_UART_CLK_FREQ);
;;;76         assert(kStatus_Success == result);
000020  b904              CBNZ     r4,|L1.36|
000022  e004              B        |L1.46|
                  |L1.36|
000024  224c              MOVS     r2,#0x4c
000026  a105              ADR      r1,|L1.60|
000028  a009              ADR      r0,|L1.80|
00002a  f7fffffe          BL       __aeabi_assert
                  |L1.46|
;;;77         return result;
00002e  4620              MOV      r0,r4
;;;78     }
000030  bd70              POP      {r4-r6,pc}
;;;79     
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x0001000b
                  |L1.56|
                          DCD      0x40086000
                  |L1.60|
00003c  5352435c          DCB      "SRC\\Board\\board.c",0
000040  426f6172
000044  645c626f
000048  6172642e
00004c  6300    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L1.80|
000050  6b537461          DCB      "kStatus_Success == result",0
000054  7475735f
000058  53756363
00005c  65737320
000060  3d3d2072
000064  6573756c
000068  7400    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.BOARD_InitSDRAM||, CODE, READONLY, ALIGN=2

                  BOARD_InitSDRAM PROC
;;;80     /* Initialize the external memory. */
;;;81     void BOARD_InitSDRAM(void)
000000  b500              PUSH     {lr}
;;;82     {
000002  b091              SUB      sp,sp,#0x44
;;;83         emc_basic_config_t basicConfig;
;;;84         emc_dynamic_timing_config_t dynTiming;
;;;85         emc_dynamic_chip_config_t dynChipConfig;
;;;86     
;;;87         /* Basic configuration. */
;;;88         basicConfig.endian = kEMC_LittleEndian;
000004  2000              MOVS     r0,#0
000006  f88d0040          STRB     r0,[sp,#0x40]
;;;89         basicConfig.fbClkSrc = kEMC_IntloopbackEmcclk;
00000a  f88d0041          STRB     r0,[sp,#0x41]
;;;90         basicConfig.emcClkDiv = 1;
00000e  2001              MOVS     r0,#1
000010  f88d0042          STRB     r0,[sp,#0x42]
;;;91         /* Dynamic memory timing configuration. */
;;;92         dynTiming.readConfig = kEMC_Cmddelay;
000014  f88d000c          STRB     r0,[sp,#0xc]
;;;93         dynTiming.refreshPeriod_Nanosec = SDRAM_REFRESHPERIOD_NS;
000018  f6435009          MOV      r0,#0x3d09
00001c  9004              STR      r0,[sp,#0x10]
;;;94         dynTiming.tRp_Ns = SDRAM_TRP_NS;
00001e  2012              MOVS     r0,#0x12
000020  9005              STR      r0,[sp,#0x14]
;;;95         dynTiming.tRas_Ns = SDRAM_TRAS_NS;
000022  202a              MOVS     r0,#0x2a
000024  9006              STR      r0,[sp,#0x18]
;;;96         dynTiming.tSrex_Ns = SDRAM_TSREX_NS;
000026  2043              MOVS     r0,#0x43
000028  9007              STR      r0,[sp,#0x1c]
;;;97         dynTiming.tApr_Ns = SDRAM_TAPR_NS;
00002a  2012              MOVS     r0,#0x12
00002c  9008              STR      r0,[sp,#0x20]
;;;98         dynTiming.tWr_Ns = (1000000000 / CLOCK_GetFreq(kCLOCK_EMC) + SDRAM_TWRDELT_NS); /* one clk + 6ns */
00002e  200c              MOVS     r0,#0xc
000030  f7fffffe          BL       CLOCK_GetFreq
000034  4917              LDR      r1,|L2.148|
000036  fbb1f0f0          UDIV     r0,r1,r0
00003a  1d80              ADDS     r0,r0,#6
00003c  900a              STR      r0,[sp,#0x28]
;;;99         dynTiming.tDal_Ns = dynTiming.tWr_Ns + dynTiming.tRp_Ns;
00003e  9905              LDR      r1,[sp,#0x14]
000040  980a              LDR      r0,[sp,#0x28]
000042  4408              ADD      r0,r0,r1
000044  9009              STR      r0,[sp,#0x24]
;;;100        dynTiming.tRc_Ns = SDRAM_TRC_NS;
000046  203c              MOVS     r0,#0x3c
000048  900b              STR      r0,[sp,#0x2c]
;;;101        dynTiming.tRfc_Ns = SDRAM_RFC_NS;
00004a  900c              STR      r0,[sp,#0x30]
;;;102        dynTiming.tXsr_Ns = SDRAM_XSR_NS;
00004c  2043              MOVS     r0,#0x43
00004e  900d              STR      r0,[sp,#0x34]
;;;103        dynTiming.tRrd_Ns = SDRAM_RRD_NS;
000050  200c              MOVS     r0,#0xc
000052  900e              STR      r0,[sp,#0x38]
;;;104        dynTiming.tMrd_Nclk = SDRAM_MRD_NCLK;
000054  2002              MOVS     r0,#2
000056  f88d003c          STRB     r0,[sp,#0x3c]
;;;105        /* Dynamic memory chip specific configuration: Chip 0 - MTL48LC8M16A2B4-6A */
;;;106        dynChipConfig.chipIndex = 0;
00005a  2000              MOVS     r0,#0
00005c  f88d0000          STRB     r0,[sp,#0]
;;;107        dynChipConfig.dynamicDevice = kEMC_Sdram;
000060  f88d0001          STRB     r0,[sp,#1]
;;;108        dynChipConfig.rAS_Nclk = SDRAM_RAS_NCLK;
000064  2002              MOVS     r0,#2
000066  f88d0002          STRB     r0,[sp,#2]
;;;109        dynChipConfig.sdramModeReg = SDRAM_MODEREG_VALUE;
00006a  2023              MOVS     r0,#0x23
00006c  f8ad0004          STRH     r0,[sp,#4]
;;;110        dynChipConfig.sdramExtModeReg = 0; /* it has no use for normal sdram */
000070  2000              MOVS     r0,#0
000072  f8ad0006          STRH     r0,[sp,#6]
;;;111        dynChipConfig.devAddrMap = SDRAM_DEV_MEMORYMAP;
000076  2009              MOVS     r0,#9
000078  f88d0008          STRB     r0,[sp,#8]
;;;112        /* EMC Basic configuration. */
;;;113        EMC_Init(EMC, &basicConfig);
00007c  a910              ADD      r1,sp,#0x40
00007e  4806              LDR      r0,|L2.152|
000080  f7fffffe          BL       EMC_Init
;;;114        /* EMC Dynamc memory configuration. */
;;;115        EMC_DynamicMemInit(EMC, &dynTiming, &dynChipConfig, 1);
000084  2301              MOVS     r3,#1
000086  466a              MOV      r2,sp
000088  a903              ADD      r1,sp,#0xc
00008a  4803              LDR      r0,|L2.152|
00008c  f7fffffe          BL       EMC_DynamicMemInit
;;;116    }
000090  b011              ADD      sp,sp,#0x44
000092  bd00              POP      {pc}
;;;117    
                          ENDP

                  |L2.148|
                          DCD      0x3b9aca00
                  |L2.152|
                          DCD      0x40081000

                          AREA ||i.BOARD_InitSPIFI_ExternalFlash||, CODE, READONLY, ALIGN=2

                  BOARD_InitSPIFI_ExternalFlash PROC
;;;170    
;;;171    void BOARD_InitSPIFI_ExternalFlash(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;172    {
;;;173    	  spifi_config_t config = {0};  
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
000008  9002              STR      r0,[sp,#8]
;;;174    	  
;;;175    		CLOCK_AttachClk(kMAIN_CLK_to_SPIFI_CLK);
00000a  f44f7084          MOV      r0,#0x108
00000e  f7fffffe          BL       CLOCK_AttachClk
;;;176    		
;;;177    		uint32_t sourceClockFreq;
;;;178    		
;;;179        sourceClockFreq = CLOCK_GetSpifiClkFreq();
000012  f7fffffe          BL       CLOCK_GetSpifiClkFreq
000016  4604              MOV      r4,r0
;;;180    
;;;181        /* Set the clock divider */
;;;182        CLOCK_SetClkDiv(kCLOCK_DivSpifiClk, sourceClockFreq / EXAMPLE_SPI_BAUDRATE - 1U, false);
000018  480b              LDR      r0,|L3.72|
00001a  fbb4f0f0          UDIV     r0,r4,r0
00001e  1e45              SUBS     r5,r0,#1
000020  2200              MOVS     r2,#0
000022  4629              MOV      r1,r5
000024  2024              MOVS     r0,#0x24
000026  f7fffffe          BL       CLOCK_SetClkDiv
;;;183    
;;;184        /* Initialize SPIFI */
;;;185        SPIFI_GetDefaultConfig(&config);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       SPIFI_GetDefaultConfig
;;;186        SPIFI_Init(EXAMPLE_SPIFI, &config);
000030  4669              MOV      r1,sp
000032  4806              LDR      r0,|L3.76|
000034  f7fffffe          BL       SPIFI_Init
;;;187    
;;;188        /* Enable Quad mode */
;;;189        enable_quad_mode();
000038  f7fffffe          BL       enable_quad_mode
;;;190    
;;;191        /* Setup memory command */
;;;192        SPIFI_SetMemoryCommand(EXAMPLE_SPIFI, &command[READ]);
00003c  4904              LDR      r1,|L3.80|
00003e  4803              LDR      r0,|L3.76|
000040  f7fffffe          BL       SPIFI_SetMemoryCommand
;;;193    }
000044  bd3e              POP      {r1-r5,pc}
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x0112a880
                  |L3.76|
                          DCD      0x40080000
                  |L3.80|
                          DCD      command

                          AREA ||i.EMC_MirrorChipAddr||, CODE, READONLY, ALIGN=1

                  EMC_MirrorChipAddr PROC
;;;300     */
;;;301    static void EMC_MirrorChipAddr(EMC_Type *base, bool enable)
000000  b121              CBZ      r1,|L4.12|
;;;302    {
;;;303        if (enable) 
;;;304        {
;;;305            base->CONTROL |= EMC_CONTROL_M_MASK;
000002  6802              LDR      r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;306        }
;;;307        else 
;;;308        {
;;;309            base->CONTROL &= ~EMC_CONTROL_M_MASK;
00000c  6802              LDR      r2,[r0,#0]
00000e  f0220202          BIC      r2,r2,#2
000012  6002              STR      r2,[r0,#0]
                  |L4.20|
;;;310        }
;;;311    }
000014  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||i.check_if_finish||, CODE, READONLY, ALIGN=2

                  check_if_finish PROC
;;;140    
;;;141    void check_if_finish()
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143        uint32_t val = 0;
000002  2400              MOVS     r4,#0
;;;144        /* Check WIP bit */
;;;145        do
000004  bf00              NOP      
                  |L5.6|
;;;146        {
;;;147            SPIFI_SetCommand(EXAMPLE_SPIFI, &command[GET_STATUS]);
000006  490a              LDR      r1,|L5.48|
000008  480a              LDR      r0,|L5.52|
00000a  f7fffffe          BL       SPIFI_SetCommand
;;;148            while ((EXAMPLE_SPIFI->STAT & SPIFI_STAT_INTRQ_MASK) == 0U)
00000e  bf00              NOP      
                  |L5.16|
000010  4808              LDR      r0,|L5.52|
000012  69c0              LDR      r0,[r0,#0x1c]
000014  f0000020          AND      r0,r0,#0x20
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L5.16|
;;;149            {
;;;150            }
;;;151            val = SPIFI_ReadData(EXAMPLE_SPIFI);
00001c  bf00              NOP      
00001e  4805              LDR      r0,|L5.52|
000020  6940              LDR      r0,[r0,#0x14]
000022  4604              MOV      r4,r0
;;;152        } while (val & 0x1);
000024  f0040001          AND      r0,r4,#1
000028  2800              CMP      r0,#0
00002a  d1ec              BNE      |L5.6|
;;;153    }
00002c  bd10              POP      {r4,pc}
;;;154    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      command+0x10
                  |L5.52|
                          DCD      0x40080000

                          AREA ||i.enable_quad_mode||, CODE, READONLY, ALIGN=2

                  enable_quad_mode PROC
;;;154    
;;;155    void enable_quad_mode()
000000  b510              PUSH     {r4,lr}
;;;156    {
;;;157        /* Write enable */
;;;158        SPIFI_SetCommand(EXAMPLE_SPIFI, &command[WRITE_ENABLE]);
000002  4908              LDR      r1,|L6.36|
000004  4808              LDR      r0,|L6.40|
000006  f7fffffe          BL       SPIFI_SetCommand
;;;159    
;;;160        /* Set write register command */
;;;161        SPIFI_SetCommand(EXAMPLE_SPIFI, &command[WRITE_REGISTER]);
00000a  4906              LDR      r1,|L6.36|
00000c  3108              ADDS     r1,r1,#8
00000e  4806              LDR      r0,|L6.40|
000010  f7fffffe          BL       SPIFI_SetCommand
;;;162    
;;;163        SPIFI_WriteData(EXAMPLE_SPIFI, 0x40);
000014  2040              MOVS     r0,#0x40
000016  4904              LDR      r1,|L6.40|
000018  6148              STR      r0,[r1,#0x14]
00001a  bf00              NOP      
;;;164    
;;;165        check_if_finish();
00001c  f7fffffe          BL       check_if_finish
;;;166    }
000020  bd10              POP      {r4,pc}
;;;167    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      command+0x20
                  |L6.40|
                          DCD      0x40080000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ExtClockIn
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=1

                  command
000000  0100              DCW      0x0100
000002  0000              DCB      0x00,0x00
000004  0101046b          DCB      0x01,0x01,0x04,0x6b
000008  0100              DCW      0x0100
00000a  0001              DCB      0x00,0x01
00000c  00020438          DCB      0x00,0x02,0x04,0x38
000010  0004              DCW      0x0004
000012  0000              DCB      0x00,0x00
000014  00000105          DCB      0x00,0x00,0x01,0x05
000018  0000              DCW      0x0000
00001a  0001              DCB      0x00,0x01
00001c  00000420          DCB      0x00,0x00,0x04,0x20
000020  0000              DCW      0x0000
000022  0001              DCB      0x00,0x01
000024  00000106          DCB      0x00,0x00,0x01,0x06
000028  0004              DCW      0x0004
00002a  0001              DCB      0x00,0x01
00002c  00000101          DCB      0x00,0x00,0x01,0x01

;*** Start embedded assembler ***

#line 1 "SRC\\Board\\board.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_board_c_0f6fde53____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_board_c_0f6fde53____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_board_c_0f6fde53____REVSH|
#line 402
|__asm___7_board_c_0f6fde53____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_board_c_0f6fde53____RRX|
#line 587
|__asm___7_board_c_0f6fde53____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
