; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_flexcomm.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_flexcomm.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_flexcomm.crf SRC\Drivers\fsl_flexcomm.c]
                          THUMB

                          AREA ||i.FLEXCOMM0_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM0_DriverIRQHandler PROC
;;;160    /* IRQ handler functions overloading weak symbols in the startup */
;;;161    void FLEXCOMM0_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163        assert(s_flexcommIrqHandler[0]);
000002  4808              LDR      r0,|L1.36|
000004  6800              LDR      r0,[r0,#0]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L1.10|
000008  e004              B        |L1.20|
                  |L1.10|
00000a  22a3              MOVS     r2,#0xa3
00000c  a106              ADR      r1,|L1.40|
00000e  a00d              ADR      r0,|L1.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L1.20|
;;;164        s_flexcommIrqHandler[0]((void *)s_flexcommBaseAddrs[0], s_flexcommHandle[0]);
000014  4b11              LDR      r3,|L1.92|
000016  6819              LDR      r1,[r3,#0]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L1.96|
00001a  6818              LDR      r0,[r3,#0]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L1.36|
00001e  681a              LDR      r2,[r3,#0]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;165    }
000022  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L1.36|
                          DCD      s_flexcommIrqHandler
                  |L1.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L1.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[0]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b305d00
                  |L1.92|
                          DCD      s_flexcommHandle
                  |L1.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM1_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM1_DriverIRQHandler PROC
;;;167    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 1U)
;;;168    void FLEXCOMM1_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170        assert(s_flexcommIrqHandler[1]);
000002  4808              LDR      r0,|L2.36|
000004  6840              LDR      r0,[r0,#4]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L2.10|
000008  e004              B        |L2.20|
                  |L2.10|
00000a  22aa              MOVS     r2,#0xaa
00000c  a106              ADR      r1,|L2.40|
00000e  a00d              ADR      r0,|L2.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L2.20|
;;;171        s_flexcommIrqHandler[1]((void *)s_flexcommBaseAddrs[1], s_flexcommHandle[1]);
000014  4b11              LDR      r3,|L2.92|
000016  6859              LDR      r1,[r3,#4]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L2.96|
00001a  6858              LDR      r0,[r3,#4]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L2.36|
00001e  685a              LDR      r2,[r3,#4]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;172    }
000022  bd10              POP      {r4,pc}
;;;173    #endif
                          ENDP

                  |L2.36|
                          DCD      s_flexcommIrqHandler
                  |L2.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L2.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[1]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b315d00
                  |L2.92|
                          DCD      s_flexcommHandle
                  |L2.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM2_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM2_DriverIRQHandler PROC
;;;175    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 2U)
;;;176    void FLEXCOMM2_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;177    {
;;;178        assert(s_flexcommIrqHandler[2]);
000002  4808              LDR      r0,|L3.36|
000004  6880              LDR      r0,[r0,#8]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L3.10|
000008  e004              B        |L3.20|
                  |L3.10|
00000a  22b2              MOVS     r2,#0xb2
00000c  a106              ADR      r1,|L3.40|
00000e  a00d              ADR      r0,|L3.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L3.20|
;;;179        s_flexcommIrqHandler[2]((void *)s_flexcommBaseAddrs[2], s_flexcommHandle[2]);
000014  4b11              LDR      r3,|L3.92|
000016  6899              LDR      r1,[r3,#8]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L3.96|
00001a  6898              LDR      r0,[r3,#8]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L3.36|
00001e  689a              LDR      r2,[r3,#8]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;180    }
000022  bd10              POP      {r4,pc}
;;;181    #endif
                          ENDP

                  |L3.36|
                          DCD      s_flexcommIrqHandler
                  |L3.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L3.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[2]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b325d00
                  |L3.92|
                          DCD      s_flexcommHandle
                  |L3.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM3_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM3_DriverIRQHandler PROC
;;;183    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 3U)
;;;184    void FLEXCOMM3_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186        assert(s_flexcommIrqHandler[3]);
000002  4808              LDR      r0,|L4.36|
000004  68c0              LDR      r0,[r0,#0xc]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L4.10|
000008  e004              B        |L4.20|
                  |L4.10|
00000a  22ba              MOVS     r2,#0xba
00000c  a106              ADR      r1,|L4.40|
00000e  a00d              ADR      r0,|L4.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L4.20|
;;;187        s_flexcommIrqHandler[3]((void *)s_flexcommBaseAddrs[3], s_flexcommHandle[3]);
000014  4b11              LDR      r3,|L4.92|
000016  68d9              LDR      r1,[r3,#0xc]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L4.96|
00001a  68d8              LDR      r0,[r3,#0xc]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L4.36|
00001e  68da              LDR      r2,[r3,#0xc]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;188    }
000022  bd10              POP      {r4,pc}
;;;189    #endif
                          ENDP

                  |L4.36|
                          DCD      s_flexcommIrqHandler
                  |L4.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L4.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[3]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b335d00
                  |L4.92|
                          DCD      s_flexcommHandle
                  |L4.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM4_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM4_DriverIRQHandler PROC
;;;191    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 4U)
;;;192    void FLEXCOMM4_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194        assert(s_flexcommIrqHandler[4]);
000002  4808              LDR      r0,|L5.36|
000004  6900              LDR      r0,[r0,#0x10]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L5.10|
000008  e004              B        |L5.20|
                  |L5.10|
00000a  22c2              MOVS     r2,#0xc2
00000c  a106              ADR      r1,|L5.40|
00000e  a00d              ADR      r0,|L5.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L5.20|
;;;195        s_flexcommIrqHandler[4]((void *)s_flexcommBaseAddrs[4], s_flexcommHandle[4]);
000014  4b11              LDR      r3,|L5.92|
000016  6919              LDR      r1,[r3,#0x10]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L5.96|
00001a  6918              LDR      r0,[r3,#0x10]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L5.36|
00001e  691a              LDR      r2,[r3,#0x10]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;196    }
000022  bd10              POP      {r4,pc}
;;;197    
                          ENDP

                  |L5.36|
                          DCD      s_flexcommIrqHandler
                  |L5.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L5.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[4]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b345d00
                  |L5.92|
                          DCD      s_flexcommHandle
                  |L5.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM5_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM5_DriverIRQHandler PROC
;;;200    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 5U)
;;;201    void FLEXCOMM5_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203        assert(s_flexcommIrqHandler[5]);
000002  4808              LDR      r0,|L6.36|
000004  6940              LDR      r0,[r0,#0x14]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L6.10|
000008  e004              B        |L6.20|
                  |L6.10|
00000a  22cb              MOVS     r2,#0xcb
00000c  a106              ADR      r1,|L6.40|
00000e  a00d              ADR      r0,|L6.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L6.20|
;;;204        s_flexcommIrqHandler[5]((void *)s_flexcommBaseAddrs[5], s_flexcommHandle[5]);
000014  4b11              LDR      r3,|L6.92|
000016  6959              LDR      r1,[r3,#0x14]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L6.96|
00001a  6958              LDR      r0,[r3,#0x14]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L6.36|
00001e  695a              LDR      r2,[r3,#0x14]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;205    }
000022  bd10              POP      {r4,pc}
;;;206    #endif
                          ENDP

                  |L6.36|
                          DCD      s_flexcommIrqHandler
                  |L6.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L6.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[5]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b355d00
                  |L6.92|
                          DCD      s_flexcommHandle
                  |L6.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM8_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM8_DriverIRQHandler PROC
;;;226    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 8U)
;;;227    void FLEXCOMM8_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;228    {
;;;229        assert(s_flexcommIrqHandler[8]);
000002  4808              LDR      r0,|L7.36|
000004  6a00              LDR      r0,[r0,#0x20]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L7.10|
000008  e004              B        |L7.20|
                  |L7.10|
00000a  22e5              MOVS     r2,#0xe5
00000c  a106              ADR      r1,|L7.40|
00000e  a00d              ADR      r0,|L7.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L7.20|
;;;230        s_flexcommIrqHandler[8]((void *)s_flexcommBaseAddrs[8], s_flexcommHandle[8]);
000014  4b11              LDR      r3,|L7.92|
000016  6a19              LDR      r1,[r3,#0x20]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L7.96|
00001a  6a18              LDR      r0,[r3,#0x20]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L7.36|
00001e  6a1a              LDR      r2,[r3,#0x20]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;231    }
000022  bd10              POP      {r4,pc}
;;;232    #endif
                          ENDP

                  |L7.36|
                          DCD      s_flexcommIrqHandler
                  |L7.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L7.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[8]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b385d00
                  |L7.92|
                          DCD      s_flexcommHandle
                  |L7.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM9_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM9_DriverIRQHandler PROC
;;;234    #if (FSL_FEATURE_SOC_FLEXCOMM_COUNT > 9U)
;;;235    void FLEXCOMM9_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;236    {
;;;237        assert(s_flexcommIrqHandler[9]);
000002  4808              LDR      r0,|L8.36|
000004  6a40              LDR      r0,[r0,#0x24]  ; s_flexcommIrqHandler
000006  b100              CBZ      r0,|L8.10|
000008  e004              B        |L8.20|
                  |L8.10|
00000a  22ed              MOVS     r2,#0xed
00000c  a106              ADR      r1,|L8.40|
00000e  a00d              ADR      r0,|L8.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L8.20|
;;;238        s_flexcommIrqHandler[9]((void *)s_flexcommBaseAddrs[9], s_flexcommHandle[9]);
000014  4b11              LDR      r3,|L8.92|
000016  6a59              LDR      r1,[r3,#0x24]  ; s_flexcommHandle
000018  4b11              LDR      r3,|L8.96|
00001a  6a58              LDR      r0,[r3,#0x24]  ; s_flexcommBaseAddrs
00001c  4b01              LDR      r3,|L8.36|
00001e  6a5a              LDR      r2,[r3,#0x24]  ; s_flexcommIrqHandler
000020  4790              BLX      r2
;;;239    }
000022  bd10              POP      {r4,pc}
;;;240    #endif
                          ENDP

                  |L8.36|
                          DCD      s_flexcommIrqHandler
                  |L8.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  666c6578
00003c  636f6d6d
000040  2e6300  
000043  00                DCB      0
                  |L8.68|
000044  735f666c          DCB      "s_flexcommIrqHandler[9]",0
000048  6578636f
00004c  6d6d4972
000050  7148616e
000054  646c6572
000058  5b395d00
                  |L8.92|
                          DCD      s_flexcommHandle
                  |L8.96|
                          DCD      s_flexcommBaseAddrs

                          AREA ||i.FLEXCOMM_GetInstance||, CODE, READONLY, ALIGN=2

                  FLEXCOMM_GetInstance PROC
;;;84     /* Get the index corresponding to the FLEXCOMM */
;;;85     uint32_t FLEXCOMM_GetInstance(void *base)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
000002  4605              MOV      r5,r0
;;;87         int i;
;;;88     
;;;89         for (i = 0; i < FSL_FEATURE_SOC_FLEXCOMM_COUNT; i++)
000004  2400              MOVS     r4,#0
000006  e007              B        |L9.24|
                  |L9.8|
;;;90         {
;;;91             if ((uint32_t)base == s_flexcommBaseAddrs[i])
000008  4807              LDR      r0,|L9.40|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d101              BNE      |L9.22|
;;;92             {
;;;93                 return i;
000012  4620              MOV      r0,r4
;;;94             }
;;;95         }
;;;96     
;;;97         assert(false);
;;;98         return 0;
;;;99     }
000014  bd70              POP      {r4-r6,pc}
                  |L9.22|
000016  1c64              ADDS     r4,r4,#1              ;89
                  |L9.24|
000018  2c0a              CMP      r4,#0xa               ;89
00001a  dbf5              BLT      |L9.8|
00001c  2261              MOVS     r2,#0x61              ;97
00001e  a103              ADR      r1,|L9.44|
000020  a009              ADR      r0,|L9.72|
000022  f7fffffe          BL       __aeabi_assert
;;;100    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      s_flexcommBaseAddrs
                  |L9.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_flexcomm.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  666c6578
000040  636f6d6d
000044  2e6300  
000047  00                DCB      0
                  |L9.72|
000048  66616c73          DCB      "false",0
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.FLEXCOMM_Init||, CODE, READONLY, ALIGN=2

                  FLEXCOMM_Init PROC
;;;128    
;;;129    status_t FLEXCOMM_Init(void *base, FLEXCOMM_PERIPH_T periph)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;131        int idx = FLEXCOMM_GetInstance(base);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLEXCOMM_GetInstance
00000c  4604              MOV      r4,r0
;;;132    
;;;133        if (idx < 0)
00000e  2c00              CMP      r4,#0
000010  da01              BGE      |L10.22|
;;;134        {
;;;135            return kStatus_InvalidArgument;
000012  2004              MOVS     r0,#4
                  |L10.20|
;;;136        }
;;;137    
;;;138    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;139        /* Enable the peripheral clock */
;;;140        CLOCK_EnableClock(s_flexcommClocks[idx]);
;;;141    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;142    
;;;143        /* Set the FLEXCOMM to given peripheral */
;;;144        return FLEXCOMM_SetPeriph((FLEXCOMM_Type *)base, periph, 0);
;;;145    }
000014  bd70              POP      {r4-r6,pc}
                  |L10.22|
000016  490c              LDR      r1,|L10.72|
000018  f8310014          LDRH     r0,[r1,r4,LSL #1]     ;140
00001c  0a01              LSRS     r1,r0,#8              ;140
00001e  2903              CMP      r1,#3                 ;140
000020  d205              BCS      |L10.46|
000022  2201              MOVS     r2,#1                 ;140
000024  4082              LSLS     r2,r2,r0              ;140
000026  4b09              LDR      r3,|L10.76|
000028  f8432021          STR      r2,[r3,r1,LSL #2]     ;140
00002c  e005              B        |L10.58|
                  |L10.46|
00002e  2201              MOVS     r2,#1                 ;140
000030  0793              LSLS     r3,r2,#30             ;140
000032  64da              STR      r2,[r3,#0x4c]         ;140
000034  4082              LSLS     r2,r2,r0              ;140
000036  4b06              LDR      r3,|L10.80|
000038  615a              STR      r2,[r3,#0x14]         ;140
                  |L10.58|
00003a  bf00              NOP                            ;140
00003c  2200              MOVS     r2,#0                 ;144
00003e  4631              MOV      r1,r6                 ;144
000040  4628              MOV      r0,r5                 ;144
000042  f7fffffe          BL       FLEXCOMM_SetPeriph
000046  e7e5              B        |L10.20|
;;;146    
                          ENDP

                  |L10.72|
                          DCD      s_flexcommClocks
                  |L10.76|
                          DCD      0x40000220
                  |L10.80|
                          DCD      0x40040000

                          AREA ||i.FLEXCOMM_PeripheralIsPresent||, CODE, READONLY, ALIGN=1

                  FLEXCOMM_PeripheralIsPresent PROC
;;;63     /* check whether flexcomm supports peripheral type */
;;;64     static bool FLEXCOMM_PeripheralIsPresent(FLEXCOMM_Type *base, FLEXCOMM_PERIPH_T periph)
000000  b510              PUSH     {r4,lr}
;;;65     {
000002  4602              MOV      r2,r0
;;;66         if (periph == FLEXCOMM_PERIPH_NONE)
000004  b909              CBNZ     r1,|L11.10|
;;;67         {
;;;68             return true;
000006  2001              MOVS     r0,#1
                  |L11.8|
;;;69         }
;;;70         else if ((periph >= FLEXCOMM_PERIPH_USART) && (periph <= FLEXCOMM_PERIPH_I2S_TX))
;;;71         {
;;;72             return (base->PSELID & (uint32_t)(1 << ((uint32_t)periph + 3))) > 0 ? true : false;
;;;73         }
;;;74         else if (periph == FLEXCOMM_PERIPH_I2S_RX)
;;;75         {
;;;76             return (base->PSELID & (1 << 7)) > 0 ? true : false;
;;;77         }
;;;78         else
;;;79         {
;;;80             return false;
;;;81         }
;;;82     }
000008  bd10              POP      {r4,pc}
                  |L11.10|
00000a  2901              CMP      r1,#1                 ;70
00000c  db0c              BLT      |L11.40|
00000e  2904              CMP      r1,#4                 ;70
000010  dc0a              BGT      |L11.40|
000012  f8d20ff8          LDR      r0,[r2,#0xff8]        ;72
000016  1ccb              ADDS     r3,r1,#3              ;72
000018  2401              MOVS     r4,#1                 ;72
00001a  409c              LSLS     r4,r4,r3              ;72
00001c  4020              ANDS     r0,r0,r4              ;72
00001e  b108              CBZ      r0,|L11.36|
000020  2001              MOVS     r0,#1                 ;72
000022  e7f1              B        |L11.8|
                  |L11.36|
000024  2000              MOVS     r0,#0                 ;72
000026  e7ef              B        |L11.8|
                  |L11.40|
000028  2905              CMP      r1,#5                 ;74
00002a  d104              BNE      |L11.54|
00002c  f8d20ff8          LDR      r0,[r2,#0xff8]        ;76
000030  f3c010c0          UBFX     r0,r0,#7,#1           ;76
000034  e7e8              B        |L11.8|
                  |L11.54|
000036  2000              MOVS     r0,#0                 ;80
000038  e7e6              B        |L11.8|
;;;83     
                          ENDP


                          AREA ||i.FLEXCOMM_SetIRQHandler||, CODE, READONLY, ALIGN=2

                  FLEXCOMM_SetIRQHandler PROC
;;;146    
;;;147    void FLEXCOMM_SetIRQHandler(void *base, flexcomm_irq_handler_t handler, void *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;149        uint32_t instance;
;;;150    
;;;151        /* Look up instance number */
;;;152        instance = FLEXCOMM_GetInstance(base);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FLEXCOMM_GetInstance
000010  4604              MOV      r4,r0
;;;153    
;;;154        /* Clear handler first to avoid execution of the handler with wrong handle */
;;;155        s_flexcommIrqHandler[instance] = NULL;
000012  2000              MOVS     r0,#0
000014  4905              LDR      r1,|L12.44|
000016  f8410024          STR      r0,[r1,r4,LSL #2]
;;;156        s_flexcommHandle[instance] = handle;
00001a  4805              LDR      r0,|L12.48|
00001c  f8406024          STR      r6,[r0,r4,LSL #2]
;;;157        s_flexcommIrqHandler[instance] = handler;
000020  4608              MOV      r0,r1
000022  f8405024          STR      r5,[r0,r4,LSL #2]
;;;158    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;159    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      s_flexcommIrqHandler
                  |L12.48|
                          DCD      s_flexcommHandle

                          AREA ||i.FLEXCOMM_SetPeriph||, CODE, READONLY, ALIGN=1

                  FLEXCOMM_SetPeriph PROC
;;;101    /* Changes FLEXCOMM mode */
;;;102    status_t FLEXCOMM_SetPeriph(FLEXCOMM_Type *base, FLEXCOMM_PERIPH_T periph, int lock)
000000  b570              PUSH     {r4-r6,lr}
;;;103    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;104        /* Check whether peripheral type is present */
;;;105        if (!FLEXCOMM_PeripheralIsPresent(base, periph))
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       FLEXCOMM_PeripheralIsPresent
000010  b908              CBNZ     r0,|L13.22|
;;;106        {
;;;107            return kStatus_OutOfRange;
000012  2003              MOVS     r0,#3
                  |L13.20|
;;;108        }
;;;109    
;;;110        /* Flexcomm is locked to different peripheral type than expected  */
;;;111        if ((base->PSELID & FLEXCOMM_PSELID_LOCK_MASK) && ((base->PSELID & FLEXCOMM_PSELID_PERSEL_MASK) != periph))
;;;112        {
;;;113            return kStatus_Fail;
;;;114        }
;;;115    
;;;116        /* Check if we are asked to lock */
;;;117        if (lock)
;;;118        {
;;;119            base->PSELID = (uint32_t)periph | FLEXCOMM_PSELID_LOCK_MASK;
;;;120        }
;;;121        else
;;;122        {
;;;123            base->PSELID = (uint32_t)periph;
;;;124        }
;;;125    
;;;126        return kStatus_Success;
;;;127    }
000014  bd70              POP      {r4-r6,pc}
                  |L13.22|
000016  f8d40ff8          LDR      r0,[r4,#0xff8]        ;111
00001a  f0000008          AND      r0,r0,#8              ;111
00001e  b138              CBZ      r0,|L13.48|
000020  f8d40ff8          LDR      r0,[r4,#0xff8]        ;111
000024  f0000007          AND      r0,r0,#7              ;111
000028  42a8              CMP      r0,r5                 ;111
00002a  d001              BEQ      |L13.48|
00002c  2001              MOVS     r0,#1                 ;113
00002e  e7f1              B        |L13.20|
                  |L13.48|
000030  b126              CBZ      r6,|L13.60|
000032  f0450008          ORR      r0,r5,#8              ;119
000036  f8c40ff8          STR      r0,[r4,#0xff8]        ;119
00003a  e001              B        |L13.64|
                  |L13.60|
00003c  f8c45ff8          STR      r5,[r4,#0xff8]        ;123
                  |L13.64|
000040  2000              MOVS     r0,#0                 ;126
000042  e7e7              B        |L13.20|
;;;128    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_flexcommIrqHandler
                          %        40
                  s_flexcommHandle
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  kFlexcommIrqs
000000  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
000004  12131415          DCB      0x12,0x13,0x14,0x15
000008  28290000          DCB      0x28,0x29,0x00,0x00
                  s_flexcommBaseAddrs
                          DCD      0x40086000
                          DCD      0x40087000
                          DCD      0x40088000
                          DCD      0x40089000
                          DCD      0x4008a000
                          DCD      0x40096000
                          DCD      0x40097000
                          DCD      0x40098000
                          DCD      0x40099000
                          DCD      0x4009a000
                  s_flexcommClocks
000034  010b010c          DCW      0x010b,0x010c
000038  010d010e          DCW      0x010d,0x010e
00003c  010f0110          DCW      0x010f,0x0110
000040  01110112          DCW      0x0111,0x0112
000044  020e020f          DCW      0x020e,0x020f

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_flexcomm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_fsl_flexcomm_c_a7786cfd____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_fsl_flexcomm_c_a7786cfd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_fsl_flexcomm_c_a7786cfd____REVSH|
#line 402
|__asm___14_fsl_flexcomm_c_a7786cfd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_fsl_flexcomm_c_a7786cfd____RRX|
#line 587
|__asm___14_fsl_flexcomm_c_a7786cfd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
