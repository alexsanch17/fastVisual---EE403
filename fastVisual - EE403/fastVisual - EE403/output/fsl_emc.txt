; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_emc.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_emc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_emc.crf SRC\Drivers\fsl_emc.c]
                          THUMB

                          AREA ||i.EMC_CalculateTimerCycles||, CODE, READONLY, ALIGN=2

                  EMC_CalculateTimerCycles PROC
;;;116    
;;;117    static uint32_t EMC_CalculateTimerCycles(EMC_Type *base, uint32_t timer_Ns, uint32_t plus)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;118    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;119        uint32_t cycles;
;;;120    
;;;121        cycles = CLOCK_GetFreq(kCLOCK_EMC) / EMC_HZ_ONEMHZ * timer_Ns;
00000a  200c              MOVS     r0,#0xc
00000c  f7fffffe          BL       CLOCK_GetFreq
000010  4909              LDR      r1,|L1.56|
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  fb00f406          MUL      r4,r0,r6
;;;122        cycles = EMC_DIV_ROUND_UP(cycles, EMC_MILLISECS_ONESEC); /* Round up. */
00001a  f20430e7          ADD      r0,r4,#0x3e7
00001e  f44f717a          MOV      r1,#0x3e8
000022  fbb0f4f1          UDIV     r4,r0,r1
;;;123    
;;;124        /* Decrese according to the plus. */
;;;125        if (cycles >= plus)
000026  42ac              CMP      r4,r5
000028  d301              BCC      |L1.46|
;;;126        {
;;;127            cycles = cycles - plus;
00002a  1b64              SUBS     r4,r4,r5
00002c  e000              B        |L1.48|
                  |L1.46|
;;;128        }
;;;129        else
;;;130        {
;;;131            cycles = 0;
00002e  2400              MOVS     r4,#0
                  |L1.48|
;;;132        }
;;;133        
;;;134        return cycles;
000030  4620              MOV      r0,r4
;;;135    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x000f4240

                          AREA ||i.EMC_Deinit||, CODE, READONLY, ALIGN=2

                  EMC_Deinit PROC
;;;372    
;;;373    void EMC_Deinit(EMC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4605              MOV      r5,r0
;;;375        /* Deinit the EMC. */
;;;376        base->CONTROL &= ~EMC_CONTROL_E_MASK;
000004  6828              LDR      r0,[r5,#0]
000006  f0200001          BIC      r0,r0,#1
00000a  6028              STR      r0,[r5,#0]
;;;377    
;;;378        /* Disable EMC clock. */
;;;379        CLOCK_DisableClock(s_EMCClock[EMC_GetInstance(base)]);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       EMC_GetInstance
000012  490a              LDR      r1,|L2.60|
000014  f8314010          LDRH     r4,[r1,r0,LSL #1]
000018  0a20              LSRS     r0,r4,#8
00001a  2803              CMP      r0,#3
00001c  d205              BCS      |L2.42|
00001e  2101              MOVS     r1,#1
000020  40a1              LSLS     r1,r1,r4
000022  4a07              LDR      r2,|L2.64|
000024  f8421020          STR      r1,[r2,r0,LSL #2]
000028  e006              B        |L2.56|
                  |L2.42|
00002a  2101              MOVS     r1,#1
00002c  40a1              LSLS     r1,r1,r4
00002e  4a05              LDR      r2,|L2.68|
000030  6191              STR      r1,[r2,#0x18]
000032  2100              MOVS     r1,#0
000034  0312              LSLS     r2,r2,#12
000036  64d1              STR      r1,[r2,#0x4c]
                  |L2.56|
000038  bf00              NOP      
;;;380    }
00003a  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L2.60|
                          DCD      s_EMCClock
                  |L2.64|
                          DCD      0x40000240
                  |L2.68|
                          DCD      0x40040000

                          AREA ||i.EMC_DynamicMemInit||, CODE, READONLY, ALIGN=2

                  EMC_DynamicMemInit PROC
;;;217    
;;;218    void EMC_DynamicMemInit(EMC_Type *base, emc_dynamic_timing_config_t *timing, 
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;219            emc_dynamic_chip_config_t *config, uint32_t totalChips)
;;;220    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;221        assert(config);
00000c  f1b80f00          CMP      r8,#0
000010  d000              BEQ      |L3.20|
000012  e004              B        |L3.30|
                  |L3.20|
000014  22dd              MOVS     r2,#0xdd
000016  a18f              ADR      r1,|L3.596|
000018  a094              ADR      r0,|L3.620|
00001a  f7fffffe          BL       __aeabi_assert
                  |L3.30|
;;;222        assert(timing);
00001e  b106              CBZ      r6,|L3.34|
000020  e004              B        |L3.44|
                  |L3.34|
000022  22de              MOVS     r2,#0xde
000024  a18b              ADR      r1,|L3.596|
000026  a093              ADR      r0,|L3.628|
000028  f7fffffe          BL       __aeabi_assert
                  |L3.44|
;;;223        assert(totalChips <= EMC_DYNAMIC_MEMDEV_NUM);
00002c  f1b90f04          CMP      r9,#4
000030  d800              BHI      |L3.52|
000032  e004              B        |L3.62|
                  |L3.52|
000034  22df              MOVS     r2,#0xdf
000036  a187              ADR      r1,|L3.596|
000038  a090              ADR      r0,|L3.636|
00003a  f7fffffe          BL       __aeabi_assert
                  |L3.62|
;;;224    
;;;225        uint32_t count;
;;;226        uint8_t casLatency;
;;;227        uint32_t addr;
;;;228        uint32_t offset;
;;;229        uint32_t data;
;;;230        emc_dynamic_chip_config_t *dynamicConfig = config;
00003e  4645              MOV      r5,r8
;;;231    
;;;232        /* Setting for dynamic memory controller chip independent configuration. */
;;;233        for (count = 0; (count < totalChips) && (dynamicConfig != NULL); count ++)
000040  2700              MOVS     r7,#0
000042  e024              B        |L3.142|
                  |L3.68|
;;;234        {
;;;235            base->DYNAMIC[dynamicConfig->chipIndex].DYNAMICCONFIG  = EMC_DYNAMIC_DYNAMICCONFIG_MD(dynamicConfig->dynamicDevice) |
000044  7868              LDRB     r0,[r5,#1]
000046  2118              MOVS     r1,#0x18
000048  ea0100c0          AND      r0,r1,r0,LSL #3
00004c  7a29              LDRB     r1,[r5,#8]
00004e  f44f42bf          MOV      r2,#0x5f80
000052  ea0211c1          AND      r1,r2,r1,LSL #7
000056  4308              ORRS     r0,r0,r1
000058  782a              LDRB     r2,[r5,#0]
00005a  f5047180          ADD      r1,r4,#0x100
00005e  eb011142          ADD      r1,r1,r2,LSL #5
000062  6008              STR      r0,[r1,#0]
;;;236                EMC_ADDRMAP(dynamicConfig->devAddrMap);
;;;237            /* Abstract CAS latency from the sdram mode reigster setting values. */
;;;238            casLatency = (dynamicConfig->sdramModeReg & EMC_SDRAM_MODE_CL_MASK) >> EMC_SDRAM_MODE_CL_SHIFT;
000064  7928              LDRB     r0,[r5,#4]
000066  f3c01002          UBFX     r0,r0,#4,#3
00006a  9001              STR      r0,[sp,#4]
;;;239            base->DYNAMIC[dynamicConfig->chipIndex].DYNAMICRASCAS  =  EMC_DYNAMIC_DYNAMICRASCAS_RAS(dynamicConfig->rAS_Nclk) |
00006c  78a8              LDRB     r0,[r5,#2]
00006e  f0000103          AND      r1,r0,#3
000072  f44f7240          MOV      r2,#0x300
000076  9801              LDR      r0,[sp,#4]
000078  ea022000          AND      r0,r2,r0,LSL #8
00007c  4308              ORRS     r0,r0,r1
00007e  782a              LDRB     r2,[r5,#0]
000080  f5047180          ADD      r1,r4,#0x100
000084  eb011142          ADD      r1,r1,r2,LSL #5
000088  6048              STR      r0,[r1,#4]
;;;240            EMC_DYNAMIC_DYNAMICRASCAS_CAS(casLatency);
;;;241            
;;;242            dynamicConfig ++;
00008a  350a              ADDS     r5,r5,#0xa
00008c  1c7f              ADDS     r7,r7,#1              ;233
                  |L3.142|
00008e  454f              CMP      r7,r9                 ;233
000090  d201              BCS      |L3.150|
000092  2d00              CMP      r5,#0                 ;233
000094  d1d6              BNE      |L3.68|
                  |L3.150|
;;;243        }
;;;244    
;;;245        /* Configure the Dynamic Memory controller timing/latency for all chips. */
;;;246        base->DYNAMICREADCONFIG = EMC_DYNAMICREADCONFIG_RD(timing->readConfig);
000096  7830              LDRB     r0,[r6,#0]
000098  f0000003          AND      r0,r0,#3
00009c  62a0              STR      r0,[r4,#0x28]
;;;247        base->DYNAMICRP = EMC_CalculateTimerCycles(base, timing->tRp_Ns, 1) & EMC_DYNAMICRP_TRP_MASK;
00009e  2201              MOVS     r2,#1
0000a0  4620              MOV      r0,r4
0000a2  68b1              LDR      r1,[r6,#8]
0000a4  f7fffffe          BL       EMC_CalculateTimerCycles
0000a8  f000000f          AND      r0,r0,#0xf
0000ac  6320              STR      r0,[r4,#0x30]
;;;248        base->DYNAMICRAS = EMC_CalculateTimerCycles(base, timing->tRas_Ns, 1) & EMC_DYNAMICRAS_TRAS_MASK;
0000ae  2201              MOVS     r2,#1
0000b0  4620              MOV      r0,r4
0000b2  68f1              LDR      r1,[r6,#0xc]
0000b4  f7fffffe          BL       EMC_CalculateTimerCycles
0000b8  f000000f          AND      r0,r0,#0xf
0000bc  6360              STR      r0,[r4,#0x34]
;;;249        base->DYNAMICSREX = EMC_CalculateTimerCycles(base, timing->tSrex_Ns, 1) & EMC_DYNAMICSREX_TSREX_MASK;
0000be  2201              MOVS     r2,#1
0000c0  4620              MOV      r0,r4
0000c2  6931              LDR      r1,[r6,#0x10]
0000c4  f7fffffe          BL       EMC_CalculateTimerCycles
0000c8  f000000f          AND      r0,r0,#0xf
0000cc  63a0              STR      r0,[r4,#0x38]
;;;250        base->DYNAMICAPR = EMC_CalculateTimerCycles(base, timing->tApr_Ns, 1) & EMC_DYNAMICAPR_TAPR_MASK;
0000ce  2201              MOVS     r2,#1
0000d0  4620              MOV      r0,r4
0000d2  6971              LDR      r1,[r6,#0x14]
0000d4  f7fffffe          BL       EMC_CalculateTimerCycles
0000d8  f000000f          AND      r0,r0,#0xf
0000dc  63e0              STR      r0,[r4,#0x3c]
;;;251        base->DYNAMICDAL = EMC_CalculateTimerCycles(base, timing->tDal_Ns, 0) & EMC_DYNAMICDAL_TDAL_MASK;
0000de  2200              MOVS     r2,#0
0000e0  4620              MOV      r0,r4
0000e2  69b1              LDR      r1,[r6,#0x18]
0000e4  f7fffffe          BL       EMC_CalculateTimerCycles
0000e8  f000000f          AND      r0,r0,#0xf
0000ec  6420              STR      r0,[r4,#0x40]
;;;252        base->DYNAMICWR = EMC_CalculateTimerCycles(base, timing->tWr_Ns, 1) & EMC_DYNAMICWR_TWR_MASK;
0000ee  2201              MOVS     r2,#1
0000f0  4620              MOV      r0,r4
0000f2  69f1              LDR      r1,[r6,#0x1c]
0000f4  f7fffffe          BL       EMC_CalculateTimerCycles
0000f8  f000000f          AND      r0,r0,#0xf
0000fc  6460              STR      r0,[r4,#0x44]
;;;253        base->DYNAMICRC = EMC_CalculateTimerCycles(base, timing->tRc_Ns, 1) & EMC_DYNAMICRC_TRC_MASK;
0000fe  2201              MOVS     r2,#1
000100  4620              MOV      r0,r4
000102  6a31              LDR      r1,[r6,#0x20]
000104  f7fffffe          BL       EMC_CalculateTimerCycles
000108  f000001f          AND      r0,r0,#0x1f
00010c  64a0              STR      r0,[r4,#0x48]
;;;254        base->DYNAMICRFC = EMC_CalculateTimerCycles(base, timing->tRfc_Ns, 1) &EMC_DYNAMICRFC_TRFC_MASK;
00010e  2201              MOVS     r2,#1
000110  4620              MOV      r0,r4
000112  6a71              LDR      r1,[r6,#0x24]
000114  f7fffffe          BL       EMC_CalculateTimerCycles
000118  f000001f          AND      r0,r0,#0x1f
00011c  64e0              STR      r0,[r4,#0x4c]
;;;255        base->DYNAMICXSR = EMC_CalculateTimerCycles(base, timing->tXsr_Ns, 1) & EMC_DYNAMICXSR_TXSR_MASK;
00011e  2201              MOVS     r2,#1
000120  4620              MOV      r0,r4
000122  6ab1              LDR      r1,[r6,#0x28]
000124  f7fffffe          BL       EMC_CalculateTimerCycles
000128  f000001f          AND      r0,r0,#0x1f
00012c  6520              STR      r0,[r4,#0x50]
;;;256        base->DYNAMICRRD = EMC_CalculateTimerCycles(base, timing->tRrd_Ns, 1) & EMC_DYNAMICRRD_TRRD_MASK;
00012e  2201              MOVS     r2,#1
000130  4620              MOV      r0,r4
000132  6af1              LDR      r1,[r6,#0x2c]
000134  f7fffffe          BL       EMC_CalculateTimerCycles
000138  f000000f          AND      r0,r0,#0xf
00013c  6560              STR      r0,[r4,#0x54]
;;;257        base->DYNAMICMRD = EMC_DYNAMICMRD_TMRD((timing->tMrd_Nclk > 0)?timing->tMrd_Nclk - 1:0);
00013e  f8960030          LDRB     r0,[r6,#0x30]
000142  2800              CMP      r0,#0
000144  dd03              BLE      |L3.334|
000146  f8960030          LDRB     r0,[r6,#0x30]
00014a  1e40              SUBS     r0,r0,#1
00014c  e000              B        |L3.336|
                  |L3.334|
00014e  2000              MOVS     r0,#0
                  |L3.336|
000150  f000000f          AND      r0,r0,#0xf
000154  65a0              STR      r0,[r4,#0x58]
;;;258    
;;;259        /* Initialize the SDRAM.*/ 
;;;260        for (count = 0; count < EMC_SDRAM_WAIT_CYCLES;  count ++)
000156  2700              MOVS     r7,#0
000158  e000              B        |L3.348|
                  |L3.346|
00015a  1c7f              ADDS     r7,r7,#1
                  |L3.348|
00015c  f5b76ffa          CMP      r7,#0x7d0
000160  d3fb              BCC      |L3.346|
;;;261        {
;;;262        }
;;;263        /* Step 2. issue nop command. */
;;;264        base->DYNAMICCONTROL  = 0x00000183;
000162  f2401083          MOV      r0,#0x183
000166  6220              STR      r0,[r4,#0x20]
;;;265        for (count = 0; count < EMC_SDRAM_WAIT_CYCLES;  count ++)
000168  2700              MOVS     r7,#0
00016a  e000              B        |L3.366|
                  |L3.364|
00016c  1c7f              ADDS     r7,r7,#1
                  |L3.366|
00016e  f5b76ffa          CMP      r7,#0x7d0
000172  d3fb              BCC      |L3.364|
;;;266        {
;;;267        }
;;;268        /* Step 3. issue precharge all command. */
;;;269        base->DYNAMICCONTROL  = 0x00000103;
000174  f2401003          MOV      r0,#0x103
000178  6220              STR      r0,[r4,#0x20]
;;;270    
;;;271        /* Step 4. issue two auto-refresh command. */
;;;272        base->DYNAMICREFRESH = 2;
00017a  2002              MOVS     r0,#2
00017c  6260              STR      r0,[r4,#0x24]
;;;273        for (count = 0; count < EMC_SDRAM_WAIT_CYCLES/2; count ++)
00017e  2700              MOVS     r7,#0
000180  e000              B        |L3.388|
                  |L3.386|
000182  1c7f              ADDS     r7,r7,#1
                  |L3.388|
000184  f5b77f7a          CMP      r7,#0x3e8
000188  d3fb              BCC      |L3.386|
;;;274        {
;;;275        }
;;;276    
;;;277        base->DYNAMICREFRESH = EMC_CalculateTimerCycles(base, timing->refreshPeriod_Nanosec, 0)/EMC_REFRESH_CLOCK_PARAM;
00018a  2200              MOVS     r2,#0
00018c  4620              MOV      r0,r4
00018e  6871              LDR      r1,[r6,#4]
000190  f7fffffe          BL       EMC_CalculateTimerCycles
000194  0900              LSRS     r0,r0,#4
000196  6260              STR      r0,[r4,#0x24]
;;;278    
;;;279        /* Step 5. issue a mode command and set the mode value. */
;;;280        base->DYNAMICCONTROL  = 0x00000083;
000198  2083              MOVS     r0,#0x83
00019a  6220              STR      r0,[r4,#0x20]
;;;281    
;;;282        /* Calculate the mode settings here and to reach the 8 auto-refresh time requirement. */
;;;283        dynamicConfig = config;
00019c  4645              MOV      r5,r8
;;;284        for (count = 0; (count < totalChips) && (dynamicConfig != NULL); count ++)
00019e  2700              MOVS     r7,#0
0001a0  e015              B        |L3.462|
                  |L3.418|
;;;285        {
;;;286            /* Get the shift value first. */
;;;287            offset = EMC_ModeOffset(dynamicConfig->devAddrMap);
0001a2  7a28              LDRB     r0,[r5,#8]
0001a4  f7fffffe          BL       EMC_ModeOffset
0001a8  4682              MOV      r10,r0
;;;288            addr = (s_EMCDYCSBases[dynamicConfig->chipIndex] | 
0001aa  7828              LDRB     r0,[r5,#0]
0001ac  493d              LDR      r1,|L3.676|
0001ae  f8511020          LDR      r1,[r1,r0,LSL #2]
0001b2  88a8              LDRH     r0,[r5,#4]
0001b4  f42042c0          BIC      r2,r0,#0x6000
0001b8  fa02f20a          LSL      r2,r2,r10
0001bc  ea410b02          ORR      r11,r1,r2
;;;289                ((uint32_t)(dynamicConfig->sdramModeReg & ~EMC_SDRAM_BANKCS_BA_MASK ) << offset));
;;;290            /* Set the right mode setting value. */
;;;291            data = *(volatile uint32_t *)addr;
0001c0  f8db0000          LDR      r0,[r11,#0]
0001c4  9000              STR      r0,[sp,#0]
;;;292            data = data;
0001c6  9800              LDR      r0,[sp,#0]
0001c8  9000              STR      r0,[sp,#0]
;;;293            dynamicConfig ++;
0001ca  350a              ADDS     r5,r5,#0xa
0001cc  1c7f              ADDS     r7,r7,#1              ;284
                  |L3.462|
0001ce  454f              CMP      r7,r9                 ;284
0001d0  d201              BCS      |L3.470|
0001d2  2d00              CMP      r5,#0                 ;284
0001d4  d1e5              BNE      |L3.418|
                  |L3.470|
;;;294        }
;;;295    
;;;296        if (config->dynamicDevice)
0001d6  f8980001          LDRB     r0,[r8,#1]
0001da  b300              CBZ      r0,|L3.542|
;;;297        {
;;;298            /* Add extended mode register if the low-power sdram is used. */
;;;299            base->DYNAMICCONTROL  = 0x00000083;
0001dc  2083              MOVS     r0,#0x83
0001de  6220              STR      r0,[r4,#0x20]
;;;300            /* Calculate the mode settings for extended mode register. */
;;;301            dynamicConfig = config;
0001e0  4645              MOV      r5,r8
;;;302            for (count = 0; (count < totalChips) && (dynamicConfig != NULL); count ++)
0001e2  2700              MOVS     r7,#0
0001e4  e017              B        |L3.534|
                  |L3.486|
;;;303            {
;;;304                /* Get the shift value first. */
;;;305                offset = EMC_ModeOffset(dynamicConfig->devAddrMap);
0001e6  7a28              LDRB     r0,[r5,#8]
0001e8  f7fffffe          BL       EMC_ModeOffset
0001ec  4682              MOV      r10,r0
;;;306                addr = (s_EMCDYCSBases[dynamicConfig->chipIndex] | (((uint32_t)(dynamicConfig->sdramExtModeReg & ~EMC_SDRAM_BANKCS_BA_MASK) |
0001ee  7828              LDRB     r0,[r5,#0]
0001f0  492c              LDR      r1,|L3.676|
0001f2  f8510020          LDR      r0,[r1,r0,LSL #2]
0001f6  88e9              LDRH     r1,[r5,#6]
0001f8  f42141c0          BIC      r1,r1,#0x6000
0001fc  f4414180          ORR      r1,r1,#0x4000
000200  fa01f10a          LSL      r1,r1,r10
000204  ea400b01          ORR      r11,r0,r1
;;;307                    EMC_SDRAM_BANKCS_BA1_MASK) << offset));
;;;308                /* Set the right mode setting value. */
;;;309                data = *(volatile uint32_t *)addr;
000208  f8db0000          LDR      r0,[r11,#0]
00020c  9000              STR      r0,[sp,#0]
;;;310                data = data;
00020e  9800              LDR      r0,[sp,#0]
000210  9000              STR      r0,[sp,#0]
;;;311                dynamicConfig ++;
000212  350a              ADDS     r5,r5,#0xa
000214  1c7f              ADDS     r7,r7,#1              ;302
                  |L3.534|
000216  454f              CMP      r7,r9                 ;302
000218  d201              BCS      |L3.542|
00021a  2d00              CMP      r5,#0                 ;302
00021c  d1e3              BNE      |L3.486|
                  |L3.542|
;;;312            }        
;;;313        }
;;;314    
;;;315        /* Step 6. issue normal operation command. */
;;;316        base->DYNAMICCONTROL  = 0x00000000; /* Issue NORMAL command */
00021e  2000              MOVS     r0,#0
000220  6220              STR      r0,[r4,#0x20]
;;;317    
;;;318        /* The buffer shall be disabled when do the sdram initialization and
;;;319         * enabled after the initialization during normal opeation.
;;;320         */
;;;321        dynamicConfig = config;
000222  4645              MOV      r5,r8
;;;322        for (count = 0; (count < totalChips) && (dynamicConfig != NULL); count ++)
000224  2700              MOVS     r7,#0
000226  e00f              B        |L3.584|
                  |L3.552|
;;;323        {
;;;324            base->DYNAMIC[dynamicConfig->chipIndex].DYNAMICCONFIG |= EMC_DYNAMIC_DYNAMICCONFIG_B_MASK;        
000228  7829              LDRB     r1,[r5,#0]
00022a  f5047080          ADD      r0,r4,#0x100
00022e  eb001041          ADD      r0,r0,r1,LSL #5
000232  6800              LDR      r0,[r0,#0]
000234  f4402100          ORR      r1,r0,#0x80000
000238  782a              LDRB     r2,[r5,#0]
00023a  f5047080          ADD      r0,r4,#0x100
00023e  eb001042          ADD      r0,r0,r2,LSL #5
000242  6001              STR      r1,[r0,#0]
;;;325            dynamicConfig ++;
000244  350a              ADDS     r5,r5,#0xa
000246  1c7f              ADDS     r7,r7,#1              ;322
                  |L3.584|
000248  454f              CMP      r7,r9                 ;322
00024a  d201              BCS      |L3.592|
00024c  2d00              CMP      r5,#0                 ;322
00024e  d1eb              BNE      |L3.552|
                  |L3.592|
;;;326        }
;;;327    }
000250  e8bd9ffc          POP      {r2-r12,pc}
;;;328    
                          ENDP

                  |L3.596|
000254  5352435c          DCB      "SRC\\Drivers\\fsl_emc.c",0
000258  44726976
00025c  6572735c
000260  66736c5f
000264  656d632e
000268  6300    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L3.620|
00026c  636f6e66          DCB      "config",0
000270  696700  
000273  00                DCB      0
                  |L3.628|
000274  74696d69          DCB      "timing",0
000278  6e6700  
00027b  00                DCB      0
                  |L3.636|
00027c  746f7461          DCB      "totalChips <= EMC_DYNAMIC_MEMDEV_NUM",0
000280  6c436869
000284  7073203c
000288  3d20454d
00028c  435f4459
000290  4e414d49
000294  435f4d45
000298  4d444556
00029c  5f4e554d
0002a0  00      
0002a1  00                DCB      0
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L3.676|
                          DCD      s_EMCDYCSBases

                          AREA ||i.EMC_GetInstance||, CODE, READONLY, ALIGN=2

                  EMC_GetInstance PROC
;;;98     
;;;99     static uint32_t EMC_GetInstance(EMC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
000002  4605              MOV      r5,r0
;;;101        uint32_t instance;
;;;102    
;;;103        /* Find the instance index from base address mappings. */
;;;104        for (instance = 0; instance < FSL_FEATURE_SOC_EMC_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L4.22|
                  |L4.8|
;;;105        {
;;;106            if (s_EMCBases[instance] == base)
000008  4809              LDR      r0,|L4.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L4.20|
;;;107            {
;;;108                break;
000012  e002              B        |L4.26|
                  |L4.20|
000014  1c64              ADDS     r4,r4,#1              ;104
                  |L4.22|
000016  2c00              CMP      r4,#0                 ;104
000018  d0f6              BEQ      |L4.8|
                  |L4.26|
00001a  bf00              NOP      
;;;109            }
;;;110        }
;;;111    
;;;112        assert(instance < FSL_FEATURE_SOC_EMC_COUNT);
00001c  b904              CBNZ     r4,|L4.32|
00001e  e004              B        |L4.42|
                  |L4.32|
000020  2270              MOVS     r2,#0x70
000022  a104              ADR      r1,|L4.52|
000024  a009              ADR      r0,|L4.76|
000026  f7fffffe          BL       __aeabi_assert
                  |L4.42|
;;;113    
;;;114        return instance;
00002a  4620              MOV      r0,r4
;;;115    }
00002c  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      s_EMCBases
                  |L4.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_emc.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  656d632e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L4.76|
00004c  696e7374          DCB      "instance < FSL_FEATURE_SOC_EMC_COUNT",0
000050  616e6365
000054  203c2046
000058  534c5f46
00005c  45415455
000060  52455f53
000064  4f435f45
000068  4d435f43
00006c  4f554e54
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.EMC_Init||, CODE, READONLY, ALIGN=2

                  EMC_Init PROC
;;;197    
;;;198    void EMC_Init(EMC_Type *base, emc_basic_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;199    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;200        /* Enable EMC clock. */
;;;201        CLOCK_EnableClock((s_EMCClock[EMC_GetInstance(base)]));
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       EMC_GetInstance
00000c  4916              LDR      r1,|L5.104|
00000e  f8315010          LDRH     r5,[r1,r0,LSL #1]
000012  0a28              LSRS     r0,r5,#8
000014  2803              CMP      r0,#3
000016  d205              BCS      |L5.36|
000018  2101              MOVS     r1,#1
00001a  40a9              LSLS     r1,r1,r5
00001c  4a13              LDR      r2,|L5.108|
00001e  f8421020          STR      r1,[r2,r0,LSL #2]
000022  e005              B        |L5.48|
                  |L5.36|
000024  2101              MOVS     r1,#1
000026  078a              LSLS     r2,r1,#30
000028  64d1              STR      r1,[r2,#0x4c]
00002a  40a9              LSLS     r1,r1,r5
00002c  4a10              LDR      r2,|L5.112|
00002e  6151              STR      r1,[r2,#0x14]
                  |L5.48|
000030  bf00              NOP      
;;;202    
;;;203        /* Reset the EMC. */
;;;204        SYSCON->PRESETCTRL[2] |= SYSCON_PRESETCTRL_EMC_RESET_MASK;
000032  4810              LDR      r0,|L5.116|
000034  6800              LDR      r0,[r0,#0]
000036  f0400180          ORR      r1,r0,#0x80
00003a  480e              LDR      r0,|L5.116|
00003c  6001              STR      r1,[r0,#0]
;;;205        SYSCON->PRESETCTRL[2] &= ~ SYSCON_PRESETCTRL_EMC_RESET_MASK;
00003e  6800              LDR      r0,[r0,#0]
000040  f0200180          BIC      r1,r0,#0x80
000044  480b              LDR      r0,|L5.116|
000046  6001              STR      r1,[r0,#0]
;;;206        
;;;207        /* Set the EMC sytem configure. */
;;;208        SYSCON->EMCCLKDIV = SYSCON_EMCCLKDIV_DIV(config->emcClkDiv);
000048  78a0              LDRB     r0,[r4,#2]
00004a  490b              LDR      r1,|L5.120|
00004c  6008              STR      r0,[r1,#0]
;;;209    
;;;210        SYSCON->EMCSYSCTRL = SYSCON_EMCSYSCTRL_EMCFBCLKINSEL(config->fbClkSrc);
00004e  7860              LDRB     r0,[r4,#1]
000050  2108              MOVS     r1,#8
000052  ea0100c0          AND      r0,r1,r0,LSL #3
000056  4908              LDR      r1,|L5.120|
000058  318c              ADDS     r1,r1,#0x8c
00005a  6008              STR      r0,[r1,#0]
;;;211    
;;;212        /* Set the endian mode. */
;;;213        base->CONFIG = config->endian;
00005c  7820              LDRB     r0,[r4,#0]
00005e  60b0              STR      r0,[r6,#8]
;;;214        /* Enable the EMC module with normal memory map mode and normal work mode. */
;;;215        base->CONTROL = EMC_CONTROL_E_MASK;
000060  2001              MOVS     r0,#1
000062  6030              STR      r0,[r6,#0]
;;;216    }
000064  bd70              POP      {r4-r6,pc}
;;;217    
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      s_EMCClock
                  |L5.108|
                          DCD      0x40000220
                  |L5.112|
                          DCD      0x40040000
                  |L5.116|
                          DCD      0x40000108
                  |L5.120|
                          DCD      0x400003b8

                          AREA ||i.EMC_MirrorChipAddr||, CODE, READONLY, ALIGN=1

                  EMC_MirrorChipAddr PROC
;;;300     */
;;;301    static void EMC_MirrorChipAddr(EMC_Type *base, bool enable)
000000  b121              CBZ      r1,|L6.12|
;;;302    {
;;;303        if (enable) 
;;;304        {
;;;305            base->CONTROL |= EMC_CONTROL_M_MASK;
000002  6802              LDR      r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L6.20|
                  |L6.12|
;;;306        }
;;;307        else 
;;;308        {
;;;309            base->CONTROL &= ~EMC_CONTROL_M_MASK;
00000c  6802              LDR      r2,[r0,#0]
00000e  f0220202          BIC      r2,r2,#2
000012  6002              STR      r2,[r0,#0]
                  |L6.20|
;;;310        }
;;;311    }
000014  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||i.EMC_ModeOffset||, CODE, READONLY, ALIGN=1

                  EMC_ModeOffset PROC
;;;136    
;;;137    static uint32_t EMC_ModeOffset(uint32_t addrMap)
000000  4601              MOV      r1,r0
;;;138    {
;;;139        uint8_t offset = 0;
000002  2000              MOVS     r0,#0
;;;140        uint32_t columbase = addrMap & EMC_DYNCTL_COLUMNBASE_MASK;
000004  f0010203          AND      r2,r1,#3
;;;141    
;;;142        /* First calculate the column length. */
;;;143        if (columbase == 0x10)
000008  2a10              CMP      r2,#0x10
00000a  d101              BNE      |L7.16|
;;;144        {
;;;145            offset = 8;
00000c  2008              MOVS     r0,#8
00000e  e010              B        |L7.50|
                  |L7.16|
;;;146        }
;;;147        else
;;;148        {
;;;149            if (!columbase)
000010  b90a              CBNZ     r2,|L7.22|
;;;150            {
;;;151                offset = 9;          
000012  2009              MOVS     r0,#9
000014  e000              B        |L7.24|
                  |L7.22|
;;;152            }
;;;153            else
;;;154            {
;;;155                offset = 8;
000016  2008              MOVS     r0,#8
                  |L7.24|
;;;156            }
;;;157            /* Add column length increase check. */
;;;158            if (((addrMap & EMC_DYNCTL_COLUMNPLUS_MASK) >> EMC_DYNCTL_COLUMNPLUS_OFFSET) == 1)
000018  f3c103c1          UBFX     r3,r1,#3,#2
00001c  2b01              CMP      r3,#1
00001e  d102              BNE      |L7.38|
;;;159            {
;;;160                offset += 1;   
000020  1c43              ADDS     r3,r0,#1
000022  b2d8              UXTB     r0,r3
000024  e005              B        |L7.50|
                  |L7.38|
;;;161            }
;;;162            else if (((addrMap & EMC_DYNCTL_COLUMNPLUS_MASK) >> EMC_DYNCTL_COLUMNPLUS_OFFSET) == 2)
000026  f3c103c1          UBFX     r3,r1,#3,#2
00002a  2b02              CMP      r3,#2
00002c  d101              BNE      |L7.50|
;;;163            {
;;;164                offset += 2;
00002e  1c83              ADDS     r3,r0,#2
000030  b2d8              UXTB     r0,r3
                  |L7.50|
;;;165            }
;;;166            else
;;;167            {
;;;168                /* To avoid MISRA rule 14.10 error. */
;;;169            }        
;;;170        }
;;;171    
;;;172        /* Add Buswidth/16. */
;;;173        if (addrMap & EMC_DYNCTL_BUSWIDTH_MASK)
000032  f0010380          AND      r3,r1,#0x80
000036  b113              CBZ      r3,|L7.62|
;;;174        {
;;;175            offset += 2;
000038  1c83              ADDS     r3,r0,#2
00003a  b2d8              UXTB     r0,r3
00003c  e001              B        |L7.66|
                  |L7.62|
;;;176        }
;;;177        else
;;;178        {
;;;179            offset += 1;
00003e  1c43              ADDS     r3,r0,#1
000040  b2d8              UXTB     r0,r3
                  |L7.66|
;;;180        }
;;;181    
;;;182        /* Add bank select bit if the sdram address map mode is RBC(row-bank-column) mode. */
;;;183        if (!(addrMap & EMC_DYNCTL_BUSADDRMAP_MASK))
000042  f0010320          AND      r3,r1,#0x20
000046  b93b              CBNZ     r3,|L7.88|
;;;184        {
;;;185            if (!(addrMap & EMC_DYNCTL_DEVBANKS_BITS_MASK))
000048  f001031c          AND      r3,r1,#0x1c
00004c  b913              CBNZ     r3,|L7.84|
;;;186            {
;;;187              offset += 1; 
00004e  1c43              ADDS     r3,r0,#1
000050  b2d8              UXTB     r0,r3
000052  e001              B        |L7.88|
                  |L7.84|
;;;188            }
;;;189            else
;;;190            {
;;;191              offset += 2;
000054  1c83              ADDS     r3,r0,#2
000056  b2d8              UXTB     r0,r3
                  |L7.88|
;;;192            }
;;;193        }
;;;194    
;;;195        return offset;
;;;196    }
000058  4770              BX       lr
;;;197    
                          ENDP


                          AREA ||i.EMC_StaticMemInit||, CODE, READONLY, ALIGN=2

                  EMC_StaticMemInit PROC
;;;328    
;;;329    void EMC_StaticMemInit(EMC_Type *base, uint32_t *extWait_Ns, 
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;330             emc_static_chip_config_t *config, uint32_t totalChips)
;;;331    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;332        assert(config);
00000c  b107              CBZ      r7,|L8.16|
00000e  e005              B        |L8.28|
                  |L8.16|
000010  f44f72a6          MOV      r2,#0x14c
000014  a13c              ADR      r1,|L8.264|
000016  a042              ADR      r0,|L8.288|
000018  f7fffffe          BL       __aeabi_assert
                  |L8.28|
;;;333    
;;;334        uint32_t count;
;;;335        emc_static_chip_config_t *staticConfig = config;
00001c  463c              MOV      r4,r7
;;;336    
;;;337        /* Initialize extended wait. */
;;;338        if (extWait_Ns)
00001e  f1b80f00          CMP      r8,#0
000022  d01a              BEQ      |L8.90|
;;;339        {   
;;;340            for (count = 0; (count < totalChips) && (staticConfig != NULL); count ++)
000024  2600              MOVS     r6,#0
000026  e00b              B        |L8.64|
                  |L8.40|
;;;341            {
;;;342                assert(staticConfig->specailConfig & kEMC_AsynchronosPageEnable);
000028  7920              LDRB     r0,[r4,#4]
00002a  f0000008          AND      r0,r0,#8
00002e  b100              CBZ      r0,|L8.50|
000030  e005              B        |L8.62|
                  |L8.50|
000032  f44f72ab          MOV      r2,#0x156
000036  a134              ADR      r1,|L8.264|
000038  a03b              ADR      r0,|L8.296|
00003a  f7fffffe          BL       __aeabi_assert
                  |L8.62|
00003e  1c76              ADDS     r6,r6,#1              ;340
                  |L8.64|
000040  454e              CMP      r6,r9                 ;340
000042  d201              BCS      |L8.72|
000044  2c00              CMP      r4,#0                 ;340
000046  d1ef              BNE      |L8.40|
                  |L8.72|
;;;343            }
;;;344    
;;;345            base->STATICEXTENDEDWAIT = EMC_CalculateTimerCycles(base, *extWait_Ns, 1);
000048  2201              MOVS     r2,#1
00004a  4628              MOV      r0,r5
00004c  f8d81000          LDR      r1,[r8,#0]
000050  f7fffffe          BL       EMC_CalculateTimerCycles
000054  f8c50080          STR      r0,[r5,#0x80]
;;;346            staticConfig ++;
000058  3420              ADDS     r4,r4,#0x20
                  |L8.90|
;;;347        }
;;;348    
;;;349        /* Initialize the static memory chip specific configure. */
;;;350        staticConfig = config;
00005a  463c              MOV      r4,r7
;;;351        for (count = 0; (count < totalChips) && (staticConfig != NULL); count ++)
00005c  2600              MOVS     r6,#0
00005e  e04c              B        |L8.250|
                  |L8.96|
;;;352        {
;;;353    
;;;354            base->STATIC[staticConfig->chipIndex].STATICCONFIG = 
000060  7861              LDRB     r1,[r4,#1]
000062  6860              LDR      r0,[r4,#4]
000064  4308              ORRS     r0,r0,r1
000066  7822              LDRB     r2,[r4,#0]
000068  f5057100          ADD      r1,r5,#0x200
00006c  eb011142          ADD      r1,r1,r2,LSL #5
000070  6008              STR      r0,[r1,#0]
;;;355                (staticConfig->specailConfig | staticConfig->memWidth);
;;;356            base->STATIC[staticConfig->chipIndex].STATICWAITWEN =
000072  2201              MOVS     r2,#1
000074  4628              MOV      r0,r5
000076  68a1              LDR      r1,[r4,#8]
000078  f7fffffe          BL       EMC_CalculateTimerCycles
00007c  7822              LDRB     r2,[r4,#0]
00007e  f5057100          ADD      r1,r5,#0x200
000082  eb011142          ADD      r1,r1,r2,LSL #5
000086  6048              STR      r0,[r1,#4]
;;;357                EMC_CalculateTimerCycles(base, staticConfig->tWaitWriteEn_Ns, 1);
;;;358            base->STATIC[staticConfig->chipIndex].STATICWAITOEN = 
000088  2200              MOVS     r2,#0
00008a  4628              MOV      r0,r5
00008c  68e1              LDR      r1,[r4,#0xc]
00008e  f7fffffe          BL       EMC_CalculateTimerCycles
000092  7822              LDRB     r2,[r4,#0]
000094  f5057100          ADD      r1,r5,#0x200
000098  eb011142          ADD      r1,r1,r2,LSL #5
00009c  6088              STR      r0,[r1,#8]
;;;359                EMC_CalculateTimerCycles(base, staticConfig->tWaitOutEn_Ns, 0);
;;;360            base->STATIC[staticConfig->chipIndex].STATICWAITRD = 
00009e  2201              MOVS     r2,#1
0000a0  4628              MOV      r0,r5
0000a2  6921              LDR      r1,[r4,#0x10]
0000a4  f7fffffe          BL       EMC_CalculateTimerCycles
0000a8  7822              LDRB     r2,[r4,#0]
0000aa  f5057100          ADD      r1,r5,#0x200
0000ae  eb011142          ADD      r1,r1,r2,LSL #5
0000b2  60c8              STR      r0,[r1,#0xc]
;;;361                EMC_CalculateTimerCycles(base, staticConfig->tWaitReadNoPage_Ns, 1);
;;;362            base->STATIC[staticConfig->chipIndex].STATICWAITPAGE = 
0000b4  2201              MOVS     r2,#1
0000b6  4628              MOV      r0,r5
0000b8  6961              LDR      r1,[r4,#0x14]
0000ba  f7fffffe          BL       EMC_CalculateTimerCycles
0000be  7822              LDRB     r2,[r4,#0]
0000c0  f5057100          ADD      r1,r5,#0x200
0000c4  eb011142          ADD      r1,r1,r2,LSL #5
0000c8  6108              STR      r0,[r1,#0x10]
;;;363                EMC_CalculateTimerCycles(base, staticConfig->tWaitReadPage_Ns, 1);
;;;364            base->STATIC[staticConfig->chipIndex].STATICWAITWR = 
0000ca  2202              MOVS     r2,#2
0000cc  4628              MOV      r0,r5
0000ce  69a1              LDR      r1,[r4,#0x18]
0000d0  f7fffffe          BL       EMC_CalculateTimerCycles
0000d4  7822              LDRB     r2,[r4,#0]
0000d6  f5057100          ADD      r1,r5,#0x200
0000da  eb011142          ADD      r1,r1,r2,LSL #5
0000de  6148              STR      r0,[r1,#0x14]
;;;365                EMC_CalculateTimerCycles(base, staticConfig->tWaitWrite_Ns, 2);
;;;366            base->STATIC[staticConfig->chipIndex].STATICWAITTURN = 
0000e0  2201              MOVS     r2,#1
0000e2  4628              MOV      r0,r5
0000e4  69e1              LDR      r1,[r4,#0x1c]
0000e6  f7fffffe          BL       EMC_CalculateTimerCycles
0000ea  7822              LDRB     r2,[r4,#0]
0000ec  f5057100          ADD      r1,r5,#0x200
0000f0  eb011142          ADD      r1,r1,r2,LSL #5
0000f4  6188              STR      r0,[r1,#0x18]
;;;367                EMC_CalculateTimerCycles(base, staticConfig->tWaitTurn_Ns, 1);
;;;368            
;;;369            staticConfig ++;
0000f6  3420              ADDS     r4,r4,#0x20
0000f8  1c76              ADDS     r6,r6,#1              ;351
                  |L8.250|
0000fa  454e              CMP      r6,r9                 ;351
0000fc  d201              BCS      |L8.258|
0000fe  2c00              CMP      r4,#0                 ;351
000100  d1ae              BNE      |L8.96|
                  |L8.258|
;;;370        }
;;;371    }   
000102  e8bd87f0          POP      {r4-r10,pc}
;;;372    
                          ENDP

000106  0000              DCW      0x0000
                  |L8.264|
000108  5352435c          DCB      "SRC\\Drivers\\fsl_emc.c",0
00010c  44726976
000110  6572735c
000114  66736c5f
000118  656d632e
00011c  6300    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L8.288|
000120  636f6e66          DCB      "config",0
000124  696700  
000127  00                DCB      0
                  |L8.296|
000128  73746174          DCB      "staticConfig->specailConfig & kEMC_AsynchronosPageEnabl"
00012c  6963436f
000130  6e666967
000134  2d3e7370
000138  65636169
00013c  6c436f6e
000140  66696720
000144  26206b45
000148  4d435f41
00014c  73796e63
000150  68726f6e
000154  6f735061
000158  6765456e
00015c  61626c  
00015f  6500              DCB      "e",0
000161  00                DCB      0
000162  00                DCB      0
000163  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_EMCClock
000000  0207              DCW      0x0207
000002  0000              DCB      0x00,0x00
                  s_EMCBases
                          DCD      0x40081000

                          AREA ||.data||, DATA, ALIGN=2

                  s_EMCDYCSBases
                          DCD      0xa0000000
                          DCD      0xb0000000
                          DCD      0xc0000000
                          DCD      0xd0000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_emc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_emc_c_EMC_Init____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_emc_c_EMC_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_emc_c_EMC_Init____REVSH|
#line 402
|__asm___9_fsl_emc_c_EMC_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_emc_c_EMC_Init____RRX|
#line 587
|__asm___9_fsl_emc_c_EMC_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
