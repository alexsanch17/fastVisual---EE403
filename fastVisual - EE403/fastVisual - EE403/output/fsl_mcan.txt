; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_mcan.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_mcan.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_mcan.crf SRC\Drivers\fsl_mcan.c]
                          THUMB

                          AREA ||i.CAN0_IRQ0_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  CAN0_IRQ0_DriverIRQHandler PROC
;;;797    #if (FSL_FEATURE_SOC_LPC_CAN_COUNT > 0)
;;;798    void CAN0_IRQ0_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;799    {
;;;800        assert(s_mcanHandle[0]);
000002  4808              LDR      r0,|L1.36|
000004  6800              LDR      r0,[r0,#0]  ; s_mcanHandle
000006  b100              CBZ      r0,|L1.10|
000008  e005              B        |L1.22|
                  |L1.10|
00000a  f44f7248          MOV      r2,#0x320
00000e  a106              ADR      r1,|L1.40|
000010  a00b              ADR      r0,|L1.64|
000012  f7fffffe          BL       __aeabi_assert
                  |L1.22|
;;;801    
;;;802        s_mcanIsr(CAN0, s_mcanHandle[0]);
000016  4803              LDR      r0,|L1.36|
000018  6801              LDR      r1,[r0,#0]  ; s_mcanHandle
00001a  480d              LDR      r0,|L1.80|
00001c  4a0d              LDR      r2,|L1.84|
00001e  6812              LDR      r2,[r2,#0]  ; s_mcanIsr
000020  4790              BLX      r2
;;;803    }
000022  bd10              POP      {r4,pc}
;;;804    
                          ENDP

                  |L1.36|
                          DCD      s_mcanHandle
                  |L1.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  6d63616e
00003c  2e6300  
00003f  00                DCB      0
                  |L1.64|
000040  735f6d63          DCB      "s_mcanHandle[0]",0
000044  616e4861
000048  6e646c65
00004c  5b305d00
                  |L1.80|
                          DCD      0x4009d000
                  |L1.84|
                          DCD      s_mcanIsr

                          AREA ||i.CAN0_IRQ1_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  CAN0_IRQ1_DriverIRQHandler PROC
;;;804    
;;;805    void CAN0_IRQ1_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;806    {
;;;807        assert(s_mcanHandle[0]);
000002  4808              LDR      r0,|L2.36|
000004  6800              LDR      r0,[r0,#0]  ; s_mcanHandle
000006  b100              CBZ      r0,|L2.10|
000008  e005              B        |L2.22|
                  |L2.10|
00000a  f2403227          MOV      r2,#0x327
00000e  a106              ADR      r1,|L2.40|
000010  a00b              ADR      r0,|L2.64|
000012  f7fffffe          BL       __aeabi_assert
                  |L2.22|
;;;808    
;;;809        s_mcanIsr(CAN0, s_mcanHandle[0]);
000016  4803              LDR      r0,|L2.36|
000018  6801              LDR      r1,[r0,#0]  ; s_mcanHandle
00001a  480d              LDR      r0,|L2.80|
00001c  4a0d              LDR      r2,|L2.84|
00001e  6812              LDR      r2,[r2,#0]  ; s_mcanIsr
000020  4790              BLX      r2
;;;810    }
000022  bd10              POP      {r4,pc}
;;;811    #endif
                          ENDP

                  |L2.36|
                          DCD      s_mcanHandle
                  |L2.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  6d63616e
00003c  2e6300  
00003f  00                DCB      0
                  |L2.64|
000040  735f6d63          DCB      "s_mcanHandle[0]",0
000044  616e4861
000048  6e646c65
00004c  5b305d00
                  |L2.80|
                          DCD      0x4009d000
                  |L2.84|
                          DCD      s_mcanIsr

                          AREA ||i.CAN1_IRQ0_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  CAN1_IRQ0_DriverIRQHandler PROC
;;;813    #if (FSL_FEATURE_SOC_LPC_CAN_COUNT > 1)
;;;814    void CAN1_IRQ0_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;815    {
;;;816        assert(s_mcanHandle[1]);
000002  4808              LDR      r0,|L3.36|
000004  6840              LDR      r0,[r0,#4]  ; s_mcanHandle
000006  b100              CBZ      r0,|L3.10|
000008  e005              B        |L3.22|
                  |L3.10|
00000a  f44f724c          MOV      r2,#0x330
00000e  a106              ADR      r1,|L3.40|
000010  a00b              ADR      r0,|L3.64|
000012  f7fffffe          BL       __aeabi_assert
                  |L3.22|
;;;817    
;;;818        s_mcanIsr(CAN1, s_mcanHandle[1]);
000016  4803              LDR      r0,|L3.36|
000018  6841              LDR      r1,[r0,#4]  ; s_mcanHandle
00001a  480d              LDR      r0,|L3.80|
00001c  4a0d              LDR      r2,|L3.84|
00001e  6812              LDR      r2,[r2,#0]  ; s_mcanIsr
000020  4790              BLX      r2
;;;819    }
000022  bd10              POP      {r4,pc}
;;;820    
                          ENDP

                  |L3.36|
                          DCD      s_mcanHandle
                  |L3.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  6d63616e
00003c  2e6300  
00003f  00                DCB      0
                  |L3.64|
000040  735f6d63          DCB      "s_mcanHandle[1]",0
000044  616e4861
000048  6e646c65
00004c  5b315d00
                  |L3.80|
                          DCD      0x4009e000
                  |L3.84|
                          DCD      s_mcanIsr

                          AREA ||i.CAN1_IRQ1_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  CAN1_IRQ1_DriverIRQHandler PROC
;;;820    
;;;821    void CAN1_IRQ1_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;822    {
;;;823        assert(s_mcanHandle[1]);
000002  4808              LDR      r0,|L4.36|
000004  6840              LDR      r0,[r0,#4]  ; s_mcanHandle
000006  b100              CBZ      r0,|L4.10|
000008  e005              B        |L4.22|
                  |L4.10|
00000a  f2403237          MOV      r2,#0x337
00000e  a106              ADR      r1,|L4.40|
000010  a00b              ADR      r0,|L4.64|
000012  f7fffffe          BL       __aeabi_assert
                  |L4.22|
;;;824    
;;;825        s_mcanIsr(CAN1, s_mcanHandle[1]);
000016  4803              LDR      r0,|L4.36|
000018  6841              LDR      r1,[r0,#4]  ; s_mcanHandle
00001a  480d              LDR      r0,|L4.80|
00001c  4a0d              LDR      r2,|L4.84|
00001e  6812              LDR      r2,[r2,#0]  ; s_mcanIsr
000020  4790              BLX      r2
;;;826    }
000022  bd10              POP      {r4,pc}
;;;827    #endif
                          ENDP

                  |L4.36|
                          DCD      s_mcanHandle
                  |L4.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  6d63616e
00003c  2e6300  
00003f  00                DCB      0
                  |L4.64|
000040  735f6d63          DCB      "s_mcanHandle[1]",0
000044  616e4861
000048  6e646c65
00004c  5b315d00
                  |L4.80|
                          DCD      0x4009e000
                  |L4.84|
                          DCD      s_mcanIsr

                          AREA ||i.EnableIRQ||, CODE, READONLY, ALIGN=1

                  EnableIRQ PROC
;;;198     */
;;;199    static inline void EnableIRQ(IRQn_Type interrupt)
000000  f1100f80          CMN      r0,#0x80
;;;200    {
;;;201        if (NotAvail_IRQn == interrupt)
000004  d100              BNE      |L5.8|
                  |L5.6|
;;;202        {
;;;203            return;
;;;204        }
;;;205    
;;;206    #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
;;;207        if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
;;;208    #endif
;;;209        {
;;;210            NVIC_EnableIRQ(interrupt);
;;;211        }
;;;212    }
000006  4770              BX       lr
                  |L5.8|
000008  bf00              NOP                            ;210
00000a  f000021f          AND      r2,r0,#0x1f           ;210
00000e  2101              MOVS     r1,#1                 ;210
000010  4091              LSLS     r1,r1,r2              ;210
000012  0942              LSRS     r2,r0,#5              ;210
000014  0092              LSLS     r2,r2,#2              ;210
000016  f10222e0          ADD      r2,r2,#0xe000e000     ;210
00001a  f8c21100          STR      r1,[r2,#0x100]        ;210
00001e  bf00              NOP                            ;210
000020  bf00              NOP      
000022  e7f0              B        |L5.6|
;;;213    
                          ENDP


                          AREA ||i.MCAN_ClearStatusFlag||, CODE, READONLY, ALIGN=1

                  MCAN_ClearStatusFlag PROC
;;;659     */
;;;660    static inline void MCAN_ClearStatusFlag(CAN_Type *base, uint32_t mask)
000000  6d02              LDR      r2,[r0,#0x50]
;;;661    {
;;;662        /* Write 1 to clear status flag. */
;;;663        base->IR |= mask;
000002  430a              ORRS     r2,r2,r1
000004  6502              STR      r2,[r0,#0x50]
;;;664    }
000006  4770              BX       lr
;;;665    
                          ENDP


                          AREA ||i.MCAN_Deinit||, CODE, READONLY, ALIGN=2

                  MCAN_Deinit PROC
;;;254    
;;;255    void MCAN_Deinit(CAN_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
;;;257        /* Reset all Register Contents. */
;;;258        MCAN_Reset(base);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       MCAN_Reset
;;;259    
;;;260    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;261        /* Disable MCAN clock. */
;;;262        CLOCK_DisableClock(s_mcanClock[MCAN_GetInstance(base)]);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       MCAN_GetInstance
000010  490a              LDR      r1,|L7.60|
000012  f8314010          LDRH     r4,[r1,r0,LSL #1]
000016  0a20              LSRS     r0,r4,#8
000018  2803              CMP      r0,#3
00001a  d205              BCS      |L7.40|
00001c  2101              MOVS     r1,#1
00001e  40a1              LSLS     r1,r1,r4
000020  4a07              LDR      r2,|L7.64|
000022  f8421020          STR      r1,[r2,r0,LSL #2]
000026  e006              B        |L7.54|
                  |L7.40|
000028  2101              MOVS     r1,#1
00002a  40a1              LSLS     r1,r1,r4
00002c  4a05              LDR      r2,|L7.68|
00002e  6191              STR      r1,[r2,#0x18]
000030  2100              MOVS     r1,#0
000032  0312              LSLS     r2,r2,#12
000034  64d1              STR      r1,[r2,#0x4c]
                  |L7.54|
000036  bf00              NOP      
;;;263    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;264    }
000038  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      s_mcanClock
                  |L7.64|
                          DCD      0x40000240
                  |L7.68|
                          DCD      0x40040000

                          AREA ||i.MCAN_DisableInterrupts||, CODE, READONLY, ALIGN=1

                  MCAN_DisableInterrupts PROC
;;;776     */
;;;777    static inline void MCAN_DisableInterrupts(CAN_Type *base, uint32_t mask)
000000  6d42              LDR      r2,[r0,#0x54]
;;;778    {
;;;779        base->IE &= ~mask;
000002  438a              BICS     r2,r2,r1
000004  6542              STR      r2,[r0,#0x54]
;;;780    }
000006  4770              BX       lr
;;;781    
                          ENDP


                          AREA ||i.MCAN_EnableInterrupts||, CODE, READONLY, ALIGN=1

                  MCAN_EnableInterrupts PROC
;;;727     */
;;;728    static inline void MCAN_EnableInterrupts(CAN_Type *base, uint32_t line, uint32_t mask)
000000  b510              PUSH     {r4,lr}
;;;729    {
;;;730        base->ILE |= (1U << line);
000002  6dc3              LDR      r3,[r0,#0x5c]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  4323              ORRS     r3,r3,r4
00000a  65c3              STR      r3,[r0,#0x5c]
;;;731        if (0 == line)
00000c  b919              CBNZ     r1,|L9.22|
;;;732        {
;;;733            base->ILS &= ~mask;
00000e  6d83              LDR      r3,[r0,#0x58]
000010  4393              BICS     r3,r3,r2
000012  6583              STR      r3,[r0,#0x58]
000014  e002              B        |L9.28|
                  |L9.22|
;;;734        }
;;;735        else
;;;736        {
;;;737            base->ILS |= mask;
000016  6d83              LDR      r3,[r0,#0x58]
000018  4313              ORRS     r3,r3,r2
00001a  6583              STR      r3,[r0,#0x58]
                  |L9.28|
;;;738        }
;;;739        base->IE |= mask;
00001c  6d43              LDR      r3,[r0,#0x54]
00001e  4313              ORRS     r3,r3,r2
000020  6543              STR      r3,[r0,#0x54]
;;;740    }
000022  bd10              POP      {r4,pc}
;;;741    
                          ENDP


                          AREA ||i.MCAN_EnterNormalMode||, CODE, READONLY, ALIGN=1

                  MCAN_EnterNormalMode PROC
;;;265    
;;;266    void MCAN_EnterNormalMode(CAN_Type *base)
000000  6981              LDR      r1,[r0,#0x18]
;;;267    {
;;;268        /* Reset INIT bit to enter normal mode. */
;;;269        base->CCCR &= ~CAN_CCCR_INIT_MASK;
000002  f0210101          BIC      r1,r1,#1
000006  6181              STR      r1,[r0,#0x18]
;;;270        while(((base->CCCR & CAN_CCCR_INIT_MASK) >> CAN_CCCR_INIT_SHIFT))
000008  bf00              NOP      
                  |L10.10|
00000a  6981              LDR      r1,[r0,#0x18]
00000c  f0010101          AND      r1,r1,#1
000010  2900              CMP      r1,#0
000012  d1fa              BNE      |L10.10|
;;;271        {
;;;272        }
;;;273    }
000014  4770              BX       lr
;;;274    
                          ENDP


                          AREA ||i.MCAN_GetDefaultConfig||, CODE, READONLY, ALIGN=2

                  MCAN_GetDefaultConfig PROC
;;;274    
;;;275    void MCAN_GetDefaultConfig(mcan_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;276    {
000002  4604              MOV      r4,r0
;;;277        /* Assertion. */
;;;278        assert(config);
000004  b104              CBZ      r4,|L11.8|
000006  e005              B        |L11.20|
                  |L11.8|
000008  f44f728b          MOV      r2,#0x116
00000c  a106              ADR      r1,|L11.40|
00000e  a00c              ADR      r0,|L11.64|
000010  f7fffffe          BL       __aeabi_assert
                  |L11.20|
;;;279    
;;;280        /* Initialize MCAN Module config struct with default value. */
;;;281        config->baudRateA = 500000U;
000014  480c              LDR      r0,|L11.72|
000016  6020              STR      r0,[r4,#0]
;;;282        config->baudRateD = 500000U;
000018  6060              STR      r0,[r4,#4]
;;;283        config->enableCanfdNormal = false;
00001a  2000              MOVS     r0,#0
00001c  7220              STRB     r0,[r4,#8]
;;;284        config->enableCanfdSwitch = false;
00001e  7260              STRB     r0,[r4,#9]
;;;285        config->enableLoopBackInt = false;
000020  72a0              STRB     r0,[r4,#0xa]
;;;286        config->enableLoopBackExt = false;
000022  72e0              STRB     r0,[r4,#0xb]
;;;287        config->enableBusMon = false;
000024  7320              STRB     r0,[r4,#0xc]
;;;288    }
000026  bd10              POP      {r4,pc}
;;;289    
                          ENDP

                  |L11.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  6d63616e
00003c  2e6300  
00003f  00                DCB      0
                  |L11.64|
000040  636f6e66          DCB      "config",0
000044  696700  
000047  00                DCB      0
                  |L11.72|
                          DCD      0x0007a120

                          AREA ||i.MCAN_GetInstance||, CODE, READONLY, ALIGN=2

                  MCAN_GetInstance PROC
;;;140    
;;;141    uint32_t MCAN_GetInstance(CAN_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
000002  4605              MOV      r5,r0
;;;143        uint32_t instance;
;;;144    
;;;145        /* Find the instance index from base address mappings. */
;;;146        for (instance = 0; instance < FSL_FEATURE_SOC_LPC_CAN_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L12.22|
                  |L12.8|
;;;147        {
;;;148            if (s_mcanBases[instance] == base)
000008  4809              LDR      r0,|L12.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L12.20|
;;;149            {
;;;150                break;
000012  e002              B        |L12.26|
                  |L12.20|
000014  1c64              ADDS     r4,r4,#1              ;146
                  |L12.22|
000016  2c02              CMP      r4,#2                 ;146
000018  d3f6              BCC      |L12.8|
                  |L12.26|
00001a  bf00              NOP      
;;;151            }
;;;152        }
;;;153    
;;;154        assert(instance < FSL_FEATURE_SOC_LPC_CAN_COUNT);
00001c  2c02              CMP      r4,#2
00001e  d200              BCS      |L12.34|
000020  e004              B        |L12.44|
                  |L12.34|
000022  229a              MOVS     r2,#0x9a
000024  a103              ADR      r1,|L12.52|
000026  a009              ADR      r0,|L12.76|
000028  f7fffffe          BL       __aeabi_assert
                  |L12.44|
;;;155    
;;;156        return instance;
00002c  4620              MOV      r0,r4
;;;157    }
00002e  bd70              POP      {r4-r6,pc}
;;;158    
                          ENDP

                  |L12.48|
                          DCD      s_mcanBases
                  |L12.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  6d63616e
000048  2e6300  
00004b  00                DCB      0
                  |L12.76|
00004c  696e7374          DCB      "instance < FSL_FEATURE_SOC_LPC_CAN_COUNT",0
000050  616e6365
000054  203c2046
000058  534c5f46
00005c  45415455
000060  52455f53
000064  4f435f4c
000068  50435f43
00006c  414e5f43
000070  4f554e54
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.MCAN_GetMsgRAMBase||, CODE, READONLY, ALIGN=1

                  MCAN_GetMsgRAMBase PROC
;;;503     */
;;;504    static inline uint32_t MCAN_GetMsgRAMBase(CAN_Type *base)
000000  4601              MOV      r1,r0
;;;505    {
;;;506        return base->MRBA;
000002  f8d10200          LDR      r0,[r1,#0x200]
;;;507    }
000006  4770              BX       lr
;;;508    
                          ENDP


                          AREA ||i.MCAN_GetRxBufferElementAddress||, CODE, READONLY, ALIGN=2

                  MCAN_GetRxBufferElementAddress PROC
;;;426    
;;;427    static uint32_t MCAN_GetRxBufferElementAddress(CAN_Type *base, uint8_t idx)
000000  b570              PUSH     {r4-r6,lr}
;;;428    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;429        assert(idx <= 63U);
000006  2e3f              CMP      r6,#0x3f
000008  d800              BHI      |L14.12|
00000a  e005              B        |L14.24|
                  |L14.12|
00000c  f24012ad          MOV      r2,#0x1ad
000010  a10c              ADR      r1,|L14.68|
000012  a012              ADR      r0,|L14.92|
000014  f7fffffe          BL       __aeabi_assert
                  |L14.24|
;;;430        uint32_t eSize;
;;;431        eSize = (base->RXESC & CAN_RXESC_RBDS_MASK) >> CAN_RXESC_RBDS_SHIFT;
000018  f8d500bc          LDR      r0,[r5,#0xbc]
00001c  f3c02402          UBFX     r4,r0,#8,#3
;;;432        if (eSize < 5U)
000020  2c05              CMP      r4,#5
000022  d201              BCS      |L14.40|
;;;433        {
;;;434            eSize += 4U;
000024  1d24              ADDS     r4,r4,#4
000026  e002              B        |L14.46|
                  |L14.40|
;;;435        }
;;;436        else
;;;437        {
;;;438            eSize = eSize * 4U - 10U;
000028  200a              MOVS     r0,#0xa
00002a  ebc00484          RSB      r4,r0,r4,LSL #2
                  |L14.46|
;;;439        }
;;;440        return (base->RXBC & CAN_RXBC_RBSA_MASK) + idx * eSize * 4U;
00002e  f8d510ac          LDR      r1,[r5,#0xac]
000032  f64f70fc          MOV      r0,#0xfffc
000036  4001              ANDS     r1,r1,r0
000038  fb06f004          MUL      r0,r6,r4
00003c  eb010080          ADD      r0,r1,r0,LSL #2
;;;441    }
000040  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  6d63616e
000058  2e6300  
00005b  00                DCB      0
                  |L14.92|
00005c  69647820          DCB      "idx <= 63U",0
000060  3c3d2036
000064  335500  
000067  00                DCB      0

                          AREA ||i.MCAN_GetRxFifo0ElementAddress||, CODE, READONLY, ALIGN=1

                  MCAN_GetRxFifo0ElementAddress PROC
;;;394    
;;;395    static uint32_t MCAN_GetRxFifo0ElementAddress(CAN_Type *base)
000000  4602              MOV      r2,r0
;;;396    {
;;;397        uint32_t eSize;
;;;398        eSize = (base->RXESC & CAN_RXESC_F0DS_MASK) >> CAN_RXESC_F0DS_SHIFT;
000002  f8d200bc          LDR      r0,[r2,#0xbc]
000006  f0000107          AND      r1,r0,#7
;;;399        if (eSize < 5U)
00000a  2905              CMP      r1,#5
00000c  d201              BCS      |L15.18|
;;;400        {
;;;401            eSize += 4U;
00000e  1d09              ADDS     r1,r1,#4
000010  e002              B        |L15.24|
                  |L15.18|
;;;402        }
;;;403        else
;;;404        {
;;;405            eSize = eSize * 4U - 10U;
000012  200a              MOVS     r0,#0xa
000014  ebc00181          RSB      r1,r0,r1,LSL #2
                  |L15.24|
;;;406        }
;;;407        return (base->RXF0C & CAN_RXF0C_F0SA_MASK) +
000018  f8d230a0          LDR      r3,[r2,#0xa0]
00001c  f64f70fc          MOV      r0,#0xfffc
000020  4003              ANDS     r3,r3,r0
000022  f8d200a4          LDR      r0,[r2,#0xa4]
000026  f3c02005          UBFX     r0,r0,#8,#6
00002a  4348              MULS     r0,r1,r0
00002c  eb030080          ADD      r0,r3,r0,LSL #2
;;;408            ((base->RXF0S & CAN_RXF0S_F0GI_MASK) >> CAN_RXF0S_F0GI_SHIFT) * eSize * 4U;
;;;409    }
000030  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.MCAN_GetRxFifo1ElementAddress||, CODE, READONLY, ALIGN=1

                  MCAN_GetRxFifo1ElementAddress PROC
;;;410    
;;;411    static uint32_t MCAN_GetRxFifo1ElementAddress(CAN_Type *base)
000000  4602              MOV      r2,r0
;;;412    {
;;;413        uint32_t eSize;
;;;414        eSize = (base->RXESC & CAN_RXESC_F1DS_MASK) >> CAN_RXESC_F1DS_SHIFT;
000002  f8d200bc          LDR      r0,[r2,#0xbc]
000006  f3c01102          UBFX     r1,r0,#4,#3
;;;415        if (eSize < 5U)
00000a  2905              CMP      r1,#5
00000c  d201              BCS      |L16.18|
;;;416        {
;;;417            eSize += 4U;
00000e  1d09              ADDS     r1,r1,#4
000010  e002              B        |L16.24|
                  |L16.18|
;;;418        }
;;;419        else
;;;420        {
;;;421            eSize = eSize * 4U - 10U;
000012  200a              MOVS     r0,#0xa
000014  ebc00181          RSB      r1,r0,r1,LSL #2
                  |L16.24|
;;;422        }
;;;423        return (base->RXF1C & CAN_RXF1C_F1SA_MASK) +
000018  f8d230b0          LDR      r3,[r2,#0xb0]
00001c  f64f70fc          MOV      r0,#0xfffc
000020  4003              ANDS     r3,r3,r0
000022  f8d200b4          LDR      r0,[r2,#0xb4]
000026  f3c02005          UBFX     r0,r0,#8,#6
00002a  4348              MULS     r0,r1,r0
00002c  eb030080          ADD      r0,r3,r0,LSL #2
;;;424            ((base->RXF1S & CAN_RXF1S_F1GI_MASK) >> CAN_RXF1S_F1GI_SHIFT) * eSize * 4U;
;;;425    }
000030  4770              BX       lr
;;;426    
                          ENDP


                          AREA ||i.MCAN_GetStatusFlag||, CODE, READONLY, ALIGN=1

                  MCAN_GetStatusFlag PROC
;;;646     */
;;;647    static inline uint32_t MCAN_GetStatusFlag(CAN_Type *base, uint32_t mask)
000000  4602              MOV      r2,r0
;;;648    {
;;;649        return (bool)(base->IR & mask);
000002  6d10              LDR      r0,[r2,#0x50]
000004  4008              ANDS     r0,r0,r1
000006  b108              CBZ      r0,|L17.12|
000008  2001              MOVS     r0,#1
                  |L17.10|
;;;650    }
00000a  4770              BX       lr
                  |L17.12|
00000c  2000              MOVS     r0,#0                 ;649
00000e  e7fc              B        |L17.10|
;;;651    
                          ENDP


                          AREA ||i.MCAN_GetTxBufferElementAddress||, CODE, READONLY, ALIGN=2

                  MCAN_GetTxBufferElementAddress PROC
;;;442    
;;;443    static uint32_t MCAN_GetTxBufferElementAddress(CAN_Type *base, uint8_t idx)
000000  b570              PUSH     {r4-r6,lr}
;;;444    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;445        assert(idx <= 31U);
000006  2e1f              CMP      r6,#0x1f
000008  d800              BHI      |L18.12|
00000a  e005              B        |L18.24|
                  |L18.12|
00000c  f24012bd          MOV      r2,#0x1bd
000010  a10c              ADR      r1,|L18.68|
000012  a012              ADR      r0,|L18.92|
000014  f7fffffe          BL       __aeabi_assert
                  |L18.24|
;;;446        uint32_t eSize;
;;;447        eSize = (base->TXESC & CAN_TXESC_TBDS_MASK) >> CAN_TXESC_TBDS_SHIFT;
000018  f8d500c8          LDR      r0,[r5,#0xc8]
00001c  f0000407          AND      r4,r0,#7
;;;448        if (eSize < 5U)
000020  2c05              CMP      r4,#5
000022  d201              BCS      |L18.40|
;;;449        {
;;;450            eSize += 4U;
000024  1d24              ADDS     r4,r4,#4
000026  e002              B        |L18.46|
                  |L18.40|
;;;451        }
;;;452        else
;;;453        {
;;;454            eSize = eSize * 4U - 10U;
000028  200a              MOVS     r0,#0xa
00002a  ebc00484          RSB      r4,r0,r4,LSL #2
                  |L18.46|
;;;455        }
;;;456        return (base->TXBC & CAN_TXBC_TBSA_MASK) + idx * eSize * 4U;
00002e  f8d510c0          LDR      r1,[r5,#0xc0]
000032  f64f70fc          MOV      r0,#0xfffc
000036  4001              ANDS     r1,r1,r0
000038  fb06f004          MUL      r0,r6,r4
00003c  eb010080          ADD      r0,r1,r0,LSL #2
;;;457    }
000040  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP

000042  0000              DCW      0x0000
                  |L18.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  6d63616e
000058  2e6300  
00005b  00                DCB      0
                  |L18.92|
00005c  69647820          DCB      "idx <= 31U",0
000060  3c3d2033
000064  315500  
000067  00                DCB      0

                          AREA ||i.MCAN_Init||, CODE, READONLY, ALIGN=2

                  MCAN_Init PROC
;;;218    
;;;219    void MCAN_Init(CAN_Type *base, const mcan_config_t *config, uint32_t sourceClock_Hz)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;220    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;221    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;222        /* Enable MCAN clock. */
;;;223        CLOCK_EnableClock(s_mcanClock[MCAN_GetInstance(base)]);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       MCAN_GetInstance
000010  4921              LDR      r1,|L19.152|
000012  f8316010          LDRH     r6,[r1,r0,LSL #1]
000016  0a30              LSRS     r0,r6,#8
000018  2803              CMP      r0,#3
00001a  d205              BCS      |L19.40|
00001c  2101              MOVS     r1,#1
00001e  40b1              LSLS     r1,r1,r6
000020  4a1e              LDR      r2,|L19.156|
000022  f8421020          STR      r1,[r2,r0,LSL #2]
000026  e005              B        |L19.52|
                  |L19.40|
000028  2101              MOVS     r1,#1
00002a  078a              LSLS     r2,r1,#30
00002c  64d1              STR      r1,[r2,#0x4c]
00002e  40b1              LSLS     r1,r1,r6
000030  4a1b              LDR      r2,|L19.160|
000032  6151              STR      r1,[r2,#0x14]
                  |L19.52|
000034  bf00              NOP      
;;;224    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;225    
;;;226        MCAN_Reset(base);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       MCAN_Reset
;;;227    
;;;228        if (config->enableLoopBackInt)
00003c  7aa8              LDRB     r0,[r5,#0xa]
00003e  b138              CBZ      r0,|L19.80|
;;;229        {
;;;230            base->CCCR |= CAN_CCCR_TEST_MASK | CAN_CCCR_MON_MASK;
000040  69a0              LDR      r0,[r4,#0x18]
000042  f04000a0          ORR      r0,r0,#0xa0
000046  61a0              STR      r0,[r4,#0x18]
;;;231            base->TEST |= CAN_TEST_LBCK_MASK;
000048  6920              LDR      r0,[r4,#0x10]
00004a  f0400010          ORR      r0,r0,#0x10
00004e  6120              STR      r0,[r4,#0x10]
                  |L19.80|
;;;232        }
;;;233        if (config->enableLoopBackExt)
000050  7ae8              LDRB     r0,[r5,#0xb]
000052  b138              CBZ      r0,|L19.100|
;;;234        {
;;;235            base->CCCR |= CAN_CCCR_TEST_MASK;
000054  69a0              LDR      r0,[r4,#0x18]
000056  f0400080          ORR      r0,r0,#0x80
00005a  61a0              STR      r0,[r4,#0x18]
;;;236            base->TEST |= CAN_TEST_LBCK_MASK;
00005c  6920              LDR      r0,[r4,#0x10]
00005e  f0400010          ORR      r0,r0,#0x10
000062  6120              STR      r0,[r4,#0x10]
                  |L19.100|
;;;237        }
;;;238        if (config->enableBusMon)
000064  7b28              LDRB     r0,[r5,#0xc]
000066  b118              CBZ      r0,|L19.112|
;;;239        {
;;;240            base->CCCR |= CAN_CCCR_MON_MASK;
000068  69a0              LDR      r0,[r4,#0x18]
00006a  f0400020          ORR      r0,r0,#0x20
00006e  61a0              STR      r0,[r4,#0x18]
                  |L19.112|
;;;241        }
;;;242        if (config->enableCanfdNormal)
000070  7a28              LDRB     r0,[r5,#8]
000072  b118              CBZ      r0,|L19.124|
;;;243        {
;;;244            base->CCCR |= CAN_CCCR_FDOE_MASK;
000074  69a0              LDR      r0,[r4,#0x18]
000076  f4407080          ORR      r0,r0,#0x100
00007a  61a0              STR      r0,[r4,#0x18]
                  |L19.124|
;;;245        }
;;;246        if (config->enableCanfdSwitch)
00007c  7a68              LDRB     r0,[r5,#9]
00007e  b118              CBZ      r0,|L19.136|
;;;247        {
;;;248            base->CCCR |= CAN_CCCR_FDOE_MASK | CAN_CCCR_BRSE_MASK;
000080  69a0              LDR      r0,[r4,#0x18]
000082  f4407040          ORR      r0,r0,#0x300
000086  61a0              STR      r0,[r4,#0x18]
                  |L19.136|
;;;249        }
;;;250    
;;;251        /* Set baud rate of arbitration and data phase. */
;;;252        MCAN_SetBaudRate(base, sourceClock_Hz, config->baudRateA, config->baudRateD);
000088  4639              MOV      r1,r7
00008a  4620              MOV      r0,r4
00008c  e9d52300          LDRD     r2,r3,[r5,#0]
000090  f7fffffe          BL       MCAN_SetBaudRate
;;;253    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;254    
                          ENDP

                  |L19.152|
                          DCD      s_mcanClock
                  |L19.156|
                          DCD      0x40000220
                  |L19.160|
                          DCD      0x40040000

                          AREA ||i.MCAN_IsTransmitOccurred||, CODE, READONLY, ALIGN=1

                  MCAN_IsTransmitOccurred PROC
;;;464    
;;;465    uint32_t MCAN_IsTransmitOccurred(CAN_Type *base, uint8_t idx)
000000  4602              MOV      r2,r0
;;;466    {
;;;467        return (base->TXBTO & (uint32_t)(1U << idx)) >> (uint32_t)idx;
000002  f8d200d8          LDR      r0,[r2,#0xd8]
000006  2301              MOVS     r3,#1
000008  408b              LSLS     r3,r3,r1
00000a  4018              ANDS     r0,r0,r3
00000c  40c8              LSRS     r0,r0,r1
;;;468    }
00000e  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.MCAN_IsTransmitRequestPending||, CODE, READONLY, ALIGN=1

                  MCAN_IsTransmitRequestPending PROC
;;;459    
;;;460    uint32_t MCAN_IsTransmitRequestPending(CAN_Type *base, uint8_t idx)
000000  4602              MOV      r2,r0
;;;461    {
;;;462        return (base->TXBRP & (uint32_t)(1U << idx)) >> (uint32_t)idx;
000002  f8d200cc          LDR      r0,[r2,#0xcc]
000006  2301              MOVS     r3,#1
000008  408b              LSLS     r3,r3,r1
00000a  4018              ANDS     r0,r0,r3
00000c  40c8              LSRS     r0,r0,r1
;;;463    }
00000e  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.MCAN_ReadRxBuffer||, CODE, READONLY, ALIGN=1

                  MCAN_ReadRxBuffer PROC
;;;488    
;;;489    status_t MCAN_ReadRxBuffer(CAN_Type *base, uint8_t idx, mcan_rx_buffer_frame_t *rxFrame)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;490    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;491        mcan_rx_buffer_frame_t *elementAddress = 0;
00000a  2700              MOVS     r7,#0
;;;492        elementAddress = (mcan_rx_buffer_frame_t *)(MCAN_GetMsgRAMBase(base) + MCAN_GetRxBufferElementAddress(base, idx));
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       MCAN_GetMsgRAMBase
000012  4680              MOV      r8,r0
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       MCAN_GetRxBufferElementAddress
00001c  eb080700          ADD      r7,r8,r0
;;;493        memcpy(rxFrame, elementAddress, (rxFrame->size + 8U) * 4U);
000020  7b20              LDRB     r0,[r4,#0xc]
000022  3008              ADDS     r0,r0,#8
000024  0082              LSLS     r2,r0,#2
000026  4639              MOV      r1,r7
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       __aeabi_memcpy4
;;;494        return kStatus_Success;
00002e  2000              MOVS     r0,#0
;;;495    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;496    
                          ENDP


                          AREA ||i.MCAN_ReadRxFifo||, CODE, READONLY, ALIGN=2

                  MCAN_ReadRxFifo PROC
;;;496    
;;;497    status_t MCAN_ReadRxFifo(CAN_Type *base, uint8_t fifoBlock, mcan_rx_buffer_frame_t *rxFrame)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;498    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;499        assert((fifoBlock == 0) || (fifoBlock == 1U));
00000a  b10d              CBZ      r5,|L23.16|
00000c  2d01              CMP      r5,#1
00000e  d100              BNE      |L23.18|
                  |L23.16|
000010  e005              B        |L23.30|
                  |L23.18|
000012  f24012f3          MOV      r2,#0x1f3
000016  a118              ADR      r1,|L23.120|
000018  a01d              ADR      r0,|L23.144|
00001a  f7fffffe          BL       __aeabi_assert
                  |L23.30|
;;;500        mcan_rx_buffer_frame_t *elementAddress = 0;
00001e  2700              MOVS     r7,#0
;;;501        if(0 == fifoBlock)
000020  b94d              CBNZ     r5,|L23.54|
;;;502        {
;;;503            elementAddress = (mcan_rx_buffer_frame_t *)(MCAN_GetMsgRAMBase(base) + MCAN_GetRxFifo0ElementAddress(base));
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       MCAN_GetMsgRAMBase
000028  4680              MOV      r8,r0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       MCAN_GetRxFifo0ElementAddress
000030  eb080700          ADD      r7,r8,r0
000034  e008              B        |L23.72|
                  |L23.54|
;;;504        }
;;;505        else
;;;506        {
;;;507            elementAddress = (mcan_rx_buffer_frame_t *)(MCAN_GetMsgRAMBase(base) + MCAN_GetRxFifo1ElementAddress(base));
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       MCAN_GetMsgRAMBase
00003c  4680              MOV      r8,r0
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       MCAN_GetRxFifo1ElementAddress
000044  eb080700          ADD      r7,r8,r0
                  |L23.72|
;;;508        }
;;;509        memcpy(rxFrame, elementAddress, 8U);
000048  e9d70100          LDRD     r0,r1,[r7,#0]
00004c  e9c60100          STRD     r0,r1,[r6,#0]
;;;510        rxFrame->data = (uint8_t *)elementAddress + 8U;
000050  f1070008          ADD      r0,r7,#8
000054  60b0              STR      r0,[r6,#8]
;;;511        /* Acknowledge the read. */
;;;512        if(0 == fifoBlock)
000056  b935              CBNZ     r5,|L23.102|
;;;513        {
;;;514            base->RXF0A = (base->RXF0S & CAN_RXF0S_F0GI_MASK) >> CAN_RXF0S_F0GI_SHIFT;
000058  f8d400a4          LDR      r0,[r4,#0xa4]
00005c  f3c02005          UBFX     r0,r0,#8,#6
000060  f8c400a8          STR      r0,[r4,#0xa8]
000064  e005              B        |L23.114|
                  |L23.102|
;;;515        }
;;;516        else
;;;517        {
;;;518            base->RXF1A = (base->RXF1S & CAN_RXF1S_F1GI_MASK) >> CAN_RXF1S_F1GI_SHIFT;
000066  f8d400b4          LDR      r0,[r4,#0xb4]
00006a  f3c02005          UBFX     r0,r0,#8,#6
00006e  f8c400b8          STR      r0,[r4,#0xb8]
                  |L23.114|
;;;519        }
;;;520        return kStatus_Success;
000072  2000              MOVS     r0,#0
;;;521    }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;522    
                          ENDP

                  |L23.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  6d63616e
00008c  2e6300  
00008f  00                DCB      0
                  |L23.144|
000090  28666966          DCB      "(fifoBlock == 0) || (fifoBlock == 1U)",0
000094  6f426c6f
000098  636b203d
00009c  3d203029
0000a0  207c7c20
0000a4  28666966
0000a8  6f426c6f
0000ac  636b203d
0000b0  3d203155
0000b4  2900    
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.MCAN_Reset||, CODE, READONLY, ALIGN=1

                  MCAN_Reset PROC
;;;158    
;;;159    static void MCAN_Reset(CAN_Type *base)
000000  6981              LDR      r1,[r0,#0x18]
;;;160    {
;;;161        /* Set INIT bit. */
;;;162        base->CCCR |= CAN_CCCR_INIT_MASK;
000002  f0410101          ORR      r1,r1,#1
000006  6181              STR      r1,[r0,#0x18]
;;;163        /* Confirm the value has been accepted. */
;;;164        while(!((base->CCCR & CAN_CCCR_INIT_MASK) >> CAN_CCCR_INIT_SHIFT))
000008  bf00              NOP      
                  |L24.10|
00000a  6981              LDR      r1,[r0,#0x18]
00000c  f0010101          AND      r1,r1,#1
000010  2900              CMP      r1,#0
000012  d0fa              BEQ      |L24.10|
;;;165        {
;;;166        }
;;;167    
;;;168        /* Set CCE bit to have access to the protected configuration registers,
;;;169           and clear some status registers. */
;;;170        base->CCCR |= CAN_CCCR_CCE_MASK;
000014  6981              LDR      r1,[r0,#0x18]
000016  f0410102          ORR      r1,r1,#2
00001a  6181              STR      r1,[r0,#0x18]
;;;171    }
00001c  4770              BX       lr
;;;172    
                          ENDP


                          AREA ||i.MCAN_SetArbitrationTimingConfig||, CODE, READONLY, ALIGN=2

                  MCAN_SetArbitrationTimingConfig PROC
;;;304    
;;;305    void MCAN_SetArbitrationTimingConfig(CAN_Type *base, const mcan_timing_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;306    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;307        /* Assertion. */
;;;308        assert(config);
000006  b104              CBZ      r4,|L25.10|
000008  e005              B        |L25.22|
                  |L25.10|
00000a  f44f729a          MOV      r2,#0x134
00000e  a110              ADR      r1,|L25.80|
000010  a015              ADR      r0,|L25.104|
000012  f7fffffe          BL       __aeabi_assert
                  |L25.22|
;;;309    
;;;310        /* Cleaning previous Timing Setting. */
;;;311        base->NBTP &= ~(CAN_NBTP_NSJW_MASK | CAN_NBTP_NTSEG2_MASK |
000016  69e8              LDR      r0,[r5,#0x1c]
000018  f0000080          AND      r0,r0,#0x80
00001c  61e8              STR      r0,[r5,#0x1c]
;;;312            CAN_NBTP_NTSEG1_MASK | CAN_NBTP_NBRP_MASK);
;;;313    
;;;314        /* Updating Timing Setting according to configuration structure. */
;;;315        base->NBTP |=
00001e  8820              LDRH     r0,[r4,#0]
000020  4913              LDR      r1,|L25.112|
000022  ea014000          AND      r0,r1,r0,LSL #16
000026  78a1              LDRB     r1,[r4,#2]
000028  f04f427e          MOV      r2,#0xfe000000
00002c  ea026141          AND      r1,r2,r1,LSL #25
000030  4308              ORRS     r0,r0,r1
000032  78e1              LDRB     r1,[r4,#3]
000034  f44f427f          MOV      r2,#0xff00
000038  ea022101          AND      r1,r2,r1,LSL #8
00003c  4308              ORRS     r0,r0,r1
00003e  7921              LDRB     r1,[r4,#4]
000040  f001017f          AND      r1,r1,#0x7f
000044  4308              ORRS     r0,r0,r1
000046  69e9              LDR      r1,[r5,#0x1c]
000048  4308              ORRS     r0,r0,r1
00004a  61e8              STR      r0,[r5,#0x1c]
;;;316            (CAN_NBTP_NBRP(config->preDivider) | CAN_NBTP_NSJW(config->rJumpwidth) |
;;;317             CAN_NBTP_NTSEG1(config->seg1) | CAN_NBTP_NTSEG2(config->seg2));
;;;318    }
00004c  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP

00004e  0000              DCW      0x0000
                  |L25.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  6d63616e
000064  2e6300  
000067  00                DCB      0
                  |L25.104|
000068  636f6e66          DCB      "config",0
00006c  696700  
00006f  00                DCB      0
                  |L25.112|
                          DCD      0x01ff0000

                          AREA ||i.MCAN_SetBaudRate||, CODE, READONLY, ALIGN=1

                  MCAN_SetBaudRate PROC
;;;172    
;;;173    static void MCAN_SetBaudRate(CAN_Type *base, uint32_t sourceClock_Hz,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;174        uint32_t baudRateA_Bps, uint32_t baudRateD_Bps)
;;;175    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;176        mcan_timing_config_t timingConfigA, timingConfigD;
;;;177        uint32_t preDivA = baudRateA_Bps * MCAN_TIME_QUANTA_NUM;
00000c  013c              LSLS     r4,r7,#4
;;;178        uint32_t preDivD = baudRateD_Bps * MCAN_TIME_QUANTA_NUM;
00000e  ea4f1508          LSL      r5,r8,#4
;;;179    
;;;180        if (0 == preDivA)
000012  b904              CBNZ     r4,|L26.22|
;;;181        {
;;;182            preDivA = 1U;
000014  2401              MOVS     r4,#1
                  |L26.22|
;;;183        }
;;;184        if (0 == preDivD)
000016  b905              CBNZ     r5,|L26.26|
;;;185        {
;;;186            preDivD = 1U;
000018  2501              MOVS     r5,#1
                  |L26.26|
;;;187        }
;;;188    
;;;189        preDivA = (sourceClock_Hz / preDivA) - 1U;
00001a  fbb6f0f4          UDIV     r0,r6,r4
00001e  1e44              SUBS     r4,r0,#1
;;;190        preDivD = (sourceClock_Hz / preDivD) - 1U;
000020  fbb6f0f5          UDIV     r0,r6,r5
000024  1e45              SUBS     r5,r0,#1
;;;191    
;;;192        /* Desired baud rate is too low. */
;;;193        if (preDivA > 0x1FFU)
000026  f5b47f00          CMP      r4,#0x200
00002a  d301              BCC      |L26.48|
;;;194        {
;;;195            preDivA = 0x1FFU;
00002c  f24014ff          MOV      r4,#0x1ff
                  |L26.48|
;;;196        }
;;;197        if (preDivD > 0x1FU)
000030  2d1f              CMP      r5,#0x1f
000032  d900              BLS      |L26.54|
;;;198        {
;;;199            preDivD = 0x1FU;
000034  251f              MOVS     r5,#0x1f
                  |L26.54|
;;;200        }
;;;201    
;;;202        /* MCAN timing setting formula:
;;;203         * MCAN_TIME_QUANTA_NUM = 1 + (xTSEG1 + 1) + (xTSEG2 + 1));
;;;204         */
;;;205        timingConfigA.preDivider = preDivA;
000036  b2a0              UXTH     r0,r4
000038  f8ad0008          STRH     r0,[sp,#8]
;;;206        timingConfigA.seg1 = 0xAU;
00003c  200a              MOVS     r0,#0xa
00003e  f88d000b          STRB     r0,[sp,#0xb]
;;;207        timingConfigA.seg2 = 0x3U;
000042  2003              MOVS     r0,#3
000044  f88d000c          STRB     r0,[sp,#0xc]
;;;208        timingConfigA.rJumpwidth = 0x3U;
000048  f88d000a          STRB     r0,[sp,#0xa]
;;;209        timingConfigD.preDivider = preDivD;
00004c  b2a8              UXTH     r0,r5
00004e  f8ad0000          STRH     r0,[sp,#0]
;;;210        timingConfigD.seg1 = 0xAU;
000052  200a              MOVS     r0,#0xa
000054  f88d0003          STRB     r0,[sp,#3]
;;;211        timingConfigD.seg2 = 0x3U;
000058  2003              MOVS     r0,#3
00005a  f88d0004          STRB     r0,[sp,#4]
;;;212        timingConfigD.rJumpwidth = 0x3U;
00005e  f88d0002          STRB     r0,[sp,#2]
;;;213    
;;;214        /* Update actual timing characteristic. */
;;;215        MCAN_SetArbitrationTimingConfig(base, &timingConfigA);
000062  a902              ADD      r1,sp,#8
000064  4648              MOV      r0,r9
000066  f7fffffe          BL       MCAN_SetArbitrationTimingConfig
;;;216        MCAN_SetDataTimingConfig(base, &timingConfigD);
00006a  4669              MOV      r1,sp
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       MCAN_SetDataTimingConfig
;;;217    }
000072  e8bd87ff          POP      {r0-r10,pc}
;;;218    
                          ENDP


                          AREA ||i.MCAN_SetDataTimingConfig||, CODE, READONLY, ALIGN=2

                  MCAN_SetDataTimingConfig PROC
;;;289    
;;;290    void MCAN_SetDataTimingConfig(CAN_Type *base, const mcan_timing_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;292        /* Assertion. */
;;;293        assert(config);
000006  b104              CBZ      r4,|L27.10|
000008  e005              B        |L27.22|
                  |L27.10|
00000a  f2401225          MOV      r2,#0x125
00000e  a110              ADR      r1,|L27.80|
000010  a015              ADR      r0,|L27.104|
000012  f7fffffe          BL       __aeabi_assert
                  |L27.22|
;;;294    
;;;295        /* Cleaning previous Timing Setting. */
;;;296        base->DBTP &= ~(CAN_DBTP_DSJW_MASK | CAN_DBTP_DTSEG2_MASK |
000016  68e8              LDR      r0,[r5,#0xc]
000018  4915              LDR      r1,|L27.112|
00001a  4008              ANDS     r0,r0,r1
00001c  60e8              STR      r0,[r5,#0xc]
;;;297            CAN_DBTP_DTSEG1_MASK | CAN_DBTP_DBRP_MASK);
;;;298    
;;;299        /* Updating Timing Setting according to configuration structure. */
;;;300        base->DBTP |=
00001e  8820              LDRH     r0,[r4,#0]
000020  f44f11f8          MOV      r1,#0x1f0000
000024  ea014000          AND      r0,r1,r0,LSL #16
000028  78a1              LDRB     r1,[r4,#2]
00002a  f001010f          AND      r1,r1,#0xf
00002e  4308              ORRS     r0,r0,r1
000030  78e1              LDRB     r1,[r4,#3]
000032  f44f52f8          MOV      r2,#0x1f00
000036  ea022101          AND      r1,r2,r1,LSL #8
00003a  4308              ORRS     r0,r0,r1
00003c  7921              LDRB     r1,[r4,#4]
00003e  22f0              MOVS     r2,#0xf0
000040  ea021101          AND      r1,r2,r1,LSL #4
000044  4308              ORRS     r0,r0,r1
000046  68e9              LDR      r1,[r5,#0xc]
000048  4308              ORRS     r0,r0,r1
00004a  60e8              STR      r0,[r5,#0xc]
;;;301            (CAN_DBTP_DBRP(config->preDivider) | CAN_DBTP_DSJW(config->rJumpwidth) |
;;;302             CAN_DBTP_DTSEG1(config->seg1) | CAN_DBTP_DTSEG2(config->seg2));
;;;303    }
00004c  bd70              POP      {r4-r6,pc}
;;;304    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  6d63616e
000064  2e6300  
000067  00                DCB      0
                  |L27.104|
000068  636f6e66          DCB      "config",0
00006c  696700  
00006f  00                DCB      0
                  |L27.112|
                          DCD      0xffe0e000

                          AREA ||i.MCAN_SetEXTFilterElement||, CODE, READONLY, ALIGN=1

                  MCAN_SetEXTFilterElement PROC
;;;386    
;;;387    void MCAN_SetEXTFilterElement(CAN_Type *base, const mcan_frame_filter_config_t *config,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;388                                  const mcan_ext_filter_element_config_t *filter, uint8_t idx)
;;;389    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;390        uint8_t *elementAddress = 0;
00000c  f04f0800          MOV      r8,#0
;;;391        elementAddress = (uint8_t *)(MCAN_GetMsgRAMBase(base) + config->address + idx * 8U);
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       MCAN_GetMsgRAMBase
000016  6829              LDR      r1,[r5,#0]
000018  4408              ADD      r0,r0,r1
00001a  eb0008c4          ADD      r8,r0,r4,LSL #3
;;;392        memcpy(elementAddress, filter, sizeof(filter));
00001e  6830              LDR      r0,[r6,#0]
000020  f8c80000          STR      r0,[r8,#0]
;;;393    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;394    
                          ENDP


                          AREA ||i.MCAN_SetFilterConfig||, CODE, READONLY, ALIGN=1

                  MCAN_SetFilterConfig PROC
;;;319    
;;;320    void MCAN_SetFilterConfig(CAN_Type *base, const mcan_frame_filter_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;321    {
;;;322        /* Set global configuration of remote/nonmasking frames, set filter address and list size. */
;;;323        if (config->idFormat == kMCAN_FrameIDStandard)
000002  7a0a              LDRB     r2,[r1,#8]
000004  b9ea              CBNZ     r2,|L29.66|
;;;324        {
;;;325            base->GFC |= CAN_GFC_RRFS(config->remFrame) | CAN_GFC_ANFS(config->nmFrame);
000006  7a4a              LDRB     r2,[r1,#9]
000008  2302              MOVS     r3,#2
00000a  ea030242          AND      r2,r3,r2,LSL #1
00000e  7a8b              LDRB     r3,[r1,#0xa]
000010  2430              MOVS     r4,#0x30
000012  ea041303          AND      r3,r4,r3,LSL #4
000016  431a              ORRS     r2,r2,r3
000018  f8503f80          LDR      r3,[r0,#0x80]!
00001c  431a              ORRS     r2,r2,r3
00001e  6002              STR      r2,[r0,#0]
;;;326            base->SIDFC |= CAN_SIDFC_FLSSA(config->address >> CAN_SIDFC_FLSSA_SHIFT) | CAN_SIDFC_LSS(config->listSize);
000020  680a              LDR      r2,[r1,#0]
000022  0892              LSRS     r2,r2,#2
000024  f64f73fc          MOV      r3,#0xfffc
000028  ea030282          AND      r2,r3,r2,LSL #2
00002c  888b              LDRH     r3,[r1,#4]
00002e  f44f047f          MOV      r4,#0xff0000
000032  ea044303          AND      r3,r4,r3,LSL #16
000036  431a              ORRS     r2,r2,r3
000038  6843              LDR      r3,[r0,#4]
00003a  431a              ORRS     r2,r2,r3
00003c  6042              STR      r2,[r0,#4]
00003e  3880              SUBS     r0,r0,#0x80
000040  e01b              B        |L29.122|
                  |L29.66|
;;;327        }
;;;328        else
;;;329        {
;;;330            base->GFC |= CAN_GFC_RRFE(config->remFrame) | CAN_GFC_ANFE(config->nmFrame);
000042  7a4a              LDRB     r2,[r1,#9]
000044  f0020201          AND      r2,r2,#1
000048  7a8b              LDRB     r3,[r1,#0xa]
00004a  240c              MOVS     r4,#0xc
00004c  ea040383          AND      r3,r4,r3,LSL #2
000050  431a              ORRS     r2,r2,r3
000052  f8503f80          LDR      r3,[r0,#0x80]!
000056  431a              ORRS     r2,r2,r3
000058  6002              STR      r2,[r0,#0]
;;;331            base->XIDFC |= CAN_XIDFC_FLESA(config->address >> CAN_XIDFC_FLESA_SHIFT) | CAN_XIDFC_LSE(config->listSize);
00005a  680a              LDR      r2,[r1,#0]
00005c  0892              LSRS     r2,r2,#2
00005e  f64f73fc          MOV      r3,#0xfffc
000062  ea030282          AND      r2,r3,r2,LSL #2
000066  888b              LDRH     r3,[r1,#4]
000068  f44f047f          MOV      r4,#0xff0000
00006c  ea044303          AND      r3,r4,r3,LSL #16
000070  431a              ORRS     r2,r2,r3
000072  6883              LDR      r3,[r0,#8]
000074  431a              ORRS     r2,r2,r3
000076  6082              STR      r2,[r0,#8]
000078  3880              SUBS     r0,r0,#0x80
                  |L29.122|
;;;332        }
;;;333    }
00007a  bd10              POP      {r4,pc}
;;;334    
                          ENDP


                          AREA ||i.MCAN_SetRxBufferConfig||, CODE, READONLY, ALIGN=1

                  MCAN_SetRxBufferConfig PROC
;;;352    
;;;353    void MCAN_SetRxBufferConfig(CAN_Type *base, const mcan_rx_buffer_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;354    {
;;;355        /* Set Rx Buffer start address. */
;;;356        base->RXBC |= CAN_RXBC_RBSA(config->address >> CAN_RXBC_RBSA_SHIFT);
000002  f8502fac          LDR      r2,[r0,#0xac]!
000006  680b              LDR      r3,[r1,#0]
000008  089b              LSRS     r3,r3,#2
00000a  f64f74fc          MOV      r4,#0xfffc
00000e  ea040383          AND      r3,r4,r3,LSL #2
000012  431a              ORRS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
;;;357        /* Set Rx Buffer data field size */
;;;358        base->RXESC |= CAN_RXESC_RBDS(config->datafieldSize);
000016  6902              LDR      r2,[r0,#0x10]
000018  790b              LDRB     r3,[r1,#4]
00001a  f44f64e0          MOV      r4,#0x700
00001e  ea042303          AND      r3,r4,r3,LSL #8
000022  431a              ORRS     r2,r2,r3
000024  6102              STR      r2,[r0,#0x10]
000026  38ac              SUBS     r0,r0,#0xac
;;;359    }
000028  bd10              POP      {r4,pc}
;;;360    
                          ENDP


                          AREA ||i.MCAN_SetRxFifo0Config||, CODE, READONLY, ALIGN=1

                  MCAN_SetRxFifo0Config PROC
;;;334    
;;;335    void MCAN_SetRxFifo0Config(CAN_Type *base, const mcan_rx_fifo_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;336    {
;;;337        /* Set Rx FIFO 0 start address, element size, watermark, operation mode. */
;;;338        base->RXF0C |= CAN_RXF0C_F0SA(config->address >> CAN_RXF0C_F0SA_SHIFT) | CAN_RXF0C_F0S(config->elementSize) |
000002  680a              LDR      r2,[r1,#0]
000004  0892              LSRS     r2,r2,#2
000006  f64f73fc          MOV      r3,#0xfffc
00000a  ea030282          AND      r2,r3,r2,LSL #2
00000e  888b              LDRH     r3,[r1,#4]
000010  f44f04fe          MOV      r4,#0x7f0000
000014  ea044303          AND      r3,r4,r3,LSL #16
000018  431a              ORRS     r2,r2,r3
00001a  7a0b              LDRB     r3,[r1,#8]
00001c  0224              LSLS     r4,r4,#8
00001e  ea046303          AND      r3,r4,r3,LSL #24
000022  431a              ORRS     r2,r2,r3
000024  7b0b              LDRB     r3,[r1,#0xc]
000026  01e4              LSLS     r4,r4,#7
000028  ea0473c3          AND      r3,r4,r3,LSL #31
00002c  431a              ORRS     r2,r2,r3
00002e  f8503fa0          LDR      r3,[r0,#0xa0]!
000032  431a              ORRS     r2,r2,r3
000034  6002              STR      r2,[r0,#0]
;;;339            CAN_RXF0C_F0WM(config->watermark) | CAN_RXF0C_F0OM(config->opmode);
;;;340        /* Set Rx FIFO 0 data field size */
;;;341        base->RXESC |= CAN_RXESC_F0DS(config->datafieldSize);
000036  69c2              LDR      r2,[r0,#0x1c]
000038  7b4b              LDRB     r3,[r1,#0xd]
00003a  f0030307          AND      r3,r3,#7
00003e  431a              ORRS     r2,r2,r3
000040  61c2              STR      r2,[r0,#0x1c]
000042  38a0              SUBS     r0,r0,#0xa0
;;;342    }
000044  bd10              POP      {r4,pc}
;;;343    
                          ENDP


                          AREA ||i.MCAN_SetRxFifo1Config||, CODE, READONLY, ALIGN=1

                  MCAN_SetRxFifo1Config PROC
;;;343    
;;;344    void MCAN_SetRxFifo1Config(CAN_Type *base, const mcan_rx_fifo_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;345    {
;;;346        /* Set Rx FIFO 1 start address, element size, watermark, operation mode. */
;;;347        base->RXF1C |= CAN_RXF1C_F1SA(config->address >> CAN_RXF1C_F1SA_SHIFT) | CAN_RXF1C_F1S(config->elementSize) |
000002  680a              LDR      r2,[r1,#0]
000004  0892              LSRS     r2,r2,#2
000006  f64f73fc          MOV      r3,#0xfffc
00000a  ea030282          AND      r2,r3,r2,LSL #2
00000e  888b              LDRH     r3,[r1,#4]
000010  f44f04fe          MOV      r4,#0x7f0000
000014  ea044303          AND      r3,r4,r3,LSL #16
000018  431a              ORRS     r2,r2,r3
00001a  7a0b              LDRB     r3,[r1,#8]
00001c  0224              LSLS     r4,r4,#8
00001e  ea046303          AND      r3,r4,r3,LSL #24
000022  431a              ORRS     r2,r2,r3
000024  7b0b              LDRB     r3,[r1,#0xc]
000026  01e4              LSLS     r4,r4,#7
000028  ea0473c3          AND      r3,r4,r3,LSL #31
00002c  431a              ORRS     r2,r2,r3
00002e  f8503fb0          LDR      r3,[r0,#0xb0]!
000032  431a              ORRS     r2,r2,r3
000034  6002              STR      r2,[r0,#0]
;;;348            CAN_RXF1C_F1WM(config->watermark) | CAN_RXF1C_F1OM(config->opmode);
;;;349        /* Set Rx FIFO 1 data field size */
;;;350        base->RXESC |= CAN_RXESC_F1DS(config->datafieldSize);
000036  68c2              LDR      r2,[r0,#0xc]
000038  7b4b              LDRB     r3,[r1,#0xd]
00003a  2470              MOVS     r4,#0x70
00003c  ea041303          AND      r3,r4,r3,LSL #4
000040  431a              ORRS     r2,r2,r3
000042  60c2              STR      r2,[r0,#0xc]
000044  38b0              SUBS     r0,r0,#0xb0
;;;351    }
000046  bd10              POP      {r4,pc}
;;;352    
                          ENDP


                          AREA ||i.MCAN_SetSTDFilterElement||, CODE, READONLY, ALIGN=1

                  MCAN_SetSTDFilterElement PROC
;;;378    
;;;379    void MCAN_SetSTDFilterElement(CAN_Type *base, const mcan_frame_filter_config_t *config,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;380                                  const mcan_std_filter_element_config_t *filter, uint8_t idx)
;;;381    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;382        uint8_t *elementAddress = 0;
00000c  f04f0800          MOV      r8,#0
;;;383        elementAddress = (uint8_t *)(MCAN_GetMsgRAMBase(base) + config->address + idx * 4U);
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       MCAN_GetMsgRAMBase
000016  6829              LDR      r1,[r5,#0]
000018  4408              ADD      r0,r0,r1
00001a  eb000884          ADD      r8,r0,r4,LSL #2
;;;384        memcpy(elementAddress, filter, sizeof(filter));
00001e  6830              LDR      r0,[r6,#0]
000020  f8c80000          STR      r0,[r8,#0]
;;;385    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;386    
                          ENDP


                          AREA ||i.MCAN_SetTxBufferConfig||, CODE, READONLY, ALIGN=2

                  MCAN_SetTxBufferConfig PROC
;;;367    
;;;368    void MCAN_SetTxBufferConfig(CAN_Type *base, const mcan_tx_buffer_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;370        assert((config->dedicatedSize + config->fqSize) <= 32U);
000006  e9d40101          LDRD     r0,r1,[r4,#4]
00000a  4408              ADD      r0,r0,r1
00000c  2820              CMP      r0,#0x20
00000e  d800              BHI      |L34.18|
000010  e005              B        |L34.30|
                  |L34.18|
000012  f44f72b9          MOV      r2,#0x172
000016  a113              ADR      r1,|L34.100|
000018  a018              ADR      r0,|L34.124|
00001a  f7fffffe          BL       __aeabi_assert
                  |L34.30|
;;;371    
;;;372        /* Set Tx Buffer start address, size, fifo/queue mode. */
;;;373        base->TXBC |= CAN_TXBC_TBSA(config->address >> CAN_TXBC_TBSA_SHIFT) | CAN_TXBC_NDTB(config->dedicatedSize) |
00001e  6820              LDR      r0,[r4,#0]
000020  0880              LSRS     r0,r0,#2
000022  f64f71fc          MOV      r1,#0xfffc
000026  ea010080          AND      r0,r1,r0,LSL #2
00002a  88a1              LDRH     r1,[r4,#4]
00002c  f44f127c          MOV      r2,#0x3f0000
000030  ea024101          AND      r1,r2,r1,LSL #16
000034  4308              ORRS     r0,r0,r1
000036  7a21              LDRB     r1,[r4,#8]
000038  0212              LSLS     r2,r2,#8
00003a  ea026101          AND      r1,r2,r1,LSL #24
00003e  4308              ORRS     r0,r0,r1
000040  7b21              LDRB     r1,[r4,#0xc]
000042  f04f4280          MOV      r2,#0x40000000
000046  ea027181          AND      r1,r2,r1,LSL #30
00004a  4308              ORRS     r0,r0,r1
00004c  f8551fc0          LDR      r1,[r5,#0xc0]!
000050  4308              ORRS     r0,r0,r1
000052  6028              STR      r0,[r5,#0]
;;;374            CAN_TXBC_TFQS(config->fqSize) | CAN_TXBC_TFQM(config->mode);
;;;375        /* Set Tx Buffer data field size */
;;;376        base->TXESC |= CAN_TXESC_TBDS(config->datafieldSize);
000054  68a8              LDR      r0,[r5,#8]
000056  7b61              LDRB     r1,[r4,#0xd]
000058  f0010107          AND      r1,r1,#7
00005c  4308              ORRS     r0,r0,r1
00005e  60a8              STR      r0,[r5,#8]
000060  3dc0              SUBS     r5,r5,#0xc0
;;;377    }
000062  bd70              POP      {r4-r6,pc}
;;;378    
                          ENDP

                  |L34.100|
000064  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000068  44726976
00006c  6572735c
000070  66736c5f
000074  6d63616e
000078  2e6300  
00007b  00                DCB      0
                  |L34.124|
00007c  28636f6e          DCB      "(config->dedicatedSize + config->fqSize) <= 32U",0
000080  6669672d
000084  3e646564
000088  69636174
00008c  65645369
000090  7a65202b
000094  20636f6e
000098  6669672d
00009c  3e667153
0000a0  697a6529
0000a4  203c3d20
0000a8  33325500

                          AREA ||i.MCAN_SetTxEventFifoConfig||, CODE, READONLY, ALIGN=1

                  MCAN_SetTxEventFifoConfig PROC
;;;360    
;;;361    void MCAN_SetTxEventFifoConfig(CAN_Type *base, const mcan_tx_fifo_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;362    {
;;;363        /* Set TX Event FIFO start address, element size, watermark. */
;;;364        base->TXEFC |= CAN_TXEFC_EFSA(config->address >> CAN_TXEFC_EFSA_SHIFT) |
000002  680a              LDR      r2,[r1,#0]
000004  0892              LSRS     r2,r2,#2
000006  f64f73fc          MOV      r3,#0xfffc
00000a  ea030282          AND      r2,r3,r2,LSL #2
00000e  888b              LDRH     r3,[r1,#4]
000010  f44f147c          MOV      r4,#0x3f0000
000014  ea044303          AND      r3,r4,r3,LSL #16
000018  431a              ORRS     r2,r2,r3
00001a  7a0b              LDRB     r3,[r1,#8]
00001c  0224              LSLS     r4,r4,#8
00001e  ea046303          AND      r3,r4,r3,LSL #24
000022  431a              ORRS     r2,r2,r3
000024  f8d030f0          LDR      r3,[r0,#0xf0]
000028  431a              ORRS     r2,r2,r3
00002a  f8c020f0          STR      r2,[r0,#0xf0]
;;;365            CAN_TXEFC_EFS(config->elementSize) | CAN_TXEFC_EFWM(config->watermark);
;;;366    }
00002e  bd10              POP      {r4,pc}
;;;367    
                          ENDP


                          AREA ||i.MCAN_TransferAbortReceiveFifo||, CODE, READONLY, ALIGN=2

                  MCAN_TransferAbortReceiveFifo PROC
;;;711    
;;;712    void MCAN_TransferAbortReceiveFifo(CAN_Type *base, uint8_t fifoBlock, mcan_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;713    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;714        /* Assertion. */
;;;715        assert(handle);
000008  b105              CBZ      r5,|L36.12|
00000a  e005              B        |L36.24|
                  |L36.12|
00000c  f24022cb          MOV      r2,#0x2cb
000010  a10e              ADR      r1,|L36.76|
000012  a014              ADR      r0,|L36.100|
000014  f7fffffe          BL       __aeabi_assert
                  |L36.24|
;;;716        assert((fifoBlock == 0) || (fifoBlock == 1));
000018  b10c              CBZ      r4,|L36.30|
00001a  2c01              CMP      r4,#1
00001c  d100              BNE      |L36.32|
                  |L36.30|
00001e  e005              B        |L36.44|
                  |L36.32|
000020  f44f7233          MOV      r2,#0x2cc
000024  a109              ADR      r1,|L36.76|
000026  a011              ADR      r0,|L36.108|
000028  f7fffffe          BL       __aeabi_assert
                  |L36.44|
;;;717    
;;;718        /* Check if Rx FIFO is enabled. */
;;;719        if (fifoBlock)
00002c  b124              CBZ      r4,|L36.56|
;;;720        {
;;;721            /* Disable Rx Message FIFO Interrupts. */
;;;722            MCAN_DisableInterrupts(base, CAN_IE_RF1NE_MASK);
00002e  2110              MOVS     r1,#0x10
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       MCAN_DisableInterrupts
000036  e003              B        |L36.64|
                  |L36.56|
;;;723        }
;;;724        else
;;;725        {
;;;726            MCAN_DisableInterrupts(base, CAN_IE_RF0NE_MASK);
000038  2101              MOVS     r1,#1
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       MCAN_DisableInterrupts
                  |L36.64|
;;;727        }
;;;728        /* Un-register handle. */
;;;729        handle->rxFifoFrameBuf = 0x0;
000040  2000              MOVS     r0,#0
000042  f8c50108          STR      r0,[r5,#0x108]
;;;730    
;;;731        handle->rxFifoState = kMCAN_StateIdle;
000046  f885014d          STRB     r0,[r5,#0x14d]
;;;732    }
00004a  bd70              POP      {r4-r6,pc}
;;;733    
                          ENDP

                  |L36.76|
00004c  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000050  44726976
000054  6572735c
000058  66736c5f
00005c  6d63616e
000060  2e6300  
000063  00                DCB      0
                  |L36.100|
000064  68616e64          DCB      "handle",0
000068  6c6500  
00006b  00                DCB      0
                  |L36.108|
00006c  28666966          DCB      "(fifoBlock == 0) || (fifoBlock == 1)",0
000070  6f426c6f
000074  636b203d
000078  3d203029
00007c  207c7c20
000080  28666966
000084  6f426c6f
000088  636b203d
00008c  3d203129
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.MCAN_TransferAbortSend||, CODE, READONLY, ALIGN=2

                  MCAN_TransferAbortSend PROC
;;;692    
;;;693    void MCAN_TransferAbortSend(CAN_Type *base, mcan_handle_t *handle, uint8_t bufferIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;694    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;695        /* Assertion. */
;;;696        assert(handle);
000008  b106              CBZ      r6,|L37.12|
00000a  e005              B        |L37.24|
                  |L37.12|
00000c  f44f722e          MOV      r2,#0x2b8
000010  a116              ADR      r1,|L37.108|
000012  a01c              ADR      r0,|L37.132|
000014  f7fffffe          BL       __aeabi_assert
                  |L37.24|
;;;697        assert(bufferIdx <= 63U);
000018  2c3f              CMP      r4,#0x3f
00001a  d800              BHI      |L37.30|
00001c  e005              B        |L37.42|
                  |L37.30|
00001e  f24022b9          MOV      r2,#0x2b9
000022  a112              ADR      r1,|L37.108|
000024  a019              ADR      r0,|L37.140|
000026  f7fffffe          BL       __aeabi_assert
                  |L37.42|
;;;698    
;;;699        /* Disable Buffer Interrupt. */
;;;700        MCAN_DisableTransmitBufferInterrupts(base, bufferIdx);
00002a  bf00              NOP      
00002c  f8d500e0          LDR      r0,[r5,#0xe0]
000030  2101              MOVS     r1,#1
000032  40a1              LSLS     r1,r1,r4
000034  4388              BICS     r0,r0,r1
000036  f8c500e0          STR      r0,[r5,#0xe0]
00003a  bf00              NOP      
;;;701        MCAN_DisableInterrupts(base, CAN_IE_TCE_MASK);
00003c  f44f7100          MOV      r1,#0x200
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       MCAN_DisableInterrupts
;;;702    
;;;703        /* Cancel send request. */
;;;704        MCAN_TransmitCancelRequest(base, bufferIdx);
000046  bf00              NOP      
000048  f8d500d4          LDR      r0,[r5,#0xd4]
00004c  2101              MOVS     r1,#1
00004e  40a1              LSLS     r1,r1,r4
000050  4308              ORRS     r0,r0,r1
000052  f8c500d4          STR      r0,[r5,#0xd4]
000056  bf00              NOP      
;;;705    
;;;706        /* Un-register handle. */
;;;707        handle->bufferFrameBuf[bufferIdx] = 0x0;
000058  2100              MOVS     r1,#0
00005a  f1060008          ADD      r0,r6,#8
00005e  f8401024          STR      r1,[r0,r4,LSL #2]
;;;708    
;;;709        handle->bufferState[bufferIdx] = kMCAN_StateIdle;
000062  f206100d          ADD      r0,r6,#0x10d
000066  5501              STRB     r1,[r0,r4]
;;;710    }
000068  bd70              POP      {r4-r6,pc}
;;;711    
                          ENDP

00006a  0000              DCW      0x0000
                  |L37.108|
00006c  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000070  44726976
000074  6572735c
000078  66736c5f
00007c  6d63616e
000080  2e6300  
000083  00                DCB      0
                  |L37.132|
000084  68616e64          DCB      "handle",0
000088  6c6500  
00008b  00                DCB      0
                  |L37.140|
00008c  62756666          DCB      "bufferIdx <= 63U",0
000090  65724964
000094  78203c3d
000098  20363355
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.MCAN_TransferCreateHandle||, CODE, READONLY, ALIGN=2

                  MCAN_TransferCreateHandle PROC
;;;571    
;;;572    void MCAN_TransferCreateHandle(CAN_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;573                                      mcan_handle_t *handle,
;;;574                                      mcan_transfer_callback_t callback,
;;;575                                      void *userData)
;;;576    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;577        assert(handle);
00000c  b104              CBZ      r4,|L38.16|
00000e  e005              B        |L38.28|
                  |L38.16|
000010  f2402241          MOV      r2,#0x241
000014  a119              ADR      r1,|L38.124|
000016  a01f              ADR      r0,|L38.148|
000018  f7fffffe          BL       __aeabi_assert
                  |L38.28|
;;;578    
;;;579        uint8_t instance;
;;;580    
;;;581        /* Clean MCAN transfer handle. */
;;;582        memset(handle, 0, sizeof(*handle));
00001c  f44f71a8          MOV      r1,#0x150
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       __aeabi_memclr4
;;;583    
;;;584        /* Get instance from peripheral base address. */
;;;585        instance = MCAN_GetInstance(base);
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       MCAN_GetInstance
00002c  b2c5              UXTB     r5,r0
;;;586    
;;;587        /* Save the context in global variables to support the double weak mechanism. */
;;;588        s_mcanHandle[instance] = handle;
00002e  481b              LDR      r0,|L38.156|
000030  f8404025          STR      r4,[r0,r5,LSL #2]
;;;589    
;;;590        /* Register Callback function. */
;;;591        handle->callback = callback;
000034  6026              STR      r6,[r4,#0]
;;;592        handle->userData = userData;
000036  6067              STR      r7,[r4,#4]
;;;593    
;;;594        s_mcanIsr = MCAN_TransferHandleIRQ;
000038  4819              LDR      r0,|L38.160|
00003a  491a              LDR      r1,|L38.164|
00003c  6008              STR      r0,[r1,#0]  ; s_mcanIsr
;;;595    
;;;596        /* We Enable Error & Status interrupt here, because this interrupt just
;;;597         * report current status of MCAN module through Callback function.
;;;598         * It is insignificance without a available callback function.
;;;599         */
;;;600        if (handle->callback != NULL)
00003e  6820              LDR      r0,[r4,#0]
000040  b130              CBZ      r0,|L38.80|
;;;601        {
;;;602            MCAN_EnableInterrupts(base, 0, kMCAN_BusOffInterruptEnable | kMCAN_ErrorInterruptEnable | kMCAN_WarningInterruptEnable);
000042  f04f7260          MOV      r2,#0x3800000
000046  2100              MOVS     r1,#0
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       MCAN_EnableInterrupts
00004e  e004              B        |L38.90|
                  |L38.80|
;;;603        }
;;;604        else
;;;605        {
;;;606            MCAN_DisableInterrupts(base, kMCAN_BusOffInterruptEnable | kMCAN_ErrorInterruptEnable | kMCAN_WarningInterruptEnable);
000050  f04f7160          MOV      r1,#0x3800000
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       MCAN_DisableInterrupts
                  |L38.90|
;;;607        }
;;;608    
;;;609        /* Enable interrupts in NVIC. */
;;;610        EnableIRQ((IRQn_Type)(s_mcanIRQ[instance][0]));
00005a  4913              LDR      r1,|L38.168|
00005c  eb010145          ADD      r1,r1,r5,LSL #1
000060  f9910000          LDRSB    r0,[r1,#0]
000064  f7fffffe          BL       EnableIRQ
;;;611        EnableIRQ((IRQn_Type)(s_mcanIRQ[instance][1]));
000068  490f              LDR      r1,|L38.168|
00006a  eb010145          ADD      r1,r1,r5,LSL #1
00006e  f9910001          LDRSB    r0,[r1,#1]
000072  f7fffffe          BL       EnableIRQ
;;;612    }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;613    
                          ENDP

00007a  0000              DCW      0x0000
                  |L38.124|
00007c  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000080  44726976
000084  6572735c
000088  66736c5f
00008c  6d63616e
000090  2e6300  
000093  00                DCB      0
                  |L38.148|
000094  68616e64          DCB      "handle",0
000098  6c6500  
00009b  00                DCB      0
                  |L38.156|
                          DCD      s_mcanHandle
                  |L38.160|
                          DCD      MCAN_TransferHandleIRQ
                  |L38.164|
                          DCD      s_mcanIsr
                  |L38.168|
                          DCD      s_mcanIRQ

                          AREA ||i.MCAN_TransferHandleIRQ||, CODE, READONLY, ALIGN=2

                  MCAN_TransferHandleIRQ PROC
;;;733    
;;;734    void MCAN_TransferHandleIRQ(CAN_Type *base, mcan_handle_t *handle)
000000  b5f8              PUSH     {r3-r7,lr}
;;;735    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;736        /* Assertion. */
;;;737        assert(handle);
000006  b104              CBZ      r4,|L39.10|
000008  e005              B        |L39.22|
                  |L39.10|
00000a  f24022e1          MOV      r2,#0x2e1
00000e  a12f              ADR      r1,|L39.204|
000010  a034              ADR      r0,|L39.228|
000012  f7fffffe          BL       __aeabi_assert
                  |L39.22|
;;;738    
;;;739        status_t status = kStatus_MCAN_UnHandled;
000016  f6410749          MOV      r7,#0x1849
;;;740        uint32_t result;
;;;741    
;;;742        /* Store Current MCAN Module Error and Status. */
;;;743        result = base->IR;
00001a  6d35              LDR      r5,[r6,#0x50]
;;;744    
;;;745        do
00001c  bf00              NOP      
                  |L39.30|
;;;746        {
;;;747            /* Solve Rx FIFO, Tx interrupt. */
;;;748            if (result & kMCAN_TxTransmitCompleteFlag)
00001e  f4057000          AND      r0,r5,#0x200
000022  b140              CBZ      r0,|L39.54|
;;;749            {
;;;750                status = kStatus_MCAN_TxIdle;
000024  f6410739          MOV      r7,#0x1839
;;;751                MCAN_TransferAbortSend(base, handle, handle->txbufferIdx);
000028  f894210c          LDRB     r2,[r4,#0x10c]
00002c  4621              MOV      r1,r4
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       MCAN_TransferAbortSend
000034  e02c              B        |L39.144|
                  |L39.54|
;;;752            }
;;;753            else if (result & kMCAN_RxFifo0NewFlag)
000036  f0050001          AND      r0,r5,#1
00003a  b168              CBZ      r0,|L39.88|
;;;754            {
;;;755                MCAN_ReadRxFifo(base, 0, handle->rxFifoFrameBuf);
00003c  f8d42108          LDR      r2,[r4,#0x108]
000040  2100              MOVS     r1,#0
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       MCAN_ReadRxFifo
;;;756                status = kStatus_MCAN_RxFifo0Idle;
000048  f641073d          MOV      r7,#0x183d
;;;757                MCAN_TransferAbortReceiveFifo(base, 0, handle);
00004c  4622              MOV      r2,r4
00004e  2100              MOVS     r1,#0
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       MCAN_TransferAbortReceiveFifo
000056  e01b              B        |L39.144|
                  |L39.88|
;;;758            }
;;;759            else if (result & kMCAN_RxFifo0LostFlag)
000058  f0050008          AND      r0,r5,#8
00005c  b110              CBZ      r0,|L39.100|
;;;760            {
;;;761                status = kStatus_MCAN_RxFifo0Lost;
00005e  f44f57c2          MOV      r7,#0x1840
000062  e015              B        |L39.144|
                  |L39.100|
;;;762            }
;;;763            else if (result & kMCAN_RxFifo1NewFlag)
000064  f0050010          AND      r0,r5,#0x10
000068  b168              CBZ      r0,|L39.134|
;;;764            {
;;;765                MCAN_ReadRxFifo(base, 1, handle->rxFifoFrameBuf);
00006a  f8d42108          LDR      r2,[r4,#0x108]
00006e  2101              MOVS     r1,#1
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       MCAN_ReadRxFifo
;;;766                status = kStatus_MCAN_RxFifo1Idle;
000076  f6410742          MOV      r7,#0x1842
;;;767                MCAN_TransferAbortReceiveFifo(base, 1, handle);
00007a  4622              MOV      r2,r4
00007c  2101              MOVS     r1,#1
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       MCAN_TransferAbortReceiveFifo
000084  e004              B        |L39.144|
                  |L39.134|
;;;768            }
;;;769            else if (result & kMCAN_RxFifo1LostFlag)
000086  f0050080          AND      r0,r5,#0x80
00008a  b108              CBZ      r0,|L39.144|
;;;770            {
;;;771                status = kStatus_MCAN_RxFifo0Lost;
00008c  f44f57c2          MOV      r7,#0x1840
                  |L39.144|
;;;772            }
;;;773            else
;;;774            {
;;;775                ;
;;;776            }
;;;777    
;;;778            /* Clear resolved Rx FIFO, Tx Buffer IRQ. */
;;;779            MCAN_ClearStatusFlag(base, result);
000090  4629              MOV      r1,r5
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       MCAN_ClearStatusFlag
;;;780    
;;;781            /* Calling Callback Function if has one. */
;;;782            if (handle->callback != NULL)
000098  6820              LDR      r0,[r4,#0]
00009a  b140              CBZ      r0,|L39.174|
;;;783            {
;;;784                handle->callback(base, handle, status, result, handle->userData);
00009c  6860              LDR      r0,[r4,#4]
00009e  9000              STR      r0,[sp,#0]
0000a0  462b              MOV      r3,r5
0000a2  463a              MOV      r2,r7
0000a4  4621              MOV      r1,r4
0000a6  4630              MOV      r0,r6
0000a8  f8d4c000          LDR      r12,[r4,#0]
0000ac  47e0              BLX      r12
                  |L39.174|
;;;785            }
;;;786    
;;;787            /* Reset return status */
;;;788            status = kStatus_MCAN_UnHandled;
0000ae  f6410749          MOV      r7,#0x1849
;;;789    
;;;790            /* Store Current MCAN Module Error and Status. */
;;;791            result = base->IR;
0000b2  6d35              LDR      r5,[r6,#0x50]
;;;792        }
;;;793        while ((0 != MCAN_GetStatusFlag(base, 0xFFFFFFFFU)) ||
0000b4  f04f31ff          MOV      r1,#0xffffffff
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       MCAN_GetStatusFlag
0000be  2800              CMP      r0,#0
0000c0  d1ad              BNE      |L39.30|
;;;794               (0 != (result & (kMCAN_ErrorWarningIntFlag | kMCAN_BusOffIntFlag | kMCAN_ErrorPassiveIntFlag))));
0000c2  f0057060          AND      r0,r5,#0x3800000
0000c6  2800              CMP      r0,#0
0000c8  d1a9              BNE      |L39.30|
;;;795    }
0000ca  bdf8              POP      {r3-r7,pc}
;;;796    
                          ENDP

                  |L39.204|
0000cc  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
0000d0  44726976
0000d4  6572735c
0000d8  66736c5f
0000dc  6d63616e
0000e0  2e6300  
0000e3  00                DCB      0
                  |L39.228|
0000e4  68616e64          DCB      "handle",0
0000e8  6c6500  
0000eb  00                DCB      0

                          AREA ||i.MCAN_TransferReceiveBlocking||, CODE, READONLY, ALIGN=2

                  MCAN_TransferReceiveBlocking PROC
;;;540    
;;;541    status_t MCAN_TransferReceiveBlocking(CAN_Type *base, uint8_t bufferIdx, mcan_rx_buffer_frame_t *rxFrame)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;542    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;543        assert(bufferIdx <= 63U);
00000a  2d3f              CMP      r5,#0x3f
00000c  d800              BHI      |L40.16|
00000e  e005              B        |L40.28|
                  |L40.16|
000010  f240221f          MOV      r2,#0x21f
000014  a126              ADR      r1,|L40.176|
000016  a02c              ADR      r0,|L40.200|
000018  f7fffffe          BL       __aeabi_assert
                  |L40.28|
;;;544    
;;;545        while (!MCAN_GetRxBufferStatusFlag(base, bufferIdx))
00001c  bf00              NOP      
                  |L40.30|
00001e  462e              MOV      r6,r5
000020  2e3f              CMP      r6,#0x3f
000022  d800              BHI      |L40.38|
000024  e005              B        |L40.50|
                  |L40.38|
000026  f24022a5          MOV      r2,#0x2a5
00002a  a12c              ADR      r1,|L40.220|
00002c  a031              ADR      r0,|L40.244|
00002e  f7fffffe          BL       __aeabi_assert
                  |L40.50|
000032  2e1f              CMP      r6,#0x1f
000034  d809              BHI      |L40.74|
000036  f8d40098          LDR      r0,[r4,#0x98]
00003a  2101              MOVS     r1,#1
00003c  40b1              LSLS     r1,r1,r6
00003e  4008              ANDS     r0,r0,r1
000040  b108              CBZ      r0,|L40.70|
000042  2001              MOVS     r0,#1
000044  e00c              B        |L40.96|
                  |L40.70|
000046  2000              MOVS     r0,#0
000048  e00a              B        |L40.96|
                  |L40.74|
00004a  f8d4009c          LDR      r0,[r4,#0x9c]
00004e  f1a6011f          SUB      r1,r6,#0x1f
000052  2201              MOVS     r2,#1
000054  408a              LSLS     r2,r2,r1
000056  4010              ANDS     r0,r0,r2
000058  b108              CBZ      r0,|L40.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L40.96|
                  |L40.94|
00005e  2000              MOVS     r0,#0
                  |L40.96|
000060  2800              CMP      r0,#0
000062  d0dc              BEQ      |L40.30|
;;;546        {
;;;547        }
;;;548        MCAN_ClearRxBufferStatusFlag(base, bufferIdx);
000064  462e              MOV      r6,r5
000066  2e3f              CMP      r6,#0x3f
000068  d800              BHI      |L40.108|
00006a  e005              B        |L40.120|
                  |L40.108|
00006c  f24022bb          MOV      r2,#0x2bb
000070  a11a              ADR      r1,|L40.220|
000072  a020              ADR      r0,|L40.244|
000074  f7fffffe          BL       __aeabi_assert
                  |L40.120|
000078  2e1f              CMP      r6,#0x1f
00007a  d807              BHI      |L40.140|
00007c  f8d40098          LDR      r0,[r4,#0x98]
000080  2101              MOVS     r1,#1
000082  40b1              LSLS     r1,r1,r6
000084  4388              BICS     r0,r0,r1
000086  f8c40098          STR      r0,[r4,#0x98]
00008a  e008              B        |L40.158|
                  |L40.140|
00008c  f8d4009c          LDR      r0,[r4,#0x9c]
000090  f1a6011f          SUB      r1,r6,#0x1f
000094  2201              MOVS     r2,#1
000096  408a              LSLS     r2,r2,r1
000098  4390              BICS     r0,r0,r2
00009a  f8c4009c          STR      r0,[r4,#0x9c]
                  |L40.158|
00009e  bf00              NOP      
;;;549        return MCAN_ReadRxBuffer(base, bufferIdx, rxFrame);
0000a0  463a              MOV      r2,r7
0000a2  4629              MOV      r1,r5
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       MCAN_ReadRxBuffer
;;;550    }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;551    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L40.176|
0000b0  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
0000b4  44726976
0000b8  6572735c
0000bc  66736c5f
0000c0  6d63616e
0000c4  2e6300  
0000c7  00                DCB      0
                  |L40.200|
0000c8  62756666          DCB      "bufferIdx <= 63U",0
0000cc  65724964
0000d0  78203c3d
0000d4  20363355
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L40.220|
0000dc  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.h",0
0000e0  44726976
0000e4  6572735c
0000e8  66736c5f
0000ec  6d63616e
0000f0  2e6800  
0000f3  00                DCB      0
                  |L40.244|
0000f4  69647820          DCB      "idx <= 63U",0
0000f8  3c3d2036
0000fc  335500  
0000ff  00                DCB      0

                          AREA ||i.MCAN_TransferReceiveFifoBlocking||, CODE, READONLY, ALIGN=2

                  MCAN_TransferReceiveFifoBlocking PROC
;;;551    
;;;552    status_t MCAN_TransferReceiveFifoBlocking(CAN_Type *base, uint8_t fifoBlock, mcan_rx_buffer_frame_t *rxFrame)
000000  b570              PUSH     {r4-r6,lr}
;;;553    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;554        assert((fifoBlock == 0) || (fifoBlock == 1U));
000008  b10c              CBZ      r4,|L41.14|
00000a  2c01              CMP      r4,#1
00000c  d100              BNE      |L41.16|
                  |L41.14|
00000e  e005              B        |L41.28|
                  |L41.16|
000010  f240222a          MOV      r2,#0x22a
000014  a110              ADR      r1,|L41.88|
000016  a016              ADR      r0,|L41.112|
000018  f7fffffe          BL       __aeabi_assert
                  |L41.28|
;;;555        if (0 == fifoBlock)
00001c  b95c              CBNZ     r4,|L41.54|
;;;556        {
;;;557            while (!MCAN_GetStatusFlag(base, CAN_IR_RF0N_MASK))
00001e  bf00              NOP      
                  |L41.32|
000020  2101              MOVS     r1,#1
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       MCAN_GetStatusFlag
000028  2800              CMP      r0,#0
00002a  d0f9              BEQ      |L41.32|
;;;558            {
;;;559            }
;;;560            MCAN_ClearStatusFlag(base, CAN_IR_RF0N_MASK);
00002c  2101              MOVS     r1,#1
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       MCAN_ClearStatusFlag
000034  e00a              B        |L41.76|
                  |L41.54|
;;;561        }
;;;562        else
;;;563        {
;;;564            while (!MCAN_GetStatusFlag(base, CAN_IR_RF1N_MASK))
000036  bf00              NOP      
                  |L41.56|
000038  2110              MOVS     r1,#0x10
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       MCAN_GetStatusFlag
000040  2800              CMP      r0,#0
000042  d0f9              BEQ      |L41.56|
;;;565            {
;;;566            }
;;;567            MCAN_ClearStatusFlag(base, CAN_IR_RF1N_MASK);
000044  2110              MOVS     r1,#0x10
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       MCAN_ClearStatusFlag
                  |L41.76|
;;;568        }
;;;569        return MCAN_ReadRxFifo(base, fifoBlock, rxFrame);
00004c  4632              MOV      r2,r6
00004e  4621              MOV      r1,r4
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       MCAN_ReadRxFifo
;;;570    }
000056  bd70              POP      {r4-r6,pc}
;;;571    
                          ENDP

                  |L41.88|
000058  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
00005c  44726976
000060  6572735c
000064  66736c5f
000068  6d63616e
00006c  2e6300  
00006f  00                DCB      0
                  |L41.112|
000070  28666966          DCB      "(fifoBlock == 0) || (fifoBlock == 1U)",0
000074  6f426c6f
000078  636b203d
00007c  3d203029
000080  207c7c20
000084  28666966
000088  6f426c6f
00008c  636b203d
000090  3d203155
000094  2900    
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.MCAN_TransferReceiveFifoNonBlocking||, CODE, READONLY, ALIGN=2

                  MCAN_TransferReceiveFifoNonBlocking PROC
;;;659    
;;;660    status_t MCAN_TransferReceiveFifoNonBlocking(CAN_Type *base, uint8_t fifoBlock,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;661                                                 mcan_handle_t *handle, mcan_fifo_transfer_t *xfer)
;;;662    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;663        /* Assertion. */
;;;664        assert((fifoBlock == 0) || (fifoBlock == 1U));
00000c  b10c              CBZ      r4,|L42.18|
00000e  2c01              CMP      r4,#1
000010  d100              BNE      |L42.20|
                  |L42.18|
000012  e005              B        |L42.32|
                  |L42.20|
000014  f44f7226          MOV      r2,#0x298
000018  a119              ADR      r1,|L42.128|
00001a  a01f              ADR      r0,|L42.152|
00001c  f7fffffe          BL       __aeabi_assert
                  |L42.32|
;;;665        assert(handle);
000020  b105              CBZ      r5,|L42.36|
000022  e005              B        |L42.48|
                  |L42.36|
000024  f2402299          MOV      r2,#0x299
000028  a115              ADR      r1,|L42.128|
00002a  a025              ADR      r0,|L42.192|
00002c  f7fffffe          BL       __aeabi_assert
                  |L42.48|
;;;666        assert(xfer);
000030  b106              CBZ      r6,|L42.52|
000032  e005              B        |L42.64|
                  |L42.52|
000034  f240229a          MOV      r2,#0x29a
000038  a111              ADR      r1,|L42.128|
00003a  a023              ADR      r0,|L42.200|
00003c  f7fffffe          BL       __aeabi_assert
                  |L42.64|
;;;667    
;;;668        /* Check if Message Buffer is idle. */
;;;669        if (kMCAN_StateIdle == handle->rxFifoState)
000040  f895014d          LDRB     r0,[r5,#0x14d]
000044  b9a0              CBNZ     r0,|L42.112|
;;;670        {
;;;671            handle->rxFifoState = kMCAN_StateRxFifo;
000046  2005              MOVS     r0,#5
000048  f885014d          STRB     r0,[r5,#0x14d]
;;;672    
;;;673            /* Register Message Buffer. */
;;;674            handle->rxFifoFrameBuf = xfer->frame;
00004c  6830              LDR      r0,[r6,#0]
00004e  f8c50108          STR      r0,[r5,#0x108]
;;;675    
;;;676            /* Enable FIFO Interrupt. */
;;;677            if(fifoBlock)
000052  b12c              CBZ      r4,|L42.96|
;;;678            {
;;;679                MCAN_EnableInterrupts(base, 0, CAN_IE_RF1NE_MASK);
000054  2210              MOVS     r2,#0x10
000056  2100              MOVS     r1,#0
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       MCAN_EnableInterrupts
00005e  e004              B        |L42.106|
                  |L42.96|
;;;680            }
;;;681            else
;;;682            {
;;;683                MCAN_EnableInterrupts(base, 0, CAN_IE_RF0NE_MASK);
000060  2201              MOVS     r2,#1
000062  2100              MOVS     r1,#0
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       MCAN_EnableInterrupts
                  |L42.106|
;;;684            }
;;;685            return kStatus_Success;
00006a  2000              MOVS     r0,#0
                  |L42.108|
;;;686        }
;;;687        else
;;;688        {
;;;689            return fifoBlock ? kStatus_MCAN_RxFifo1Busy : kStatus_MCAN_RxFifo0Busy;
;;;690        }
;;;691    }
00006c  e8bd81f0          POP      {r4-r8,pc}
                  |L42.112|
000070  b114              CBZ      r4,|L42.120|
000072  f6410047          MOV      r0,#0x1847            ;689
000076  e7f9              B        |L42.108|
                  |L42.120|
000078  f6410046          MOV      r0,#0x1846            ;689
00007c  e7f6              B        |L42.108|
;;;692    
                          ENDP

00007e  0000              DCW      0x0000
                  |L42.128|
000080  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
000084  44726976
000088  6572735c
00008c  66736c5f
000090  6d63616e
000094  2e6300  
000097  00                DCB      0
                  |L42.152|
000098  28666966          DCB      "(fifoBlock == 0) || (fifoBlock == 1U)",0
00009c  6f426c6f
0000a0  636b203d
0000a4  3d203029
0000a8  207c7c20
0000ac  28666966
0000b0  6f426c6f
0000b4  636b203d
0000b8  3d203155
0000bc  2900    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L42.192|
0000c0  68616e64          DCB      "handle",0
0000c4  6c6500  
0000c7  00                DCB      0
                  |L42.200|
0000c8  78666572          DCB      "xfer",0
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.MCAN_TransferSendBlocking||, CODE, READONLY, ALIGN=1

                  MCAN_TransferSendBlocking PROC
;;;522    
;;;523    status_t MCAN_TransferSendBlocking(CAN_Type *base, uint8_t idx, mcan_tx_buffer_frame_t *txFrame)
000000  b570              PUSH     {r4-r6,lr}
;;;524    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;525        if(kStatus_Success == MCAN_WriteTxBuffer(base, idx, txFrame))
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       MCAN_WriteTxBuffer
000012  b960              CBNZ     r0,|L43.46|
;;;526        {
;;;527            MCAN_TransmitAddRequest(base, idx);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       MCAN_TransmitAddRequest
;;;528    
;;;529            /* Wait until message sent out. */
;;;530            while (!MCAN_IsTransmitOccurred(base, idx))
00001c  bf00              NOP      
                  |L43.30|
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       MCAN_IsTransmitOccurred
000026  2800              CMP      r0,#0
000028  d0f9              BEQ      |L43.30|
;;;531            {
;;;532            }
;;;533            return kStatus_Success;
00002a  2000              MOVS     r0,#0
                  |L43.44|
;;;534        }
;;;535        else
;;;536        {
;;;537            return kStatus_Fail;
;;;538        }
;;;539    }
00002c  bd70              POP      {r4-r6,pc}
                  |L43.46|
00002e  2001              MOVS     r0,#1                 ;537
000030  e7fc              B        |L43.44|
;;;540    
                          ENDP


                          AREA ||i.MCAN_TransferSendNonBlocking||, CODE, READONLY, ALIGN=2

                  MCAN_TransferSendNonBlocking PROC
;;;613    
;;;614    status_t MCAN_TransferSendNonBlocking(CAN_Type *base, mcan_handle_t *handle, mcan_buffer_transfer_t *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;615    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;616        /* Assertion. */
;;;617        assert(handle);
000008  b105              CBZ      r5,|L44.12|
00000a  e005              B        |L44.24|
                  |L44.12|
00000c  f2402269          MOV      r2,#0x269
000010  a12c              ADR      r1,|L44.196|
000012  a032              ADR      r0,|L44.220|
000014  f7fffffe          BL       __aeabi_assert
                  |L44.24|
;;;618        assert(xfer);
000018  b104              CBZ      r4,|L44.28|
00001a  e005              B        |L44.40|
                  |L44.28|
00001c  f240226a          MOV      r2,#0x26a
000020  a128              ADR      r1,|L44.196|
000022  a030              ADR      r0,|L44.228|
000024  f7fffffe          BL       __aeabi_assert
                  |L44.40|
;;;619        assert(xfer->bufferIdx <= 63U);
000028  7920              LDRB     r0,[r4,#4]
00002a  283f              CMP      r0,#0x3f
00002c  d800              BHI      |L44.48|
00002e  e005              B        |L44.60|
                  |L44.48|
000030  f240226b          MOV      r2,#0x26b
000034  a123              ADR      r1,|L44.196|
000036  a02d              ADR      r0,|L44.236|
000038  f7fffffe          BL       __aeabi_assert
                  |L44.60|
;;;620    
;;;621        /* Check if Tx Buffer is idle. */
;;;622        if (kMCAN_StateIdle == handle->bufferState[xfer->bufferIdx])
00003c  7921              LDRB     r1,[r4,#4]
00003e  f205100d          ADD      r0,r5,#0x10d
000042  5c40              LDRB     r0,[r0,r1]
000044  bb98              CBNZ     r0,|L44.174|
;;;623        {
;;;624            handle->txbufferIdx = xfer->bufferIdx;
000046  7920              LDRB     r0,[r4,#4]
000048  f885010c          STRB     r0,[r5,#0x10c]
;;;625            /* Distinguish transmit type. */
;;;626            if (kMCAN_FrameTypeRemote == xfer->frame->xtd)
00004c  6820              LDR      r0,[r4,#0]
00004e  6800              LDR      r0,[r0,#0]
000050  f3c07080          UBFX     r0,r0,#30,#1
000054  b158              CBZ      r0,|L44.110|
;;;627            {
;;;628                handle->bufferState[xfer->bufferIdx] = kMCAN_StateTxRemote;
000056  2104              MOVS     r1,#4
000058  7922              LDRB     r2,[r4,#4]
00005a  f205100d          ADD      r0,r5,#0x10d
00005e  5481              STRB     r1,[r0,r2]
;;;629    
;;;630                /* Register user Frame buffer to receive remote Frame. */
;;;631                handle->bufferFrameBuf[xfer->bufferIdx] = xfer->frame;
000060  7922              LDRB     r2,[r4,#4]
000062  f1050008          ADD      r0,r5,#8
000066  6821              LDR      r1,[r4,#0]
000068  f8401022          STR      r1,[r0,r2,LSL #2]
00006c  e004              B        |L44.120|
                  |L44.110|
;;;632            }
;;;633            else
;;;634            {
;;;635                handle->bufferState[xfer->bufferIdx] = kMCAN_StateTxData;
00006e  2103              MOVS     r1,#3
000070  7922              LDRB     r2,[r4,#4]
000072  f205100d          ADD      r0,r5,#0x10d
000076  5481              STRB     r1,[r0,r2]
                  |L44.120|
;;;636            }
;;;637    
;;;638            if (kStatus_Success == MCAN_WriteTxBuffer(base, xfer->bufferIdx, xfer->frame))
000078  7921              LDRB     r1,[r4,#4]
00007a  4630              MOV      r0,r6
00007c  6822              LDR      r2,[r4,#0]
00007e  f7fffffe          BL       MCAN_WriteTxBuffer
000082  b9a8              CBNZ     r0,|L44.176|
;;;639            {
;;;640                /* Enable Buffer Interrupt. */
;;;641                MCAN_EnableTransmitBufferInterrupts(base, xfer->bufferIdx);
000084  7920              LDRB     r0,[r4,#4]
000086  f8d610e0          LDR      r1,[r6,#0xe0]
00008a  2201              MOVS     r2,#1
00008c  4082              LSLS     r2,r2,r0
00008e  4311              ORRS     r1,r1,r2
000090  f8c610e0          STR      r1,[r6,#0xe0]
000094  bf00              NOP      
;;;642                MCAN_EnableInterrupts(base, 0, CAN_IE_TCE_MASK);
000096  f44f7200          MOV      r2,#0x200
00009a  2100              MOVS     r1,#0
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       MCAN_EnableInterrupts
;;;643                
;;;644                MCAN_TransmitAddRequest(base, xfer->bufferIdx);
0000a2  7921              LDRB     r1,[r4,#4]
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       MCAN_TransmitAddRequest
;;;645    
;;;646                return kStatus_Success;
0000aa  2000              MOVS     r0,#0
                  |L44.172|
;;;647            }
;;;648            else
;;;649            {
;;;650                handle->bufferState[xfer->bufferIdx] = kMCAN_StateIdle;
;;;651                return kStatus_Fail;
;;;652            }
;;;653        }
;;;654        else
;;;655        {
;;;656            return kStatus_MCAN_TxBusy;
;;;657        }
;;;658    }
0000ac  bd70              POP      {r4-r6,pc}
                  |L44.174|
0000ae  e006              B        |L44.190|
                  |L44.176|
0000b0  2100              MOVS     r1,#0                 ;650
0000b2  7922              LDRB     r2,[r4,#4]            ;650
0000b4  f205100d          ADD      r0,r5,#0x10d          ;650
0000b8  5481              STRB     r1,[r0,r2]            ;650
0000ba  2001              MOVS     r0,#1                 ;651
0000bc  e7f6              B        |L44.172|
                  |L44.190|
0000be  f6410038          MOV      r0,#0x1838            ;656
0000c2  e7f3              B        |L44.172|
;;;659    
                          ENDP

                  |L44.196|
0000c4  5352435c          DCB      "SRC\\Drivers\\fsl_mcan.c",0
0000c8  44726976
0000cc  6572735c
0000d0  66736c5f
0000d4  6d63616e
0000d8  2e6300  
0000db  00                DCB      0
                  |L44.220|
0000dc  68616e64          DCB      "handle",0
0000e0  6c6500  
0000e3  00                DCB      0
                  |L44.228|
0000e4  78666572          DCB      "xfer",0
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L44.236|
0000ec  78666572          DCB      "xfer->bufferIdx <= 63U",0
0000f0  2d3e6275
0000f4  66666572
0000f8  49647820
0000fc  3c3d2036
000100  335500  
000103  00                DCB      0

                          AREA ||i.MCAN_TransmitAddRequest||, CODE, READONLY, ALIGN=1

                  MCAN_TransmitAddRequest PROC
;;;828     */
;;;829    static inline void MCAN_TransmitAddRequest(CAN_Type *base, uint8_t idx)
000000  f8d020d0          LDR      r2,[r0,#0xd0]
;;;830    {
;;;831        base->TXBAR |= (uint32_t)(1U << idx);
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  f8c020d0          STR      r2,[r0,#0xd0]
;;;832    }
00000e  4770              BX       lr
;;;833    
                          ENDP


                          AREA ||i.MCAN_WriteTxBuffer||, CODE, READONLY, ALIGN=1

                  MCAN_WriteTxBuffer PROC
;;;469    
;;;470    status_t MCAN_WriteTxBuffer(CAN_Type *base, uint8_t idx, const mcan_tx_buffer_frame_t *txFrame)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;471    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;472        if (!MCAN_IsTransmitRequestPending(base, idx))
00000a  4639              MOV      r1,r7
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       MCAN_IsTransmitRequestPending
000012  b9b8              CBNZ     r0,|L46.68|
;;;473        {
;;;474            uint8_t *elementAddress = 0;
000014  2500              MOVS     r5,#0
;;;475            elementAddress = (uint8_t *)(MCAN_GetMsgRAMBase(base) + MCAN_GetTxBufferElementAddress(base, idx));
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       MCAN_GetMsgRAMBase
00001c  4680              MOV      r8,r0
00001e  4639              MOV      r1,r7
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       MCAN_GetTxBufferElementAddress
000026  eb080500          ADD      r5,r8,r0
;;;476    
;;;477            /* Write 2 words configuration field. */
;;;478            memcpy(elementAddress, (uint8_t *)txFrame, 8U);
00002a  6820              LDR      r0,[r4,#0]
00002c  6028              STR      r0,[r5,#0]
00002e  6860              LDR      r0,[r4,#4]
000030  6068              STR      r0,[r5,#4]
;;;479            /* Write data field. */
;;;480            memcpy(elementAddress + 8U, txFrame->data, txFrame->size);
000032  7b22              LDRB     r2,[r4,#0xc]
000034  f1050008          ADD      r0,r5,#8
000038  68a1              LDR      r1,[r4,#8]
00003a  f7fffffe          BL       __aeabi_memcpy
;;;481            return kStatus_Success;
00003e  2000              MOVS     r0,#0
                  |L46.64|
;;;482        }
;;;483        else
;;;484        {
;;;485            return kStatus_Fail;
;;;486        }
;;;487    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L46.68|
000044  2001              MOVS     r0,#1                 ;485
000046  e7fb              B        |L46.64|
;;;488    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_mcanBases
                          DCD      0x4009d000
                          DCD      0x4009e000
                  s_mcanIRQ
000008  2b2c2d2e          DCB      0x2b,0x2c,0x2d,0x2e
                  s_mcanClock
00000c  01070108          DCW      0x0107,0x0108

                          AREA ||.data||, DATA, ALIGN=2

                  s_mcanHandle
                          %        8
                  s_mcanIsr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_mcan.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_mcan_c_7eadfd73____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fsl_mcan_c_7eadfd73____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_mcan_c_7eadfd73____REVSH|
#line 402
|__asm___10_fsl_mcan_c_7eadfd73____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_mcan_c_7eadfd73____RRX|
#line 587
|__asm___10_fsl_mcan_c_7eadfd73____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
