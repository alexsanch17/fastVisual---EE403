L 1 "SRC\main.c"
N
N#include "board.h"
L 1 ".\SRC\Board\board.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _BOARD_H_
N#define _BOARD_H_
N
N#include "clock_config.h"
L 1 ".\SRC\Board\clock_config.h" 1
N/*
N * Copyright (c) 2015, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N#ifndef _CLOCK_CONFIG_H_
N#define _CLOCK_CONFIG_H_
N
N/*******************************************************************************
N * DEFINITION
N ******************************************************************************/
N#define BOARD_XTAL0_CLK_HZ 12000000U
N#define BOARD_XTAL32K_CLK_HZ 32768U
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif /* __cplusplus*/
N
Nvoid BOARD_BootClockVLPR(void);
Nvoid BOARD_BootClockRUN(void);
Nvoid BOARD_BootClockHSRUN(void);
Nvoid BOARD_BootClock_PLL_RUN(void);
N	
N#if defined(__cplusplus)
X#if 0L
S}
N#endif /* __cplusplus*/
N
N#endif /* _CLOCK_CONFIG_H_ */
L 35 ".\SRC\Board\board.h" 2
N#include "fsl_common.h"
L 1 ".\SRC\Drivers\fsl_common.h" 1
N/*
N * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _FSL_COMMON_H_
N#define _FSL_COMMON_H_
N
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5060019
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 35 ".\SRC\Drivers\fsl_common.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 36 ".\SRC\Drivers\fsl_common.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 37 ".\SRC\Drivers\fsl_common.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 38 ".\SRC\Drivers\fsl_common.h" 2
N#include "fsl_device_registers.h"
L 1 ".\SRC\System\fsl_device_registers.h" 1
N/*
N * Copyright (c) 2014 - 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef __FSL_DEVICE_REGISTERS_H__
N#define __FSL_DEVICE_REGISTERS_H__
N
N/*
N * Include the cpu specific register header files.
N *
N * The CPU macro should be declared in the project or makefile.
N */
N#if (defined(CPU_LPC54608J512BD208) || defined(CPU_LPC54608J512ET180))
X#if (0L || 1L)
N
N#define LPC54608_SERIES
N
N/* CMSIS-style register definitions */
N#include "LPC54608.h"
L 1 ".\SRC\System\LPC54608.h" 1
N/*
N** ###################################################################
N**     Processors:          LPC54608J512BD208
N**                          LPC54608J512ET180
N**
N**     Compilers:           Keil ARM C/C++ Compiler
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**
N**     Reference manual:    LPC54S60x/LPC5460x User manual Rev. 0.7 8 Sep 2016
N**     Version:             rev. 1.0, 2016-08-12
N**     Build:               b161018
N**
N**     Abstract:
N**         CMSIS Peripheral Access Layer for LPC54608
N**
N**     Copyright (c) 1997 - 2016 Freescale Semiconductor, Inc.
N**     All rights reserved.
N**
N**     Redistribution and use in source and binary forms, with or without modification,
N**     are permitted provided that the following conditions are met:
N**
N**     o Redistributions of source code must retain the above copyright notice, this list
N**       of conditions and the following disclaimer.
N**
N**     o Redistributions in binary form must reproduce the above copyright notice, this
N**       list of conditions and the following disclaimer in the documentation and/or
N**       other materials provided with the distribution.
N**
N**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N**       contributors may be used to endorse or promote products derived from this
N**       software without specific prior written permission.
N**
N**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N**
N**     http:                 www.freescale.com
N**     mail:                 support@freescale.com
N**
N**     Revisions:
N**     - rev. 1.0 (2016-08-12)
N**         Initial version.
N**
N** ###################################################################
N*/
N
N/*!
N * @file LPC54608.h
N * @version 1.0
N * @date 2016-08-12
N * @brief CMSIS Peripheral Access Layer for LPC54608
N *
N * CMSIS Peripheral Access Layer for LPC54608
N */
N
N#ifndef _LPC54608_H_
N#define _LPC54608_H_                             /**< Symbol preventing repeated inclusion */
N
N/** Memory map major version (memory maps with equal major version number are
N * compatible) */
N#define MCU_MEM_MAP_VERSION 0x0100U
N/** Memory map minor version */
N#define MCU_MEM_MAP_VERSION_MINOR 0x0000U
N
N
N/* ----------------------------------------------------------------------------
N   -- Interrupt vector numbers
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Interrupt_vector_numbers Interrupt vector numbers
N * @{
N */
N
N/** Interrupt Number Definitions */
N#define NUMBER_OF_INT_VECTORS 73                 /**< Number of interrupts in the Vector table */
N
Ntypedef enum IRQn {
N  /* Auxiliary constants */
N  NotAvail_IRQn                = -128,             /**< Not available device specific interrupt */
N
N  /* Core interrupts */
N  NonMaskableInt_IRQn          = -14,              /**< Non Maskable Interrupt */
N  HardFault_IRQn               = -13,              /**< Cortex-M4 SV Hard Fault Interrupt */
N  MemoryManagement_IRQn        = -12,              /**< Cortex-M4 Memory Management Interrupt */
N  BusFault_IRQn                = -11,              /**< Cortex-M4 Bus Fault Interrupt */
N  UsageFault_IRQn              = -10,              /**< Cortex-M4 Usage Fault Interrupt */
N  SVCall_IRQn                  = -5,               /**< Cortex-M4 SV Call Interrupt */
N  DebugMonitor_IRQn            = -4,               /**< Cortex-M4 Debug Monitor Interrupt */
N  PendSV_IRQn                  = -2,               /**< Cortex-M4 Pend SV Interrupt */
N  SysTick_IRQn                 = -1,               /**< Cortex-M4 System Tick Interrupt */
N
N  /* Device specific interrupts */
N  WDT_BOD_IRQn                 = 0,                /**< Windowed watchdog timer, Brownout detect */
N  DMA0_IRQn                    = 1,                /**< DMA controller */
N  GINT0_IRQn                   = 2,                /**< GPIO group 0 */
N  GINT1_IRQn                   = 3,                /**< GPIO group 1 */
N  PIN_INT0_IRQn                = 4,                /**< Pin interrupt 0 or pattern match engine slice 0 */
N  PIN_INT1_IRQn                = 5,                /**< Pin interrupt 1or pattern match engine slice 1 */
N  PIN_INT2_IRQn                = 6,                /**< Pin interrupt 2 or pattern match engine slice 2 */
N  PIN_INT3_IRQn                = 7,                /**< Pin interrupt 3 or pattern match engine slice 3 */
N  UTICK0_IRQn                  = 8,                /**< Micro-tick Timer */
N  MRT0_IRQn                    = 9,                /**< Multi-rate timer */
N  CTIMER0_IRQn                 = 10,               /**< Standard counter/timer CTIMER0 */
N  CTIMER1_IRQn                 = 11,               /**< Standard counter/timer CTIMER1 */
N  SCT0_IRQn                    = 12,               /**< SCTimer/PWM */
N  CTIMER3_IRQn                 = 13,               /**< Standard counter/timer CTIMER3 */
N  FLEXCOMM0_IRQn               = 14,               /**< Flexcomm Interface 0 (USART, SPI, I2C, FLEXCOMM) */
N  FLEXCOMM1_IRQn               = 15,               /**< Flexcomm Interface 1 (USART, SPI, I2C, FLEXCOMM) */
N  FLEXCOMM2_IRQn               = 16,               /**< Flexcomm Interface 2 (USART, SPI, I2C, FLEXCOMM) */
N  FLEXCOMM3_IRQn               = 17,               /**< Flexcomm Interface 3 (USART, SPI, I2C, FLEXCOMM) */
N  FLEXCOMM4_IRQn               = 18,               /**< Flexcomm Interface 4 (USART, SPI, I2C, FLEXCOMM) */
N  FLEXCOMM5_IRQn               = 19,               /**< Flexcomm Interface 5 (USART, SPI, I2C,, FLEXCOMM) */
N  FLEXCOMM6_IRQn               = 20,               /**< Flexcomm Interface 6 (USART, SPI, I2C, I2S,, FLEXCOMM) */
N  FLEXCOMM7_IRQn               = 21,               /**< Flexcomm Interface 7 (USART, SPI, I2C, I2S,, FLEXCOMM) */
N  ADC0_SEQA_IRQn               = 22,               /**< ADC0 sequence A completion. */
N  ADC0_SEQB_IRQn               = 23,               /**< ADC0 sequence B completion. */
N  ADC0_THCMP_IRQn              = 24,               /**< ADC0 threshold compare and error. */
N  DMIC0_IRQn                   = 25,               /**< Digital microphone and DMIC subsystem */
N  HWVAD0_IRQn                  = 26,               /**< Hardware Voice Activity Detector */
N  USB0_NEEDCLK_IRQn            = 27,               /**< USB Activity Wake-up Interrupt */
N  USB0_IRQn                    = 28,               /**< USB device */
N  RTC_IRQn                     = 29,               /**< RTC alarm and wake-up interrupts */
N  Reserved46_IRQn              = 30,               /**< Reserved interrupt */
N  Reserved47_IRQn              = 31,               /**< Reserved interrupt */
N  PIN_INT4_IRQn                = 32,               /**< Pin interrupt 4 or pattern match engine slice 4 int */
N  PIN_INT5_IRQn                = 33,               /**< Pin interrupt 5 or pattern match engine slice 5 int */
N  PIN_INT6_IRQn                = 34,               /**< Pin interrupt 6 or pattern match engine slice 6 int */
N  PIN_INT7_IRQn                = 35,               /**< Pin interrupt 7 or pattern match engine slice 7 int */
N  CTIMER2_IRQn                 = 36,               /**< Standard counter/timer CTIMER2 */
N  CTIMER4_IRQn                 = 37,               /**< Standard counter/timer CTIMER4 */
N  RIT_IRQn                     = 38,               /**< Repetitive Interrupt Timer */
N  SPIFI0_IRQn                  = 39,               /**< SPI flash interface */
N  FLEXCOMM8_IRQn               = 40,               /**< Flexcomm Interface 8 (USART, SPI, I2C, FLEXCOMM) */
N  FLEXCOMM9_IRQn               = 41,               /**< Flexcomm Interface 9 (USART, SPI, I2C, FLEXCOMM) */
N  SDIO_IRQn                    = 42,               /**< SD/MMC  */
N  CAN0_IRQ0_IRQn               = 43,               /**< CAN0 interrupt0 */
N  CAN0_IRQ1_IRQn               = 44,               /**< CAN0 interrupt1 */
N  CAN1_IRQ0_IRQn               = 45,               /**< CAN1 interrupt0 */
N  CAN1_IRQ1_IRQn               = 46,               /**< CAN1 interrupt1 */
N  USB1_IRQn                    = 47,               /**< USB1 interrupt */
N  USB1_NEEDCLK_IRQn            = 48,               /**< USB1 activity */
N  ETHERNET_IRQn                = 49,               /**< Ethernet */
N  ETHERNET_PMT_IRQn            = 50,               /**< Ethernet power management interrupt */
N  ETHERNET_MACLP_IRQn          = 51,               /**< Ethernet MAC interrupt */
N  EEPROM_IRQn                  = 52,               /**< EEPROM interrupt */
N  LCD_IRQn                     = 53,               /**< LCD interrupt */
N  SHA_IRQn                     = 54,               /**< SHA interrupt */
N  SMARTCARD0_IRQn              = 55,               /**< Smart card 0 interrupt */
N  SMARTCARD1_IRQn              = 56                /**< Smart card 1 interrupt */
N} IRQn_Type;
N
N/*!
N * @}
N */ /* end of group Interrupt_vector_numbers */
N
N
N/* ----------------------------------------------------------------------------
N   -- Cortex M4 Core Configuration
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Cortex_Core_Configuration Cortex M4 Core Configuration
N * @{
N */
N
N#define __MPU_PRESENT                  1         /**< Defines if an MPU is present or not */
N#define __NVIC_PRIO_BITS               3         /**< Number of priority bits implemented in the NVIC */
N#define __Vendor_SysTickConfig         0         /**< Vendor specific implementation of SysTickConfig is defined */
N#define __FPU_PRESENT                  1         /**< Defines if an FPU is present or not */
N
N#include "core_cm4.h"                  /* Core Peripheral Access Layer */
L 1 ".\SRC\System\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM4_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x04U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1U)
X    #if (1 == 1U)
N      #define __FPU_USED       1U
N    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
N    #endif
N  #else
S    #define __FPU_USED         0U
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 ".\SRC\System\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 ".\SRC\System\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x04U) == 0x04U) || ((0x04U) == 0x07U)
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
X#if (1 == 1U) && (1U == 1U)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return(result);
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x04U) >= 0x03U) || (__CORTEX_SC >= 300U)
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060422 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x04U) >= 0x04U)   
N
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
N
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 ".\SRC\System\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 211 ".\SRC\System\CMSIS\Include\core_cm4.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 ".\SRC\System\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 212 ".\SRC\System\CMSIS\Include\core_cm4.h" 2
N#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
L 1 ".\SRC\System\CMSIS\Include\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 213 ".\SRC\System\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RSERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
X  volatile uint32_t ACTLR;                   
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[29U];
N  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
X  volatile  uint32_t IWR;                     
N  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
X  volatile const  uint32_t IRR;                     
N  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                    
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N  \brief    Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
X  volatile uint32_t FPCCR;                   
N  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
X  volatile uint32_t FPCAR;                   
N  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
X  volatile uint32_t FPDSCR;                  
N  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
X  volatile const  uint32_t MVFR0;                   
N  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
X  volatile const  uint32_t MVFR1;                   
N} FPU_Type;
N
N/* Floating-Point Context Control Register Definitions */
N#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register Definitions */
N#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register Definitions */
N#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 Definitions */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 Definitions */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N#if (__FPU_PRESENT == 1U)
X#if (1 == 1U)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in NVIC and returns the active bit.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 3)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 3)));
N  }
N  else
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 3)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(3)) ? (uint32_t)(3) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(3)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(3));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 3) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != 0x5AA55AA5U)
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5U;        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == 0x5AA55AA5U)
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 181 ".\SRC\System\LPC54608.h" 2
N#include "system_LPC54608.h"           /* Device specific configuration file */
L 1 ".\SRC\System\system_LPC54608.h" 1
N/*
N** ###################################################################
N**     Processors:          LPC54608J512BD208
N**                          LPC54608J512ET180
N**
N**     Compilers:           Keil ARM C/C++ Compiler
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**
N**     Reference manual:    LPC54S60x/LPC5460x User manual Rev. 0.7 8 Sep 2016
N**     Version:             rev. 1.0, 2016-08-12
N**     Build:               b161018
N**
N**     Abstract:
N**         Provides a system configuration function and a global variable that
N**         contains the system frequency. It configures the device and initializes
N**         the oscillator (PLL) that is part of the microcontroller device.
N**
N**     Copyright (c) 2016 Freescale Semiconductor, Inc.
N**     All rights reserved.
N**
N**     Redistribution and use in source and binary forms, with or without modification,
N**     are permitted provided that the following conditions are met:
N**
N**     o Redistributions of source code must retain the above copyright notice, this list
N**       of conditions and the following disclaimer.
N**
N**     o Redistributions in binary form must reproduce the above copyright notice, this
N**       list of conditions and the following disclaimer in the documentation and/or
N**       other materials provided with the distribution.
N**
N**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N**       contributors may be used to endorse or promote products derived from this
N**       software without specific prior written permission.
N**
N**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N**
N**     http:                 www.freescale.com
N**     mail:                 support@freescale.com
N**
N**     Revisions:
N**     - rev. 1.0 (2016-08-12)
N**         Initial version.
N**
N** ###################################################################
N*/
N
N/*!
N * @file LPC54608
N * @version 1.0
N * @date 2016-08-12
N * @brief Device specific configuration file for LPC54608 (header file)
N *
N * Provides a system configuration function and a global variable that contains
N * the system frequency. It configures the device and initializes the oscillator
N * (PLL) that is part of the microcontroller device.
N */
N
N#ifndef _SYSTEM_LPC54608_H_
N#define _SYSTEM_LPC54608_H_                      /**< Symbol preventing repeated inclusion */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N#define DEFAULT_SYSTEM_CLOCK           12000000u           /* Default System clock value */
N#define CLK_RTC_32K_CLK                   32768u           /* RTC oscillator 32 kHz output (32k_clk */
N#define CLK_FRO_12MHZ                  12000000u           /* FRO 12 MHz (fro_12m) */
N#define CLK_FRO_48MHZ                  48000000u           /* FRO 48 MHz (fro_48m) */
N#define CLK_FRO_96MHZ                  96000000u           /* FRO 96 MHz (fro_96m) */
N#define CLK_CLK_IN                            0u           /* Default CLK_IN pin clock */
N
N
N/**
N * @brief System clock frequency (core clock)
N *
N * The system clock frequency supplied to the SysTick timer and the processor
N * core clock. This variable can be used by the user application to setup the
N * SysTick timer or configure other parameters. It may also be used by debugger to
N * query the frequency of the debug timer or configure the trace clock speed
N * SystemCoreClock is initialized with a correct predefined value.
N */
Nextern uint32_t SystemCoreClock;
N
N/**
N * @brief Setup the microcontroller system.
N *
N * Typically this function configures the oscillator (PLL) that is part of the
N * microcontroller device. For systems with variable clock speed it also updates
N * the variable SystemCoreClock. SystemInit is called from startup_device file.
N */
Nvoid SystemInit (void);
N
N/**
N * @brief Updates the SystemCoreClock variable.
N *
N * It must be called whenever the core clock is changed during program
N * execution. SystemCoreClockUpdate() evaluates the clock register settings and calculates
N * the current core clock.
N */
Nvoid SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* _SYSTEM_LPC54608_H_ */
L 182 ".\SRC\System\LPC54608.h" 2
N
N/*!
N * @}
N */ /* end of group Cortex_Core_Configuration */
N
N
N/* ----------------------------------------------------------------------------
N   -- Mapping Information
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Mapping_Information Mapping Information
N * @{
N */
N
N/** Mapping Information */
N
N/*!
N * @}
N */ /* end of group Mapping_Information */
N
N
N/* ----------------------------------------------------------------------------
N   -- Device Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Peripheral_access_layer Device Peripheral Access Layer
N * @{
N */
N
N
N/*
N** Start of section using anonymous unions
N*/
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma language=extended
S#else
S  #error Not supported compiler type
N#endif
N
N/* ----------------------------------------------------------------------------
N   -- ADC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ADC_Peripheral_Access_Layer ADC Peripheral Access Layer
N * @{
N */
N
N/** ADC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< ADC Control register. Contains the clock divide value, resolution selection, sampling time selection, and mode controls., offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t INSEL;                             /**< Input Select. Allows selection of the temperature sensor as an alternate input to ADC channel 0., offset: 0x4 */
X  volatile uint32_t INSEL;                              
N  __IO uint32_t SEQ_CTRL[2];                       /**< ADC Conversion Sequence-n control register: Controls triggering and channel selection for conversion sequence-n. Also specifies interrupt mode for sequence-n., array offset: 0x8, array step: 0x4 */
X  volatile uint32_t SEQ_CTRL[2];                        
N  __I  uint32_t SEQ_GDAT[2];                       /**< ADC Sequence-n Global Data register. This register contains the result of the most recent ADC conversion performed under sequence-n., array offset: 0x10, array step: 0x4 */
X  volatile const  uint32_t SEQ_GDAT[2];                        
N       uint8_t RESERVED_0[8];
N  __I  uint32_t DAT[12];                           /**< ADC Channel 0 Data register. This register contains the result of the most recent conversion completed on channel 0., array offset: 0x20, array step: 0x4 */
X  volatile const  uint32_t DAT[12];                            
N  __IO uint32_t THR0_LOW;                          /**< ADC Low Compare Threshold register 0: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0., offset: 0x50 */
X  volatile uint32_t THR0_LOW;                           
N  __IO uint32_t THR1_LOW;                          /**< ADC Low Compare Threshold register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1., offset: 0x54 */
X  volatile uint32_t THR1_LOW;                           
N  __IO uint32_t THR0_HIGH;                         /**< ADC High Compare Threshold register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0., offset: 0x58 */
X  volatile uint32_t THR0_HIGH;                          
N  __IO uint32_t THR1_HIGH;                         /**< ADC High Compare Threshold register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1., offset: 0x5C */
X  volatile uint32_t THR1_HIGH;                          
N  __IO uint32_t CHAN_THRSEL;                       /**< ADC Channel-Threshold Select register. Specifies which set of threshold compare registers are to be used for each channel, offset: 0x60 */
X  volatile uint32_t CHAN_THRSEL;                        
N  __IO uint32_t INTEN;                             /**< ADC Interrupt Enable register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated., offset: 0x64 */
X  volatile uint32_t INTEN;                              
N  __IO uint32_t FLAGS;                             /**< ADC Flags register. Contains the four interrupt/DMA trigger flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers)., offset: 0x68 */
X  volatile uint32_t FLAGS;                              
N  __IO uint32_t STARTUP;                           /**< ADC Startup register., offset: 0x6C */
X  volatile uint32_t STARTUP;                            
N  __IO uint32_t CALIB;                             /**< ADC Calibration register., offset: 0x70 */
X  volatile uint32_t CALIB;                              
N} ADC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ADC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ADC_Register_Masks ADC Register Masks
N * @{
N */
N
N/*! @name CTRL - ADC Control register. Contains the clock divide value, resolution selection, sampling time selection, and mode controls. */
N#define ADC_CTRL_CLKDIV_MASK                     (0xFFU)
N#define ADC_CTRL_CLKDIV_SHIFT                    (0U)
N#define ADC_CTRL_CLKDIV(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_CLKDIV_SHIFT)) & ADC_CTRL_CLKDIV_MASK)
N#define ADC_CTRL_ASYNMODE_MASK                   (0x100U)
N#define ADC_CTRL_ASYNMODE_SHIFT                  (8U)
N#define ADC_CTRL_ASYNMODE(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_ASYNMODE_SHIFT)) & ADC_CTRL_ASYNMODE_MASK)
N#define ADC_CTRL_RESOL_MASK                      (0x600U)
N#define ADC_CTRL_RESOL_SHIFT                     (9U)
N#define ADC_CTRL_RESOL(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_RESOL_SHIFT)) & ADC_CTRL_RESOL_MASK)
N#define ADC_CTRL_BYPASSCAL_MASK                  (0x800U)
N#define ADC_CTRL_BYPASSCAL_SHIFT                 (11U)
N#define ADC_CTRL_BYPASSCAL(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_BYPASSCAL_SHIFT)) & ADC_CTRL_BYPASSCAL_MASK)
N#define ADC_CTRL_TSAMP_MASK                      (0x7000U)
N#define ADC_CTRL_TSAMP_SHIFT                     (12U)
N#define ADC_CTRL_TSAMP(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_TSAMP_SHIFT)) & ADC_CTRL_TSAMP_MASK)
N
N/*! @name INSEL - Input Select. Allows selection of the temperature sensor as an alternate input to ADC channel 0. */
N#define ADC_INSEL_SEL_MASK                       (0x3U)
N#define ADC_INSEL_SEL_SHIFT                      (0U)
N#define ADC_INSEL_SEL(x)                         (((uint32_t)(((uint32_t)(x)) << ADC_INSEL_SEL_SHIFT)) & ADC_INSEL_SEL_MASK)
N
N/*! @name SEQ_CTRL - ADC Conversion Sequence-n control register: Controls triggering and channel selection for conversion sequence-n. Also specifies interrupt mode for sequence-n. */
N#define ADC_SEQ_CTRL_CHANNELS_MASK               (0xFFFU)
N#define ADC_SEQ_CTRL_CHANNELS_SHIFT              (0U)
N#define ADC_SEQ_CTRL_CHANNELS(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_CHANNELS_SHIFT)) & ADC_SEQ_CTRL_CHANNELS_MASK)
N#define ADC_SEQ_CTRL_TRIGGER_MASK                (0x3F000U)
N#define ADC_SEQ_CTRL_TRIGGER_SHIFT               (12U)
N#define ADC_SEQ_CTRL_TRIGGER(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_TRIGGER_SHIFT)) & ADC_SEQ_CTRL_TRIGGER_MASK)
N#define ADC_SEQ_CTRL_TRIGPOL_MASK                (0x40000U)
N#define ADC_SEQ_CTRL_TRIGPOL_SHIFT               (18U)
N#define ADC_SEQ_CTRL_TRIGPOL(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_TRIGPOL_SHIFT)) & ADC_SEQ_CTRL_TRIGPOL_MASK)
N#define ADC_SEQ_CTRL_SYNCBYPASS_MASK             (0x80000U)
N#define ADC_SEQ_CTRL_SYNCBYPASS_SHIFT            (19U)
N#define ADC_SEQ_CTRL_SYNCBYPASS(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_SYNCBYPASS_SHIFT)) & ADC_SEQ_CTRL_SYNCBYPASS_MASK)
N#define ADC_SEQ_CTRL_START_MASK                  (0x4000000U)
N#define ADC_SEQ_CTRL_START_SHIFT                 (26U)
N#define ADC_SEQ_CTRL_START(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_START_SHIFT)) & ADC_SEQ_CTRL_START_MASK)
N#define ADC_SEQ_CTRL_BURST_MASK                  (0x8000000U)
N#define ADC_SEQ_CTRL_BURST_SHIFT                 (27U)
N#define ADC_SEQ_CTRL_BURST(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_BURST_SHIFT)) & ADC_SEQ_CTRL_BURST_MASK)
N#define ADC_SEQ_CTRL_SINGLESTEP_MASK             (0x10000000U)
N#define ADC_SEQ_CTRL_SINGLESTEP_SHIFT            (28U)
N#define ADC_SEQ_CTRL_SINGLESTEP(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_SINGLESTEP_SHIFT)) & ADC_SEQ_CTRL_SINGLESTEP_MASK)
N#define ADC_SEQ_CTRL_LOWPRIO_MASK                (0x20000000U)
N#define ADC_SEQ_CTRL_LOWPRIO_SHIFT               (29U)
N#define ADC_SEQ_CTRL_LOWPRIO(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_LOWPRIO_SHIFT)) & ADC_SEQ_CTRL_LOWPRIO_MASK)
N#define ADC_SEQ_CTRL_MODE_MASK                   (0x40000000U)
N#define ADC_SEQ_CTRL_MODE_SHIFT                  (30U)
N#define ADC_SEQ_CTRL_MODE(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_MODE_SHIFT)) & ADC_SEQ_CTRL_MODE_MASK)
N#define ADC_SEQ_CTRL_SEQ_ENA_MASK                (0x80000000U)
N#define ADC_SEQ_CTRL_SEQ_ENA_SHIFT               (31U)
N#define ADC_SEQ_CTRL_SEQ_ENA(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_SEQ_ENA_SHIFT)) & ADC_SEQ_CTRL_SEQ_ENA_MASK)
N
N/* The count of ADC_SEQ_CTRL */
N#define ADC_SEQ_CTRL_COUNT                       (2U)
N
N/*! @name SEQ_GDAT - ADC Sequence-n Global Data register. This register contains the result of the most recent ADC conversion performed under sequence-n. */
N#define ADC_SEQ_GDAT_RESULT_MASK                 (0xFFF0U)
N#define ADC_SEQ_GDAT_RESULT_SHIFT                (4U)
N#define ADC_SEQ_GDAT_RESULT(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_RESULT_SHIFT)) & ADC_SEQ_GDAT_RESULT_MASK)
N#define ADC_SEQ_GDAT_THCMPRANGE_MASK             (0x30000U)
N#define ADC_SEQ_GDAT_THCMPRANGE_SHIFT            (16U)
N#define ADC_SEQ_GDAT_THCMPRANGE(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_THCMPRANGE_SHIFT)) & ADC_SEQ_GDAT_THCMPRANGE_MASK)
N#define ADC_SEQ_GDAT_THCMPCROSS_MASK             (0xC0000U)
N#define ADC_SEQ_GDAT_THCMPCROSS_SHIFT            (18U)
N#define ADC_SEQ_GDAT_THCMPCROSS(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_THCMPCROSS_SHIFT)) & ADC_SEQ_GDAT_THCMPCROSS_MASK)
N#define ADC_SEQ_GDAT_CHN_MASK                    (0x3C000000U)
N#define ADC_SEQ_GDAT_CHN_SHIFT                   (26U)
N#define ADC_SEQ_GDAT_CHN(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_CHN_SHIFT)) & ADC_SEQ_GDAT_CHN_MASK)
N#define ADC_SEQ_GDAT_OVERRUN_MASK                (0x40000000U)
N#define ADC_SEQ_GDAT_OVERRUN_SHIFT               (30U)
N#define ADC_SEQ_GDAT_OVERRUN(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_OVERRUN_SHIFT)) & ADC_SEQ_GDAT_OVERRUN_MASK)
N#define ADC_SEQ_GDAT_DATAVALID_MASK              (0x80000000U)
N#define ADC_SEQ_GDAT_DATAVALID_SHIFT             (31U)
N#define ADC_SEQ_GDAT_DATAVALID(x)                (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_DATAVALID_SHIFT)) & ADC_SEQ_GDAT_DATAVALID_MASK)
N
N/* The count of ADC_SEQ_GDAT */
N#define ADC_SEQ_GDAT_COUNT                       (2U)
N
N/*! @name DAT - ADC Channel 0 Data register. This register contains the result of the most recent conversion completed on channel 0. */
N#define ADC_DAT_RESULT_MASK                      (0xFFF0U)
N#define ADC_DAT_RESULT_SHIFT                     (4U)
N#define ADC_DAT_RESULT(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_DAT_RESULT_SHIFT)) & ADC_DAT_RESULT_MASK)
N#define ADC_DAT_THCMPRANGE_MASK                  (0x30000U)
N#define ADC_DAT_THCMPRANGE_SHIFT                 (16U)
N#define ADC_DAT_THCMPRANGE(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_DAT_THCMPRANGE_SHIFT)) & ADC_DAT_THCMPRANGE_MASK)
N#define ADC_DAT_THCMPCROSS_MASK                  (0xC0000U)
N#define ADC_DAT_THCMPCROSS_SHIFT                 (18U)
N#define ADC_DAT_THCMPCROSS(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_DAT_THCMPCROSS_SHIFT)) & ADC_DAT_THCMPCROSS_MASK)
N#define ADC_DAT_CHANNEL_MASK                     (0x3C000000U)
N#define ADC_DAT_CHANNEL_SHIFT                    (26U)
N#define ADC_DAT_CHANNEL(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_DAT_CHANNEL_SHIFT)) & ADC_DAT_CHANNEL_MASK)
N#define ADC_DAT_OVERRUN_MASK                     (0x40000000U)
N#define ADC_DAT_OVERRUN_SHIFT                    (30U)
N#define ADC_DAT_OVERRUN(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_DAT_OVERRUN_SHIFT)) & ADC_DAT_OVERRUN_MASK)
N#define ADC_DAT_DATAVALID_MASK                   (0x80000000U)
N#define ADC_DAT_DATAVALID_SHIFT                  (31U)
N#define ADC_DAT_DATAVALID(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_DAT_DATAVALID_SHIFT)) & ADC_DAT_DATAVALID_MASK)
N
N/* The count of ADC_DAT */
N#define ADC_DAT_COUNT                            (12U)
N
N/*! @name THR0_LOW - ADC Low Compare Threshold register 0: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0. */
N#define ADC_THR0_LOW_THRLOW_MASK                 (0xFFF0U)
N#define ADC_THR0_LOW_THRLOW_SHIFT                (4U)
N#define ADC_THR0_LOW_THRLOW(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_THR0_LOW_THRLOW_SHIFT)) & ADC_THR0_LOW_THRLOW_MASK)
N
N/*! @name THR1_LOW - ADC Low Compare Threshold register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1. */
N#define ADC_THR1_LOW_THRLOW_MASK                 (0xFFF0U)
N#define ADC_THR1_LOW_THRLOW_SHIFT                (4U)
N#define ADC_THR1_LOW_THRLOW(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_THR1_LOW_THRLOW_SHIFT)) & ADC_THR1_LOW_THRLOW_MASK)
N
N/*! @name THR0_HIGH - ADC High Compare Threshold register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0. */
N#define ADC_THR0_HIGH_THRHIGH_MASK               (0xFFF0U)
N#define ADC_THR0_HIGH_THRHIGH_SHIFT              (4U)
N#define ADC_THR0_HIGH_THRHIGH(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_THR0_HIGH_THRHIGH_SHIFT)) & ADC_THR0_HIGH_THRHIGH_MASK)
N
N/*! @name THR1_HIGH - ADC High Compare Threshold register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1. */
N#define ADC_THR1_HIGH_THRHIGH_MASK               (0xFFF0U)
N#define ADC_THR1_HIGH_THRHIGH_SHIFT              (4U)
N#define ADC_THR1_HIGH_THRHIGH(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_THR1_HIGH_THRHIGH_SHIFT)) & ADC_THR1_HIGH_THRHIGH_MASK)
N
N/*! @name CHAN_THRSEL - ADC Channel-Threshold Select register. Specifies which set of threshold compare registers are to be used for each channel */
N#define ADC_CHAN_THRSEL_CH0_THRSEL_MASK          (0x1U)
N#define ADC_CHAN_THRSEL_CH0_THRSEL_SHIFT         (0U)
N#define ADC_CHAN_THRSEL_CH0_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH0_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH0_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH1_THRSEL_MASK          (0x2U)
N#define ADC_CHAN_THRSEL_CH1_THRSEL_SHIFT         (1U)
N#define ADC_CHAN_THRSEL_CH1_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH1_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH1_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH2_THRSEL_MASK          (0x4U)
N#define ADC_CHAN_THRSEL_CH2_THRSEL_SHIFT         (2U)
N#define ADC_CHAN_THRSEL_CH2_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH2_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH2_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH3_THRSEL_MASK          (0x8U)
N#define ADC_CHAN_THRSEL_CH3_THRSEL_SHIFT         (3U)
N#define ADC_CHAN_THRSEL_CH3_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH3_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH3_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH4_THRSEL_MASK          (0x10U)
N#define ADC_CHAN_THRSEL_CH4_THRSEL_SHIFT         (4U)
N#define ADC_CHAN_THRSEL_CH4_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH4_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH4_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH5_THRSEL_MASK          (0x20U)
N#define ADC_CHAN_THRSEL_CH5_THRSEL_SHIFT         (5U)
N#define ADC_CHAN_THRSEL_CH5_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH5_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH5_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH6_THRSEL_MASK          (0x40U)
N#define ADC_CHAN_THRSEL_CH6_THRSEL_SHIFT         (6U)
N#define ADC_CHAN_THRSEL_CH6_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH6_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH6_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH7_THRSEL_MASK          (0x80U)
N#define ADC_CHAN_THRSEL_CH7_THRSEL_SHIFT         (7U)
N#define ADC_CHAN_THRSEL_CH7_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH7_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH7_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH8_THRSEL_MASK          (0x100U)
N#define ADC_CHAN_THRSEL_CH8_THRSEL_SHIFT         (8U)
N#define ADC_CHAN_THRSEL_CH8_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH8_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH8_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH9_THRSEL_MASK          (0x200U)
N#define ADC_CHAN_THRSEL_CH9_THRSEL_SHIFT         (9U)
N#define ADC_CHAN_THRSEL_CH9_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH9_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH9_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH10_THRSEL_MASK         (0x400U)
N#define ADC_CHAN_THRSEL_CH10_THRSEL_SHIFT        (10U)
N#define ADC_CHAN_THRSEL_CH10_THRSEL(x)           (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH10_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH10_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH11_THRSEL_MASK         (0x800U)
N#define ADC_CHAN_THRSEL_CH11_THRSEL_SHIFT        (11U)
N#define ADC_CHAN_THRSEL_CH11_THRSEL(x)           (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH11_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH11_THRSEL_MASK)
N
N/*! @name INTEN - ADC Interrupt Enable register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated. */
N#define ADC_INTEN_SEQA_INTEN_MASK                (0x1U)
N#define ADC_INTEN_SEQA_INTEN_SHIFT               (0U)
N#define ADC_INTEN_SEQA_INTEN(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_SEQA_INTEN_SHIFT)) & ADC_INTEN_SEQA_INTEN_MASK)
N#define ADC_INTEN_SEQB_INTEN_MASK                (0x2U)
N#define ADC_INTEN_SEQB_INTEN_SHIFT               (1U)
N#define ADC_INTEN_SEQB_INTEN(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_SEQB_INTEN_SHIFT)) & ADC_INTEN_SEQB_INTEN_MASK)
N#define ADC_INTEN_OVR_INTEN_MASK                 (0x4U)
N#define ADC_INTEN_OVR_INTEN_SHIFT                (2U)
N#define ADC_INTEN_OVR_INTEN(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_OVR_INTEN_SHIFT)) & ADC_INTEN_OVR_INTEN_MASK)
N#define ADC_INTEN_ADCMPINTEN0_MASK               (0x18U)
N#define ADC_INTEN_ADCMPINTEN0_SHIFT              (3U)
N#define ADC_INTEN_ADCMPINTEN0(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN0_SHIFT)) & ADC_INTEN_ADCMPINTEN0_MASK)
N#define ADC_INTEN_ADCMPINTEN1_MASK               (0x60U)
N#define ADC_INTEN_ADCMPINTEN1_SHIFT              (5U)
N#define ADC_INTEN_ADCMPINTEN1(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN1_SHIFT)) & ADC_INTEN_ADCMPINTEN1_MASK)
N#define ADC_INTEN_ADCMPINTEN2_MASK               (0x180U)
N#define ADC_INTEN_ADCMPINTEN2_SHIFT              (7U)
N#define ADC_INTEN_ADCMPINTEN2(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN2_SHIFT)) & ADC_INTEN_ADCMPINTEN2_MASK)
N#define ADC_INTEN_ADCMPINTEN3_MASK               (0x600U)
N#define ADC_INTEN_ADCMPINTEN3_SHIFT              (9U)
N#define ADC_INTEN_ADCMPINTEN3(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN3_SHIFT)) & ADC_INTEN_ADCMPINTEN3_MASK)
N#define ADC_INTEN_ADCMPINTEN4_MASK               (0x1800U)
N#define ADC_INTEN_ADCMPINTEN4_SHIFT              (11U)
N#define ADC_INTEN_ADCMPINTEN4(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN4_SHIFT)) & ADC_INTEN_ADCMPINTEN4_MASK)
N#define ADC_INTEN_ADCMPINTEN5_MASK               (0x6000U)
N#define ADC_INTEN_ADCMPINTEN5_SHIFT              (13U)
N#define ADC_INTEN_ADCMPINTEN5(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN5_SHIFT)) & ADC_INTEN_ADCMPINTEN5_MASK)
N#define ADC_INTEN_ADCMPINTEN6_MASK               (0x18000U)
N#define ADC_INTEN_ADCMPINTEN6_SHIFT              (15U)
N#define ADC_INTEN_ADCMPINTEN6(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN6_SHIFT)) & ADC_INTEN_ADCMPINTEN6_MASK)
N#define ADC_INTEN_ADCMPINTEN7_MASK               (0x60000U)
N#define ADC_INTEN_ADCMPINTEN7_SHIFT              (17U)
N#define ADC_INTEN_ADCMPINTEN7(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN7_SHIFT)) & ADC_INTEN_ADCMPINTEN7_MASK)
N#define ADC_INTEN_ADCMPINTEN8_MASK               (0x180000U)
N#define ADC_INTEN_ADCMPINTEN8_SHIFT              (19U)
N#define ADC_INTEN_ADCMPINTEN8(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN8_SHIFT)) & ADC_INTEN_ADCMPINTEN8_MASK)
N#define ADC_INTEN_ADCMPINTEN9_MASK               (0x600000U)
N#define ADC_INTEN_ADCMPINTEN9_SHIFT              (21U)
N#define ADC_INTEN_ADCMPINTEN9(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN9_SHIFT)) & ADC_INTEN_ADCMPINTEN9_MASK)
N#define ADC_INTEN_ADCMPINTEN10_MASK              (0x1800000U)
N#define ADC_INTEN_ADCMPINTEN10_SHIFT             (23U)
N#define ADC_INTEN_ADCMPINTEN10(x)                (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN10_SHIFT)) & ADC_INTEN_ADCMPINTEN10_MASK)
N#define ADC_INTEN_ADCMPINTEN11_MASK              (0x6000000U)
N#define ADC_INTEN_ADCMPINTEN11_SHIFT             (25U)
N#define ADC_INTEN_ADCMPINTEN11(x)                (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN11_SHIFT)) & ADC_INTEN_ADCMPINTEN11_MASK)
N
N/*! @name FLAGS - ADC Flags register. Contains the four interrupt/DMA trigger flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers). */
N#define ADC_FLAGS_THCMP0_MASK                    (0x1U)
N#define ADC_FLAGS_THCMP0_SHIFT                   (0U)
N#define ADC_FLAGS_THCMP0(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP0_SHIFT)) & ADC_FLAGS_THCMP0_MASK)
N#define ADC_FLAGS_THCMP1_MASK                    (0x2U)
N#define ADC_FLAGS_THCMP1_SHIFT                   (1U)
N#define ADC_FLAGS_THCMP1(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP1_SHIFT)) & ADC_FLAGS_THCMP1_MASK)
N#define ADC_FLAGS_THCMP2_MASK                    (0x4U)
N#define ADC_FLAGS_THCMP2_SHIFT                   (2U)
N#define ADC_FLAGS_THCMP2(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP2_SHIFT)) & ADC_FLAGS_THCMP2_MASK)
N#define ADC_FLAGS_THCMP3_MASK                    (0x8U)
N#define ADC_FLAGS_THCMP3_SHIFT                   (3U)
N#define ADC_FLAGS_THCMP3(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP3_SHIFT)) & ADC_FLAGS_THCMP3_MASK)
N#define ADC_FLAGS_THCMP4_MASK                    (0x10U)
N#define ADC_FLAGS_THCMP4_SHIFT                   (4U)
N#define ADC_FLAGS_THCMP4(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP4_SHIFT)) & ADC_FLAGS_THCMP4_MASK)
N#define ADC_FLAGS_THCMP5_MASK                    (0x20U)
N#define ADC_FLAGS_THCMP5_SHIFT                   (5U)
N#define ADC_FLAGS_THCMP5(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP5_SHIFT)) & ADC_FLAGS_THCMP5_MASK)
N#define ADC_FLAGS_THCMP6_MASK                    (0x40U)
N#define ADC_FLAGS_THCMP6_SHIFT                   (6U)
N#define ADC_FLAGS_THCMP6(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP6_SHIFT)) & ADC_FLAGS_THCMP6_MASK)
N#define ADC_FLAGS_THCMP7_MASK                    (0x80U)
N#define ADC_FLAGS_THCMP7_SHIFT                   (7U)
N#define ADC_FLAGS_THCMP7(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP7_SHIFT)) & ADC_FLAGS_THCMP7_MASK)
N#define ADC_FLAGS_THCMP8_MASK                    (0x100U)
N#define ADC_FLAGS_THCMP8_SHIFT                   (8U)
N#define ADC_FLAGS_THCMP8(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP8_SHIFT)) & ADC_FLAGS_THCMP8_MASK)
N#define ADC_FLAGS_THCMP9_MASK                    (0x200U)
N#define ADC_FLAGS_THCMP9_SHIFT                   (9U)
N#define ADC_FLAGS_THCMP9(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP9_SHIFT)) & ADC_FLAGS_THCMP9_MASK)
N#define ADC_FLAGS_THCMP10_MASK                   (0x400U)
N#define ADC_FLAGS_THCMP10_SHIFT                  (10U)
N#define ADC_FLAGS_THCMP10(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP10_SHIFT)) & ADC_FLAGS_THCMP10_MASK)
N#define ADC_FLAGS_THCMP11_MASK                   (0x800U)
N#define ADC_FLAGS_THCMP11_SHIFT                  (11U)
N#define ADC_FLAGS_THCMP11(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP11_SHIFT)) & ADC_FLAGS_THCMP11_MASK)
N#define ADC_FLAGS_OVERRUN0_MASK                  (0x1000U)
N#define ADC_FLAGS_OVERRUN0_SHIFT                 (12U)
N#define ADC_FLAGS_OVERRUN0(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN0_SHIFT)) & ADC_FLAGS_OVERRUN0_MASK)
N#define ADC_FLAGS_OVERRUN1_MASK                  (0x2000U)
N#define ADC_FLAGS_OVERRUN1_SHIFT                 (13U)
N#define ADC_FLAGS_OVERRUN1(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN1_SHIFT)) & ADC_FLAGS_OVERRUN1_MASK)
N#define ADC_FLAGS_OVERRUN2_MASK                  (0x4000U)
N#define ADC_FLAGS_OVERRUN2_SHIFT                 (14U)
N#define ADC_FLAGS_OVERRUN2(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN2_SHIFT)) & ADC_FLAGS_OVERRUN2_MASK)
N#define ADC_FLAGS_OVERRUN3_MASK                  (0x8000U)
N#define ADC_FLAGS_OVERRUN3_SHIFT                 (15U)
N#define ADC_FLAGS_OVERRUN3(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN3_SHIFT)) & ADC_FLAGS_OVERRUN3_MASK)
N#define ADC_FLAGS_OVERRUN4_MASK                  (0x10000U)
N#define ADC_FLAGS_OVERRUN4_SHIFT                 (16U)
N#define ADC_FLAGS_OVERRUN4(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN4_SHIFT)) & ADC_FLAGS_OVERRUN4_MASK)
N#define ADC_FLAGS_OVERRUN5_MASK                  (0x20000U)
N#define ADC_FLAGS_OVERRUN5_SHIFT                 (17U)
N#define ADC_FLAGS_OVERRUN5(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN5_SHIFT)) & ADC_FLAGS_OVERRUN5_MASK)
N#define ADC_FLAGS_OVERRUN6_MASK                  (0x40000U)
N#define ADC_FLAGS_OVERRUN6_SHIFT                 (18U)
N#define ADC_FLAGS_OVERRUN6(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN6_SHIFT)) & ADC_FLAGS_OVERRUN6_MASK)
N#define ADC_FLAGS_OVERRUN7_MASK                  (0x80000U)
N#define ADC_FLAGS_OVERRUN7_SHIFT                 (19U)
N#define ADC_FLAGS_OVERRUN7(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN7_SHIFT)) & ADC_FLAGS_OVERRUN7_MASK)
N#define ADC_FLAGS_OVERRUN8_MASK                  (0x100000U)
N#define ADC_FLAGS_OVERRUN8_SHIFT                 (20U)
N#define ADC_FLAGS_OVERRUN8(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN8_SHIFT)) & ADC_FLAGS_OVERRUN8_MASK)
N#define ADC_FLAGS_OVERRUN9_MASK                  (0x200000U)
N#define ADC_FLAGS_OVERRUN9_SHIFT                 (21U)
N#define ADC_FLAGS_OVERRUN9(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN9_SHIFT)) & ADC_FLAGS_OVERRUN9_MASK)
N#define ADC_FLAGS_OVERRUN10_MASK                 (0x400000U)
N#define ADC_FLAGS_OVERRUN10_SHIFT                (22U)
N#define ADC_FLAGS_OVERRUN10(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN10_SHIFT)) & ADC_FLAGS_OVERRUN10_MASK)
N#define ADC_FLAGS_OVERRUN11_MASK                 (0x800000U)
N#define ADC_FLAGS_OVERRUN11_SHIFT                (23U)
N#define ADC_FLAGS_OVERRUN11(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN11_SHIFT)) & ADC_FLAGS_OVERRUN11_MASK)
N#define ADC_FLAGS_SEQA_OVR_MASK                  (0x1000000U)
N#define ADC_FLAGS_SEQA_OVR_SHIFT                 (24U)
N#define ADC_FLAGS_SEQA_OVR(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQA_OVR_SHIFT)) & ADC_FLAGS_SEQA_OVR_MASK)
N#define ADC_FLAGS_SEQB_OVR_MASK                  (0x2000000U)
N#define ADC_FLAGS_SEQB_OVR_SHIFT                 (25U)
N#define ADC_FLAGS_SEQB_OVR(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQB_OVR_SHIFT)) & ADC_FLAGS_SEQB_OVR_MASK)
N#define ADC_FLAGS_SEQA_INT_MASK                  (0x10000000U)
N#define ADC_FLAGS_SEQA_INT_SHIFT                 (28U)
N#define ADC_FLAGS_SEQA_INT(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQA_INT_SHIFT)) & ADC_FLAGS_SEQA_INT_MASK)
N#define ADC_FLAGS_SEQB_INT_MASK                  (0x20000000U)
N#define ADC_FLAGS_SEQB_INT_SHIFT                 (29U)
N#define ADC_FLAGS_SEQB_INT(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQB_INT_SHIFT)) & ADC_FLAGS_SEQB_INT_MASK)
N#define ADC_FLAGS_THCMP_INT_MASK                 (0x40000000U)
N#define ADC_FLAGS_THCMP_INT_SHIFT                (30U)
N#define ADC_FLAGS_THCMP_INT(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP_INT_SHIFT)) & ADC_FLAGS_THCMP_INT_MASK)
N#define ADC_FLAGS_OVR_INT_MASK                   (0x80000000U)
N#define ADC_FLAGS_OVR_INT_SHIFT                  (31U)
N#define ADC_FLAGS_OVR_INT(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVR_INT_SHIFT)) & ADC_FLAGS_OVR_INT_MASK)
N
N/*! @name STARTUP - ADC Startup register. */
N#define ADC_STARTUP_ADC_ENA_MASK                 (0x1U)
N#define ADC_STARTUP_ADC_ENA_SHIFT                (0U)
N#define ADC_STARTUP_ADC_ENA(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_STARTUP_ADC_ENA_SHIFT)) & ADC_STARTUP_ADC_ENA_MASK)
N#define ADC_STARTUP_ADC_INIT_MASK                (0x2U)
N#define ADC_STARTUP_ADC_INIT_SHIFT               (1U)
N#define ADC_STARTUP_ADC_INIT(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_STARTUP_ADC_INIT_SHIFT)) & ADC_STARTUP_ADC_INIT_MASK)
N
N/*! @name CALIB - ADC Calibration register. */
N#define ADC_CALIB_CALIB_MASK                     (0x1U)
N#define ADC_CALIB_CALIB_SHIFT                    (0U)
N#define ADC_CALIB_CALIB(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CALIB_CALIB_SHIFT)) & ADC_CALIB_CALIB_MASK)
N#define ADC_CALIB_CALREQD_MASK                   (0x2U)
N#define ADC_CALIB_CALREQD_SHIFT                  (1U)
N#define ADC_CALIB_CALREQD(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_CALIB_CALREQD_SHIFT)) & ADC_CALIB_CALREQD_MASK)
N#define ADC_CALIB_CALVALUE_MASK                  (0x1FCU)
N#define ADC_CALIB_CALVALUE_SHIFT                 (2U)
N#define ADC_CALIB_CALVALUE(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_CALIB_CALVALUE_SHIFT)) & ADC_CALIB_CALVALUE_MASK)
N
N
N/*!
N * @}
N */ /* end of group ADC_Register_Masks */
N
N
N/* ADC - Peripheral instance base addresses */
N/** Peripheral ADC0 base address */
N#define ADC0_BASE                                (0x400A0000u)
N/** Peripheral ADC0 base pointer */
N#define ADC0                                     ((ADC_Type *)ADC0_BASE)
N/** Array initializer of ADC peripheral base addresses */
N#define ADC_BASE_ADDRS                           { ADC0_BASE }
N/** Array initializer of ADC peripheral base pointers */
N#define ADC_BASE_PTRS                            { ADC0 }
N/** Interrupt vectors for the ADC peripheral type */
N#define ADC_SEQ_IRQS                             { ADC0_SEQA_IRQn, ADC0_SEQB_IRQn }
N#define ADC_THCMP_IRQS                           { ADC0_THCMP_IRQn }
N
N/*!
N * @}
N */ /* end of group ADC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- ASYNC_SYSCON Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ASYNC_SYSCON_Peripheral_Access_Layer ASYNC_SYSCON Peripheral Access Layer
N * @{
N */
N
N/** ASYNC_SYSCON - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t ASYNCPRESETCTRL;                   /**< Async peripheral reset control, offset: 0x0 */
X  volatile uint32_t ASYNCPRESETCTRL;                    
N  __O  uint32_t ASYNCPRESETCTRLSET;                /**< Set bits in ASYNCPRESETCTRL, offset: 0x4 */
X  volatile  uint32_t ASYNCPRESETCTRLSET;                 
N  __O  uint32_t ASYNCPRESETCTRLCLR;                /**< Clear bits in ASYNCPRESETCTRL, offset: 0x8 */
X  volatile  uint32_t ASYNCPRESETCTRLCLR;                 
N       uint8_t RESERVED_0[4];
N  __IO uint32_t ASYNCAPBCLKCTRL;                   /**< Async peripheral clock control, offset: 0x10 */
X  volatile uint32_t ASYNCAPBCLKCTRL;                    
N  __O  uint32_t ASYNCAPBCLKCTRLSET;                /**< Set bits in ASYNCAPBCLKCTRL, offset: 0x14 */
X  volatile  uint32_t ASYNCAPBCLKCTRLSET;                 
N  __O  uint32_t ASYNCAPBCLKCTRLCLR;                /**< Clear bits in ASYNCAPBCLKCTRL, offset: 0x18 */
X  volatile  uint32_t ASYNCAPBCLKCTRLCLR;                 
N       uint8_t RESERVED_1[4];
N  __IO uint32_t ASYNCAPBCLKSELA;                   /**< Async APB clock source select A, offset: 0x20 */
X  volatile uint32_t ASYNCAPBCLKSELA;                    
N} ASYNC_SYSCON_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ASYNC_SYSCON Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ASYNC_SYSCON_Register_Masks ASYNC_SYSCON Register Masks
N * @{
N */
N
N/*! @name ASYNCPRESETCTRL - Async peripheral reset control */
N#define ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER3_MASK (0x2000U)
N#define ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER3_SHIFT (13U)
N#define ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER3(x)  (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER3_SHIFT)) & ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER3_MASK)
N#define ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER4_MASK (0x4000U)
N#define ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER4_SHIFT (14U)
N#define ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER4(x)  (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER4_SHIFT)) & ASYNC_SYSCON_ASYNCPRESETCTRL_CTIMER4_MASK)
N
N/*! @name ASYNCPRESETCTRLSET - Set bits in ASYNCPRESETCTRL */
N#define ASYNC_SYSCON_ASYNCPRESETCTRLSET_ARST_SET_MASK (0xFFFFFFFFU)
N#define ASYNC_SYSCON_ASYNCPRESETCTRLSET_ARST_SET_SHIFT (0U)
N#define ASYNC_SYSCON_ASYNCPRESETCTRLSET_ARST_SET(x) (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCPRESETCTRLSET_ARST_SET_SHIFT)) & ASYNC_SYSCON_ASYNCPRESETCTRLSET_ARST_SET_MASK)
N
N/*! @name ASYNCPRESETCTRLCLR - Clear bits in ASYNCPRESETCTRL */
N#define ASYNC_SYSCON_ASYNCPRESETCTRLCLR_ARST_CLR_MASK (0xFFFFFFFFU)
N#define ASYNC_SYSCON_ASYNCPRESETCTRLCLR_ARST_CLR_SHIFT (0U)
N#define ASYNC_SYSCON_ASYNCPRESETCTRLCLR_ARST_CLR(x) (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCPRESETCTRLCLR_ARST_CLR_SHIFT)) & ASYNC_SYSCON_ASYNCPRESETCTRLCLR_ARST_CLR_MASK)
N
N/*! @name ASYNCAPBCLKCTRL - Async peripheral clock control */
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER3_MASK (0x2000U)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER3_SHIFT (13U)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER3(x)  (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER3_SHIFT)) & ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER3_MASK)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER4_MASK (0x4000U)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER4_SHIFT (14U)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER4(x)  (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER4_SHIFT)) & ASYNC_SYSCON_ASYNCAPBCLKCTRL_CTIMER4_MASK)
N
N/*! @name ASYNCAPBCLKCTRLSET - Set bits in ASYNCAPBCLKCTRL */
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRLSET_ACLK_SET_MASK (0xFFFFFFFFU)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRLSET_ACLK_SET_SHIFT (0U)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRLSET_ACLK_SET(x) (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCAPBCLKCTRLSET_ACLK_SET_SHIFT)) & ASYNC_SYSCON_ASYNCAPBCLKCTRLSET_ACLK_SET_MASK)
N
N/*! @name ASYNCAPBCLKCTRLCLR - Clear bits in ASYNCAPBCLKCTRL */
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRLCLR_ACLK_CLR_MASK (0xFFFFFFFFU)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRLCLR_ACLK_CLR_SHIFT (0U)
N#define ASYNC_SYSCON_ASYNCAPBCLKCTRLCLR_ACLK_CLR(x) (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCAPBCLKCTRLCLR_ACLK_CLR_SHIFT)) & ASYNC_SYSCON_ASYNCAPBCLKCTRLCLR_ACLK_CLR_MASK)
N
N/*! @name ASYNCAPBCLKSELA - Async APB clock source select A */
N#define ASYNC_SYSCON_ASYNCAPBCLKSELA_SEL_MASK    (0x3U)
N#define ASYNC_SYSCON_ASYNCAPBCLKSELA_SEL_SHIFT   (0U)
N#define ASYNC_SYSCON_ASYNCAPBCLKSELA_SEL(x)      (((uint32_t)(((uint32_t)(x)) << ASYNC_SYSCON_ASYNCAPBCLKSELA_SEL_SHIFT)) & ASYNC_SYSCON_ASYNCAPBCLKSELA_SEL_MASK)
N
N
N/*!
N * @}
N */ /* end of group ASYNC_SYSCON_Register_Masks */
N
N
N/* ASYNC_SYSCON - Peripheral instance base addresses */
N/** Peripheral ASYNC_SYSCON base address */
N#define ASYNC_SYSCON_BASE                        (0x40040000u)
N/** Peripheral ASYNC_SYSCON base pointer */
N#define ASYNC_SYSCON                             ((ASYNC_SYSCON_Type *)ASYNC_SYSCON_BASE)
N/** Array initializer of ASYNC_SYSCON peripheral base addresses */
N#define ASYNC_SYSCON_BASE_ADDRS                  { ASYNC_SYSCON_BASE }
N/** Array initializer of ASYNC_SYSCON peripheral base pointers */
N#define ASYNC_SYSCON_BASE_PTRS                   { ASYNC_SYSCON }
N
N/*!
N * @}
N */ /* end of group ASYNC_SYSCON_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- CAN Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CAN_Peripheral_Access_Layer CAN Peripheral Access Layer
N * @{
N */
N
N/** CAN - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[12];
N  __IO uint32_t DBTP;                              /**< Data Bit Timing Prescaler Register, offset: 0xC */
X  volatile uint32_t DBTP;                               
N  __IO uint32_t TEST;                              /**< Test Register, offset: 0x10 */
X  volatile uint32_t TEST;                               
N       uint8_t RESERVED_1[4];
N  __IO uint32_t CCCR;                              /**< CC Control Register, offset: 0x18 */
X  volatile uint32_t CCCR;                               
N  __IO uint32_t NBTP;                              /**< Nominal Bit Timing and Prescaler Register, offset: 0x1C */
X  volatile uint32_t NBTP;                               
N  __IO uint32_t TSCC;                              /**< Timestamp Counter Configuration, offset: 0x20 */
X  volatile uint32_t TSCC;                               
N  __IO uint32_t TSCV;                              /**< Timestamp Counter Value, offset: 0x24 */
X  volatile uint32_t TSCV;                               
N  __IO uint32_t TOCC;                              /**< Timeout Counter Configuration, offset: 0x28 */
X  volatile uint32_t TOCC;                               
N  __I  uint32_t TOCV;                              /**< Timeout Counter Value, offset: 0x2C */
X  volatile const  uint32_t TOCV;                               
N       uint8_t RESERVED_2[16];
N  __I  uint32_t ECR;                               /**< Error Counter Register, offset: 0x40 */
X  volatile const  uint32_t ECR;                                
N  __I  uint32_t PSR;                               /**< Protocol Status Register, offset: 0x44 */
X  volatile const  uint32_t PSR;                                
N  __IO uint32_t TDCR;                              /**< Transmitter Delay Compensator Register, offset: 0x48 */
X  volatile uint32_t TDCR;                               
N       uint8_t RESERVED_3[4];
N  __IO uint32_t IR;                                /**< Interrupt Register, offset: 0x50 */
X  volatile uint32_t IR;                                 
N  __IO uint32_t IE;                                /**< Interrupt Enable, offset: 0x54 */
X  volatile uint32_t IE;                                 
N  __IO uint32_t ILS;                               /**< Interrupt Line Select, offset: 0x58 */
X  volatile uint32_t ILS;                                
N  __IO uint32_t ILE;                               /**< Interrupt Line Enable, offset: 0x5C */
X  volatile uint32_t ILE;                                
N       uint8_t RESERVED_4[32];
N  __IO uint32_t GFC;                               /**< Global Filter Configuration, offset: 0x80 */
X  volatile uint32_t GFC;                                
N  __IO uint32_t SIDFC;                             /**< Standard ID Filter Configuration, offset: 0x84 */
X  volatile uint32_t SIDFC;                              
N  __IO uint32_t XIDFC;                             /**< Extended ID Filter Configuration, offset: 0x88 */
X  volatile uint32_t XIDFC;                              
N       uint8_t RESERVED_5[4];
N  __IO uint32_t XIDAM;                             /**< Extended ID AND Mask, offset: 0x90 */
X  volatile uint32_t XIDAM;                              
N  __I  uint32_t HPMS;                              /**< High Priority Message Status, offset: 0x94 */
X  volatile const  uint32_t HPMS;                               
N  __IO uint32_t NDAT1;                             /**< New Data 1, offset: 0x98 */
X  volatile uint32_t NDAT1;                              
N  __IO uint32_t NDAT2;                             /**< New Data 2, offset: 0x9C */
X  volatile uint32_t NDAT2;                              
N  __IO uint32_t RXF0C;                             /**< Rx FIFO 0 Configuration, offset: 0xA0 */
X  volatile uint32_t RXF0C;                              
N  __IO uint32_t RXF0S;                             /**< Rx FIFO 0 Status, offset: 0xA4 */
X  volatile uint32_t RXF0S;                              
N  __IO uint32_t RXF0A;                             /**< Rx FIFO 0 Acknowledge, offset: 0xA8 */
X  volatile uint32_t RXF0A;                              
N  __IO uint32_t RXBC;                              /**< Rx Buffer Configuration, offset: 0xAC */
X  volatile uint32_t RXBC;                               
N  __IO uint32_t RXF1C;                             /**< Rx FIFO 1 Configuration, offset: 0xB0 */
X  volatile uint32_t RXF1C;                              
N  __I  uint32_t RXF1S;                             /**< Rx FIFO 1 Status, offset: 0xB4 */
X  volatile const  uint32_t RXF1S;                              
N  __IO uint32_t RXF1A;                             /**< Rx FIFO 1 Acknowledge, offset: 0xB8 */
X  volatile uint32_t RXF1A;                              
N  __IO uint32_t RXESC;                             /**< Rx Buffer and FIFO Element Size Configuration, offset: 0xBC */
X  volatile uint32_t RXESC;                              
N  __IO uint32_t TXBC;                              /**< Tx Buffer Configuration, offset: 0xC0 */
X  volatile uint32_t TXBC;                               
N  __IO uint32_t TXFQS;                             /**< Tx FIFO/Queue Status, offset: 0xC4 */
X  volatile uint32_t TXFQS;                              
N  __IO uint32_t TXESC;                             /**< Tx Buffer Element Size Configuration, offset: 0xC8 */
X  volatile uint32_t TXESC;                              
N  __IO uint32_t TXBRP;                             /**< Tx Buffer Request Pending, offset: 0xCC */
X  volatile uint32_t TXBRP;                              
N  __IO uint32_t TXBAR;                             /**< Tx Buffer Add Request, offset: 0xD0 */
X  volatile uint32_t TXBAR;                              
N  __IO uint32_t TXBCR;                             /**< Tx Buffer Cancellation Request, offset: 0xD4 */
X  volatile uint32_t TXBCR;                              
N  __IO uint32_t TXBTO;                             /**< Tx Buffer Transmission Occurred, offset: 0xD8 */
X  volatile uint32_t TXBTO;                              
N  __IO uint32_t TXBCF;                             /**< Tx Buffer Cancellation Finished, offset: 0xDC */
X  volatile uint32_t TXBCF;                              
N  __IO uint32_t TXBTIE;                            /**< Tx Buffer Transmission Interrupt Enable, offset: 0xE0 */
X  volatile uint32_t TXBTIE;                             
N  __IO uint32_t TXBCIE;                            /**< Tx Buffer Cancellation Finished Interrupt Enable, offset: 0xE4 */
X  volatile uint32_t TXBCIE;                             
N       uint8_t RESERVED_6[8];
N  __IO uint32_t TXEFC;                             /**< Tx Event FIFO Configuration, offset: 0xF0 */
X  volatile uint32_t TXEFC;                              
N  __I  uint32_t TXEFS;                             /**< Tx Event FIFO Status, offset: 0xF4 */
X  volatile const  uint32_t TXEFS;                              
N  __IO uint32_t TXEFA;                             /**< Tx Event FIFO Acknowledge, offset: 0xF8 */
X  volatile uint32_t TXEFA;                              
N       uint8_t RESERVED_7[260];
N  __IO uint32_t MRBA;                              /**< CAN Message RAM Base Address, offset: 0x200 */
X  volatile uint32_t MRBA;                               
N       uint8_t RESERVED_8[508];
N  __IO uint32_t ETSCC;                             /**< External Timestamp Counter Configuration, offset: 0x400 */
X  volatile uint32_t ETSCC;                              
N       uint8_t RESERVED_9[508];
N  __IO uint32_t ETSCV;                             /**< External Timestamp Counter Value, offset: 0x600 */
X  volatile uint32_t ETSCV;                              
N} CAN_Type;
N
N/* ----------------------------------------------------------------------------
N   -- CAN Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CAN_Register_Masks CAN Register Masks
N * @{
N */
N
N/*! @name DBTP - Data Bit Timing Prescaler Register */
N#define CAN_DBTP_DSJW_MASK                       (0xFU)
N#define CAN_DBTP_DSJW_SHIFT                      (0U)
N#define CAN_DBTP_DSJW(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_DBTP_DSJW_SHIFT)) & CAN_DBTP_DSJW_MASK)
N#define CAN_DBTP_DTSEG2_MASK                     (0xF0U)
N#define CAN_DBTP_DTSEG2_SHIFT                    (4U)
N#define CAN_DBTP_DTSEG2(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_DBTP_DTSEG2_SHIFT)) & CAN_DBTP_DTSEG2_MASK)
N#define CAN_DBTP_DTSEG1_MASK                     (0x1F00U)
N#define CAN_DBTP_DTSEG1_SHIFT                    (8U)
N#define CAN_DBTP_DTSEG1(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_DBTP_DTSEG1_SHIFT)) & CAN_DBTP_DTSEG1_MASK)
N#define CAN_DBTP_DBRP_MASK                       (0x1F0000U)
N#define CAN_DBTP_DBRP_SHIFT                      (16U)
N#define CAN_DBTP_DBRP(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_DBTP_DBRP_SHIFT)) & CAN_DBTP_DBRP_MASK)
N#define CAN_DBTP_TDC_MASK                        (0x800000U)
N#define CAN_DBTP_TDC_SHIFT                       (23U)
N#define CAN_DBTP_TDC(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_DBTP_TDC_SHIFT)) & CAN_DBTP_TDC_MASK)
N
N/*! @name TEST - Test Register */
N#define CAN_TEST_LBCK_MASK                       (0x10U)
N#define CAN_TEST_LBCK_SHIFT                      (4U)
N#define CAN_TEST_LBCK(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TEST_LBCK_SHIFT)) & CAN_TEST_LBCK_MASK)
N#define CAN_TEST_TX_MASK                         (0x60U)
N#define CAN_TEST_TX_SHIFT                        (5U)
N#define CAN_TEST_TX(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_TEST_TX_SHIFT)) & CAN_TEST_TX_MASK)
N#define CAN_TEST_RX_MASK                         (0x80U)
N#define CAN_TEST_RX_SHIFT                        (7U)
N#define CAN_TEST_RX(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_TEST_RX_SHIFT)) & CAN_TEST_RX_MASK)
N
N/*! @name CCCR - CC Control Register */
N#define CAN_CCCR_INIT_MASK                       (0x1U)
N#define CAN_CCCR_INIT_SHIFT                      (0U)
N#define CAN_CCCR_INIT(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_INIT_SHIFT)) & CAN_CCCR_INIT_MASK)
N#define CAN_CCCR_CCE_MASK                        (0x2U)
N#define CAN_CCCR_CCE_SHIFT                       (1U)
N#define CAN_CCCR_CCE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_CCE_SHIFT)) & CAN_CCCR_CCE_MASK)
N#define CAN_CCCR_ASM_MASK                        (0x4U)
N#define CAN_CCCR_ASM_SHIFT                       (2U)
N#define CAN_CCCR_ASM(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_ASM_SHIFT)) & CAN_CCCR_ASM_MASK)
N#define CAN_CCCR_CSA_MASK                        (0x8U)
N#define CAN_CCCR_CSA_SHIFT                       (3U)
N#define CAN_CCCR_CSA(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_CSA_SHIFT)) & CAN_CCCR_CSA_MASK)
N#define CAN_CCCR_CSR_MASK                        (0x10U)
N#define CAN_CCCR_CSR_SHIFT                       (4U)
N#define CAN_CCCR_CSR(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_CSR_SHIFT)) & CAN_CCCR_CSR_MASK)
N#define CAN_CCCR_MON_MASK                        (0x20U)
N#define CAN_CCCR_MON_SHIFT                       (5U)
N#define CAN_CCCR_MON(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_MON_SHIFT)) & CAN_CCCR_MON_MASK)
N#define CAN_CCCR_DAR_MASK                        (0x40U)
N#define CAN_CCCR_DAR_SHIFT                       (6U)
N#define CAN_CCCR_DAR(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_DAR_SHIFT)) & CAN_CCCR_DAR_MASK)
N#define CAN_CCCR_TEST_MASK                       (0x80U)
N#define CAN_CCCR_TEST_SHIFT                      (7U)
N#define CAN_CCCR_TEST(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_TEST_SHIFT)) & CAN_CCCR_TEST_MASK)
N#define CAN_CCCR_FDOE_MASK                       (0x100U)
N#define CAN_CCCR_FDOE_SHIFT                      (8U)
N#define CAN_CCCR_FDOE(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_FDOE_SHIFT)) & CAN_CCCR_FDOE_MASK)
N#define CAN_CCCR_BRSE_MASK                       (0x200U)
N#define CAN_CCCR_BRSE_SHIFT                      (9U)
N#define CAN_CCCR_BRSE(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_BRSE_SHIFT)) & CAN_CCCR_BRSE_MASK)
N#define CAN_CCCR_PXHD_MASK                       (0x1000U)
N#define CAN_CCCR_PXHD_SHIFT                      (12U)
N#define CAN_CCCR_PXHD(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_PXHD_SHIFT)) & CAN_CCCR_PXHD_MASK)
N#define CAN_CCCR_EFBI_MASK                       (0x2000U)
N#define CAN_CCCR_EFBI_SHIFT                      (13U)
N#define CAN_CCCR_EFBI(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_EFBI_SHIFT)) & CAN_CCCR_EFBI_MASK)
N#define CAN_CCCR_TXP_MASK                        (0x4000U)
N#define CAN_CCCR_TXP_SHIFT                       (14U)
N#define CAN_CCCR_TXP(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_TXP_SHIFT)) & CAN_CCCR_TXP_MASK)
N#define CAN_CCCR_NISO_MASK                       (0x8000U)
N#define CAN_CCCR_NISO_SHIFT                      (15U)
N#define CAN_CCCR_NISO(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_CCCR_NISO_SHIFT)) & CAN_CCCR_NISO_MASK)
N
N/*! @name NBTP - Nominal Bit Timing and Prescaler Register */
N#define CAN_NBTP_NTSEG2_MASK                     (0x7FU)
N#define CAN_NBTP_NTSEG2_SHIFT                    (0U)
N#define CAN_NBTP_NTSEG2(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_NBTP_NTSEG2_SHIFT)) & CAN_NBTP_NTSEG2_MASK)
N#define CAN_NBTP_NTSEG1_MASK                     (0xFF00U)
N#define CAN_NBTP_NTSEG1_SHIFT                    (8U)
N#define CAN_NBTP_NTSEG1(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_NBTP_NTSEG1_SHIFT)) & CAN_NBTP_NTSEG1_MASK)
N#define CAN_NBTP_NBRP_MASK                       (0x1FF0000U)
N#define CAN_NBTP_NBRP_SHIFT                      (16U)
N#define CAN_NBTP_NBRP(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_NBTP_NBRP_SHIFT)) & CAN_NBTP_NBRP_MASK)
N#define CAN_NBTP_NSJW_MASK                       (0xFE000000U)
N#define CAN_NBTP_NSJW_SHIFT                      (25U)
N#define CAN_NBTP_NSJW(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_NBTP_NSJW_SHIFT)) & CAN_NBTP_NSJW_MASK)
N
N/*! @name TSCC - Timestamp Counter Configuration */
N#define CAN_TSCC_TSS_MASK                        (0x3U)
N#define CAN_TSCC_TSS_SHIFT                       (0U)
N#define CAN_TSCC_TSS(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TSCC_TSS_SHIFT)) & CAN_TSCC_TSS_MASK)
N#define CAN_TSCC_TCP_MASK                        (0xF0000U)
N#define CAN_TSCC_TCP_SHIFT                       (16U)
N#define CAN_TSCC_TCP(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TSCC_TCP_SHIFT)) & CAN_TSCC_TCP_MASK)
N
N/*! @name TSCV - Timestamp Counter Value */
N#define CAN_TSCV_TSC_MASK                        (0xFFFFU)
N#define CAN_TSCV_TSC_SHIFT                       (0U)
N#define CAN_TSCV_TSC(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TSCV_TSC_SHIFT)) & CAN_TSCV_TSC_MASK)
N
N/*! @name TOCC - Timeout Counter Configuration */
N#define CAN_TOCC_ETOC_MASK                       (0x1U)
N#define CAN_TOCC_ETOC_SHIFT                      (0U)
N#define CAN_TOCC_ETOC(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TOCC_ETOC_SHIFT)) & CAN_TOCC_ETOC_MASK)
N#define CAN_TOCC_TOS_MASK                        (0x6U)
N#define CAN_TOCC_TOS_SHIFT                       (1U)
N#define CAN_TOCC_TOS(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TOCC_TOS_SHIFT)) & CAN_TOCC_TOS_MASK)
N#define CAN_TOCC_TOP_MASK                        (0xFFFF0000U)
N#define CAN_TOCC_TOP_SHIFT                       (16U)
N#define CAN_TOCC_TOP(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TOCC_TOP_SHIFT)) & CAN_TOCC_TOP_MASK)
N
N/*! @name TOCV - Timeout Counter Value */
N#define CAN_TOCV_TOC_MASK                        (0xFFFFU)
N#define CAN_TOCV_TOC_SHIFT                       (0U)
N#define CAN_TOCV_TOC(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TOCV_TOC_SHIFT)) & CAN_TOCV_TOC_MASK)
N
N/*! @name ECR - Error Counter Register */
N#define CAN_ECR_TEC_MASK                         (0xFFU)
N#define CAN_ECR_TEC_SHIFT                        (0U)
N#define CAN_ECR_TEC(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ECR_TEC_SHIFT)) & CAN_ECR_TEC_MASK)
N#define CAN_ECR_REC_MASK                         (0x7F00U)
N#define CAN_ECR_REC_SHIFT                        (8U)
N#define CAN_ECR_REC(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ECR_REC_SHIFT)) & CAN_ECR_REC_MASK)
N#define CAN_ECR_RP_MASK                          (0x8000U)
N#define CAN_ECR_RP_SHIFT                         (15U)
N#define CAN_ECR_RP(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_ECR_RP_SHIFT)) & CAN_ECR_RP_MASK)
N#define CAN_ECR_CEL_MASK                         (0xFF0000U)
N#define CAN_ECR_CEL_SHIFT                        (16U)
N#define CAN_ECR_CEL(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ECR_CEL_SHIFT)) & CAN_ECR_CEL_MASK)
N
N/*! @name PSR - Protocol Status Register */
N#define CAN_PSR_LEC_MASK                         (0x7U)
N#define CAN_PSR_LEC_SHIFT                        (0U)
N#define CAN_PSR_LEC(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_PSR_LEC_SHIFT)) & CAN_PSR_LEC_MASK)
N#define CAN_PSR_ACT_MASK                         (0x18U)
N#define CAN_PSR_ACT_SHIFT                        (3U)
N#define CAN_PSR_ACT(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_PSR_ACT_SHIFT)) & CAN_PSR_ACT_MASK)
N#define CAN_PSR_EP_MASK                          (0x20U)
N#define CAN_PSR_EP_SHIFT                         (5U)
N#define CAN_PSR_EP(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_PSR_EP_SHIFT)) & CAN_PSR_EP_MASK)
N#define CAN_PSR_EW_MASK                          (0x40U)
N#define CAN_PSR_EW_SHIFT                         (6U)
N#define CAN_PSR_EW(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_PSR_EW_SHIFT)) & CAN_PSR_EW_MASK)
N#define CAN_PSR_BO_MASK                          (0x80U)
N#define CAN_PSR_BO_SHIFT                         (7U)
N#define CAN_PSR_BO(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_PSR_BO_SHIFT)) & CAN_PSR_BO_MASK)
N#define CAN_PSR_DLEC_MASK                        (0x700U)
N#define CAN_PSR_DLEC_SHIFT                       (8U)
N#define CAN_PSR_DLEC(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_PSR_DLEC_SHIFT)) & CAN_PSR_DLEC_MASK)
N#define CAN_PSR_RESI_MASK                        (0x800U)
N#define CAN_PSR_RESI_SHIFT                       (11U)
N#define CAN_PSR_RESI(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_PSR_RESI_SHIFT)) & CAN_PSR_RESI_MASK)
N#define CAN_PSR_RBRS_MASK                        (0x1000U)
N#define CAN_PSR_RBRS_SHIFT                       (12U)
N#define CAN_PSR_RBRS(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_PSR_RBRS_SHIFT)) & CAN_PSR_RBRS_MASK)
N#define CAN_PSR_RFDF_MASK                        (0x2000U)
N#define CAN_PSR_RFDF_SHIFT                       (13U)
N#define CAN_PSR_RFDF(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_PSR_RFDF_SHIFT)) & CAN_PSR_RFDF_MASK)
N#define CAN_PSR_PXE_MASK                         (0x4000U)
N#define CAN_PSR_PXE_SHIFT                        (14U)
N#define CAN_PSR_PXE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_PSR_PXE_SHIFT)) & CAN_PSR_PXE_MASK)
N#define CAN_PSR_TDCV_MASK                        (0x7F0000U)
N#define CAN_PSR_TDCV_SHIFT                       (16U)
N#define CAN_PSR_TDCV(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_PSR_TDCV_SHIFT)) & CAN_PSR_TDCV_MASK)
N
N/*! @name TDCR - Transmitter Delay Compensator Register */
N#define CAN_TDCR_TDCF_MASK                       (0x7FU)
N#define CAN_TDCR_TDCF_SHIFT                      (0U)
N#define CAN_TDCR_TDCF(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TDCR_TDCF_SHIFT)) & CAN_TDCR_TDCF_MASK)
N#define CAN_TDCR_TDCO_MASK                       (0x7F00U)
N#define CAN_TDCR_TDCO_SHIFT                      (8U)
N#define CAN_TDCR_TDCO(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TDCR_TDCO_SHIFT)) & CAN_TDCR_TDCO_MASK)
N
N/*! @name IR - Interrupt Register */
N#define CAN_IR_RF0N_MASK                         (0x1U)
N#define CAN_IR_RF0N_SHIFT                        (0U)
N#define CAN_IR_RF0N(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF0N_SHIFT)) & CAN_IR_RF0N_MASK)
N#define CAN_IR_RF0W_MASK                         (0x2U)
N#define CAN_IR_RF0W_SHIFT                        (1U)
N#define CAN_IR_RF0W(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF0W_SHIFT)) & CAN_IR_RF0W_MASK)
N#define CAN_IR_RF0F_MASK                         (0x4U)
N#define CAN_IR_RF0F_SHIFT                        (2U)
N#define CAN_IR_RF0F(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF0F_SHIFT)) & CAN_IR_RF0F_MASK)
N#define CAN_IR_RF0L_MASK                         (0x8U)
N#define CAN_IR_RF0L_SHIFT                        (3U)
N#define CAN_IR_RF0L(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF0L_SHIFT)) & CAN_IR_RF0L_MASK)
N#define CAN_IR_RF1N_MASK                         (0x10U)
N#define CAN_IR_RF1N_SHIFT                        (4U)
N#define CAN_IR_RF1N(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF1N_SHIFT)) & CAN_IR_RF1N_MASK)
N#define CAN_IR_RF1W_MASK                         (0x20U)
N#define CAN_IR_RF1W_SHIFT                        (5U)
N#define CAN_IR_RF1W(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF1W_SHIFT)) & CAN_IR_RF1W_MASK)
N#define CAN_IR_RF1F_MASK                         (0x40U)
N#define CAN_IR_RF1F_SHIFT                        (6U)
N#define CAN_IR_RF1F(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF1F_SHIFT)) & CAN_IR_RF1F_MASK)
N#define CAN_IR_RF1L_MASK                         (0x80U)
N#define CAN_IR_RF1L_SHIFT                        (7U)
N#define CAN_IR_RF1L(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_RF1L_SHIFT)) & CAN_IR_RF1L_MASK)
N#define CAN_IR_HPM_MASK                          (0x100U)
N#define CAN_IR_HPM_SHIFT                         (8U)
N#define CAN_IR_HPM(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_HPM_SHIFT)) & CAN_IR_HPM_MASK)
N#define CAN_IR_TC_MASK                           (0x200U)
N#define CAN_IR_TC_SHIFT                          (9U)
N#define CAN_IR_TC(x)                             (((uint32_t)(((uint32_t)(x)) << CAN_IR_TC_SHIFT)) & CAN_IR_TC_MASK)
N#define CAN_IR_TCF_MASK                          (0x400U)
N#define CAN_IR_TCF_SHIFT                         (10U)
N#define CAN_IR_TCF(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_TCF_SHIFT)) & CAN_IR_TCF_MASK)
N#define CAN_IR_TFE_MASK                          (0x800U)
N#define CAN_IR_TFE_SHIFT                         (11U)
N#define CAN_IR_TFE(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_TFE_SHIFT)) & CAN_IR_TFE_MASK)
N#define CAN_IR_TEFN_MASK                         (0x1000U)
N#define CAN_IR_TEFN_SHIFT                        (12U)
N#define CAN_IR_TEFN(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_TEFN_SHIFT)) & CAN_IR_TEFN_MASK)
N#define CAN_IR_TEFW_MASK                         (0x2000U)
N#define CAN_IR_TEFW_SHIFT                        (13U)
N#define CAN_IR_TEFW(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_TEFW_SHIFT)) & CAN_IR_TEFW_MASK)
N#define CAN_IR_TEFF_MASK                         (0x4000U)
N#define CAN_IR_TEFF_SHIFT                        (14U)
N#define CAN_IR_TEFF(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_TEFF_SHIFT)) & CAN_IR_TEFF_MASK)
N#define CAN_IR_TEFL_MASK                         (0x8000U)
N#define CAN_IR_TEFL_SHIFT                        (15U)
N#define CAN_IR_TEFL(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_TEFL_SHIFT)) & CAN_IR_TEFL_MASK)
N#define CAN_IR_TSW_MASK                          (0x10000U)
N#define CAN_IR_TSW_SHIFT                         (16U)
N#define CAN_IR_TSW(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_TSW_SHIFT)) & CAN_IR_TSW_MASK)
N#define CAN_IR_MRAF_MASK                         (0x20000U)
N#define CAN_IR_MRAF_SHIFT                        (17U)
N#define CAN_IR_MRAF(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IR_MRAF_SHIFT)) & CAN_IR_MRAF_MASK)
N#define CAN_IR_TOO_MASK                          (0x40000U)
N#define CAN_IR_TOO_SHIFT                         (18U)
N#define CAN_IR_TOO(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_TOO_SHIFT)) & CAN_IR_TOO_MASK)
N#define CAN_IR_DRX_MASK                          (0x80000U)
N#define CAN_IR_DRX_SHIFT                         (19U)
N#define CAN_IR_DRX(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_DRX_SHIFT)) & CAN_IR_DRX_MASK)
N#define CAN_IR_BEC_MASK                          (0x100000U)
N#define CAN_IR_BEC_SHIFT                         (20U)
N#define CAN_IR_BEC(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_BEC_SHIFT)) & CAN_IR_BEC_MASK)
N#define CAN_IR_BEU_MASK                          (0x200000U)
N#define CAN_IR_BEU_SHIFT                         (21U)
N#define CAN_IR_BEU(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_BEU_SHIFT)) & CAN_IR_BEU_MASK)
N#define CAN_IR_ELO_MASK                          (0x400000U)
N#define CAN_IR_ELO_SHIFT                         (22U)
N#define CAN_IR_ELO(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_ELO_SHIFT)) & CAN_IR_ELO_MASK)
N#define CAN_IR_EP_MASK                           (0x800000U)
N#define CAN_IR_EP_SHIFT                          (23U)
N#define CAN_IR_EP(x)                             (((uint32_t)(((uint32_t)(x)) << CAN_IR_EP_SHIFT)) & CAN_IR_EP_MASK)
N#define CAN_IR_EW_MASK                           (0x1000000U)
N#define CAN_IR_EW_SHIFT                          (24U)
N#define CAN_IR_EW(x)                             (((uint32_t)(((uint32_t)(x)) << CAN_IR_EW_SHIFT)) & CAN_IR_EW_MASK)
N#define CAN_IR_BO_MASK                           (0x2000000U)
N#define CAN_IR_BO_SHIFT                          (25U)
N#define CAN_IR_BO(x)                             (((uint32_t)(((uint32_t)(x)) << CAN_IR_BO_SHIFT)) & CAN_IR_BO_MASK)
N#define CAN_IR_WDI_MASK                          (0x4000000U)
N#define CAN_IR_WDI_SHIFT                         (26U)
N#define CAN_IR_WDI(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_WDI_SHIFT)) & CAN_IR_WDI_MASK)
N#define CAN_IR_PEA_MASK                          (0x8000000U)
N#define CAN_IR_PEA_SHIFT                         (27U)
N#define CAN_IR_PEA(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_PEA_SHIFT)) & CAN_IR_PEA_MASK)
N#define CAN_IR_PED_MASK                          (0x10000000U)
N#define CAN_IR_PED_SHIFT                         (28U)
N#define CAN_IR_PED(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_PED_SHIFT)) & CAN_IR_PED_MASK)
N#define CAN_IR_ARA_MASK                          (0x20000000U)
N#define CAN_IR_ARA_SHIFT                         (29U)
N#define CAN_IR_ARA(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IR_ARA_SHIFT)) & CAN_IR_ARA_MASK)
N
N/*! @name IE - Interrupt Enable */
N#define CAN_IE_RF0NE_MASK                        (0x1U)
N#define CAN_IE_RF0NE_SHIFT                       (0U)
N#define CAN_IE_RF0NE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF0NE_SHIFT)) & CAN_IE_RF0NE_MASK)
N#define CAN_IE_RF0WE_MASK                        (0x2U)
N#define CAN_IE_RF0WE_SHIFT                       (1U)
N#define CAN_IE_RF0WE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF0WE_SHIFT)) & CAN_IE_RF0WE_MASK)
N#define CAN_IE_RF0FE_MASK                        (0x4U)
N#define CAN_IE_RF0FE_SHIFT                       (2U)
N#define CAN_IE_RF0FE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF0FE_SHIFT)) & CAN_IE_RF0FE_MASK)
N#define CAN_IE_RF0LE_MASK                        (0x8U)
N#define CAN_IE_RF0LE_SHIFT                       (3U)
N#define CAN_IE_RF0LE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF0LE_SHIFT)) & CAN_IE_RF0LE_MASK)
N#define CAN_IE_RF1NE_MASK                        (0x10U)
N#define CAN_IE_RF1NE_SHIFT                       (4U)
N#define CAN_IE_RF1NE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF1NE_SHIFT)) & CAN_IE_RF1NE_MASK)
N#define CAN_IE_RF1WE_MASK                        (0x20U)
N#define CAN_IE_RF1WE_SHIFT                       (5U)
N#define CAN_IE_RF1WE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF1WE_SHIFT)) & CAN_IE_RF1WE_MASK)
N#define CAN_IE_RF1FE_MASK                        (0x40U)
N#define CAN_IE_RF1FE_SHIFT                       (6U)
N#define CAN_IE_RF1FE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF1FE_SHIFT)) & CAN_IE_RF1FE_MASK)
N#define CAN_IE_RF1LE_MASK                        (0x80U)
N#define CAN_IE_RF1LE_SHIFT                       (7U)
N#define CAN_IE_RF1LE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_RF1LE_SHIFT)) & CAN_IE_RF1LE_MASK)
N#define CAN_IE_HPME_MASK                         (0x100U)
N#define CAN_IE_HPME_SHIFT                        (8U)
N#define CAN_IE_HPME(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_HPME_SHIFT)) & CAN_IE_HPME_MASK)
N#define CAN_IE_TCE_MASK                          (0x200U)
N#define CAN_IE_TCE_SHIFT                         (9U)
N#define CAN_IE_TCE(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IE_TCE_SHIFT)) & CAN_IE_TCE_MASK)
N#define CAN_IE_TCFE_MASK                         (0x400U)
N#define CAN_IE_TCFE_SHIFT                        (10U)
N#define CAN_IE_TCFE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_TCFE_SHIFT)) & CAN_IE_TCFE_MASK)
N#define CAN_IE_TFEE_MASK                         (0x800U)
N#define CAN_IE_TFEE_SHIFT                        (11U)
N#define CAN_IE_TFEE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_TFEE_SHIFT)) & CAN_IE_TFEE_MASK)
N#define CAN_IE_TEFNE_MASK                        (0x1000U)
N#define CAN_IE_TEFNE_SHIFT                       (12U)
N#define CAN_IE_TEFNE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_TEFNE_SHIFT)) & CAN_IE_TEFNE_MASK)
N#define CAN_IE_TEFWE_MASK                        (0x2000U)
N#define CAN_IE_TEFWE_SHIFT                       (13U)
N#define CAN_IE_TEFWE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_TEFWE_SHIFT)) & CAN_IE_TEFWE_MASK)
N#define CAN_IE_TEFFE_MASK                        (0x4000U)
N#define CAN_IE_TEFFE_SHIFT                       (14U)
N#define CAN_IE_TEFFE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_TEFFE_SHIFT)) & CAN_IE_TEFFE_MASK)
N#define CAN_IE_TEFLE_MASK                        (0x8000U)
N#define CAN_IE_TEFLE_SHIFT                       (15U)
N#define CAN_IE_TEFLE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_TEFLE_SHIFT)) & CAN_IE_TEFLE_MASK)
N#define CAN_IE_TSWE_MASK                         (0x10000U)
N#define CAN_IE_TSWE_SHIFT                        (16U)
N#define CAN_IE_TSWE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_TSWE_SHIFT)) & CAN_IE_TSWE_MASK)
N#define CAN_IE_MRAFE_MASK                        (0x20000U)
N#define CAN_IE_MRAFE_SHIFT                       (17U)
N#define CAN_IE_MRAFE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_IE_MRAFE_SHIFT)) & CAN_IE_MRAFE_MASK)
N#define CAN_IE_TOOE_MASK                         (0x40000U)
N#define CAN_IE_TOOE_SHIFT                        (18U)
N#define CAN_IE_TOOE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_TOOE_SHIFT)) & CAN_IE_TOOE_MASK)
N#define CAN_IE_DRXE_MASK                         (0x80000U)
N#define CAN_IE_DRXE_SHIFT                        (19U)
N#define CAN_IE_DRXE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_DRXE_SHIFT)) & CAN_IE_DRXE_MASK)
N#define CAN_IE_BECE_MASK                         (0x100000U)
N#define CAN_IE_BECE_SHIFT                        (20U)
N#define CAN_IE_BECE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_BECE_SHIFT)) & CAN_IE_BECE_MASK)
N#define CAN_IE_BEUE_MASK                         (0x200000U)
N#define CAN_IE_BEUE_SHIFT                        (21U)
N#define CAN_IE_BEUE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_BEUE_SHIFT)) & CAN_IE_BEUE_MASK)
N#define CAN_IE_ELOE_MASK                         (0x400000U)
N#define CAN_IE_ELOE_SHIFT                        (22U)
N#define CAN_IE_ELOE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_ELOE_SHIFT)) & CAN_IE_ELOE_MASK)
N#define CAN_IE_EPE_MASK                          (0x800000U)
N#define CAN_IE_EPE_SHIFT                         (23U)
N#define CAN_IE_EPE(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IE_EPE_SHIFT)) & CAN_IE_EPE_MASK)
N#define CAN_IE_EWE_MASK                          (0x1000000U)
N#define CAN_IE_EWE_SHIFT                         (24U)
N#define CAN_IE_EWE(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IE_EWE_SHIFT)) & CAN_IE_EWE_MASK)
N#define CAN_IE_BOE_MASK                          (0x2000000U)
N#define CAN_IE_BOE_SHIFT                         (25U)
N#define CAN_IE_BOE(x)                            (((uint32_t)(((uint32_t)(x)) << CAN_IE_BOE_SHIFT)) & CAN_IE_BOE_MASK)
N#define CAN_IE_WDIE_MASK                         (0x4000000U)
N#define CAN_IE_WDIE_SHIFT                        (26U)
N#define CAN_IE_WDIE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_WDIE_SHIFT)) & CAN_IE_WDIE_MASK)
N#define CAN_IE_PEAE_MASK                         (0x8000000U)
N#define CAN_IE_PEAE_SHIFT                        (27U)
N#define CAN_IE_PEAE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_PEAE_SHIFT)) & CAN_IE_PEAE_MASK)
N#define CAN_IE_PEDE_MASK                         (0x10000000U)
N#define CAN_IE_PEDE_SHIFT                        (28U)
N#define CAN_IE_PEDE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_PEDE_SHIFT)) & CAN_IE_PEDE_MASK)
N#define CAN_IE_ARAE_MASK                         (0x20000000U)
N#define CAN_IE_ARAE_SHIFT                        (29U)
N#define CAN_IE_ARAE(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_IE_ARAE_SHIFT)) & CAN_IE_ARAE_MASK)
N
N/*! @name ILS - Interrupt Line Select */
N#define CAN_ILS_RF0NL_MASK                       (0x1U)
N#define CAN_ILS_RF0NL_SHIFT                      (0U)
N#define CAN_ILS_RF0NL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF0NL_SHIFT)) & CAN_ILS_RF0NL_MASK)
N#define CAN_ILS_RF0WL_MASK                       (0x2U)
N#define CAN_ILS_RF0WL_SHIFT                      (1U)
N#define CAN_ILS_RF0WL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF0WL_SHIFT)) & CAN_ILS_RF0WL_MASK)
N#define CAN_ILS_RF0FL_MASK                       (0x4U)
N#define CAN_ILS_RF0FL_SHIFT                      (2U)
N#define CAN_ILS_RF0FL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF0FL_SHIFT)) & CAN_ILS_RF0FL_MASK)
N#define CAN_ILS_RF0LL_MASK                       (0x8U)
N#define CAN_ILS_RF0LL_SHIFT                      (3U)
N#define CAN_ILS_RF0LL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF0LL_SHIFT)) & CAN_ILS_RF0LL_MASK)
N#define CAN_ILS_RF1NL_MASK                       (0x10U)
N#define CAN_ILS_RF1NL_SHIFT                      (4U)
N#define CAN_ILS_RF1NL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF1NL_SHIFT)) & CAN_ILS_RF1NL_MASK)
N#define CAN_ILS_RF1WL_MASK                       (0x20U)
N#define CAN_ILS_RF1WL_SHIFT                      (5U)
N#define CAN_ILS_RF1WL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF1WL_SHIFT)) & CAN_ILS_RF1WL_MASK)
N#define CAN_ILS_RF1FL_MASK                       (0x40U)
N#define CAN_ILS_RF1FL_SHIFT                      (6U)
N#define CAN_ILS_RF1FL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF1FL_SHIFT)) & CAN_ILS_RF1FL_MASK)
N#define CAN_ILS_RF1LL_MASK                       (0x80U)
N#define CAN_ILS_RF1LL_SHIFT                      (7U)
N#define CAN_ILS_RF1LL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_RF1LL_SHIFT)) & CAN_ILS_RF1LL_MASK)
N#define CAN_ILS_HPML_MASK                        (0x100U)
N#define CAN_ILS_HPML_SHIFT                       (8U)
N#define CAN_ILS_HPML(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_HPML_SHIFT)) & CAN_ILS_HPML_MASK)
N#define CAN_ILS_TCL_MASK                         (0x200U)
N#define CAN_ILS_TCL_SHIFT                        (9U)
N#define CAN_ILS_TCL(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TCL_SHIFT)) & CAN_ILS_TCL_MASK)
N#define CAN_ILS_TCFL_MASK                        (0x400U)
N#define CAN_ILS_TCFL_SHIFT                       (10U)
N#define CAN_ILS_TCFL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TCFL_SHIFT)) & CAN_ILS_TCFL_MASK)
N#define CAN_ILS_TFEL_MASK                        (0x800U)
N#define CAN_ILS_TFEL_SHIFT                       (11U)
N#define CAN_ILS_TFEL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TFEL_SHIFT)) & CAN_ILS_TFEL_MASK)
N#define CAN_ILS_TEFNL_MASK                       (0x1000U)
N#define CAN_ILS_TEFNL_SHIFT                      (12U)
N#define CAN_ILS_TEFNL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TEFNL_SHIFT)) & CAN_ILS_TEFNL_MASK)
N#define CAN_ILS_TEFWL_MASK                       (0x2000U)
N#define CAN_ILS_TEFWL_SHIFT                      (13U)
N#define CAN_ILS_TEFWL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TEFWL_SHIFT)) & CAN_ILS_TEFWL_MASK)
N#define CAN_ILS_TEFFL_MASK                       (0x4000U)
N#define CAN_ILS_TEFFL_SHIFT                      (14U)
N#define CAN_ILS_TEFFL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TEFFL_SHIFT)) & CAN_ILS_TEFFL_MASK)
N#define CAN_ILS_TEFLL_MASK                       (0x8000U)
N#define CAN_ILS_TEFLL_SHIFT                      (15U)
N#define CAN_ILS_TEFLL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TEFLL_SHIFT)) & CAN_ILS_TEFLL_MASK)
N#define CAN_ILS_TSWL_MASK                        (0x10000U)
N#define CAN_ILS_TSWL_SHIFT                       (16U)
N#define CAN_ILS_TSWL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TSWL_SHIFT)) & CAN_ILS_TSWL_MASK)
N#define CAN_ILS_MRAFL_MASK                       (0x20000U)
N#define CAN_ILS_MRAFL_SHIFT                      (17U)
N#define CAN_ILS_MRAFL(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILS_MRAFL_SHIFT)) & CAN_ILS_MRAFL_MASK)
N#define CAN_ILS_TOOL_MASK                        (0x40000U)
N#define CAN_ILS_TOOL_SHIFT                       (18U)
N#define CAN_ILS_TOOL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_TOOL_SHIFT)) & CAN_ILS_TOOL_MASK)
N#define CAN_ILS_DRXL_MASK                        (0x80000U)
N#define CAN_ILS_DRXL_SHIFT                       (19U)
N#define CAN_ILS_DRXL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_DRXL_SHIFT)) & CAN_ILS_DRXL_MASK)
N#define CAN_ILS_BECL_MASK                        (0x100000U)
N#define CAN_ILS_BECL_SHIFT                       (20U)
N#define CAN_ILS_BECL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_BECL_SHIFT)) & CAN_ILS_BECL_MASK)
N#define CAN_ILS_BEUL_MASK                        (0x200000U)
N#define CAN_ILS_BEUL_SHIFT                       (21U)
N#define CAN_ILS_BEUL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_BEUL_SHIFT)) & CAN_ILS_BEUL_MASK)
N#define CAN_ILS_ELOL_MASK                        (0x400000U)
N#define CAN_ILS_ELOL_SHIFT                       (22U)
N#define CAN_ILS_ELOL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_ELOL_SHIFT)) & CAN_ILS_ELOL_MASK)
N#define CAN_ILS_EPL_MASK                         (0x800000U)
N#define CAN_ILS_EPL_SHIFT                        (23U)
N#define CAN_ILS_EPL(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ILS_EPL_SHIFT)) & CAN_ILS_EPL_MASK)
N#define CAN_ILS_EWL_MASK                         (0x1000000U)
N#define CAN_ILS_EWL_SHIFT                        (24U)
N#define CAN_ILS_EWL(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ILS_EWL_SHIFT)) & CAN_ILS_EWL_MASK)
N#define CAN_ILS_BOL_MASK                         (0x2000000U)
N#define CAN_ILS_BOL_SHIFT                        (25U)
N#define CAN_ILS_BOL(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_ILS_BOL_SHIFT)) & CAN_ILS_BOL_MASK)
N#define CAN_ILS_WDIL_MASK                        (0x4000000U)
N#define CAN_ILS_WDIL_SHIFT                       (26U)
N#define CAN_ILS_WDIL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_WDIL_SHIFT)) & CAN_ILS_WDIL_MASK)
N#define CAN_ILS_PEAL_MASK                        (0x8000000U)
N#define CAN_ILS_PEAL_SHIFT                       (27U)
N#define CAN_ILS_PEAL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_PEAL_SHIFT)) & CAN_ILS_PEAL_MASK)
N#define CAN_ILS_PEDL_MASK                        (0x10000000U)
N#define CAN_ILS_PEDL_SHIFT                       (28U)
N#define CAN_ILS_PEDL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_PEDL_SHIFT)) & CAN_ILS_PEDL_MASK)
N#define CAN_ILS_ARAL_MASK                        (0x20000000U)
N#define CAN_ILS_ARAL_SHIFT                       (29U)
N#define CAN_ILS_ARAL(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_ILS_ARAL_SHIFT)) & CAN_ILS_ARAL_MASK)
N
N/*! @name ILE - Interrupt Line Enable */
N#define CAN_ILE_EINT0_MASK                       (0x1U)
N#define CAN_ILE_EINT0_SHIFT                      (0U)
N#define CAN_ILE_EINT0(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILE_EINT0_SHIFT)) & CAN_ILE_EINT0_MASK)
N#define CAN_ILE_EINT1_MASK                       (0x2U)
N#define CAN_ILE_EINT1_SHIFT                      (1U)
N#define CAN_ILE_EINT1(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_ILE_EINT1_SHIFT)) & CAN_ILE_EINT1_MASK)
N
N/*! @name GFC - Global Filter Configuration */
N#define CAN_GFC_RRFE_MASK                        (0x1U)
N#define CAN_GFC_RRFE_SHIFT                       (0U)
N#define CAN_GFC_RRFE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_GFC_RRFE_SHIFT)) & CAN_GFC_RRFE_MASK)
N#define CAN_GFC_RRFS_MASK                        (0x2U)
N#define CAN_GFC_RRFS_SHIFT                       (1U)
N#define CAN_GFC_RRFS(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_GFC_RRFS_SHIFT)) & CAN_GFC_RRFS_MASK)
N#define CAN_GFC_ANFE_MASK                        (0xCU)
N#define CAN_GFC_ANFE_SHIFT                       (2U)
N#define CAN_GFC_ANFE(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_GFC_ANFE_SHIFT)) & CAN_GFC_ANFE_MASK)
N#define CAN_GFC_ANFS_MASK                        (0x30U)
N#define CAN_GFC_ANFS_SHIFT                       (4U)
N#define CAN_GFC_ANFS(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_GFC_ANFS_SHIFT)) & CAN_GFC_ANFS_MASK)
N
N/*! @name SIDFC - Standard ID Filter Configuration */
N#define CAN_SIDFC_FLSSA_MASK                     (0xFFFCU)
N#define CAN_SIDFC_FLSSA_SHIFT                    (2U)
N#define CAN_SIDFC_FLSSA(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_SIDFC_FLSSA_SHIFT)) & CAN_SIDFC_FLSSA_MASK)
N#define CAN_SIDFC_LSS_MASK                       (0xFF0000U)
N#define CAN_SIDFC_LSS_SHIFT                      (16U)
N#define CAN_SIDFC_LSS(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_SIDFC_LSS_SHIFT)) & CAN_SIDFC_LSS_MASK)
N
N/*! @name XIDFC - Extended ID Filter Configuration */
N#define CAN_XIDFC_FLESA_MASK                     (0xFFFCU)
N#define CAN_XIDFC_FLESA_SHIFT                    (2U)
N#define CAN_XIDFC_FLESA(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_XIDFC_FLESA_SHIFT)) & CAN_XIDFC_FLESA_MASK)
N#define CAN_XIDFC_LSE_MASK                       (0xFF0000U)
N#define CAN_XIDFC_LSE_SHIFT                      (16U)
N#define CAN_XIDFC_LSE(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_XIDFC_LSE_SHIFT)) & CAN_XIDFC_LSE_MASK)
N
N/*! @name XIDAM - Extended ID AND Mask */
N#define CAN_XIDAM_EIDM_MASK                      (0x1FFFFFFFU)
N#define CAN_XIDAM_EIDM_SHIFT                     (0U)
N#define CAN_XIDAM_EIDM(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_XIDAM_EIDM_SHIFT)) & CAN_XIDAM_EIDM_MASK)
N
N/*! @name HPMS - High Priority Message Status */
N#define CAN_HPMS_BIDX_MASK                       (0x3FU)
N#define CAN_HPMS_BIDX_SHIFT                      (0U)
N#define CAN_HPMS_BIDX(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_HPMS_BIDX_SHIFT)) & CAN_HPMS_BIDX_MASK)
N#define CAN_HPMS_MSI_MASK                        (0xC0U)
N#define CAN_HPMS_MSI_SHIFT                       (6U)
N#define CAN_HPMS_MSI(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_HPMS_MSI_SHIFT)) & CAN_HPMS_MSI_MASK)
N#define CAN_HPMS_FIDX_MASK                       (0x7F00U)
N#define CAN_HPMS_FIDX_SHIFT                      (8U)
N#define CAN_HPMS_FIDX(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_HPMS_FIDX_SHIFT)) & CAN_HPMS_FIDX_MASK)
N#define CAN_HPMS_FLST_MASK                       (0x8000U)
N#define CAN_HPMS_FLST_SHIFT                      (15U)
N#define CAN_HPMS_FLST(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_HPMS_FLST_SHIFT)) & CAN_HPMS_FLST_MASK)
N
N/*! @name NDAT1 - New Data 1 */
N#define CAN_NDAT1_ND_MASK                        (0xFFFFFFFFU)
N#define CAN_NDAT1_ND_SHIFT                       (0U)
N#define CAN_NDAT1_ND(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_NDAT1_ND_SHIFT)) & CAN_NDAT1_ND_MASK)
N
N/*! @name NDAT2 - New Data 2 */
N#define CAN_NDAT2_ND_MASK                        (0xFFFFFFFFU)
N#define CAN_NDAT2_ND_SHIFT                       (0U)
N#define CAN_NDAT2_ND(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_NDAT2_ND_SHIFT)) & CAN_NDAT2_ND_MASK)
N
N/*! @name RXF0C - Rx FIFO 0 Configuration */
N#define CAN_RXF0C_F0SA_MASK                      (0xFFFCU)
N#define CAN_RXF0C_F0SA_SHIFT                     (2U)
N#define CAN_RXF0C_F0SA(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0C_F0SA_SHIFT)) & CAN_RXF0C_F0SA_MASK)
N#define CAN_RXF0C_F0S_MASK                       (0x7F0000U)
N#define CAN_RXF0C_F0S_SHIFT                      (16U)
N#define CAN_RXF0C_F0S(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_RXF0C_F0S_SHIFT)) & CAN_RXF0C_F0S_MASK)
N#define CAN_RXF0C_F0WM_MASK                      (0x7F000000U)
N#define CAN_RXF0C_F0WM_SHIFT                     (24U)
N#define CAN_RXF0C_F0WM(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0C_F0WM_SHIFT)) & CAN_RXF0C_F0WM_MASK)
N#define CAN_RXF0C_F0OM_MASK                      (0x80000000U)
N#define CAN_RXF0C_F0OM_SHIFT                     (31U)
N#define CAN_RXF0C_F0OM(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0C_F0OM_SHIFT)) & CAN_RXF0C_F0OM_MASK)
N
N/*! @name RXF0S - Rx FIFO 0 Status */
N#define CAN_RXF0S_F0FL_MASK                      (0x7FU)
N#define CAN_RXF0S_F0FL_SHIFT                     (0U)
N#define CAN_RXF0S_F0FL(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0S_F0FL_SHIFT)) & CAN_RXF0S_F0FL_MASK)
N#define CAN_RXF0S_F0GI_MASK                      (0x3F00U)
N#define CAN_RXF0S_F0GI_SHIFT                     (8U)
N#define CAN_RXF0S_F0GI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0S_F0GI_SHIFT)) & CAN_RXF0S_F0GI_MASK)
N#define CAN_RXF0S_F0PI_MASK                      (0x3F0000U)
N#define CAN_RXF0S_F0PI_SHIFT                     (16U)
N#define CAN_RXF0S_F0PI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0S_F0PI_SHIFT)) & CAN_RXF0S_F0PI_MASK)
N#define CAN_RXF0S_F0F_MASK                       (0x1000000U)
N#define CAN_RXF0S_F0F_SHIFT                      (24U)
N#define CAN_RXF0S_F0F(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_RXF0S_F0F_SHIFT)) & CAN_RXF0S_F0F_MASK)
N#define CAN_RXF0S_RF0L_MASK                      (0x2000000U)
N#define CAN_RXF0S_RF0L_SHIFT                     (25U)
N#define CAN_RXF0S_RF0L(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0S_RF0L_SHIFT)) & CAN_RXF0S_RF0L_MASK)
N
N/*! @name RXF0A - Rx FIFO 0 Acknowledge */
N#define CAN_RXF0A_F0AI_MASK                      (0x3FU)
N#define CAN_RXF0A_F0AI_SHIFT                     (0U)
N#define CAN_RXF0A_F0AI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF0A_F0AI_SHIFT)) & CAN_RXF0A_F0AI_MASK)
N
N/*! @name RXBC - Rx Buffer Configuration */
N#define CAN_RXBC_RBSA_MASK                       (0xFFFCU)
N#define CAN_RXBC_RBSA_SHIFT                      (2U)
N#define CAN_RXBC_RBSA(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_RXBC_RBSA_SHIFT)) & CAN_RXBC_RBSA_MASK)
N
N/*! @name RXF1C - Rx FIFO 1 Configuration */
N#define CAN_RXF1C_F1SA_MASK                      (0xFFFCU)
N#define CAN_RXF1C_F1SA_SHIFT                     (2U)
N#define CAN_RXF1C_F1SA(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1C_F1SA_SHIFT)) & CAN_RXF1C_F1SA_MASK)
N#define CAN_RXF1C_F1S_MASK                       (0x7F0000U)
N#define CAN_RXF1C_F1S_SHIFT                      (16U)
N#define CAN_RXF1C_F1S(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_RXF1C_F1S_SHIFT)) & CAN_RXF1C_F1S_MASK)
N#define CAN_RXF1C_F1WM_MASK                      (0x7F000000U)
N#define CAN_RXF1C_F1WM_SHIFT                     (24U)
N#define CAN_RXF1C_F1WM(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1C_F1WM_SHIFT)) & CAN_RXF1C_F1WM_MASK)
N#define CAN_RXF1C_F1OM_MASK                      (0x80000000U)
N#define CAN_RXF1C_F1OM_SHIFT                     (31U)
N#define CAN_RXF1C_F1OM(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1C_F1OM_SHIFT)) & CAN_RXF1C_F1OM_MASK)
N
N/*! @name RXF1S - Rx FIFO 1 Status */
N#define CAN_RXF1S_F1FL_MASK                      (0x7FU)
N#define CAN_RXF1S_F1FL_SHIFT                     (0U)
N#define CAN_RXF1S_F1FL(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1S_F1FL_SHIFT)) & CAN_RXF1S_F1FL_MASK)
N#define CAN_RXF1S_F1GI_MASK                      (0x3F00U)
N#define CAN_RXF1S_F1GI_SHIFT                     (8U)
N#define CAN_RXF1S_F1GI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1S_F1GI_SHIFT)) & CAN_RXF1S_F1GI_MASK)
N#define CAN_RXF1S_F1PI_MASK                      (0x3F0000U)
N#define CAN_RXF1S_F1PI_SHIFT                     (16U)
N#define CAN_RXF1S_F1PI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1S_F1PI_SHIFT)) & CAN_RXF1S_F1PI_MASK)
N#define CAN_RXF1S_F1F_MASK                       (0x1000000U)
N#define CAN_RXF1S_F1F_SHIFT                      (24U)
N#define CAN_RXF1S_F1F(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_RXF1S_F1F_SHIFT)) & CAN_RXF1S_F1F_MASK)
N#define CAN_RXF1S_RF1L_MASK                      (0x2000000U)
N#define CAN_RXF1S_RF1L_SHIFT                     (25U)
N#define CAN_RXF1S_RF1L(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1S_RF1L_SHIFT)) & CAN_RXF1S_RF1L_MASK)
N
N/*! @name RXF1A - Rx FIFO 1 Acknowledge */
N#define CAN_RXF1A_F1AI_MASK                      (0x3FU)
N#define CAN_RXF1A_F1AI_SHIFT                     (0U)
N#define CAN_RXF1A_F1AI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXF1A_F1AI_SHIFT)) & CAN_RXF1A_F1AI_MASK)
N
N/*! @name RXESC - Rx Buffer and FIFO Element Size Configuration */
N#define CAN_RXESC_F0DS_MASK                      (0x7U)
N#define CAN_RXESC_F0DS_SHIFT                     (0U)
N#define CAN_RXESC_F0DS(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXESC_F0DS_SHIFT)) & CAN_RXESC_F0DS_MASK)
N#define CAN_RXESC_F1DS_MASK                      (0x70U)
N#define CAN_RXESC_F1DS_SHIFT                     (4U)
N#define CAN_RXESC_F1DS(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXESC_F1DS_SHIFT)) & CAN_RXESC_F1DS_MASK)
N#define CAN_RXESC_RBDS_MASK                      (0x700U)
N#define CAN_RXESC_RBDS_SHIFT                     (8U)
N#define CAN_RXESC_RBDS(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_RXESC_RBDS_SHIFT)) & CAN_RXESC_RBDS_MASK)
N
N/*! @name TXBC - Tx Buffer Configuration */
N#define CAN_TXBC_TBSA_MASK                       (0xFFFCU)
N#define CAN_TXBC_TBSA_SHIFT                      (2U)
N#define CAN_TXBC_TBSA(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXBC_TBSA_SHIFT)) & CAN_TXBC_TBSA_MASK)
N#define CAN_TXBC_NDTB_MASK                       (0x3F0000U)
N#define CAN_TXBC_NDTB_SHIFT                      (16U)
N#define CAN_TXBC_NDTB(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXBC_NDTB_SHIFT)) & CAN_TXBC_NDTB_MASK)
N#define CAN_TXBC_TFQS_MASK                       (0x3F000000U)
N#define CAN_TXBC_TFQS_SHIFT                      (24U)
N#define CAN_TXBC_TFQS(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXBC_TFQS_SHIFT)) & CAN_TXBC_TFQS_MASK)
N#define CAN_TXBC_TFQM_MASK                       (0x40000000U)
N#define CAN_TXBC_TFQM_SHIFT                      (30U)
N#define CAN_TXBC_TFQM(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXBC_TFQM_SHIFT)) & CAN_TXBC_TFQM_MASK)
N
N/*! @name TXFQS - Tx FIFO/Queue Status */
N#define CAN_TXFQS_TFGI_MASK                      (0x1F00U)
N#define CAN_TXFQS_TFGI_SHIFT                     (8U)
N#define CAN_TXFQS_TFGI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXFQS_TFGI_SHIFT)) & CAN_TXFQS_TFGI_MASK)
N#define CAN_TXFQS_TFQPI_MASK                     (0x1F0000U)
N#define CAN_TXFQS_TFQPI_SHIFT                    (16U)
N#define CAN_TXFQS_TFQPI(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_TXFQS_TFQPI_SHIFT)) & CAN_TXFQS_TFQPI_MASK)
N#define CAN_TXFQS_TFQF_MASK                      (0x200000U)
N#define CAN_TXFQS_TFQF_SHIFT                     (21U)
N#define CAN_TXFQS_TFQF(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXFQS_TFQF_SHIFT)) & CAN_TXFQS_TFQF_MASK)
N
N/*! @name TXESC - Tx Buffer Element Size Configuration */
N#define CAN_TXESC_TBDS_MASK                      (0x7U)
N#define CAN_TXESC_TBDS_SHIFT                     (0U)
N#define CAN_TXESC_TBDS(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXESC_TBDS_SHIFT)) & CAN_TXESC_TBDS_MASK)
N
N/*! @name TXBRP - Tx Buffer Request Pending */
N#define CAN_TXBRP_TRP_MASK                       (0xFFFFFFFFU)
N#define CAN_TXBRP_TRP_SHIFT                      (0U)
N#define CAN_TXBRP_TRP(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXBRP_TRP_SHIFT)) & CAN_TXBRP_TRP_MASK)
N
N/*! @name TXBAR - Tx Buffer Add Request */
N#define CAN_TXBAR_AR_MASK                        (0xFFFFFFFFU)
N#define CAN_TXBAR_AR_SHIFT                       (0U)
N#define CAN_TXBAR_AR(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TXBAR_AR_SHIFT)) & CAN_TXBAR_AR_MASK)
N
N/*! @name TXBCR - Tx Buffer Cancellation Request */
N#define CAN_TXBCR_CR_MASK                        (0xFFFFFFFFU)
N#define CAN_TXBCR_CR_SHIFT                       (0U)
N#define CAN_TXBCR_CR(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TXBCR_CR_SHIFT)) & CAN_TXBCR_CR_MASK)
N
N/*! @name TXBTO - Tx Buffer Transmission Occurred */
N#define CAN_TXBTO_TO_MASK                        (0xFFFFFFFFU)
N#define CAN_TXBTO_TO_SHIFT                       (0U)
N#define CAN_TXBTO_TO(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TXBTO_TO_SHIFT)) & CAN_TXBTO_TO_MASK)
N
N/*! @name TXBCF - Tx Buffer Cancellation Finished */
N#define CAN_TXBCF_TO_MASK                        (0xFFFFFFFFU)
N#define CAN_TXBCF_TO_SHIFT                       (0U)
N#define CAN_TXBCF_TO(x)                          (((uint32_t)(((uint32_t)(x)) << CAN_TXBCF_TO_SHIFT)) & CAN_TXBCF_TO_MASK)
N
N/*! @name TXBTIE - Tx Buffer Transmission Interrupt Enable */
N#define CAN_TXBTIE_TIE_MASK                      (0xFFFFFFFFU)
N#define CAN_TXBTIE_TIE_SHIFT                     (0U)
N#define CAN_TXBTIE_TIE(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXBTIE_TIE_SHIFT)) & CAN_TXBTIE_TIE_MASK)
N
N/*! @name TXBCIE - Tx Buffer Cancellation Finished Interrupt Enable */
N#define CAN_TXBCIE_CFIE_MASK                     (0xFFFFFFFFU)
N#define CAN_TXBCIE_CFIE_SHIFT                    (0U)
N#define CAN_TXBCIE_CFIE(x)                       (((uint32_t)(((uint32_t)(x)) << CAN_TXBCIE_CFIE_SHIFT)) & CAN_TXBCIE_CFIE_MASK)
N
N/*! @name TXEFC - Tx Event FIFO Configuration */
N#define CAN_TXEFC_EFSA_MASK                      (0xFFFCU)
N#define CAN_TXEFC_EFSA_SHIFT                     (2U)
N#define CAN_TXEFC_EFSA(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFC_EFSA_SHIFT)) & CAN_TXEFC_EFSA_MASK)
N#define CAN_TXEFC_EFS_MASK                       (0x3F0000U)
N#define CAN_TXEFC_EFS_SHIFT                      (16U)
N#define CAN_TXEFC_EFS(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXEFC_EFS_SHIFT)) & CAN_TXEFC_EFS_MASK)
N#define CAN_TXEFC_EFWM_MASK                      (0x3F000000U)
N#define CAN_TXEFC_EFWM_SHIFT                     (24U)
N#define CAN_TXEFC_EFWM(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFC_EFWM_SHIFT)) & CAN_TXEFC_EFWM_MASK)
N
N/*! @name TXEFS - Tx Event FIFO Status */
N#define CAN_TXEFS_EFFL_MASK                      (0x3FU)
N#define CAN_TXEFS_EFFL_SHIFT                     (0U)
N#define CAN_TXEFS_EFFL(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFS_EFFL_SHIFT)) & CAN_TXEFS_EFFL_MASK)
N#define CAN_TXEFS_EFGI_MASK                      (0x1F00U)
N#define CAN_TXEFS_EFGI_SHIFT                     (8U)
N#define CAN_TXEFS_EFGI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFS_EFGI_SHIFT)) & CAN_TXEFS_EFGI_MASK)
N#define CAN_TXEFS_EFPI_MASK                      (0x3F0000U)
N#define CAN_TXEFS_EFPI_SHIFT                     (16U)
N#define CAN_TXEFS_EFPI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFS_EFPI_SHIFT)) & CAN_TXEFS_EFPI_MASK)
N#define CAN_TXEFS_EFF_MASK                       (0x1000000U)
N#define CAN_TXEFS_EFF_SHIFT                      (24U)
N#define CAN_TXEFS_EFF(x)                         (((uint32_t)(((uint32_t)(x)) << CAN_TXEFS_EFF_SHIFT)) & CAN_TXEFS_EFF_MASK)
N#define CAN_TXEFS_TEFL_MASK                      (0x2000000U)
N#define CAN_TXEFS_TEFL_SHIFT                     (25U)
N#define CAN_TXEFS_TEFL(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFS_TEFL_SHIFT)) & CAN_TXEFS_TEFL_MASK)
N
N/*! @name TXEFA - Tx Event FIFO Acknowledge */
N#define CAN_TXEFA_EFAI_MASK                      (0x1FU)
N#define CAN_TXEFA_EFAI_SHIFT                     (0U)
N#define CAN_TXEFA_EFAI(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_TXEFA_EFAI_SHIFT)) & CAN_TXEFA_EFAI_MASK)
N
N/*! @name MRBA - CAN Message RAM Base Address */
N#define CAN_MRBA_BA_MASK                         (0xFFFFFFFFU)
N#define CAN_MRBA_BA_SHIFT                        (0U)
N#define CAN_MRBA_BA(x)                           (((uint32_t)(((uint32_t)(x)) << CAN_MRBA_BA_SHIFT)) & CAN_MRBA_BA_MASK)
N
N/*! @name ETSCC - External Timestamp Counter Configuration */
N#define CAN_ETSCC_ETCP_MASK                      (0x7FFU)
N#define CAN_ETSCC_ETCP_SHIFT                     (0U)
N#define CAN_ETSCC_ETCP(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_ETSCC_ETCP_SHIFT)) & CAN_ETSCC_ETCP_MASK)
N#define CAN_ETSCC_ETCE_MASK                      (0x80000000U)
N#define CAN_ETSCC_ETCE_SHIFT                     (31U)
N#define CAN_ETSCC_ETCE(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_ETSCC_ETCE_SHIFT)) & CAN_ETSCC_ETCE_MASK)
N
N/*! @name ETSCV - External Timestamp Counter Value */
N#define CAN_ETSCV_ETSC_MASK                      (0xFFFFU)
N#define CAN_ETSCV_ETSC_SHIFT                     (0U)
N#define CAN_ETSCV_ETSC(x)                        (((uint32_t)(((uint32_t)(x)) << CAN_ETSCV_ETSC_SHIFT)) & CAN_ETSCV_ETSC_MASK)
N
N
N/*!
N * @}
N */ /* end of group CAN_Register_Masks */
N
N
N/* CAN - Peripheral instance base addresses */
N/** Peripheral CAN0 base address */
N#define CAN0_BASE                                (0x4009D000u)
N/** Peripheral CAN0 base pointer */
N#define CAN0                                     ((CAN_Type *)CAN0_BASE)
N/** Peripheral CAN1 base address */
N#define CAN1_BASE                                (0x4009E000u)
N/** Peripheral CAN1 base pointer */
N#define CAN1                                     ((CAN_Type *)CAN1_BASE)
N/** Array initializer of CAN peripheral base addresses */
N#define CAN_BASE_ADDRS                           { CAN0_BASE, CAN1_BASE }
N/** Array initializer of CAN peripheral base pointers */
N#define CAN_BASE_PTRS                            { CAN0, CAN1 }
N/** Interrupt vectors for the CAN peripheral type */
N#define CAN_IRQS                                 { { CAN0_IRQ0_IRQn, CAN0_IRQ1_IRQn }, { CAN1_IRQ0_IRQn, CAN1_IRQ1_IRQn } }
N
N/*!
N * @}
N */ /* end of group CAN_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- CRC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CRC_Peripheral_Access_Layer CRC Peripheral Access Layer
N * @{
N */
N
N/** CRC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t MODE;                              /**< CRC mode register, offset: 0x0 */
X  volatile uint32_t MODE;                               
N  __IO uint32_t SEED;                              /**< CRC seed register, offset: 0x4 */
X  volatile uint32_t SEED;                               
N  union {                                          /* offset: 0x8 */
N    __I  uint32_t SUM;                               /**< CRC checksum register, offset: 0x8 */
X    volatile const  uint32_t SUM;                                
N    __O  uint32_t WR_DATA;                           /**< CRC data register, offset: 0x8 */
X    volatile  uint32_t WR_DATA;                            
N  };
N} CRC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- CRC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CRC_Register_Masks CRC Register Masks
N * @{
N */
N
N/*! @name MODE - CRC mode register */
N#define CRC_MODE_CRC_POLY_MASK                   (0x3U)
N#define CRC_MODE_CRC_POLY_SHIFT                  (0U)
N#define CRC_MODE_CRC_POLY(x)                     (((uint32_t)(((uint32_t)(x)) << CRC_MODE_CRC_POLY_SHIFT)) & CRC_MODE_CRC_POLY_MASK)
N#define CRC_MODE_BIT_RVS_WR_MASK                 (0x4U)
N#define CRC_MODE_BIT_RVS_WR_SHIFT                (2U)
N#define CRC_MODE_BIT_RVS_WR(x)                   (((uint32_t)(((uint32_t)(x)) << CRC_MODE_BIT_RVS_WR_SHIFT)) & CRC_MODE_BIT_RVS_WR_MASK)
N#define CRC_MODE_CMPL_WR_MASK                    (0x8U)
N#define CRC_MODE_CMPL_WR_SHIFT                   (3U)
N#define CRC_MODE_CMPL_WR(x)                      (((uint32_t)(((uint32_t)(x)) << CRC_MODE_CMPL_WR_SHIFT)) & CRC_MODE_CMPL_WR_MASK)
N#define CRC_MODE_BIT_RVS_SUM_MASK                (0x10U)
N#define CRC_MODE_BIT_RVS_SUM_SHIFT               (4U)
N#define CRC_MODE_BIT_RVS_SUM(x)                  (((uint32_t)(((uint32_t)(x)) << CRC_MODE_BIT_RVS_SUM_SHIFT)) & CRC_MODE_BIT_RVS_SUM_MASK)
N#define CRC_MODE_CMPL_SUM_MASK                   (0x20U)
N#define CRC_MODE_CMPL_SUM_SHIFT                  (5U)
N#define CRC_MODE_CMPL_SUM(x)                     (((uint32_t)(((uint32_t)(x)) << CRC_MODE_CMPL_SUM_SHIFT)) & CRC_MODE_CMPL_SUM_MASK)
N
N/*! @name SEED - CRC seed register */
N#define CRC_SEED_CRC_SEED_MASK                   (0xFFFFFFFFU)
N#define CRC_SEED_CRC_SEED_SHIFT                  (0U)
N#define CRC_SEED_CRC_SEED(x)                     (((uint32_t)(((uint32_t)(x)) << CRC_SEED_CRC_SEED_SHIFT)) & CRC_SEED_CRC_SEED_MASK)
N
N/*! @name SUM - CRC checksum register */
N#define CRC_SUM_CRC_SUM_MASK                     (0xFFFFFFFFU)
N#define CRC_SUM_CRC_SUM_SHIFT                    (0U)
N#define CRC_SUM_CRC_SUM(x)                       (((uint32_t)(((uint32_t)(x)) << CRC_SUM_CRC_SUM_SHIFT)) & CRC_SUM_CRC_SUM_MASK)
N
N/*! @name WR_DATA - CRC data register */
N#define CRC_WR_DATA_CRC_WR_DATA_MASK             (0xFFFFFFFFU)
N#define CRC_WR_DATA_CRC_WR_DATA_SHIFT            (0U)
N#define CRC_WR_DATA_CRC_WR_DATA(x)               (((uint32_t)(((uint32_t)(x)) << CRC_WR_DATA_CRC_WR_DATA_SHIFT)) & CRC_WR_DATA_CRC_WR_DATA_MASK)
N
N
N/*!
N * @}
N */ /* end of group CRC_Register_Masks */
N
N
N/* CRC - Peripheral instance base addresses */
N/** Peripheral CRC_ENGINE base address */
N#define CRC_ENGINE_BASE                          (0x40095000u)
N/** Peripheral CRC_ENGINE base pointer */
N#define CRC_ENGINE                               ((CRC_Type *)CRC_ENGINE_BASE)
N/** Array initializer of CRC peripheral base addresses */
N#define CRC_BASE_ADDRS                           { CRC_ENGINE_BASE }
N/** Array initializer of CRC peripheral base pointers */
N#define CRC_BASE_PTRS                            { CRC_ENGINE }
N
N/*!
N * @}
N */ /* end of group CRC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- CTIMER Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CTIMER_Peripheral_Access_Layer CTIMER Peripheral Access Layer
N * @{
N */
N
N/** CTIMER - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t IR;                                /**< Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending., offset: 0x0 */
X  volatile uint32_t IR;                                 
N  __IO uint32_t TCR;                               /**< Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR., offset: 0x4 */
X  volatile uint32_t TCR;                                
N  __IO uint32_t TC;                                /**< Timer Counter, offset: 0x8 */
X  volatile uint32_t TC;                                 
N  __IO uint32_t PR;                                /**< Prescale Register, offset: 0xC */
X  volatile uint32_t PR;                                 
N  __IO uint32_t PC;                                /**< Prescale Counter, offset: 0x10 */
X  volatile uint32_t PC;                                 
N  __IO uint32_t MCR;                               /**< Match Control Register, offset: 0x14 */
X  volatile uint32_t MCR;                                
N  __IO uint32_t MR[4];                             /**< Match Register . MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC., array offset: 0x18, array step: 0x4 */
X  volatile uint32_t MR[4];                              
N  __IO uint32_t CCR;                               /**< Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place., offset: 0x28 */
X  volatile uint32_t CCR;                                
N  __I  uint32_t CR[4];                             /**< Capture Register . CR is loaded with the value of TC when there is an event on the CAPn. input., array offset: 0x2C, array step: 0x4 */
X  volatile const  uint32_t CR[4];                              
N  __IO uint32_t EMR;                               /**< External Match Register. The EMR controls the match function and the external match pins., offset: 0x3C */
X  volatile uint32_t EMR;                                
N       uint8_t RESERVED_0[48];
N  __IO uint32_t CTCR;                              /**< Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting., offset: 0x70 */
X  volatile uint32_t CTCR;                               
N  __IO uint32_t PWMC;                              /**< PWM Control Register. The PWMCON enables PWM mode for the external match pins., offset: 0x74 */
X  volatile uint32_t PWMC;                               
N  __IO uint32_t MSR[4];                            /**< Match Shadow Register, array offset: 0x78, array step: 0x4 */
X  volatile uint32_t MSR[4];                             
N} CTIMER_Type;
N
N/* ----------------------------------------------------------------------------
N   -- CTIMER Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CTIMER_Register_Masks CTIMER Register Masks
N * @{
N */
N
N/*! @name IR - Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending. */
N#define CTIMER_IR_MR0INT_MASK                    (0x1U)
N#define CTIMER_IR_MR0INT_SHIFT                   (0U)
N#define CTIMER_IR_MR0INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_MR0INT_SHIFT)) & CTIMER_IR_MR0INT_MASK)
N#define CTIMER_IR_MR1INT_MASK                    (0x2U)
N#define CTIMER_IR_MR1INT_SHIFT                   (1U)
N#define CTIMER_IR_MR1INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_MR1INT_SHIFT)) & CTIMER_IR_MR1INT_MASK)
N#define CTIMER_IR_MR2INT_MASK                    (0x4U)
N#define CTIMER_IR_MR2INT_SHIFT                   (2U)
N#define CTIMER_IR_MR2INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_MR2INT_SHIFT)) & CTIMER_IR_MR2INT_MASK)
N#define CTIMER_IR_MR3INT_MASK                    (0x8U)
N#define CTIMER_IR_MR3INT_SHIFT                   (3U)
N#define CTIMER_IR_MR3INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_MR3INT_SHIFT)) & CTIMER_IR_MR3INT_MASK)
N#define CTIMER_IR_CR0INT_MASK                    (0x10U)
N#define CTIMER_IR_CR0INT_SHIFT                   (4U)
N#define CTIMER_IR_CR0INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_CR0INT_SHIFT)) & CTIMER_IR_CR0INT_MASK)
N#define CTIMER_IR_CR1INT_MASK                    (0x20U)
N#define CTIMER_IR_CR1INT_SHIFT                   (5U)
N#define CTIMER_IR_CR1INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_CR1INT_SHIFT)) & CTIMER_IR_CR1INT_MASK)
N#define CTIMER_IR_CR2INT_MASK                    (0x40U)
N#define CTIMER_IR_CR2INT_SHIFT                   (6U)
N#define CTIMER_IR_CR2INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_CR2INT_SHIFT)) & CTIMER_IR_CR2INT_MASK)
N#define CTIMER_IR_CR3INT_MASK                    (0x80U)
N#define CTIMER_IR_CR3INT_SHIFT                   (7U)
N#define CTIMER_IR_CR3INT(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_IR_CR3INT_SHIFT)) & CTIMER_IR_CR3INT_MASK)
N
N/*! @name TCR - Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR. */
N#define CTIMER_TCR_CEN_MASK                      (0x1U)
N#define CTIMER_TCR_CEN_SHIFT                     (0U)
N#define CTIMER_TCR_CEN(x)                        (((uint32_t)(((uint32_t)(x)) << CTIMER_TCR_CEN_SHIFT)) & CTIMER_TCR_CEN_MASK)
N#define CTIMER_TCR_CRST_MASK                     (0x2U)
N#define CTIMER_TCR_CRST_SHIFT                    (1U)
N#define CTIMER_TCR_CRST(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_TCR_CRST_SHIFT)) & CTIMER_TCR_CRST_MASK)
N
N/*! @name TC - Timer Counter */
N#define CTIMER_TC_TCVAL_MASK                     (0xFFFFFFFFU)
N#define CTIMER_TC_TCVAL_SHIFT                    (0U)
N#define CTIMER_TC_TCVAL(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_TC_TCVAL_SHIFT)) & CTIMER_TC_TCVAL_MASK)
N
N/*! @name PR - Prescale Register */
N#define CTIMER_PR_PRVAL_MASK                     (0xFFFFFFFFU)
N#define CTIMER_PR_PRVAL_SHIFT                    (0U)
N#define CTIMER_PR_PRVAL(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_PR_PRVAL_SHIFT)) & CTIMER_PR_PRVAL_MASK)
N
N/*! @name PC - Prescale Counter */
N#define CTIMER_PC_PCVAL_MASK                     (0xFFFFFFFFU)
N#define CTIMER_PC_PCVAL_SHIFT                    (0U)
N#define CTIMER_PC_PCVAL(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_PC_PCVAL_SHIFT)) & CTIMER_PC_PCVAL_MASK)
N
N/*! @name MCR - Match Control Register */
N#define CTIMER_MCR_MR0I_MASK                     (0x1U)
N#define CTIMER_MCR_MR0I_SHIFT                    (0U)
N#define CTIMER_MCR_MR0I(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR0I_SHIFT)) & CTIMER_MCR_MR0I_MASK)
N#define CTIMER_MCR_MR0R_MASK                     (0x2U)
N#define CTIMER_MCR_MR0R_SHIFT                    (1U)
N#define CTIMER_MCR_MR0R(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR0R_SHIFT)) & CTIMER_MCR_MR0R_MASK)
N#define CTIMER_MCR_MR0S_MASK                     (0x4U)
N#define CTIMER_MCR_MR0S_SHIFT                    (2U)
N#define CTIMER_MCR_MR0S(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR0S_SHIFT)) & CTIMER_MCR_MR0S_MASK)
N#define CTIMER_MCR_MR1I_MASK                     (0x8U)
N#define CTIMER_MCR_MR1I_SHIFT                    (3U)
N#define CTIMER_MCR_MR1I(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR1I_SHIFT)) & CTIMER_MCR_MR1I_MASK)
N#define CTIMER_MCR_MR1R_MASK                     (0x10U)
N#define CTIMER_MCR_MR1R_SHIFT                    (4U)
N#define CTIMER_MCR_MR1R(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR1R_SHIFT)) & CTIMER_MCR_MR1R_MASK)
N#define CTIMER_MCR_MR1S_MASK                     (0x20U)
N#define CTIMER_MCR_MR1S_SHIFT                    (5U)
N#define CTIMER_MCR_MR1S(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR1S_SHIFT)) & CTIMER_MCR_MR1S_MASK)
N#define CTIMER_MCR_MR2I_MASK                     (0x40U)
N#define CTIMER_MCR_MR2I_SHIFT                    (6U)
N#define CTIMER_MCR_MR2I(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR2I_SHIFT)) & CTIMER_MCR_MR2I_MASK)
N#define CTIMER_MCR_MR2R_MASK                     (0x80U)
N#define CTIMER_MCR_MR2R_SHIFT                    (7U)
N#define CTIMER_MCR_MR2R(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR2R_SHIFT)) & CTIMER_MCR_MR2R_MASK)
N#define CTIMER_MCR_MR2S_MASK                     (0x100U)
N#define CTIMER_MCR_MR2S_SHIFT                    (8U)
N#define CTIMER_MCR_MR2S(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR2S_SHIFT)) & CTIMER_MCR_MR2S_MASK)
N#define CTIMER_MCR_MR3I_MASK                     (0x200U)
N#define CTIMER_MCR_MR3I_SHIFT                    (9U)
N#define CTIMER_MCR_MR3I(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR3I_SHIFT)) & CTIMER_MCR_MR3I_MASK)
N#define CTIMER_MCR_MR3R_MASK                     (0x400U)
N#define CTIMER_MCR_MR3R_SHIFT                    (10U)
N#define CTIMER_MCR_MR3R(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR3R_SHIFT)) & CTIMER_MCR_MR3R_MASK)
N#define CTIMER_MCR_MR3S_MASK                     (0x800U)
N#define CTIMER_MCR_MR3S_SHIFT                    (11U)
N#define CTIMER_MCR_MR3S(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR3S_SHIFT)) & CTIMER_MCR_MR3S_MASK)
N#define CTIMER_MCR_MR0RL_MASK                    (0x1000000U)
N#define CTIMER_MCR_MR0RL_SHIFT                   (24U)
N#define CTIMER_MCR_MR0RL(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR0RL_SHIFT)) & CTIMER_MCR_MR0RL_MASK)
N#define CTIMER_MCR_MR1RL_MASK                    (0x2000000U)
N#define CTIMER_MCR_MR1RL_SHIFT                   (25U)
N#define CTIMER_MCR_MR1RL(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR1RL_SHIFT)) & CTIMER_MCR_MR1RL_MASK)
N#define CTIMER_MCR_MR2RL_MASK                    (0x4000000U)
N#define CTIMER_MCR_MR2RL_SHIFT                   (26U)
N#define CTIMER_MCR_MR2RL(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR2RL_SHIFT)) & CTIMER_MCR_MR2RL_MASK)
N#define CTIMER_MCR_MR3RL_MASK                    (0x8000000U)
N#define CTIMER_MCR_MR3RL_SHIFT                   (27U)
N#define CTIMER_MCR_MR3RL(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_MCR_MR3RL_SHIFT)) & CTIMER_MCR_MR3RL_MASK)
N
N/*! @name MR - Match Register . MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC. */
N#define CTIMER_MR_MATCH_MASK                     (0xFFFFFFFFU)
N#define CTIMER_MR_MATCH_SHIFT                    (0U)
N#define CTIMER_MR_MATCH(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_MR_MATCH_SHIFT)) & CTIMER_MR_MATCH_MASK)
N
N/* The count of CTIMER_MR */
N#define CTIMER_MR_COUNT                          (4U)
N
N/*! @name CCR - Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place. */
N#define CTIMER_CCR_CAP0RE_MASK                   (0x1U)
N#define CTIMER_CCR_CAP0RE_SHIFT                  (0U)
N#define CTIMER_CCR_CAP0RE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP0RE_SHIFT)) & CTIMER_CCR_CAP0RE_MASK)
N#define CTIMER_CCR_CAP0FE_MASK                   (0x2U)
N#define CTIMER_CCR_CAP0FE_SHIFT                  (1U)
N#define CTIMER_CCR_CAP0FE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP0FE_SHIFT)) & CTIMER_CCR_CAP0FE_MASK)
N#define CTIMER_CCR_CAP0I_MASK                    (0x4U)
N#define CTIMER_CCR_CAP0I_SHIFT                   (2U)
N#define CTIMER_CCR_CAP0I(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP0I_SHIFT)) & CTIMER_CCR_CAP0I_MASK)
N#define CTIMER_CCR_CAP1RE_MASK                   (0x8U)
N#define CTIMER_CCR_CAP1RE_SHIFT                  (3U)
N#define CTIMER_CCR_CAP1RE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP1RE_SHIFT)) & CTIMER_CCR_CAP1RE_MASK)
N#define CTIMER_CCR_CAP1FE_MASK                   (0x10U)
N#define CTIMER_CCR_CAP1FE_SHIFT                  (4U)
N#define CTIMER_CCR_CAP1FE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP1FE_SHIFT)) & CTIMER_CCR_CAP1FE_MASK)
N#define CTIMER_CCR_CAP1I_MASK                    (0x20U)
N#define CTIMER_CCR_CAP1I_SHIFT                   (5U)
N#define CTIMER_CCR_CAP1I(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP1I_SHIFT)) & CTIMER_CCR_CAP1I_MASK)
N#define CTIMER_CCR_CAP2RE_MASK                   (0x40U)
N#define CTIMER_CCR_CAP2RE_SHIFT                  (6U)
N#define CTIMER_CCR_CAP2RE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP2RE_SHIFT)) & CTIMER_CCR_CAP2RE_MASK)
N#define CTIMER_CCR_CAP2FE_MASK                   (0x80U)
N#define CTIMER_CCR_CAP2FE_SHIFT                  (7U)
N#define CTIMER_CCR_CAP2FE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP2FE_SHIFT)) & CTIMER_CCR_CAP2FE_MASK)
N#define CTIMER_CCR_CAP2I_MASK                    (0x100U)
N#define CTIMER_CCR_CAP2I_SHIFT                   (8U)
N#define CTIMER_CCR_CAP2I(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP2I_SHIFT)) & CTIMER_CCR_CAP2I_MASK)
N#define CTIMER_CCR_CAP3RE_MASK                   (0x200U)
N#define CTIMER_CCR_CAP3RE_SHIFT                  (9U)
N#define CTIMER_CCR_CAP3RE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP3RE_SHIFT)) & CTIMER_CCR_CAP3RE_MASK)
N#define CTIMER_CCR_CAP3FE_MASK                   (0x400U)
N#define CTIMER_CCR_CAP3FE_SHIFT                  (10U)
N#define CTIMER_CCR_CAP3FE(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP3FE_SHIFT)) & CTIMER_CCR_CAP3FE_MASK)
N#define CTIMER_CCR_CAP3I_MASK                    (0x800U)
N#define CTIMER_CCR_CAP3I_SHIFT                   (11U)
N#define CTIMER_CCR_CAP3I(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_CCR_CAP3I_SHIFT)) & CTIMER_CCR_CAP3I_MASK)
N
N/*! @name CR - Capture Register . CR is loaded with the value of TC when there is an event on the CAPn. input. */
N#define CTIMER_CR_CAP_MASK                       (0xFFFFFFFFU)
N#define CTIMER_CR_CAP_SHIFT                      (0U)
N#define CTIMER_CR_CAP(x)                         (((uint32_t)(((uint32_t)(x)) << CTIMER_CR_CAP_SHIFT)) & CTIMER_CR_CAP_MASK)
N
N/* The count of CTIMER_CR */
N#define CTIMER_CR_COUNT                          (4U)
N
N/*! @name EMR - External Match Register. The EMR controls the match function and the external match pins. */
N#define CTIMER_EMR_EM0_MASK                      (0x1U)
N#define CTIMER_EMR_EM0_SHIFT                     (0U)
N#define CTIMER_EMR_EM0(x)                        (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EM0_SHIFT)) & CTIMER_EMR_EM0_MASK)
N#define CTIMER_EMR_EM1_MASK                      (0x2U)
N#define CTIMER_EMR_EM1_SHIFT                     (1U)
N#define CTIMER_EMR_EM1(x)                        (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EM1_SHIFT)) & CTIMER_EMR_EM1_MASK)
N#define CTIMER_EMR_EM2_MASK                      (0x4U)
N#define CTIMER_EMR_EM2_SHIFT                     (2U)
N#define CTIMER_EMR_EM2(x)                        (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EM2_SHIFT)) & CTIMER_EMR_EM2_MASK)
N#define CTIMER_EMR_EM3_MASK                      (0x8U)
N#define CTIMER_EMR_EM3_SHIFT                     (3U)
N#define CTIMER_EMR_EM3(x)                        (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EM3_SHIFT)) & CTIMER_EMR_EM3_MASK)
N#define CTIMER_EMR_EMC0_MASK                     (0x30U)
N#define CTIMER_EMR_EMC0_SHIFT                    (4U)
N#define CTIMER_EMR_EMC0(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EMC0_SHIFT)) & CTIMER_EMR_EMC0_MASK)
N#define CTIMER_EMR_EMC1_MASK                     (0xC0U)
N#define CTIMER_EMR_EMC1_SHIFT                    (6U)
N#define CTIMER_EMR_EMC1(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EMC1_SHIFT)) & CTIMER_EMR_EMC1_MASK)
N#define CTIMER_EMR_EMC2_MASK                     (0x300U)
N#define CTIMER_EMR_EMC2_SHIFT                    (8U)
N#define CTIMER_EMR_EMC2(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EMC2_SHIFT)) & CTIMER_EMR_EMC2_MASK)
N#define CTIMER_EMR_EMC3_MASK                     (0xC00U)
N#define CTIMER_EMR_EMC3_SHIFT                    (10U)
N#define CTIMER_EMR_EMC3(x)                       (((uint32_t)(((uint32_t)(x)) << CTIMER_EMR_EMC3_SHIFT)) & CTIMER_EMR_EMC3_MASK)
N
N/*! @name CTCR - Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting. */
N#define CTIMER_CTCR_CTMODE_MASK                  (0x3U)
N#define CTIMER_CTCR_CTMODE_SHIFT                 (0U)
N#define CTIMER_CTCR_CTMODE(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_CTCR_CTMODE_SHIFT)) & CTIMER_CTCR_CTMODE_MASK)
N#define CTIMER_CTCR_CINSEL_MASK                  (0xCU)
N#define CTIMER_CTCR_CINSEL_SHIFT                 (2U)
N#define CTIMER_CTCR_CINSEL(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_CTCR_CINSEL_SHIFT)) & CTIMER_CTCR_CINSEL_MASK)
N#define CTIMER_CTCR_ENCC_MASK                    (0x10U)
N#define CTIMER_CTCR_ENCC_SHIFT                   (4U)
N#define CTIMER_CTCR_ENCC(x)                      (((uint32_t)(((uint32_t)(x)) << CTIMER_CTCR_ENCC_SHIFT)) & CTIMER_CTCR_ENCC_MASK)
N#define CTIMER_CTCR_SELCC_MASK                   (0xE0U)
N#define CTIMER_CTCR_SELCC_SHIFT                  (5U)
N#define CTIMER_CTCR_SELCC(x)                     (((uint32_t)(((uint32_t)(x)) << CTIMER_CTCR_SELCC_SHIFT)) & CTIMER_CTCR_SELCC_MASK)
N
N/*! @name PWMC - PWM Control Register. The PWMCON enables PWM mode for the external match pins. */
N#define CTIMER_PWMC_PWMEN0_MASK                  (0x1U)
N#define CTIMER_PWMC_PWMEN0_SHIFT                 (0U)
N#define CTIMER_PWMC_PWMEN0(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_PWMC_PWMEN0_SHIFT)) & CTIMER_PWMC_PWMEN0_MASK)
N#define CTIMER_PWMC_PWMEN1_MASK                  (0x2U)
N#define CTIMER_PWMC_PWMEN1_SHIFT                 (1U)
N#define CTIMER_PWMC_PWMEN1(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_PWMC_PWMEN1_SHIFT)) & CTIMER_PWMC_PWMEN1_MASK)
N#define CTIMER_PWMC_PWMEN2_MASK                  (0x4U)
N#define CTIMER_PWMC_PWMEN2_SHIFT                 (2U)
N#define CTIMER_PWMC_PWMEN2(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_PWMC_PWMEN2_SHIFT)) & CTIMER_PWMC_PWMEN2_MASK)
N#define CTIMER_PWMC_PWMEN3_MASK                  (0x8U)
N#define CTIMER_PWMC_PWMEN3_SHIFT                 (3U)
N#define CTIMER_PWMC_PWMEN3(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_PWMC_PWMEN3_SHIFT)) & CTIMER_PWMC_PWMEN3_MASK)
N
N/*! @name MSR - Match Shadow Register */
N#define CTIMER_MSR_SHADOWW_MASK                  (0xFFFFFFFFU)
N#define CTIMER_MSR_SHADOWW_SHIFT                 (0U)
N#define CTIMER_MSR_SHADOWW(x)                    (((uint32_t)(((uint32_t)(x)) << CTIMER_MSR_SHADOWW_SHIFT)) & CTIMER_MSR_SHADOWW_MASK)
N
N/* The count of CTIMER_MSR */
N#define CTIMER_MSR_COUNT                         (4U)
N
N
N/*!
N * @}
N */ /* end of group CTIMER_Register_Masks */
N
N
N/* CTIMER - Peripheral instance base addresses */
N/** Peripheral CTIMER0 base address */
N#define CTIMER0_BASE                             (0x40008000u)
N/** Peripheral CTIMER0 base pointer */
N#define CTIMER0                                  ((CTIMER_Type *)CTIMER0_BASE)
N/** Peripheral CTIMER1 base address */
N#define CTIMER1_BASE                             (0x40009000u)
N/** Peripheral CTIMER1 base pointer */
N#define CTIMER1                                  ((CTIMER_Type *)CTIMER1_BASE)
N/** Peripheral CTIMER2 base address */
N#define CTIMER2_BASE                             (0x40028000u)
N/** Peripheral CTIMER2 base pointer */
N#define CTIMER2                                  ((CTIMER_Type *)CTIMER2_BASE)
N/** Peripheral CTIMER3 base address */
N#define CTIMER3_BASE                             (0x40048000u)
N/** Peripheral CTIMER3 base pointer */
N#define CTIMER3                                  ((CTIMER_Type *)CTIMER3_BASE)
N/** Peripheral CTIMER4 base address */
N#define CTIMER4_BASE                             (0x40049000u)
N/** Peripheral CTIMER4 base pointer */
N#define CTIMER4                                  ((CTIMER_Type *)CTIMER4_BASE)
N/** Array initializer of CTIMER peripheral base addresses */
N#define CTIMER_BASE_ADDRS                        { CTIMER0_BASE, CTIMER1_BASE, CTIMER2_BASE, CTIMER3_BASE, CTIMER4_BASE }
N/** Array initializer of CTIMER peripheral base pointers */
N#define CTIMER_BASE_PTRS                         { CTIMER0, CTIMER1, CTIMER2, CTIMER3, CTIMER4 }
N/** Interrupt vectors for the CTIMER peripheral type */
N#define CTIMER_IRQS                              { CTIMER0_IRQn, CTIMER1_IRQn, CTIMER2_IRQn, CTIMER3_IRQn, CTIMER4_IRQn }
N
N/*!
N * @}
N */ /* end of group CTIMER_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- DMA Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup DMA_Peripheral_Access_Layer DMA Peripheral Access Layer
N * @{
N */
N
N/** DMA - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< DMA control., offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __I  uint32_t INTSTAT;                           /**< Interrupt status., offset: 0x4 */
X  volatile const  uint32_t INTSTAT;                            
N  __IO uint32_t SRAMBASE;                          /**< SRAM address of the channel configuration table., offset: 0x8 */
X  volatile uint32_t SRAMBASE;                           
N       uint8_t RESERVED_0[20];
N  struct {                                         /* offset: 0x20, array step: 0x5C */
N    __IO uint32_t ENABLESET;                         /**< Channel Enable read and Set for all DMA channels., array offset: 0x20, array step: 0x5C */
X    volatile uint32_t ENABLESET;                          
N         uint8_t RESERVED_0[4];
N    __O  uint32_t ENABLECLR;                         /**< Channel Enable Clear for all DMA channels., array offset: 0x28, array step: 0x5C */
X    volatile  uint32_t ENABLECLR;                          
N         uint8_t RESERVED_1[4];
N    __I  uint32_t ACTIVE;                            /**< Channel Active status for all DMA channels., array offset: 0x30, array step: 0x5C */
X    volatile const  uint32_t ACTIVE;                             
N         uint8_t RESERVED_2[4];
N    __I  uint32_t BUSY;                              /**< Channel Busy status for all DMA channels., array offset: 0x38, array step: 0x5C */
X    volatile const  uint32_t BUSY;                               
N         uint8_t RESERVED_3[4];
N    __IO uint32_t ERRINT;                            /**< Error Interrupt status for all DMA channels., array offset: 0x40, array step: 0x5C */
X    volatile uint32_t ERRINT;                             
N         uint8_t RESERVED_4[4];
N    __IO uint32_t INTENSET;                          /**< Interrupt Enable read and Set for all DMA channels., array offset: 0x48, array step: 0x5C */
X    volatile uint32_t INTENSET;                           
N         uint8_t RESERVED_5[4];
N    __O  uint32_t INTENCLR;                          /**< Interrupt Enable Clear for all DMA channels., array offset: 0x50, array step: 0x5C */
X    volatile  uint32_t INTENCLR;                           
N         uint8_t RESERVED_6[4];
N    __IO uint32_t INTA;                              /**< Interrupt A status for all DMA channels., array offset: 0x58, array step: 0x5C */
X    volatile uint32_t INTA;                               
N         uint8_t RESERVED_7[4];
N    __IO uint32_t INTB;                              /**< Interrupt B status for all DMA channels., array offset: 0x60, array step: 0x5C */
X    volatile uint32_t INTB;                               
N         uint8_t RESERVED_8[4];
N    __O  uint32_t SETVALID;                          /**< Set ValidPending control bits for all DMA channels., array offset: 0x68, array step: 0x5C */
X    volatile  uint32_t SETVALID;                           
N         uint8_t RESERVED_9[4];
N    __O  uint32_t SETTRIG;                           /**< Set Trigger control bits for all DMA channels., array offset: 0x70, array step: 0x5C */
X    volatile  uint32_t SETTRIG;                            
N         uint8_t RESERVED_10[4];
N    __O  uint32_t ABORT;                             /**< Channel Abort control for all DMA channels., array offset: 0x78, array step: 0x5C */
X    volatile  uint32_t ABORT;                              
N  } COMMON[1];
N       uint8_t RESERVED_1[900];
N  struct {                                         /* offset: 0x400, array step: 0x10 */
N    __IO uint32_t CFG;                               /**< Configuration register for DMA channel ., array offset: 0x400, array step: 0x10 */
X    volatile uint32_t CFG;                                
N    __I  uint32_t CTLSTAT;                           /**< Control and status register for DMA channel ., array offset: 0x404, array step: 0x10 */
X    volatile const  uint32_t CTLSTAT;                            
N    __IO uint32_t XFERCFG;                           /**< Transfer configuration register for DMA channel ., array offset: 0x408, array step: 0x10 */
X    volatile uint32_t XFERCFG;                            
N         uint8_t RESERVED_0[4];
N  } CHANNEL[30];
N} DMA_Type;
N
N/* ----------------------------------------------------------------------------
N   -- DMA Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup DMA_Register_Masks DMA Register Masks
N * @{
N */
N
N/*! @name CTRL - DMA control. */
N#define DMA_CTRL_ENABLE_MASK                     (0x1U)
N#define DMA_CTRL_ENABLE_SHIFT                    (0U)
N#define DMA_CTRL_ENABLE(x)                       (((uint32_t)(((uint32_t)(x)) << DMA_CTRL_ENABLE_SHIFT)) & DMA_CTRL_ENABLE_MASK)
N
N/*! @name INTSTAT - Interrupt status. */
N#define DMA_INTSTAT_ACTIVEINT_MASK               (0x2U)
N#define DMA_INTSTAT_ACTIVEINT_SHIFT              (1U)
N#define DMA_INTSTAT_ACTIVEINT(x)                 (((uint32_t)(((uint32_t)(x)) << DMA_INTSTAT_ACTIVEINT_SHIFT)) & DMA_INTSTAT_ACTIVEINT_MASK)
N#define DMA_INTSTAT_ACTIVEERRINT_MASK            (0x4U)
N#define DMA_INTSTAT_ACTIVEERRINT_SHIFT           (2U)
N#define DMA_INTSTAT_ACTIVEERRINT(x)              (((uint32_t)(((uint32_t)(x)) << DMA_INTSTAT_ACTIVEERRINT_SHIFT)) & DMA_INTSTAT_ACTIVEERRINT_MASK)
N
N/*! @name SRAMBASE - SRAM address of the channel configuration table. */
N#define DMA_SRAMBASE_OFFSET_MASK                 (0xFFFFFE00U)
N#define DMA_SRAMBASE_OFFSET_SHIFT                (9U)
N#define DMA_SRAMBASE_OFFSET(x)                   (((uint32_t)(((uint32_t)(x)) << DMA_SRAMBASE_OFFSET_SHIFT)) & DMA_SRAMBASE_OFFSET_MASK)
N
N/*! @name COMMON_ENABLESET - Channel Enable read and Set for all DMA channels. */
N#define DMA_COMMON_ENABLESET_ENA_MASK            (0xFFFFFFFFU)
N#define DMA_COMMON_ENABLESET_ENA_SHIFT           (0U)
N#define DMA_COMMON_ENABLESET_ENA(x)              (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ENABLESET_ENA_SHIFT)) & DMA_COMMON_ENABLESET_ENA_MASK)
N
N/* The count of DMA_COMMON_ENABLESET */
N#define DMA_COMMON_ENABLESET_COUNT               (1U)
N
N/*! @name COMMON_ENABLECLR - Channel Enable Clear for all DMA channels. */
N#define DMA_COMMON_ENABLECLR_CLR_MASK            (0xFFFFFFFFU)
N#define DMA_COMMON_ENABLECLR_CLR_SHIFT           (0U)
N#define DMA_COMMON_ENABLECLR_CLR(x)              (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ENABLECLR_CLR_SHIFT)) & DMA_COMMON_ENABLECLR_CLR_MASK)
N
N/* The count of DMA_COMMON_ENABLECLR */
N#define DMA_COMMON_ENABLECLR_COUNT               (1U)
N
N/*! @name COMMON_ACTIVE - Channel Active status for all DMA channels. */
N#define DMA_COMMON_ACTIVE_ACT_MASK               (0xFFFFFFFFU)
N#define DMA_COMMON_ACTIVE_ACT_SHIFT              (0U)
N#define DMA_COMMON_ACTIVE_ACT(x)                 (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ACTIVE_ACT_SHIFT)) & DMA_COMMON_ACTIVE_ACT_MASK)
N
N/* The count of DMA_COMMON_ACTIVE */
N#define DMA_COMMON_ACTIVE_COUNT                  (1U)
N
N/*! @name COMMON_BUSY - Channel Busy status for all DMA channels. */
N#define DMA_COMMON_BUSY_BSY_MASK                 (0xFFFFFFFFU)
N#define DMA_COMMON_BUSY_BSY_SHIFT                (0U)
N#define DMA_COMMON_BUSY_BSY(x)                   (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_BUSY_BSY_SHIFT)) & DMA_COMMON_BUSY_BSY_MASK)
N
N/* The count of DMA_COMMON_BUSY */
N#define DMA_COMMON_BUSY_COUNT                    (1U)
N
N/*! @name COMMON_ERRINT - Error Interrupt status for all DMA channels. */
N#define DMA_COMMON_ERRINT_ERR_MASK               (0xFFFFFFFFU)
N#define DMA_COMMON_ERRINT_ERR_SHIFT              (0U)
N#define DMA_COMMON_ERRINT_ERR(x)                 (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ERRINT_ERR_SHIFT)) & DMA_COMMON_ERRINT_ERR_MASK)
N
N/* The count of DMA_COMMON_ERRINT */
N#define DMA_COMMON_ERRINT_COUNT                  (1U)
N
N/*! @name COMMON_INTENSET - Interrupt Enable read and Set for all DMA channels. */
N#define DMA_COMMON_INTENSET_INTEN_MASK           (0xFFFFFFFFU)
N#define DMA_COMMON_INTENSET_INTEN_SHIFT          (0U)
N#define DMA_COMMON_INTENSET_INTEN(x)             (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTENSET_INTEN_SHIFT)) & DMA_COMMON_INTENSET_INTEN_MASK)
N
N/* The count of DMA_COMMON_INTENSET */
N#define DMA_COMMON_INTENSET_COUNT                (1U)
N
N/*! @name COMMON_INTENCLR - Interrupt Enable Clear for all DMA channels. */
N#define DMA_COMMON_INTENCLR_CLR_MASK             (0xFFFFFFFFU)
N#define DMA_COMMON_INTENCLR_CLR_SHIFT            (0U)
N#define DMA_COMMON_INTENCLR_CLR(x)               (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTENCLR_CLR_SHIFT)) & DMA_COMMON_INTENCLR_CLR_MASK)
N
N/* The count of DMA_COMMON_INTENCLR */
N#define DMA_COMMON_INTENCLR_COUNT                (1U)
N
N/*! @name COMMON_INTA - Interrupt A status for all DMA channels. */
N#define DMA_COMMON_INTA_IA_MASK                  (0xFFFFFFFFU)
N#define DMA_COMMON_INTA_IA_SHIFT                 (0U)
N#define DMA_COMMON_INTA_IA(x)                    (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTA_IA_SHIFT)) & DMA_COMMON_INTA_IA_MASK)
N
N/* The count of DMA_COMMON_INTA */
N#define DMA_COMMON_INTA_COUNT                    (1U)
N
N/*! @name COMMON_INTB - Interrupt B status for all DMA channels. */
N#define DMA_COMMON_INTB_IB_MASK                  (0xFFFFFFFFU)
N#define DMA_COMMON_INTB_IB_SHIFT                 (0U)
N#define DMA_COMMON_INTB_IB(x)                    (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTB_IB_SHIFT)) & DMA_COMMON_INTB_IB_MASK)
N
N/* The count of DMA_COMMON_INTB */
N#define DMA_COMMON_INTB_COUNT                    (1U)
N
N/*! @name COMMON_SETVALID - Set ValidPending control bits for all DMA channels. */
N#define DMA_COMMON_SETVALID_SV_MASK              (0xFFFFFFFFU)
N#define DMA_COMMON_SETVALID_SV_SHIFT             (0U)
N#define DMA_COMMON_SETVALID_SV(x)                (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_SETVALID_SV_SHIFT)) & DMA_COMMON_SETVALID_SV_MASK)
N
N/* The count of DMA_COMMON_SETVALID */
N#define DMA_COMMON_SETVALID_COUNT                (1U)
N
N/*! @name COMMON_SETTRIG - Set Trigger control bits for all DMA channels. */
N#define DMA_COMMON_SETTRIG_TRIG_MASK             (0xFFFFFFFFU)
N#define DMA_COMMON_SETTRIG_TRIG_SHIFT            (0U)
N#define DMA_COMMON_SETTRIG_TRIG(x)               (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_SETTRIG_TRIG_SHIFT)) & DMA_COMMON_SETTRIG_TRIG_MASK)
N
N/* The count of DMA_COMMON_SETTRIG */
N#define DMA_COMMON_SETTRIG_COUNT                 (1U)
N
N/*! @name COMMON_ABORT - Channel Abort control for all DMA channels. */
N#define DMA_COMMON_ABORT_ABORTCTRL_MASK          (0xFFFFFFFFU)
N#define DMA_COMMON_ABORT_ABORTCTRL_SHIFT         (0U)
N#define DMA_COMMON_ABORT_ABORTCTRL(x)            (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ABORT_ABORTCTRL_SHIFT)) & DMA_COMMON_ABORT_ABORTCTRL_MASK)
N
N/* The count of DMA_COMMON_ABORT */
N#define DMA_COMMON_ABORT_COUNT                   (1U)
N
N/*! @name CHANNEL_CFG - Configuration register for DMA channel . */
N#define DMA_CHANNEL_CFG_PERIPHREQEN_MASK         (0x1U)
N#define DMA_CHANNEL_CFG_PERIPHREQEN_SHIFT        (0U)
N#define DMA_CHANNEL_CFG_PERIPHREQEN(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_PERIPHREQEN_SHIFT)) & DMA_CHANNEL_CFG_PERIPHREQEN_MASK)
N#define DMA_CHANNEL_CFG_HWTRIGEN_MASK            (0x2U)
N#define DMA_CHANNEL_CFG_HWTRIGEN_SHIFT           (1U)
N#define DMA_CHANNEL_CFG_HWTRIGEN(x)              (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_HWTRIGEN_SHIFT)) & DMA_CHANNEL_CFG_HWTRIGEN_MASK)
N#define DMA_CHANNEL_CFG_TRIGPOL_MASK             (0x10U)
N#define DMA_CHANNEL_CFG_TRIGPOL_SHIFT            (4U)
N#define DMA_CHANNEL_CFG_TRIGPOL(x)               (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_TRIGPOL_SHIFT)) & DMA_CHANNEL_CFG_TRIGPOL_MASK)
N#define DMA_CHANNEL_CFG_TRIGTYPE_MASK            (0x20U)
N#define DMA_CHANNEL_CFG_TRIGTYPE_SHIFT           (5U)
N#define DMA_CHANNEL_CFG_TRIGTYPE(x)              (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_TRIGTYPE_SHIFT)) & DMA_CHANNEL_CFG_TRIGTYPE_MASK)
N#define DMA_CHANNEL_CFG_TRIGBURST_MASK           (0x40U)
N#define DMA_CHANNEL_CFG_TRIGBURST_SHIFT          (6U)
N#define DMA_CHANNEL_CFG_TRIGBURST(x)             (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_TRIGBURST_SHIFT)) & DMA_CHANNEL_CFG_TRIGBURST_MASK)
N#define DMA_CHANNEL_CFG_BURSTPOWER_MASK          (0xF00U)
N#define DMA_CHANNEL_CFG_BURSTPOWER_SHIFT         (8U)
N#define DMA_CHANNEL_CFG_BURSTPOWER(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_BURSTPOWER_SHIFT)) & DMA_CHANNEL_CFG_BURSTPOWER_MASK)
N#define DMA_CHANNEL_CFG_SRCBURSTWRAP_MASK        (0x4000U)
N#define DMA_CHANNEL_CFG_SRCBURSTWRAP_SHIFT       (14U)
N#define DMA_CHANNEL_CFG_SRCBURSTWRAP(x)          (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_SRCBURSTWRAP_SHIFT)) & DMA_CHANNEL_CFG_SRCBURSTWRAP_MASK)
N#define DMA_CHANNEL_CFG_DSTBURSTWRAP_MASK        (0x8000U)
N#define DMA_CHANNEL_CFG_DSTBURSTWRAP_SHIFT       (15U)
N#define DMA_CHANNEL_CFG_DSTBURSTWRAP(x)          (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_DSTBURSTWRAP_SHIFT)) & DMA_CHANNEL_CFG_DSTBURSTWRAP_MASK)
N#define DMA_CHANNEL_CFG_CHPRIORITY_MASK          (0x70000U)
N#define DMA_CHANNEL_CFG_CHPRIORITY_SHIFT         (16U)
N#define DMA_CHANNEL_CFG_CHPRIORITY(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_CHPRIORITY_SHIFT)) & DMA_CHANNEL_CFG_CHPRIORITY_MASK)
N
N/* The count of DMA_CHANNEL_CFG */
N#define DMA_CHANNEL_CFG_COUNT                    (30U)
N
N/*! @name CHANNEL_CTLSTAT - Control and status register for DMA channel . */
N#define DMA_CHANNEL_CTLSTAT_VALIDPENDING_MASK    (0x1U)
N#define DMA_CHANNEL_CTLSTAT_VALIDPENDING_SHIFT   (0U)
N#define DMA_CHANNEL_CTLSTAT_VALIDPENDING(x)      (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CTLSTAT_VALIDPENDING_SHIFT)) & DMA_CHANNEL_CTLSTAT_VALIDPENDING_MASK)
N#define DMA_CHANNEL_CTLSTAT_TRIG_MASK            (0x4U)
N#define DMA_CHANNEL_CTLSTAT_TRIG_SHIFT           (2U)
N#define DMA_CHANNEL_CTLSTAT_TRIG(x)              (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CTLSTAT_TRIG_SHIFT)) & DMA_CHANNEL_CTLSTAT_TRIG_MASK)
N
N/* The count of DMA_CHANNEL_CTLSTAT */
N#define DMA_CHANNEL_CTLSTAT_COUNT                (30U)
N
N/*! @name CHANNEL_XFERCFG - Transfer configuration register for DMA channel . */
N#define DMA_CHANNEL_XFERCFG_CFGVALID_MASK        (0x1U)
N#define DMA_CHANNEL_XFERCFG_CFGVALID_SHIFT       (0U)
N#define DMA_CHANNEL_XFERCFG_CFGVALID(x)          (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_CFGVALID_SHIFT)) & DMA_CHANNEL_XFERCFG_CFGVALID_MASK)
N#define DMA_CHANNEL_XFERCFG_RELOAD_MASK          (0x2U)
N#define DMA_CHANNEL_XFERCFG_RELOAD_SHIFT         (1U)
N#define DMA_CHANNEL_XFERCFG_RELOAD(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_RELOAD_SHIFT)) & DMA_CHANNEL_XFERCFG_RELOAD_MASK)
N#define DMA_CHANNEL_XFERCFG_SWTRIG_MASK          (0x4U)
N#define DMA_CHANNEL_XFERCFG_SWTRIG_SHIFT         (2U)
N#define DMA_CHANNEL_XFERCFG_SWTRIG(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SWTRIG_SHIFT)) & DMA_CHANNEL_XFERCFG_SWTRIG_MASK)
N#define DMA_CHANNEL_XFERCFG_CLRTRIG_MASK         (0x8U)
N#define DMA_CHANNEL_XFERCFG_CLRTRIG_SHIFT        (3U)
N#define DMA_CHANNEL_XFERCFG_CLRTRIG(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_CLRTRIG_SHIFT)) & DMA_CHANNEL_XFERCFG_CLRTRIG_MASK)
N#define DMA_CHANNEL_XFERCFG_SETINTA_MASK         (0x10U)
N#define DMA_CHANNEL_XFERCFG_SETINTA_SHIFT        (4U)
N#define DMA_CHANNEL_XFERCFG_SETINTA(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SETINTA_SHIFT)) & DMA_CHANNEL_XFERCFG_SETINTA_MASK)
N#define DMA_CHANNEL_XFERCFG_SETINTB_MASK         (0x20U)
N#define DMA_CHANNEL_XFERCFG_SETINTB_SHIFT        (5U)
N#define DMA_CHANNEL_XFERCFG_SETINTB(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SETINTB_SHIFT)) & DMA_CHANNEL_XFERCFG_SETINTB_MASK)
N#define DMA_CHANNEL_XFERCFG_WIDTH_MASK           (0x300U)
N#define DMA_CHANNEL_XFERCFG_WIDTH_SHIFT          (8U)
N#define DMA_CHANNEL_XFERCFG_WIDTH(x)             (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_WIDTH_SHIFT)) & DMA_CHANNEL_XFERCFG_WIDTH_MASK)
N#define DMA_CHANNEL_XFERCFG_SRCINC_MASK          (0x3000U)
N#define DMA_CHANNEL_XFERCFG_SRCINC_SHIFT         (12U)
N#define DMA_CHANNEL_XFERCFG_SRCINC(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SRCINC_SHIFT)) & DMA_CHANNEL_XFERCFG_SRCINC_MASK)
N#define DMA_CHANNEL_XFERCFG_DSTINC_MASK          (0xC000U)
N#define DMA_CHANNEL_XFERCFG_DSTINC_SHIFT         (14U)
N#define DMA_CHANNEL_XFERCFG_DSTINC(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_DSTINC_SHIFT)) & DMA_CHANNEL_XFERCFG_DSTINC_MASK)
N#define DMA_CHANNEL_XFERCFG_XFERCOUNT_MASK       (0x3FF0000U)
N#define DMA_CHANNEL_XFERCFG_XFERCOUNT_SHIFT      (16U)
N#define DMA_CHANNEL_XFERCFG_XFERCOUNT(x)         (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_XFERCOUNT_SHIFT)) & DMA_CHANNEL_XFERCFG_XFERCOUNT_MASK)
N
N/* The count of DMA_CHANNEL_XFERCFG */
N#define DMA_CHANNEL_XFERCFG_COUNT                (30U)
N
N
N/*!
N * @}
N */ /* end of group DMA_Register_Masks */
N
N
N/* DMA - Peripheral instance base addresses */
N/** Peripheral DMA0 base address */
N#define DMA0_BASE                                (0x40082000u)
N/** Peripheral DMA0 base pointer */
N#define DMA0                                     ((DMA_Type *)DMA0_BASE)
N/** Array initializer of DMA peripheral base addresses */
N#define DMA_BASE_ADDRS                           { DMA0_BASE }
N/** Array initializer of DMA peripheral base pointers */
N#define DMA_BASE_PTRS                            { DMA0 }
N/** Interrupt vectors for the DMA peripheral type */
N#define DMA_IRQS                                 { DMA0_IRQn }
N
N/*!
N * @}
N */ /* end of group DMA_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- DMIC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup DMIC_Peripheral_Access_Layer DMIC Peripheral Access Layer
N * @{
N */
N
N/** DMIC - Register Layout Typedef */
Ntypedef struct {
N  struct {                                         /* offset: 0x0, array step: 0x100 */
N    __IO uint32_t OSR;                               /**< Oversample Rate register 0, array offset: 0x0, array step: 0x100 */
X    volatile uint32_t OSR;                                
N    __IO uint32_t DIVHFCLK;                          /**< DMIC Clock Register 0, array offset: 0x4, array step: 0x100 */
X    volatile uint32_t DIVHFCLK;                           
N    __IO uint32_t PREAC2FSCOEF;                      /**< Pre-Emphasis Filter Coefficient for 2 FS register, array offset: 0x8, array step: 0x100 */
X    volatile uint32_t PREAC2FSCOEF;                       
N    __IO uint32_t PREAC4FSCOEF;                      /**< Pre-Emphasis Filter Coefficient for 4 FS register, array offset: 0xC, array step: 0x100 */
X    volatile uint32_t PREAC4FSCOEF;                       
N    __IO uint32_t GAINSHIFT;                         /**< Decimator Gain Shift register, array offset: 0x10, array step: 0x100 */
X    volatile uint32_t GAINSHIFT;                          
N         uint8_t RESERVED_0[108];
N    __IO uint32_t FIFO_CTRL;                         /**< FIFO Control register 0, array offset: 0x80, array step: 0x100 */
X    volatile uint32_t FIFO_CTRL;                          
N    __IO uint32_t FIFO_STATUS;                       /**< FIFO Status register 0, array offset: 0x84, array step: 0x100 */
X    volatile uint32_t FIFO_STATUS;                        
N    __IO uint32_t FIFO_DATA;                         /**< FIFO Data Register 0, array offset: 0x88, array step: 0x100 */
X    volatile uint32_t FIFO_DATA;                          
N    __IO uint32_t PHY_CTRL;                          /**< PDM Source Configuration register 0, array offset: 0x8C, array step: 0x100 */
X    volatile uint32_t PHY_CTRL;                           
N    __IO uint32_t DC_CTRL;                           /**< DC Control register 0, array offset: 0x90, array step: 0x100 */
X    volatile uint32_t DC_CTRL;                            
N         uint8_t RESERVED_1[108];
N  } CHANNEL[2];
N       uint8_t RESERVED_0[3328];
N  __IO uint32_t CHANEN;                            /**< Channel Enable register, offset: 0xF00 */
X  volatile uint32_t CHANEN;                             
N       uint8_t RESERVED_1[8];
N  __IO uint32_t IOCFG;                             /**< I/O Configuration register, offset: 0xF0C */
X  volatile uint32_t IOCFG;                              
N  __IO uint32_t USE2FS;                            /**< Use 2FS register, offset: 0xF10 */
X  volatile uint32_t USE2FS;                             
N       uint8_t RESERVED_2[108];
N  __IO uint32_t HWVADGAIN;                         /**< HWVAD input gain register, offset: 0xF80 */
X  volatile uint32_t HWVADGAIN;                          
N  __IO uint32_t HWVADHPFS;                         /**< HWVAD filter control register, offset: 0xF84 */
X  volatile uint32_t HWVADHPFS;                          
N  __IO uint32_t HWVADST10;                         /**< HWVAD control register, offset: 0xF88 */
X  volatile uint32_t HWVADST10;                          
N  __IO uint32_t HWVADRSTT;                         /**< HWVAD filter reset register, offset: 0xF8C */
X  volatile uint32_t HWVADRSTT;                          
N  __IO uint32_t HWVADTHGN;                         /**< HWVAD noise estimator gain register, offset: 0xF90 */
X  volatile uint32_t HWVADTHGN;                          
N  __IO uint32_t HWVADTHGS;                         /**< HWVAD signal estimator gain register, offset: 0xF94 */
X  volatile uint32_t HWVADTHGS;                          
N  __I  uint32_t HWVADLOWZ;                         /**< HWVAD noise envelope estimator register, offset: 0xF98 */
X  volatile const  uint32_t HWVADLOWZ;                          
N       uint8_t RESERVED_3[96];
N  __I  uint32_t ID;                                /**< Module Identification register, offset: 0xFFC */
X  volatile const  uint32_t ID;                                 
N} DMIC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- DMIC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup DMIC_Register_Masks DMIC Register Masks
N * @{
N */
N
N/*! @name CHANNEL_OSR - Oversample Rate register 0 */
N#define DMIC_CHANNEL_OSR_OSR_MASK                (0xFFU)
N#define DMIC_CHANNEL_OSR_OSR_SHIFT               (0U)
N#define DMIC_CHANNEL_OSR_OSR(x)                  (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_OSR_OSR_SHIFT)) & DMIC_CHANNEL_OSR_OSR_MASK)
N
N/* The count of DMIC_CHANNEL_OSR */
N#define DMIC_CHANNEL_OSR_COUNT                   (2U)
N
N/*! @name CHANNEL_DIVHFCLK - DMIC Clock Register 0 */
N#define DMIC_CHANNEL_DIVHFCLK_PDMDIV_MASK        (0xFU)
N#define DMIC_CHANNEL_DIVHFCLK_PDMDIV_SHIFT       (0U)
N#define DMIC_CHANNEL_DIVHFCLK_PDMDIV(x)          (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_DIVHFCLK_PDMDIV_SHIFT)) & DMIC_CHANNEL_DIVHFCLK_PDMDIV_MASK)
N
N/* The count of DMIC_CHANNEL_DIVHFCLK */
N#define DMIC_CHANNEL_DIVHFCLK_COUNT              (2U)
N
N/*! @name CHANNEL_PREAC2FSCOEF - Pre-Emphasis Filter Coefficient for 2 FS register */
N#define DMIC_CHANNEL_PREAC2FSCOEF_COMP_MASK      (0x3U)
N#define DMIC_CHANNEL_PREAC2FSCOEF_COMP_SHIFT     (0U)
N#define DMIC_CHANNEL_PREAC2FSCOEF_COMP(x)        (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_PREAC2FSCOEF_COMP_SHIFT)) & DMIC_CHANNEL_PREAC2FSCOEF_COMP_MASK)
N
N/* The count of DMIC_CHANNEL_PREAC2FSCOEF */
N#define DMIC_CHANNEL_PREAC2FSCOEF_COUNT          (2U)
N
N/*! @name CHANNEL_PREAC4FSCOEF - Pre-Emphasis Filter Coefficient for 4 FS register */
N#define DMIC_CHANNEL_PREAC4FSCOEF_COMP_MASK      (0x3U)
N#define DMIC_CHANNEL_PREAC4FSCOEF_COMP_SHIFT     (0U)
N#define DMIC_CHANNEL_PREAC4FSCOEF_COMP(x)        (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_PREAC4FSCOEF_COMP_SHIFT)) & DMIC_CHANNEL_PREAC4FSCOEF_COMP_MASK)
N
N/* The count of DMIC_CHANNEL_PREAC4FSCOEF */
N#define DMIC_CHANNEL_PREAC4FSCOEF_COUNT          (2U)
N
N/*! @name CHANNEL_GAINSHIFT - Decimator Gain Shift register */
N#define DMIC_CHANNEL_GAINSHIFT_GAIN_MASK         (0x3FU)
N#define DMIC_CHANNEL_GAINSHIFT_GAIN_SHIFT        (0U)
N#define DMIC_CHANNEL_GAINSHIFT_GAIN(x)           (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_GAINSHIFT_GAIN_SHIFT)) & DMIC_CHANNEL_GAINSHIFT_GAIN_MASK)
N
N/* The count of DMIC_CHANNEL_GAINSHIFT */
N#define DMIC_CHANNEL_GAINSHIFT_COUNT             (2U)
N
N/*! @name CHANNEL_FIFO_CTRL - FIFO Control register 0 */
N#define DMIC_CHANNEL_FIFO_CTRL_ENABLE_MASK       (0x1U)
N#define DMIC_CHANNEL_FIFO_CTRL_ENABLE_SHIFT      (0U)
N#define DMIC_CHANNEL_FIFO_CTRL_ENABLE(x)         (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_CTRL_ENABLE_SHIFT)) & DMIC_CHANNEL_FIFO_CTRL_ENABLE_MASK)
N#define DMIC_CHANNEL_FIFO_CTRL_RESETN_MASK       (0x2U)
N#define DMIC_CHANNEL_FIFO_CTRL_RESETN_SHIFT      (1U)
N#define DMIC_CHANNEL_FIFO_CTRL_RESETN(x)         (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_CTRL_RESETN_SHIFT)) & DMIC_CHANNEL_FIFO_CTRL_RESETN_MASK)
N#define DMIC_CHANNEL_FIFO_CTRL_INTEN_MASK        (0x4U)
N#define DMIC_CHANNEL_FIFO_CTRL_INTEN_SHIFT       (2U)
N#define DMIC_CHANNEL_FIFO_CTRL_INTEN(x)          (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_CTRL_INTEN_SHIFT)) & DMIC_CHANNEL_FIFO_CTRL_INTEN_MASK)
N#define DMIC_CHANNEL_FIFO_CTRL_DMAEN_MASK        (0x8U)
N#define DMIC_CHANNEL_FIFO_CTRL_DMAEN_SHIFT       (3U)
N#define DMIC_CHANNEL_FIFO_CTRL_DMAEN(x)          (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_CTRL_DMAEN_SHIFT)) & DMIC_CHANNEL_FIFO_CTRL_DMAEN_MASK)
N#define DMIC_CHANNEL_FIFO_CTRL_TRIGLVL_MASK      (0x1F0000U)
N#define DMIC_CHANNEL_FIFO_CTRL_TRIGLVL_SHIFT     (16U)
N#define DMIC_CHANNEL_FIFO_CTRL_TRIGLVL(x)        (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_CTRL_TRIGLVL_SHIFT)) & DMIC_CHANNEL_FIFO_CTRL_TRIGLVL_MASK)
N
N/* The count of DMIC_CHANNEL_FIFO_CTRL */
N#define DMIC_CHANNEL_FIFO_CTRL_COUNT             (2U)
N
N/*! @name CHANNEL_FIFO_STATUS - FIFO Status register 0 */
N#define DMIC_CHANNEL_FIFO_STATUS_INT_MASK        (0x1U)
N#define DMIC_CHANNEL_FIFO_STATUS_INT_SHIFT       (0U)
N#define DMIC_CHANNEL_FIFO_STATUS_INT(x)          (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_STATUS_INT_SHIFT)) & DMIC_CHANNEL_FIFO_STATUS_INT_MASK)
N#define DMIC_CHANNEL_FIFO_STATUS_OVERRUN_MASK    (0x2U)
N#define DMIC_CHANNEL_FIFO_STATUS_OVERRUN_SHIFT   (1U)
N#define DMIC_CHANNEL_FIFO_STATUS_OVERRUN(x)      (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_STATUS_OVERRUN_SHIFT)) & DMIC_CHANNEL_FIFO_STATUS_OVERRUN_MASK)
N#define DMIC_CHANNEL_FIFO_STATUS_UNDERRUN_MASK   (0x4U)
N#define DMIC_CHANNEL_FIFO_STATUS_UNDERRUN_SHIFT  (2U)
N#define DMIC_CHANNEL_FIFO_STATUS_UNDERRUN(x)     (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_STATUS_UNDERRUN_SHIFT)) & DMIC_CHANNEL_FIFO_STATUS_UNDERRUN_MASK)
N
N/* The count of DMIC_CHANNEL_FIFO_STATUS */
N#define DMIC_CHANNEL_FIFO_STATUS_COUNT           (2U)
N
N/*! @name CHANNEL_FIFO_DATA - FIFO Data Register 0 */
N#define DMIC_CHANNEL_FIFO_DATA_DATA_MASK         (0xFFFFFFU)
N#define DMIC_CHANNEL_FIFO_DATA_DATA_SHIFT        (0U)
N#define DMIC_CHANNEL_FIFO_DATA_DATA(x)           (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_FIFO_DATA_DATA_SHIFT)) & DMIC_CHANNEL_FIFO_DATA_DATA_MASK)
N
N/* The count of DMIC_CHANNEL_FIFO_DATA */
N#define DMIC_CHANNEL_FIFO_DATA_COUNT             (2U)
N
N/*! @name CHANNEL_PHY_CTRL - PDM Source Configuration register 0 */
N#define DMIC_CHANNEL_PHY_CTRL_PHY_FALL_MASK      (0x1U)
N#define DMIC_CHANNEL_PHY_CTRL_PHY_FALL_SHIFT     (0U)
N#define DMIC_CHANNEL_PHY_CTRL_PHY_FALL(x)        (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_PHY_CTRL_PHY_FALL_SHIFT)) & DMIC_CHANNEL_PHY_CTRL_PHY_FALL_MASK)
N#define DMIC_CHANNEL_PHY_CTRL_PHY_HALF_MASK      (0x2U)
N#define DMIC_CHANNEL_PHY_CTRL_PHY_HALF_SHIFT     (1U)
N#define DMIC_CHANNEL_PHY_CTRL_PHY_HALF(x)        (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_PHY_CTRL_PHY_HALF_SHIFT)) & DMIC_CHANNEL_PHY_CTRL_PHY_HALF_MASK)
N
N/* The count of DMIC_CHANNEL_PHY_CTRL */
N#define DMIC_CHANNEL_PHY_CTRL_COUNT              (2U)
N
N/*! @name CHANNEL_DC_CTRL - DC Control register 0 */
N#define DMIC_CHANNEL_DC_CTRL_DCPOLE_MASK         (0x3U)
N#define DMIC_CHANNEL_DC_CTRL_DCPOLE_SHIFT        (0U)
N#define DMIC_CHANNEL_DC_CTRL_DCPOLE(x)           (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_DC_CTRL_DCPOLE_SHIFT)) & DMIC_CHANNEL_DC_CTRL_DCPOLE_MASK)
N#define DMIC_CHANNEL_DC_CTRL_DCGAIN_MASK         (0xF0U)
N#define DMIC_CHANNEL_DC_CTRL_DCGAIN_SHIFT        (4U)
N#define DMIC_CHANNEL_DC_CTRL_DCGAIN(x)           (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_DC_CTRL_DCGAIN_SHIFT)) & DMIC_CHANNEL_DC_CTRL_DCGAIN_MASK)
N#define DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT_MASK (0x100U)
N#define DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT_SHIFT (8U)
N#define DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT(x)  (((uint32_t)(((uint32_t)(x)) << DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT_SHIFT)) & DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT_MASK)
N
N/* The count of DMIC_CHANNEL_DC_CTRL */
N#define DMIC_CHANNEL_DC_CTRL_COUNT               (2U)
N
N/*! @name CHANEN - Channel Enable register */
N#define DMIC_CHANEN_EN_CH0_MASK                  (0x1U)
N#define DMIC_CHANEN_EN_CH0_SHIFT                 (0U)
N#define DMIC_CHANEN_EN_CH0(x)                    (((uint32_t)(((uint32_t)(x)) << DMIC_CHANEN_EN_CH0_SHIFT)) & DMIC_CHANEN_EN_CH0_MASK)
N#define DMIC_CHANEN_EN_CH1_MASK                  (0x2U)
N#define DMIC_CHANEN_EN_CH1_SHIFT                 (1U)
N#define DMIC_CHANEN_EN_CH1(x)                    (((uint32_t)(((uint32_t)(x)) << DMIC_CHANEN_EN_CH1_SHIFT)) & DMIC_CHANEN_EN_CH1_MASK)
N
N/*! @name IOCFG - I/O Configuration register */
N#define DMIC_IOCFG_CLK_BYPASS0_MASK              (0x1U)
N#define DMIC_IOCFG_CLK_BYPASS0_SHIFT             (0U)
N#define DMIC_IOCFG_CLK_BYPASS0(x)                (((uint32_t)(((uint32_t)(x)) << DMIC_IOCFG_CLK_BYPASS0_SHIFT)) & DMIC_IOCFG_CLK_BYPASS0_MASK)
N#define DMIC_IOCFG_CLK_BYPASS1_MASK              (0x2U)
N#define DMIC_IOCFG_CLK_BYPASS1_SHIFT             (1U)
N#define DMIC_IOCFG_CLK_BYPASS1(x)                (((uint32_t)(((uint32_t)(x)) << DMIC_IOCFG_CLK_BYPASS1_SHIFT)) & DMIC_IOCFG_CLK_BYPASS1_MASK)
N#define DMIC_IOCFG_STEREO_DATA0_MASK             (0x4U)
N#define DMIC_IOCFG_STEREO_DATA0_SHIFT            (2U)
N#define DMIC_IOCFG_STEREO_DATA0(x)               (((uint32_t)(((uint32_t)(x)) << DMIC_IOCFG_STEREO_DATA0_SHIFT)) & DMIC_IOCFG_STEREO_DATA0_MASK)
N
N/*! @name USE2FS - Use 2FS register */
N#define DMIC_USE2FS_USE2FS_MASK                  (0x1U)
N#define DMIC_USE2FS_USE2FS_SHIFT                 (0U)
N#define DMIC_USE2FS_USE2FS(x)                    (((uint32_t)(((uint32_t)(x)) << DMIC_USE2FS_USE2FS_SHIFT)) & DMIC_USE2FS_USE2FS_MASK)
N
N/*! @name HWVADGAIN - HWVAD input gain register */
N#define DMIC_HWVADGAIN_INPUTGAIN_MASK            (0xFU)
N#define DMIC_HWVADGAIN_INPUTGAIN_SHIFT           (0U)
N#define DMIC_HWVADGAIN_INPUTGAIN(x)              (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADGAIN_INPUTGAIN_SHIFT)) & DMIC_HWVADGAIN_INPUTGAIN_MASK)
N
N/*! @name HWVADHPFS - HWVAD filter control register */
N#define DMIC_HWVADHPFS_HPFS_MASK                 (0x3U)
N#define DMIC_HWVADHPFS_HPFS_SHIFT                (0U)
N#define DMIC_HWVADHPFS_HPFS(x)                   (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADHPFS_HPFS_SHIFT)) & DMIC_HWVADHPFS_HPFS_MASK)
N
N/*! @name HWVADST10 - HWVAD control register */
N#define DMIC_HWVADST10_ST10_MASK                 (0x1U)
N#define DMIC_HWVADST10_ST10_SHIFT                (0U)
N#define DMIC_HWVADST10_ST10(x)                   (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADST10_ST10_SHIFT)) & DMIC_HWVADST10_ST10_MASK)
N
N/*! @name HWVADRSTT - HWVAD filter reset register */
N#define DMIC_HWVADRSTT_RSTT_MASK                 (0x1U)
N#define DMIC_HWVADRSTT_RSTT_SHIFT                (0U)
N#define DMIC_HWVADRSTT_RSTT(x)                   (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADRSTT_RSTT_SHIFT)) & DMIC_HWVADRSTT_RSTT_MASK)
N
N/*! @name HWVADTHGN - HWVAD noise estimator gain register */
N#define DMIC_HWVADTHGN_THGN_MASK                 (0xFU)
N#define DMIC_HWVADTHGN_THGN_SHIFT                (0U)
N#define DMIC_HWVADTHGN_THGN(x)                   (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADTHGN_THGN_SHIFT)) & DMIC_HWVADTHGN_THGN_MASK)
N
N/*! @name HWVADTHGS - HWVAD signal estimator gain register */
N#define DMIC_HWVADTHGS_THGS_MASK                 (0xFU)
N#define DMIC_HWVADTHGS_THGS_SHIFT                (0U)
N#define DMIC_HWVADTHGS_THGS(x)                   (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADTHGS_THGS_SHIFT)) & DMIC_HWVADTHGS_THGS_MASK)
N
N/*! @name HWVADLOWZ - HWVAD noise envelope estimator register */
N#define DMIC_HWVADLOWZ_LOWZ_MASK                 (0xFFFFU)
N#define DMIC_HWVADLOWZ_LOWZ_SHIFT                (0U)
N#define DMIC_HWVADLOWZ_LOWZ(x)                   (((uint32_t)(((uint32_t)(x)) << DMIC_HWVADLOWZ_LOWZ_SHIFT)) & DMIC_HWVADLOWZ_LOWZ_MASK)
N
N/*! @name ID - Module Identification register */
N#define DMIC_ID_ID_MASK                          (0xFFFFFFFFU)
N#define DMIC_ID_ID_SHIFT                         (0U)
N#define DMIC_ID_ID(x)                            (((uint32_t)(((uint32_t)(x)) << DMIC_ID_ID_SHIFT)) & DMIC_ID_ID_MASK)
N
N
N/*!
N * @}
N */ /* end of group DMIC_Register_Masks */
N
N
N/* DMIC - Peripheral instance base addresses */
N/** Peripheral DMIC0 base address */
N#define DMIC0_BASE                               (0x40090000u)
N/** Peripheral DMIC0 base pointer */
N#define DMIC0                                    ((DMIC_Type *)DMIC0_BASE)
N/** Array initializer of DMIC peripheral base addresses */
N#define DMIC_BASE_ADDRS                          { DMIC0_BASE }
N/** Array initializer of DMIC peripheral base pointers */
N#define DMIC_BASE_PTRS                           { DMIC0 }
N/** Interrupt vectors for the DMIC peripheral type */
N#define DMIC_IRQS                                { DMIC0_IRQn }
N#define DMIC_HWVAD_IRQS                          { HWVAD0_IRQn }
N
N/*!
N * @}
N */ /* end of group DMIC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- EEPROM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup EEPROM_Peripheral_Access_Layer EEPROM Peripheral Access Layer
N * @{
N */
N
N/** EEPROM - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CMD;                               /**< EEPROM command register, offset: 0x0 */
X  volatile uint32_t CMD;                                
N       uint8_t RESERVED_0[4];
N  __IO uint32_t RWSTATE;                           /**< EEPROM read wait state register, offset: 0x8 */
X  volatile uint32_t RWSTATE;                            
N  __IO uint32_t AUTOPROG;                          /**< EEPROM auto programming register, offset: 0xC */
X  volatile uint32_t AUTOPROG;                           
N  __IO uint32_t WSTATE;                            /**< EEPROM wait state register, offset: 0x10 */
X  volatile uint32_t WSTATE;                             
N  __IO uint32_t CLKDIV;                            /**< EEPROM clock divider register, offset: 0x14 */
X  volatile uint32_t CLKDIV;                             
N  __IO uint32_t PWRDWN;                            /**< EEPROM power-down register, offset: 0x18 */
X  volatile uint32_t PWRDWN;                             
N       uint8_t RESERVED_1[4028];
N  __O  uint32_t INTENCLR;                          /**< EEPROM interrupt enable clear, offset: 0xFD8 */
X  volatile  uint32_t INTENCLR;                           
N  __O  uint32_t INTENSET;                          /**< EEPROM interrupt enable set, offset: 0xFDC */
X  volatile  uint32_t INTENSET;                           
N  __I  uint32_t INTSTAT;                           /**< EEPROM interrupt status, offset: 0xFE0 */
X  volatile const  uint32_t INTSTAT;                            
N  __I  uint32_t INTEN;                             /**< EEPROM interrupt enable, offset: 0xFE4 */
X  volatile const  uint32_t INTEN;                              
N  __O  uint32_t INTSTATCLR;                        /**< EEPROM interrupt status clear, offset: 0xFE8 */
X  volatile  uint32_t INTSTATCLR;                         
N  __O  uint32_t INTSTATSET;                        /**< EEPROM interrupt status set, offset: 0xFEC */
X  volatile  uint32_t INTSTATSET;                         
N} EEPROM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- EEPROM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup EEPROM_Register_Masks EEPROM Register Masks
N * @{
N */
N
N/*! @name CMD - EEPROM command register */
N#define EEPROM_CMD_CMD_MASK                      (0x7U)
N#define EEPROM_CMD_CMD_SHIFT                     (0U)
N#define EEPROM_CMD_CMD(x)                        (((uint32_t)(((uint32_t)(x)) << EEPROM_CMD_CMD_SHIFT)) & EEPROM_CMD_CMD_MASK)
N
N/*! @name RWSTATE - EEPROM read wait state register */
N#define EEPROM_RWSTATE_RPHASE2_MASK              (0xFFU)
N#define EEPROM_RWSTATE_RPHASE2_SHIFT             (0U)
N#define EEPROM_RWSTATE_RPHASE2(x)                (((uint32_t)(((uint32_t)(x)) << EEPROM_RWSTATE_RPHASE2_SHIFT)) & EEPROM_RWSTATE_RPHASE2_MASK)
N#define EEPROM_RWSTATE_RPHASE1_MASK              (0xFF00U)
N#define EEPROM_RWSTATE_RPHASE1_SHIFT             (8U)
N#define EEPROM_RWSTATE_RPHASE1(x)                (((uint32_t)(((uint32_t)(x)) << EEPROM_RWSTATE_RPHASE1_SHIFT)) & EEPROM_RWSTATE_RPHASE1_MASK)
N
N/*! @name AUTOPROG - EEPROM auto programming register */
N#define EEPROM_AUTOPROG_AUTOPROG_MASK            (0x3U)
N#define EEPROM_AUTOPROG_AUTOPROG_SHIFT           (0U)
N#define EEPROM_AUTOPROG_AUTOPROG(x)              (((uint32_t)(((uint32_t)(x)) << EEPROM_AUTOPROG_AUTOPROG_SHIFT)) & EEPROM_AUTOPROG_AUTOPROG_MASK)
N
N/*! @name WSTATE - EEPROM wait state register */
N#define EEPROM_WSTATE_PHASE3_MASK                (0xFFU)
N#define EEPROM_WSTATE_PHASE3_SHIFT               (0U)
N#define EEPROM_WSTATE_PHASE3(x)                  (((uint32_t)(((uint32_t)(x)) << EEPROM_WSTATE_PHASE3_SHIFT)) & EEPROM_WSTATE_PHASE3_MASK)
N#define EEPROM_WSTATE_PHASE2_MASK                (0xFF00U)
N#define EEPROM_WSTATE_PHASE2_SHIFT               (8U)
N#define EEPROM_WSTATE_PHASE2(x)                  (((uint32_t)(((uint32_t)(x)) << EEPROM_WSTATE_PHASE2_SHIFT)) & EEPROM_WSTATE_PHASE2_MASK)
N#define EEPROM_WSTATE_PHASE1_MASK                (0xFF0000U)
N#define EEPROM_WSTATE_PHASE1_SHIFT               (16U)
N#define EEPROM_WSTATE_PHASE1(x)                  (((uint32_t)(((uint32_t)(x)) << EEPROM_WSTATE_PHASE1_SHIFT)) & EEPROM_WSTATE_PHASE1_MASK)
N#define EEPROM_WSTATE_LCK_PARWEP_MASK            (0x80000000U)
N#define EEPROM_WSTATE_LCK_PARWEP_SHIFT           (31U)
N#define EEPROM_WSTATE_LCK_PARWEP(x)              (((uint32_t)(((uint32_t)(x)) << EEPROM_WSTATE_LCK_PARWEP_SHIFT)) & EEPROM_WSTATE_LCK_PARWEP_MASK)
N
N/*! @name CLKDIV - EEPROM clock divider register */
N#define EEPROM_CLKDIV_CLKDIV_MASK                (0xFFFFU)
N#define EEPROM_CLKDIV_CLKDIV_SHIFT               (0U)
N#define EEPROM_CLKDIV_CLKDIV(x)                  (((uint32_t)(((uint32_t)(x)) << EEPROM_CLKDIV_CLKDIV_SHIFT)) & EEPROM_CLKDIV_CLKDIV_MASK)
N
N/*! @name PWRDWN - EEPROM power-down register */
N#define EEPROM_PWRDWN_PWRDWN_MASK                (0x1U)
N#define EEPROM_PWRDWN_PWRDWN_SHIFT               (0U)
N#define EEPROM_PWRDWN_PWRDWN(x)                  (((uint32_t)(((uint32_t)(x)) << EEPROM_PWRDWN_PWRDWN_SHIFT)) & EEPROM_PWRDWN_PWRDWN_MASK)
N
N/*! @name INTENCLR - EEPROM interrupt enable clear */
N#define EEPROM_INTENCLR_PROG_CLR_EN_MASK         (0x4U)
N#define EEPROM_INTENCLR_PROG_CLR_EN_SHIFT        (2U)
N#define EEPROM_INTENCLR_PROG_CLR_EN(x)           (((uint32_t)(((uint32_t)(x)) << EEPROM_INTENCLR_PROG_CLR_EN_SHIFT)) & EEPROM_INTENCLR_PROG_CLR_EN_MASK)
N
N/*! @name INTENSET - EEPROM interrupt enable set */
N#define EEPROM_INTENSET_PROG_SET_EN_MASK         (0x4U)
N#define EEPROM_INTENSET_PROG_SET_EN_SHIFT        (2U)
N#define EEPROM_INTENSET_PROG_SET_EN(x)           (((uint32_t)(((uint32_t)(x)) << EEPROM_INTENSET_PROG_SET_EN_SHIFT)) & EEPROM_INTENSET_PROG_SET_EN_MASK)
N
N/*! @name INTSTAT - EEPROM interrupt status */
N#define EEPROM_INTSTAT_END_OF_PROG_MASK          (0x4U)
N#define EEPROM_INTSTAT_END_OF_PROG_SHIFT         (2U)
N#define EEPROM_INTSTAT_END_OF_PROG(x)            (((uint32_t)(((uint32_t)(x)) << EEPROM_INTSTAT_END_OF_PROG_SHIFT)) & EEPROM_INTSTAT_END_OF_PROG_MASK)
N
N/*! @name INTEN - EEPROM interrupt enable */
N#define EEPROM_INTEN_EE_PROG_DONE_MASK           (0x4U)
N#define EEPROM_INTEN_EE_PROG_DONE_SHIFT          (2U)
N#define EEPROM_INTEN_EE_PROG_DONE(x)             (((uint32_t)(((uint32_t)(x)) << EEPROM_INTEN_EE_PROG_DONE_SHIFT)) & EEPROM_INTEN_EE_PROG_DONE_MASK)
N
N/*! @name INTSTATCLR - EEPROM interrupt status clear */
N#define EEPROM_INTSTATCLR_PROG_CLR_ST_MASK       (0x4U)
N#define EEPROM_INTSTATCLR_PROG_CLR_ST_SHIFT      (2U)
N#define EEPROM_INTSTATCLR_PROG_CLR_ST(x)         (((uint32_t)(((uint32_t)(x)) << EEPROM_INTSTATCLR_PROG_CLR_ST_SHIFT)) & EEPROM_INTSTATCLR_PROG_CLR_ST_MASK)
N
N/*! @name INTSTATSET - EEPROM interrupt status set */
N#define EEPROM_INTSTATSET_PROG_SET_ST_MASK       (0x4U)
N#define EEPROM_INTSTATSET_PROG_SET_ST_SHIFT      (2U)
N#define EEPROM_INTSTATSET_PROG_SET_ST(x)         (((uint32_t)(((uint32_t)(x)) << EEPROM_INTSTATSET_PROG_SET_ST_SHIFT)) & EEPROM_INTSTATSET_PROG_SET_ST_MASK)
N
N
N/*!
N * @}
N */ /* end of group EEPROM_Register_Masks */
N
N
N/* EEPROM - Peripheral instance base addresses */
N/** Peripheral EEPROM base address */
N#define EEPROM_BASE                              (0x40014000u)
N/** Peripheral EEPROM base pointer */
N#define EEPROM                                   ((EEPROM_Type *)EEPROM_BASE)
N/** Array initializer of EEPROM peripheral base addresses */
N#define EEPROM_BASE_ADDRS                        { EEPROM_BASE }
N/** Array initializer of EEPROM peripheral base pointers */
N#define EEPROM_BASE_PTRS                         { EEPROM }
N/** Interrupt vectors for the EEPROM peripheral type */
N#define EEPROM_IRQS                              { EEPROM_IRQn }
N
N/*!
N * @}
N */ /* end of group EEPROM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- EMC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup EMC_Peripheral_Access_Layer EMC Peripheral Access Layer
N * @{
N */
N
N/** EMC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CONTROL;                           /**< Controls operation of the memory controller, offset: 0x0 */
X  volatile uint32_t CONTROL;                            
N  __I  uint32_t STATUS;                            /**< Provides EMC status information, offset: 0x4 */
X  volatile const  uint32_t STATUS;                             
N  __IO uint32_t CONFIG;                            /**< Configures operation of the memory controller, offset: 0x8 */
X  volatile uint32_t CONFIG;                             
N       uint8_t RESERVED_0[20];
N  __IO uint32_t DYNAMICCONTROL;                    /**< Controls dynamic memory operation, offset: 0x20 */
X  volatile uint32_t DYNAMICCONTROL;                     
N  __IO uint32_t DYNAMICREFRESH;                    /**< Configures dynamic memory refresh, offset: 0x24 */
X  volatile uint32_t DYNAMICREFRESH;                     
N  __IO uint32_t DYNAMICREADCONFIG;                 /**< Configures dynamic memory read strategy, offset: 0x28 */
X  volatile uint32_t DYNAMICREADCONFIG;                  
N       uint8_t RESERVED_1[4];
N  __IO uint32_t DYNAMICRP;                         /**< Precharge command period, offset: 0x30 */
X  volatile uint32_t DYNAMICRP;                          
N  __IO uint32_t DYNAMICRAS;                        /**< Active to precharge command period, offset: 0x34 */
X  volatile uint32_t DYNAMICRAS;                         
N  __IO uint32_t DYNAMICSREX;                       /**< Self-refresh exit time, offset: 0x38 */
X  volatile uint32_t DYNAMICSREX;                        
N  __IO uint32_t DYNAMICAPR;                        /**< Last-data-out to active command time, offset: 0x3C */
X  volatile uint32_t DYNAMICAPR;                         
N  __IO uint32_t DYNAMICDAL;                        /**< Data-in to active command time, offset: 0x40 */
X  volatile uint32_t DYNAMICDAL;                         
N  __IO uint32_t DYNAMICWR;                         /**< Write recovery time, offset: 0x44 */
X  volatile uint32_t DYNAMICWR;                          
N  __IO uint32_t DYNAMICRC;                         /**< Selects the active to active command period, offset: 0x48 */
X  volatile uint32_t DYNAMICRC;                          
N  __IO uint32_t DYNAMICRFC;                        /**< Selects the auto-refresh period, offset: 0x4C */
X  volatile uint32_t DYNAMICRFC;                         
N  __IO uint32_t DYNAMICXSR;                        /**< Time for exit self-refresh to active command, offset: 0x50 */
X  volatile uint32_t DYNAMICXSR;                         
N  __IO uint32_t DYNAMICRRD;                        /**< Latency for active bank A to active bank B, offset: 0x54 */
X  volatile uint32_t DYNAMICRRD;                         
N  __IO uint32_t DYNAMICMRD;                        /**< Time for load mode register to active command, offset: 0x58 */
X  volatile uint32_t DYNAMICMRD;                         
N       uint8_t RESERVED_2[36];
N  __IO uint32_t STATICEXTENDEDWAIT;                /**< Time for long static memory read and write transfers, offset: 0x80 */
X  volatile uint32_t STATICEXTENDEDWAIT;                 
N       uint8_t RESERVED_3[124];
N  struct {                                         /* offset: 0x100, array step: 0x20 */
N    __IO uint32_t DYNAMICCONFIG;                     /**< Configuration information for EMC_DYCSx, array offset: 0x100, array step: 0x20 */
X    volatile uint32_t DYNAMICCONFIG;                      
N    __IO uint32_t DYNAMICRASCAS;                     /**< RAS and CAS latencies for EMC_DYCSx, array offset: 0x104, array step: 0x20 */
X    volatile uint32_t DYNAMICRASCAS;                      
N         uint8_t RESERVED_0[24];
N  } DYNAMIC[4];
N       uint8_t RESERVED_4[128];
N  struct {                                         /* offset: 0x200, array step: 0x20 */
N    __IO uint32_t STATICCONFIG;                      /**< Configuration for EMC_CSx, array offset: 0x200, array step: 0x20 */
X    volatile uint32_t STATICCONFIG;                       
N    __IO uint32_t STATICWAITWEN;                     /**< Delay from EMC_CSx to write enable, array offset: 0x204, array step: 0x20 */
X    volatile uint32_t STATICWAITWEN;                      
N    __IO uint32_t STATICWAITOEN;                     /**< Delay from EMC_CSx or address change, whichever is later, to output enable, array offset: 0x208, array step: 0x20 */
X    volatile uint32_t STATICWAITOEN;                      
N    __IO uint32_t STATICWAITRD;                      /**< Delay from EMC_CSx to a read access, array offset: 0x20C, array step: 0x20 */
X    volatile uint32_t STATICWAITRD;                       
N    __IO uint32_t STATICWAITPAGE;                    /**< Delay for asynchronous page mode sequential accesses for EMC_CSx, array offset: 0x210, array step: 0x20 */
X    volatile uint32_t STATICWAITPAGE;                     
N    __IO uint32_t STATICWAITWR;                      /**< Delay from EMC_CSx to a write access, array offset: 0x214, array step: 0x20 */
X    volatile uint32_t STATICWAITWR;                       
N    __IO uint32_t STATICWAITTURN;                    /**< Number of bus turnaround cycles EMC_CSx, array offset: 0x218, array step: 0x20 */
X    volatile uint32_t STATICWAITTURN;                     
N         uint8_t RESERVED_0[4];
N  } STATIC[4];
N} EMC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- EMC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup EMC_Register_Masks EMC Register Masks
N * @{
N */
N
N/*! @name CONTROL - Controls operation of the memory controller */
N#define EMC_CONTROL_E_MASK                       (0x1U)
N#define EMC_CONTROL_E_SHIFT                      (0U)
N#define EMC_CONTROL_E(x)                         (((uint32_t)(((uint32_t)(x)) << EMC_CONTROL_E_SHIFT)) & EMC_CONTROL_E_MASK)
N#define EMC_CONTROL_M_MASK                       (0x2U)
N#define EMC_CONTROL_M_SHIFT                      (1U)
N#define EMC_CONTROL_M(x)                         (((uint32_t)(((uint32_t)(x)) << EMC_CONTROL_M_SHIFT)) & EMC_CONTROL_M_MASK)
N#define EMC_CONTROL_L_MASK                       (0x4U)
N#define EMC_CONTROL_L_SHIFT                      (2U)
N#define EMC_CONTROL_L(x)                         (((uint32_t)(((uint32_t)(x)) << EMC_CONTROL_L_SHIFT)) & EMC_CONTROL_L_MASK)
N
N/*! @name STATUS - Provides EMC status information */
N#define EMC_STATUS_B_MASK                        (0x1U)
N#define EMC_STATUS_B_SHIFT                       (0U)
N#define EMC_STATUS_B(x)                          (((uint32_t)(((uint32_t)(x)) << EMC_STATUS_B_SHIFT)) & EMC_STATUS_B_MASK)
N#define EMC_STATUS_S_MASK                        (0x2U)
N#define EMC_STATUS_S_SHIFT                       (1U)
N#define EMC_STATUS_S(x)                          (((uint32_t)(((uint32_t)(x)) << EMC_STATUS_S_SHIFT)) & EMC_STATUS_S_MASK)
N#define EMC_STATUS_SA_MASK                       (0x4U)
N#define EMC_STATUS_SA_SHIFT                      (2U)
N#define EMC_STATUS_SA(x)                         (((uint32_t)(((uint32_t)(x)) << EMC_STATUS_SA_SHIFT)) & EMC_STATUS_SA_MASK)
N
N/*! @name CONFIG - Configures operation of the memory controller */
N#define EMC_CONFIG_EM_MASK                       (0x1U)
N#define EMC_CONFIG_EM_SHIFT                      (0U)
N#define EMC_CONFIG_EM(x)                         (((uint32_t)(((uint32_t)(x)) << EMC_CONFIG_EM_SHIFT)) & EMC_CONFIG_EM_MASK)
N#define EMC_CONFIG_CLKR_MASK                     (0x100U)
N#define EMC_CONFIG_CLKR_SHIFT                    (8U)
N#define EMC_CONFIG_CLKR(x)                       (((uint32_t)(((uint32_t)(x)) << EMC_CONFIG_CLKR_SHIFT)) & EMC_CONFIG_CLKR_MASK)
N
N/*! @name DYNAMICCONTROL - Controls dynamic memory operation */
N#define EMC_DYNAMICCONTROL_CE_MASK               (0x1U)
N#define EMC_DYNAMICCONTROL_CE_SHIFT              (0U)
N#define EMC_DYNAMICCONTROL_CE(x)                 (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICCONTROL_CE_SHIFT)) & EMC_DYNAMICCONTROL_CE_MASK)
N#define EMC_DYNAMICCONTROL_CS_MASK               (0x2U)
N#define EMC_DYNAMICCONTROL_CS_SHIFT              (1U)
N#define EMC_DYNAMICCONTROL_CS(x)                 (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICCONTROL_CS_SHIFT)) & EMC_DYNAMICCONTROL_CS_MASK)
N#define EMC_DYNAMICCONTROL_SR_MASK               (0x4U)
N#define EMC_DYNAMICCONTROL_SR_SHIFT              (2U)
N#define EMC_DYNAMICCONTROL_SR(x)                 (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICCONTROL_SR_SHIFT)) & EMC_DYNAMICCONTROL_SR_MASK)
N#define EMC_DYNAMICCONTROL_MMC_MASK              (0x20U)
N#define EMC_DYNAMICCONTROL_MMC_SHIFT             (5U)
N#define EMC_DYNAMICCONTROL_MMC(x)                (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICCONTROL_MMC_SHIFT)) & EMC_DYNAMICCONTROL_MMC_MASK)
N#define EMC_DYNAMICCONTROL_I_MASK                (0x180U)
N#define EMC_DYNAMICCONTROL_I_SHIFT               (7U)
N#define EMC_DYNAMICCONTROL_I(x)                  (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICCONTROL_I_SHIFT)) & EMC_DYNAMICCONTROL_I_MASK)
N
N/*! @name DYNAMICREFRESH - Configures dynamic memory refresh */
N#define EMC_DYNAMICREFRESH_REFRESH_MASK          (0x7FFU)
N#define EMC_DYNAMICREFRESH_REFRESH_SHIFT         (0U)
N#define EMC_DYNAMICREFRESH_REFRESH(x)            (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICREFRESH_REFRESH_SHIFT)) & EMC_DYNAMICREFRESH_REFRESH_MASK)
N
N/*! @name DYNAMICREADCONFIG - Configures dynamic memory read strategy */
N#define EMC_DYNAMICREADCONFIG_RD_MASK            (0x3U)
N#define EMC_DYNAMICREADCONFIG_RD_SHIFT           (0U)
N#define EMC_DYNAMICREADCONFIG_RD(x)              (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICREADCONFIG_RD_SHIFT)) & EMC_DYNAMICREADCONFIG_RD_MASK)
N
N/*! @name DYNAMICRP - Precharge command period */
N#define EMC_DYNAMICRP_TRP_MASK                   (0xFU)
N#define EMC_DYNAMICRP_TRP_SHIFT                  (0U)
N#define EMC_DYNAMICRP_TRP(x)                     (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICRP_TRP_SHIFT)) & EMC_DYNAMICRP_TRP_MASK)
N
N/*! @name DYNAMICRAS - Active to precharge command period */
N#define EMC_DYNAMICRAS_TRAS_MASK                 (0xFU)
N#define EMC_DYNAMICRAS_TRAS_SHIFT                (0U)
N#define EMC_DYNAMICRAS_TRAS(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICRAS_TRAS_SHIFT)) & EMC_DYNAMICRAS_TRAS_MASK)
N
N/*! @name DYNAMICSREX - Self-refresh exit time */
N#define EMC_DYNAMICSREX_TSREX_MASK               (0xFU)
N#define EMC_DYNAMICSREX_TSREX_SHIFT              (0U)
N#define EMC_DYNAMICSREX_TSREX(x)                 (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICSREX_TSREX_SHIFT)) & EMC_DYNAMICSREX_TSREX_MASK)
N
N/*! @name DYNAMICAPR - Last-data-out to active command time */
N#define EMC_DYNAMICAPR_TAPR_MASK                 (0xFU)
N#define EMC_DYNAMICAPR_TAPR_SHIFT                (0U)
N#define EMC_DYNAMICAPR_TAPR(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICAPR_TAPR_SHIFT)) & EMC_DYNAMICAPR_TAPR_MASK)
N
N/*! @name DYNAMICDAL - Data-in to active command time */
N#define EMC_DYNAMICDAL_TDAL_MASK                 (0xFU)
N#define EMC_DYNAMICDAL_TDAL_SHIFT                (0U)
N#define EMC_DYNAMICDAL_TDAL(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICDAL_TDAL_SHIFT)) & EMC_DYNAMICDAL_TDAL_MASK)
N
N/*! @name DYNAMICWR - Write recovery time */
N#define EMC_DYNAMICWR_TWR_MASK                   (0xFU)
N#define EMC_DYNAMICWR_TWR_SHIFT                  (0U)
N#define EMC_DYNAMICWR_TWR(x)                     (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICWR_TWR_SHIFT)) & EMC_DYNAMICWR_TWR_MASK)
N
N/*! @name DYNAMICRC - Selects the active to active command period */
N#define EMC_DYNAMICRC_TRC_MASK                   (0x1FU)
N#define EMC_DYNAMICRC_TRC_SHIFT                  (0U)
N#define EMC_DYNAMICRC_TRC(x)                     (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICRC_TRC_SHIFT)) & EMC_DYNAMICRC_TRC_MASK)
N
N/*! @name DYNAMICRFC - Selects the auto-refresh period */
N#define EMC_DYNAMICRFC_TRFC_MASK                 (0x1FU)
N#define EMC_DYNAMICRFC_TRFC_SHIFT                (0U)
N#define EMC_DYNAMICRFC_TRFC(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICRFC_TRFC_SHIFT)) & EMC_DYNAMICRFC_TRFC_MASK)
N
N/*! @name DYNAMICXSR - Time for exit self-refresh to active command */
N#define EMC_DYNAMICXSR_TXSR_MASK                 (0x1FU)
N#define EMC_DYNAMICXSR_TXSR_SHIFT                (0U)
N#define EMC_DYNAMICXSR_TXSR(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICXSR_TXSR_SHIFT)) & EMC_DYNAMICXSR_TXSR_MASK)
N
N/*! @name DYNAMICRRD - Latency for active bank A to active bank B */
N#define EMC_DYNAMICRRD_TRRD_MASK                 (0xFU)
N#define EMC_DYNAMICRRD_TRRD_SHIFT                (0U)
N#define EMC_DYNAMICRRD_TRRD(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICRRD_TRRD_SHIFT)) & EMC_DYNAMICRRD_TRRD_MASK)
N
N/*! @name DYNAMICMRD - Time for load mode register to active command */
N#define EMC_DYNAMICMRD_TMRD_MASK                 (0xFU)
N#define EMC_DYNAMICMRD_TMRD_SHIFT                (0U)
N#define EMC_DYNAMICMRD_TMRD(x)                   (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMICMRD_TMRD_SHIFT)) & EMC_DYNAMICMRD_TMRD_MASK)
N
N/*! @name STATICEXTENDEDWAIT - Time for long static memory read and write transfers */
N#define EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_MASK (0x3FFU)
N#define EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_SHIFT (0U)
N#define EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT(x)   (((uint32_t)(((uint32_t)(x)) << EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_SHIFT)) & EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_MASK)
N
N/*! @name DYNAMIC_DYNAMICCONFIG - Configuration information for EMC_DYCSx */
N#define EMC_DYNAMIC_DYNAMICCONFIG_MD_MASK        (0x18U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_MD_SHIFT       (3U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_MD(x)          (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICCONFIG_MD_SHIFT)) & EMC_DYNAMIC_DYNAMICCONFIG_MD_MASK)
N#define EMC_DYNAMIC_DYNAMICCONFIG_AM0_MASK       (0x1F80U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_AM0_SHIFT      (7U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_AM0(x)         (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICCONFIG_AM0_SHIFT)) & EMC_DYNAMIC_DYNAMICCONFIG_AM0_MASK)
N#define EMC_DYNAMIC_DYNAMICCONFIG_AM1_MASK       (0x4000U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_AM1_SHIFT      (14U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_AM1(x)         (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICCONFIG_AM1_SHIFT)) & EMC_DYNAMIC_DYNAMICCONFIG_AM1_MASK)
N#define EMC_DYNAMIC_DYNAMICCONFIG_B_MASK         (0x80000U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_B_SHIFT        (19U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_B(x)           (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICCONFIG_B_SHIFT)) & EMC_DYNAMIC_DYNAMICCONFIG_B_MASK)
N#define EMC_DYNAMIC_DYNAMICCONFIG_P_MASK         (0x100000U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_P_SHIFT        (20U)
N#define EMC_DYNAMIC_DYNAMICCONFIG_P(x)           (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICCONFIG_P_SHIFT)) & EMC_DYNAMIC_DYNAMICCONFIG_P_MASK)
N
N/* The count of EMC_DYNAMIC_DYNAMICCONFIG */
N#define EMC_DYNAMIC_DYNAMICCONFIG_COUNT          (4U)
N
N/*! @name DYNAMIC_DYNAMICRASCAS - RAS and CAS latencies for EMC_DYCSx */
N#define EMC_DYNAMIC_DYNAMICRASCAS_RAS_MASK       (0x3U)
N#define EMC_DYNAMIC_DYNAMICRASCAS_RAS_SHIFT      (0U)
N#define EMC_DYNAMIC_DYNAMICRASCAS_RAS(x)         (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICRASCAS_RAS_SHIFT)) & EMC_DYNAMIC_DYNAMICRASCAS_RAS_MASK)
N#define EMC_DYNAMIC_DYNAMICRASCAS_CAS_MASK       (0x300U)
N#define EMC_DYNAMIC_DYNAMICRASCAS_CAS_SHIFT      (8U)
N#define EMC_DYNAMIC_DYNAMICRASCAS_CAS(x)         (((uint32_t)(((uint32_t)(x)) << EMC_DYNAMIC_DYNAMICRASCAS_CAS_SHIFT)) & EMC_DYNAMIC_DYNAMICRASCAS_CAS_MASK)
N
N/* The count of EMC_DYNAMIC_DYNAMICRASCAS */
N#define EMC_DYNAMIC_DYNAMICRASCAS_COUNT          (4U)
N
N/*! @name STATIC_STATICCONFIG - Configuration for EMC_CSx */
N#define EMC_STATIC_STATICCONFIG_MW_MASK          (0x3U)
N#define EMC_STATIC_STATICCONFIG_MW_SHIFT         (0U)
N#define EMC_STATIC_STATICCONFIG_MW(x)            (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_MW_SHIFT)) & EMC_STATIC_STATICCONFIG_MW_MASK)
N#define EMC_STATIC_STATICCONFIG_PM_MASK          (0x8U)
N#define EMC_STATIC_STATICCONFIG_PM_SHIFT         (3U)
N#define EMC_STATIC_STATICCONFIG_PM(x)            (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_PM_SHIFT)) & EMC_STATIC_STATICCONFIG_PM_MASK)
N#define EMC_STATIC_STATICCONFIG_PC_MASK          (0x40U)
N#define EMC_STATIC_STATICCONFIG_PC_SHIFT         (6U)
N#define EMC_STATIC_STATICCONFIG_PC(x)            (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_PC_SHIFT)) & EMC_STATIC_STATICCONFIG_PC_MASK)
N#define EMC_STATIC_STATICCONFIG_PB_MASK          (0x80U)
N#define EMC_STATIC_STATICCONFIG_PB_SHIFT         (7U)
N#define EMC_STATIC_STATICCONFIG_PB(x)            (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_PB_SHIFT)) & EMC_STATIC_STATICCONFIG_PB_MASK)
N#define EMC_STATIC_STATICCONFIG_EW_MASK          (0x100U)
N#define EMC_STATIC_STATICCONFIG_EW_SHIFT         (8U)
N#define EMC_STATIC_STATICCONFIG_EW(x)            (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_EW_SHIFT)) & EMC_STATIC_STATICCONFIG_EW_MASK)
N#define EMC_STATIC_STATICCONFIG_B_MASK           (0x80000U)
N#define EMC_STATIC_STATICCONFIG_B_SHIFT          (19U)
N#define EMC_STATIC_STATICCONFIG_B(x)             (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_B_SHIFT)) & EMC_STATIC_STATICCONFIG_B_MASK)
N#define EMC_STATIC_STATICCONFIG_P_MASK           (0x100000U)
N#define EMC_STATIC_STATICCONFIG_P_SHIFT          (20U)
N#define EMC_STATIC_STATICCONFIG_P(x)             (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICCONFIG_P_SHIFT)) & EMC_STATIC_STATICCONFIG_P_MASK)
N
N/* The count of EMC_STATIC_STATICCONFIG */
N#define EMC_STATIC_STATICCONFIG_COUNT            (4U)
N
N/*! @name STATIC_STATICWAITWEN - Delay from EMC_CSx to write enable */
N#define EMC_STATIC_STATICWAITWEN_WAITWEN_MASK    (0xFU)
N#define EMC_STATIC_STATICWAITWEN_WAITWEN_SHIFT   (0U)
N#define EMC_STATIC_STATICWAITWEN_WAITWEN(x)      (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICWAITWEN_WAITWEN_SHIFT)) & EMC_STATIC_STATICWAITWEN_WAITWEN_MASK)
N
N/* The count of EMC_STATIC_STATICWAITWEN */
N#define EMC_STATIC_STATICWAITWEN_COUNT           (4U)
N
N/*! @name STATIC_STATICWAITOEN - Delay from EMC_CSx or address change, whichever is later, to output enable */
N#define EMC_STATIC_STATICWAITOEN_WAITOEN_MASK    (0xFU)
N#define EMC_STATIC_STATICWAITOEN_WAITOEN_SHIFT   (0U)
N#define EMC_STATIC_STATICWAITOEN_WAITOEN(x)      (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICWAITOEN_WAITOEN_SHIFT)) & EMC_STATIC_STATICWAITOEN_WAITOEN_MASK)
N
N/* The count of EMC_STATIC_STATICWAITOEN */
N#define EMC_STATIC_STATICWAITOEN_COUNT           (4U)
N
N/*! @name STATIC_STATICWAITRD - Delay from EMC_CSx to a read access */
N#define EMC_STATIC_STATICWAITRD_WAITRD_MASK      (0x1FU)
N#define EMC_STATIC_STATICWAITRD_WAITRD_SHIFT     (0U)
N#define EMC_STATIC_STATICWAITRD_WAITRD(x)        (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICWAITRD_WAITRD_SHIFT)) & EMC_STATIC_STATICWAITRD_WAITRD_MASK)
N
N/* The count of EMC_STATIC_STATICWAITRD */
N#define EMC_STATIC_STATICWAITRD_COUNT            (4U)
N
N/*! @name STATIC_STATICWAITPAGE - Delay for asynchronous page mode sequential accesses for EMC_CSx */
N#define EMC_STATIC_STATICWAITPAGE_WAITPAGE_MASK  (0x1FU)
N#define EMC_STATIC_STATICWAITPAGE_WAITPAGE_SHIFT (0U)
N#define EMC_STATIC_STATICWAITPAGE_WAITPAGE(x)    (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICWAITPAGE_WAITPAGE_SHIFT)) & EMC_STATIC_STATICWAITPAGE_WAITPAGE_MASK)
N
N/* The count of EMC_STATIC_STATICWAITPAGE */
N#define EMC_STATIC_STATICWAITPAGE_COUNT          (4U)
N
N/*! @name STATIC_STATICWAITWR - Delay from EMC_CSx to a write access */
N#define EMC_STATIC_STATICWAITWR_WAITWR_MASK      (0x1FU)
N#define EMC_STATIC_STATICWAITWR_WAITWR_SHIFT     (0U)
N#define EMC_STATIC_STATICWAITWR_WAITWR(x)        (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICWAITWR_WAITWR_SHIFT)) & EMC_STATIC_STATICWAITWR_WAITWR_MASK)
N
N/* The count of EMC_STATIC_STATICWAITWR */
N#define EMC_STATIC_STATICWAITWR_COUNT            (4U)
N
N/*! @name STATIC_STATICWAITTURN - Number of bus turnaround cycles EMC_CSx */
N#define EMC_STATIC_STATICWAITTURN_WAITTURN_MASK  (0xFU)
N#define EMC_STATIC_STATICWAITTURN_WAITTURN_SHIFT (0U)
N#define EMC_STATIC_STATICWAITTURN_WAITTURN(x)    (((uint32_t)(((uint32_t)(x)) << EMC_STATIC_STATICWAITTURN_WAITTURN_SHIFT)) & EMC_STATIC_STATICWAITTURN_WAITTURN_MASK)
N
N/* The count of EMC_STATIC_STATICWAITTURN */
N#define EMC_STATIC_STATICWAITTURN_COUNT          (4U)
N
N
N/*!
N * @}
N */ /* end of group EMC_Register_Masks */
N
N
N/* EMC - Peripheral instance base addresses */
N/** Peripheral EMC base address */
N#define EMC_BASE                                 (0x40081000u)
N/** Peripheral EMC base pointer */
N#define EMC                                      ((EMC_Type *)EMC_BASE)
N/** Array initializer of EMC peripheral base addresses */
N#define EMC_BASE_ADDRS                           { EMC_BASE }
N/** Array initializer of EMC peripheral base pointers */
N#define EMC_BASE_PTRS                            { EMC }
N
N/*!
N * @}
N */ /* end of group EMC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- ENET Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ENET_Peripheral_Access_Layer ENET Peripheral Access Layer
N * @{
N */
N
N/** ENET - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t MAC_CONFIG;                        /**< MAC configuration register, offset: 0x0 */
X  volatile uint32_t MAC_CONFIG;                         
N  __IO uint32_t MAC_EXT_CONFIG;                    /**< , offset: 0x4 */
X  volatile uint32_t MAC_EXT_CONFIG;                     
N  __IO uint32_t MAC_FRAME_FILTER;                  /**< MAC frame filter register, offset: 0x8 */
X  volatile uint32_t MAC_FRAME_FILTER;                   
N  __IO uint32_t MAC_WD_TIMEROUT;                   /**< MAC watchdog Timeout register, offset: 0xC */
X  volatile uint32_t MAC_WD_TIMEROUT;                    
N       uint8_t RESERVED_0[64];
N  __IO uint32_t MAC_VLAN_TAG;                      /**< MAC vlan tag register, offset: 0x50 */
X  volatile uint32_t MAC_VLAN_TAG;                       
N       uint8_t RESERVED_1[28];
N  __IO uint32_t MAC_TX_FLOW_CTRL_Q[2];             /**< Transmit flow control register, array offset: 0x70, array step: 0x4 */
X  volatile uint32_t MAC_TX_FLOW_CTRL_Q[2];              
N       uint8_t RESERVED_2[24];
N  __IO uint32_t MAC_RX_FLOW_CTRL;                  /**< Receive flow control register, offset: 0x90 */
X  volatile uint32_t MAC_RX_FLOW_CTRL;                   
N       uint8_t RESERVED_3[4];
N  __IO uint32_t MAC_TXQ_PRIO_MAP;                  /**< , offset: 0x98 */
X  volatile uint32_t MAC_TXQ_PRIO_MAP;                   
N       uint8_t RESERVED_4[4];
N  __IO uint32_t MAC_RXQ_CTRL[3];                   /**< Receive Queue Control 0 register 0x0000, array offset: 0xA0, array step: 0x4 */
X  volatile uint32_t MAC_RXQ_CTRL[3];                    
N       uint8_t RESERVED_5[4];
N  __I  uint32_t MAC_INTR_STAT;                     /**< Interrupt status register 0x0000, offset: 0xB0 */
X  volatile const  uint32_t MAC_INTR_STAT;                      
N  __IO uint32_t MAC_INTR_EN;                       /**< Interrupt enable register 0x0000, offset: 0xB4 */
X  volatile uint32_t MAC_INTR_EN;                        
N  __I  uint32_t MAC_RXTX_STAT;                     /**< Receive Transmit Status register, offset: 0xB8 */
X  volatile const  uint32_t MAC_RXTX_STAT;                      
N       uint8_t RESERVED_6[4];
N  __IO uint32_t MAC_PMT_CRTL_STAT;                 /**< , offset: 0xC0 */
X  volatile uint32_t MAC_PMT_CRTL_STAT;                  
N  __IO uint32_t MAC_RWAKE_FRFLT;                   /**< Remote wake-up frame filter, offset: 0xC4 */
X  volatile uint32_t MAC_RWAKE_FRFLT;                    
N       uint8_t RESERVED_7[8];
N  __IO uint32_t MAC_LPI_CTRL_STAT;                 /**< LPI Control and Status Register, offset: 0xD0 */
X  volatile uint32_t MAC_LPI_CTRL_STAT;                  
N  __IO uint32_t MAC_LPI_TIMER_CTRL;                /**< LPI Timers Control register, offset: 0xD4 */
X  volatile uint32_t MAC_LPI_TIMER_CTRL;                 
N  __IO uint32_t MAC_LPI_ENTR_TIMR;                 /**< LPI entry Timer register, offset: 0xD8 */
X  volatile uint32_t MAC_LPI_ENTR_TIMR;                  
N  __IO uint32_t MAC_1US_TIC_COUNTR;                /**< , offset: 0xDC */
X  volatile uint32_t MAC_1US_TIC_COUNTR;                 
N       uint8_t RESERVED_8[48];
N  __IO uint32_t MAC_VERSION;                       /**< MAC version register, offset: 0x110 */
X  volatile uint32_t MAC_VERSION;                        
N  __I  uint32_t MAC_DBG;                           /**< MAC debug register, offset: 0x114 */
X  volatile const  uint32_t MAC_DBG;                            
N       uint8_t RESERVED_9[4];
N  __IO uint32_t MAC_HW_FEAT[3];                    /**< MAC hardware feature register 0x0201, array offset: 0x11C, array step: 0x4 */
X  volatile uint32_t MAC_HW_FEAT[3];                     
N       uint8_t RESERVED_10[216];
N  __IO uint32_t MAC_MDIO_ADDR;                     /**< MIDO address Register, offset: 0x200 */
X  volatile uint32_t MAC_MDIO_ADDR;                      
N  __IO uint32_t MAC_MDIO_DATA;                     /**< MDIO Data register, offset: 0x204 */
X  volatile uint32_t MAC_MDIO_DATA;                      
N       uint8_t RESERVED_11[248];
N  __IO uint32_t MAC_ADDR_HIGH;                     /**< MAC address0 high register, offset: 0x300 */
X  volatile uint32_t MAC_ADDR_HIGH;                      
N  __IO uint32_t MAC_ADDR_LOW;                      /**< MAC address0 low register, offset: 0x304 */
X  volatile uint32_t MAC_ADDR_LOW;                       
N       uint8_t RESERVED_12[2040];
N  __IO uint32_t MAC_TIMESTAMP_CTRL;                /**< Time stamp control register, offset: 0xB00 */
X  volatile uint32_t MAC_TIMESTAMP_CTRL;                 
N  __IO uint32_t MAC_SUB_SCND_INCR;                 /**< Sub-second increment register, offset: 0xB04 */
X  volatile uint32_t MAC_SUB_SCND_INCR;                  
N  __I  uint32_t MAC_SYS_TIME_SCND;                 /**< System time seconds register, offset: 0xB08 */
X  volatile const  uint32_t MAC_SYS_TIME_SCND;                  
N  __I  uint32_t MAC_SYS_TIME_NSCND;                /**< System time nanoseconds register, offset: 0xB0C */
X  volatile const  uint32_t MAC_SYS_TIME_NSCND;                 
N  __IO uint32_t MAC_SYS_TIME_SCND_UPD;             /**< , offset: 0xB10 */
X  volatile uint32_t MAC_SYS_TIME_SCND_UPD;              
N  __IO uint32_t MAC_SYS_TIME_NSCND_UPD;            /**< , offset: 0xB14 */
X  volatile uint32_t MAC_SYS_TIME_NSCND_UPD;             
N  __IO uint32_t MAC_SYS_TIMESTMP_ADDEND;           /**< Time stamp addend register, offset: 0xB18 */
X  volatile uint32_t MAC_SYS_TIMESTMP_ADDEND;            
N  __IO uint32_t MAC_SYS_TIME_HWORD_SCND;           /**< , offset: 0xB1C */
X  volatile uint32_t MAC_SYS_TIME_HWORD_SCND;            
N  __I  uint32_t MAC_SYS_TIMESTMP_STAT;             /**< Time stamp status register, offset: 0xB20 */
X  volatile const  uint32_t MAC_SYS_TIMESTMP_STAT;              
N       uint8_t RESERVED_13[220];
N  __IO uint32_t MTL_OP_MODE;                       /**< MTL Operation Mode Register, offset: 0xC00 */
X  volatile uint32_t MTL_OP_MODE;                        
N       uint8_t RESERVED_14[28];
N  __I  uint32_t MTL_INTR_STAT;                     /**< MTL Interrupt Status register, offset: 0xC20 */
X  volatile const  uint32_t MTL_INTR_STAT;                      
N       uint8_t RESERVED_15[12];
N  __IO uint32_t MTL_RXQ_DMA_MAP;                   /**< MTL Receive Queue and DMA Channel Mapping register, offset: 0xC30 */
X  volatile uint32_t MTL_RXQ_DMA_MAP;                    
N       uint8_t RESERVED_16[204];
N  struct {                                         /* offset: 0xD00, array step: 0x40 */
N    __IO uint32_t MTL_TXQX_OP_MODE;                  /**< MTL TxQx Operation Mode register, array offset: 0xD00, array step: 0x40 */
X    volatile uint32_t MTL_TXQX_OP_MODE;                   
N    __I  uint32_t MTL_TXQX_UNDRFLW;                  /**< MTL TxQx Underflow register, array offset: 0xD04, array step: 0x40 */
X    volatile const  uint32_t MTL_TXQX_UNDRFLW;                   
N    __I  uint32_t MTL_TXQX_DBG;                      /**< MTL TxQx Debug register, array offset: 0xD08, array step: 0x40 */
X    volatile const  uint32_t MTL_TXQX_DBG;                       
N         uint8_t RESERVED_0[8];
N    __IO uint32_t MTL_TXQX_ETS_STAT;                 /**< MTL TxQx ETS Status register, array offset: 0xD14, array step: 0x40 */
X    volatile uint32_t MTL_TXQX_ETS_STAT;                  
N    __IO uint32_t MTL_TXQX_QNTM_WGHT;                /**< , array offset: 0xD18, array step: 0x40 */
X    volatile uint32_t MTL_TXQX_QNTM_WGHT;                 
N         uint8_t RESERVED_1[16];
N    __IO uint32_t MTL_TXQX_INTCTRL_STAT;             /**< , array offset: 0xD2C, array step: 0x40 */
X    volatile uint32_t MTL_TXQX_INTCTRL_STAT;              
N    __IO uint32_t MTL_RXQX_OP_MODE;                  /**< MTL RxQx Operation Mode register, array offset: 0xD30, array step: 0x40 */
X    volatile uint32_t MTL_RXQX_OP_MODE;                   
N    __IO uint32_t MTL_RXQX_MISSPKT_OVRFLW_CNT;       /**< MTL RxQx Missed Packet Overflow Counter register, array offset: 0xD34, array step: 0x40 */
X    volatile uint32_t MTL_RXQX_MISSPKT_OVRFLW_CNT;        
N    __IO uint32_t MTL_RXQX_DBG;                      /**< MTL RxQx Debug register, array offset: 0xD38, array step: 0x40 */
X    volatile uint32_t MTL_RXQX_DBG;                       
N    __IO uint32_t MTL_RXQX_CTRL;                     /**< MTL RxQx Control register, array offset: 0xD3C, array step: 0x40 */
X    volatile uint32_t MTL_RXQX_CTRL;                      
N  } MTL_QUEUE[2];
N       uint8_t RESERVED_17[640];
N  __IO uint32_t DMA_MODE;                          /**< DMA mode register, offset: 0x1000 */
X  volatile uint32_t DMA_MODE;                           
N  __IO uint32_t DMA_SYSBUS_MODE;                   /**< DMA System Bus mode, offset: 0x1004 */
X  volatile uint32_t DMA_SYSBUS_MODE;                    
N  __IO uint32_t DMA_INTR_STAT;                     /**< DMA Interrupt status, offset: 0x1008 */
X  volatile uint32_t DMA_INTR_STAT;                      
N  __IO uint32_t DMA_DBG_STAT;                      /**< DMA Debug Status, offset: 0x100C */
X  volatile uint32_t DMA_DBG_STAT;                       
N       uint8_t RESERVED_18[240];
N  struct {                                         /* offset: 0x1100, array step: 0x80 */
N    __IO uint32_t DMA_CHX_CTRL;                      /**< DMA Channelx Control, array offset: 0x1100, array step: 0x80 */
X    volatile uint32_t DMA_CHX_CTRL;                       
N    __IO uint32_t DMA_CHX_TX_CTRL;                   /**< DMA Channelx Transmit Control, array offset: 0x1104, array step: 0x80 */
X    volatile uint32_t DMA_CHX_TX_CTRL;                    
N    __IO uint32_t DMA_CHX_RX_CTRL;                   /**< DMA Channelx Receive Control, array offset: 0x1108, array step: 0x80 */
X    volatile uint32_t DMA_CHX_RX_CTRL;                    
N         uint8_t RESERVED_0[8];
N    __IO uint32_t DMA_CHX_TXDESC_LIST_ADDR;          /**< , array offset: 0x1114, array step: 0x80 */
X    volatile uint32_t DMA_CHX_TXDESC_LIST_ADDR;           
N         uint8_t RESERVED_1[4];
N    __IO uint32_t DMA_CHX_RXDESC_LIST_ADDR;          /**< , array offset: 0x111C, array step: 0x80 */
X    volatile uint32_t DMA_CHX_RXDESC_LIST_ADDR;           
N    __IO uint32_t DMA_CHX_TXDESC_TAIL_PTR;           /**< , array offset: 0x1120, array step: 0x80 */
X    volatile uint32_t DMA_CHX_TXDESC_TAIL_PTR;            
N         uint8_t RESERVED_2[4];
N    __IO uint32_t DMA_CHX_RXDESC_TAIL_PTR;           /**< , array offset: 0x1128, array step: 0x80 */
X    volatile uint32_t DMA_CHX_RXDESC_TAIL_PTR;            
N    __IO uint32_t DMA_CHX_TXDESC_RING_LENGTH;        /**< , array offset: 0x112C, array step: 0x80 */
X    volatile uint32_t DMA_CHX_TXDESC_RING_LENGTH;         
N    __IO uint32_t DMA_CHX_RXDESC_RING_LENGTH;        /**< Channelx Rx descriptor Ring Length, array offset: 0x1130, array step: 0x80 */
X    volatile uint32_t DMA_CHX_RXDESC_RING_LENGTH;         
N    __IO uint32_t DMA_CHX_INT_EN;                    /**< Channelx Interrupt Enable, array offset: 0x1134, array step: 0x80 */
X    volatile uint32_t DMA_CHX_INT_EN;                     
N    __IO uint32_t DMA_CHX_RX_INT_WDTIMER;            /**< Receive Interrupt Watchdog Timer, array offset: 0x1138, array step: 0x80 */
X    volatile uint32_t DMA_CHX_RX_INT_WDTIMER;             
N    __IO uint32_t DMA_CHX_SLOT_FUNC_CTRL_STAT;       /**< Slot Function Control and Status, array offset: 0x113C, array step: 0x80 */
X    volatile uint32_t DMA_CHX_SLOT_FUNC_CTRL_STAT;        
N         uint8_t RESERVED_3[4];
N    __I  uint32_t DMA_CHX_CUR_HST_TXDESC;            /**< Channelx Current Host Transmit descriptor, array offset: 0x1144, array step: 0x80 */
X    volatile const  uint32_t DMA_CHX_CUR_HST_TXDESC;             
N         uint8_t RESERVED_4[4];
N    __I  uint32_t DMA_CHX_CUR_HST_RXDESC;            /**< , array offset: 0x114C, array step: 0x80 */
X    volatile const  uint32_t DMA_CHX_CUR_HST_RXDESC;             
N         uint8_t RESERVED_5[4];
N    __I  uint32_t DMA_CHX_CUR_HST_TXBUF;             /**< , array offset: 0x1154, array step: 0x80 */
X    volatile const  uint32_t DMA_CHX_CUR_HST_TXBUF;              
N         uint8_t RESERVED_6[4];
N    __I  uint32_t DMA_CHX_CUR_HST_RXBUF;             /**< Channelx Current Application Receive Buffer Address, array offset: 0x115C, array step: 0x80 */
X    volatile const  uint32_t DMA_CHX_CUR_HST_RXBUF;              
N    __IO uint32_t DMA_CHX_STAT;                      /**< Channelx DMA status register, array offset: 0x1160, array step: 0x80 */
X    volatile uint32_t DMA_CHX_STAT;                       
N         uint8_t RESERVED_7[28];
N  } DMA_CH[2];
N} ENET_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ENET Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ENET_Register_Masks ENET Register Masks
N * @{
N */
N
N/*! @name MAC_CONFIG - MAC configuration register */
N#define ENET_MAC_CONFIG_RE_MASK                  (0x1U)
N#define ENET_MAC_CONFIG_RE_SHIFT                 (0U)
N#define ENET_MAC_CONFIG_RE(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_RE_SHIFT)) & ENET_MAC_CONFIG_RE_MASK)
N#define ENET_MAC_CONFIG_TE_MASK                  (0x2U)
N#define ENET_MAC_CONFIG_TE_SHIFT                 (1U)
N#define ENET_MAC_CONFIG_TE(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_TE_SHIFT)) & ENET_MAC_CONFIG_TE_MASK)
N#define ENET_MAC_CONFIG_PRELEN_MASK              (0xCU)
N#define ENET_MAC_CONFIG_PRELEN_SHIFT             (2U)
N#define ENET_MAC_CONFIG_PRELEN(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_PRELEN_SHIFT)) & ENET_MAC_CONFIG_PRELEN_MASK)
N#define ENET_MAC_CONFIG_DC_MASK                  (0x10U)
N#define ENET_MAC_CONFIG_DC_SHIFT                 (4U)
N#define ENET_MAC_CONFIG_DC(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_DC_SHIFT)) & ENET_MAC_CONFIG_DC_MASK)
N#define ENET_MAC_CONFIG_BL_MASK                  (0x60U)
N#define ENET_MAC_CONFIG_BL_SHIFT                 (5U)
N#define ENET_MAC_CONFIG_BL(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_BL_SHIFT)) & ENET_MAC_CONFIG_BL_MASK)
N#define ENET_MAC_CONFIG_DR_MASK                  (0x100U)
N#define ENET_MAC_CONFIG_DR_SHIFT                 (8U)
N#define ENET_MAC_CONFIG_DR(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_DR_SHIFT)) & ENET_MAC_CONFIG_DR_MASK)
N#define ENET_MAC_CONFIG_DCRS_MASK                (0x200U)
N#define ENET_MAC_CONFIG_DCRS_SHIFT               (9U)
N#define ENET_MAC_CONFIG_DCRS(x)                  (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_DCRS_SHIFT)) & ENET_MAC_CONFIG_DCRS_MASK)
N#define ENET_MAC_CONFIG_DO_MASK                  (0x400U)
N#define ENET_MAC_CONFIG_DO_SHIFT                 (10U)
N#define ENET_MAC_CONFIG_DO(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_DO_SHIFT)) & ENET_MAC_CONFIG_DO_MASK)
N#define ENET_MAC_CONFIG_ECRSFD_MASK              (0x800U)
N#define ENET_MAC_CONFIG_ECRSFD_SHIFT             (11U)
N#define ENET_MAC_CONFIG_ECRSFD(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_ECRSFD_SHIFT)) & ENET_MAC_CONFIG_ECRSFD_MASK)
N#define ENET_MAC_CONFIG_LM_MASK                  (0x1000U)
N#define ENET_MAC_CONFIG_LM_SHIFT                 (12U)
N#define ENET_MAC_CONFIG_LM(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_LM_SHIFT)) & ENET_MAC_CONFIG_LM_MASK)
N#define ENET_MAC_CONFIG_DM_MASK                  (0x2000U)
N#define ENET_MAC_CONFIG_DM_SHIFT                 (13U)
N#define ENET_MAC_CONFIG_DM(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_DM_SHIFT)) & ENET_MAC_CONFIG_DM_MASK)
N#define ENET_MAC_CONFIG_FES_MASK                 (0x4000U)
N#define ENET_MAC_CONFIG_FES_SHIFT                (14U)
N#define ENET_MAC_CONFIG_FES(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_FES_SHIFT)) & ENET_MAC_CONFIG_FES_MASK)
N#define ENET_MAC_CONFIG_PS_MASK                  (0x8000U)
N#define ENET_MAC_CONFIG_PS_SHIFT                 (15U)
N#define ENET_MAC_CONFIG_PS(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_PS_SHIFT)) & ENET_MAC_CONFIG_PS_MASK)
N#define ENET_MAC_CONFIG_JE_MASK                  (0x10000U)
N#define ENET_MAC_CONFIG_JE_SHIFT                 (16U)
N#define ENET_MAC_CONFIG_JE(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_JE_SHIFT)) & ENET_MAC_CONFIG_JE_MASK)
N#define ENET_MAC_CONFIG_JD_MASK                  (0x20000U)
N#define ENET_MAC_CONFIG_JD_SHIFT                 (17U)
N#define ENET_MAC_CONFIG_JD(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_JD_SHIFT)) & ENET_MAC_CONFIG_JD_MASK)
N#define ENET_MAC_CONFIG_BE_MASK                  (0x40000U)
N#define ENET_MAC_CONFIG_BE_SHIFT                 (18U)
N#define ENET_MAC_CONFIG_BE(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_BE_SHIFT)) & ENET_MAC_CONFIG_BE_MASK)
N#define ENET_MAC_CONFIG_WD_MASK                  (0x80000U)
N#define ENET_MAC_CONFIG_WD_SHIFT                 (19U)
N#define ENET_MAC_CONFIG_WD(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_WD_SHIFT)) & ENET_MAC_CONFIG_WD_MASK)
N#define ENET_MAC_CONFIG_ACS_MASK                 (0x100000U)
N#define ENET_MAC_CONFIG_ACS_SHIFT                (20U)
N#define ENET_MAC_CONFIG_ACS(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_ACS_SHIFT)) & ENET_MAC_CONFIG_ACS_MASK)
N#define ENET_MAC_CONFIG_CST_MASK                 (0x200000U)
N#define ENET_MAC_CONFIG_CST_SHIFT                (21U)
N#define ENET_MAC_CONFIG_CST(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_CST_SHIFT)) & ENET_MAC_CONFIG_CST_MASK)
N#define ENET_MAC_CONFIG_S2KP_MASK                (0x400000U)
N#define ENET_MAC_CONFIG_S2KP_SHIFT               (22U)
N#define ENET_MAC_CONFIG_S2KP(x)                  (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_S2KP_SHIFT)) & ENET_MAC_CONFIG_S2KP_MASK)
N#define ENET_MAC_CONFIG_GPSLCE_MASK              (0x800000U)
N#define ENET_MAC_CONFIG_GPSLCE_SHIFT             (23U)
N#define ENET_MAC_CONFIG_GPSLCE(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_GPSLCE_SHIFT)) & ENET_MAC_CONFIG_GPSLCE_MASK)
N#define ENET_MAC_CONFIG_IPG_MASK                 (0x7000000U)
N#define ENET_MAC_CONFIG_IPG_SHIFT                (24U)
N#define ENET_MAC_CONFIG_IPG(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_IPG_SHIFT)) & ENET_MAC_CONFIG_IPG_MASK)
N#define ENET_MAC_CONFIG_IPC_MASK                 (0x8000000U)
N#define ENET_MAC_CONFIG_IPC_SHIFT                (27U)
N#define ENET_MAC_CONFIG_IPC(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_CONFIG_IPC_SHIFT)) & ENET_MAC_CONFIG_IPC_MASK)
N
N/*! @name MAC_EXT_CONFIG -  */
N#define ENET_MAC_EXT_CONFIG_GPSL_MASK            (0x3FFFU)
N#define ENET_MAC_EXT_CONFIG_GPSL_SHIFT           (0U)
N#define ENET_MAC_EXT_CONFIG_GPSL(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_EXT_CONFIG_GPSL_SHIFT)) & ENET_MAC_EXT_CONFIG_GPSL_MASK)
N#define ENET_MAC_EXT_CONFIG_DCRCC_MASK           (0x10000U)
N#define ENET_MAC_EXT_CONFIG_DCRCC_SHIFT          (16U)
N#define ENET_MAC_EXT_CONFIG_DCRCC(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_EXT_CONFIG_DCRCC_SHIFT)) & ENET_MAC_EXT_CONFIG_DCRCC_MASK)
N#define ENET_MAC_EXT_CONFIG_SPEN_MASK            (0x20000U)
N#define ENET_MAC_EXT_CONFIG_SPEN_SHIFT           (17U)
N#define ENET_MAC_EXT_CONFIG_SPEN(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_EXT_CONFIG_SPEN_SHIFT)) & ENET_MAC_EXT_CONFIG_SPEN_MASK)
N#define ENET_MAC_EXT_CONFIG_USP_MASK             (0x40000U)
N#define ENET_MAC_EXT_CONFIG_USP_SHIFT            (18U)
N#define ENET_MAC_EXT_CONFIG_USP(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_EXT_CONFIG_USP_SHIFT)) & ENET_MAC_EXT_CONFIG_USP_MASK)
N
N/*! @name MAC_FRAME_FILTER - MAC frame filter register */
N#define ENET_MAC_FRAME_FILTER_PR_MASK            (0x1U)
N#define ENET_MAC_FRAME_FILTER_PR_SHIFT           (0U)
N#define ENET_MAC_FRAME_FILTER_PR(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_PR_SHIFT)) & ENET_MAC_FRAME_FILTER_PR_MASK)
N#define ENET_MAC_FRAME_FILTER_DAIF_MASK          (0x8U)
N#define ENET_MAC_FRAME_FILTER_DAIF_SHIFT         (3U)
N#define ENET_MAC_FRAME_FILTER_DAIF(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_DAIF_SHIFT)) & ENET_MAC_FRAME_FILTER_DAIF_MASK)
N#define ENET_MAC_FRAME_FILTER_PM_MASK            (0x10U)
N#define ENET_MAC_FRAME_FILTER_PM_SHIFT           (4U)
N#define ENET_MAC_FRAME_FILTER_PM(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_PM_SHIFT)) & ENET_MAC_FRAME_FILTER_PM_MASK)
N#define ENET_MAC_FRAME_FILTER_DBF_MASK           (0x20U)
N#define ENET_MAC_FRAME_FILTER_DBF_SHIFT          (5U)
N#define ENET_MAC_FRAME_FILTER_DBF(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_DBF_SHIFT)) & ENET_MAC_FRAME_FILTER_DBF_MASK)
N#define ENET_MAC_FRAME_FILTER_PCF_MASK           (0xC0U)
N#define ENET_MAC_FRAME_FILTER_PCF_SHIFT          (6U)
N#define ENET_MAC_FRAME_FILTER_PCF(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_PCF_SHIFT)) & ENET_MAC_FRAME_FILTER_PCF_MASK)
N#define ENET_MAC_FRAME_FILTER_SAIF_MASK          (0x100U)
N#define ENET_MAC_FRAME_FILTER_SAIF_SHIFT         (8U)
N#define ENET_MAC_FRAME_FILTER_SAIF(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_SAIF_SHIFT)) & ENET_MAC_FRAME_FILTER_SAIF_MASK)
N#define ENET_MAC_FRAME_FILTER_SAF_MASK           (0x200U)
N#define ENET_MAC_FRAME_FILTER_SAF_SHIFT          (9U)
N#define ENET_MAC_FRAME_FILTER_SAF(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_SAF_SHIFT)) & ENET_MAC_FRAME_FILTER_SAF_MASK)
N#define ENET_MAC_FRAME_FILTER_RA_MASK            (0x80000000U)
N#define ENET_MAC_FRAME_FILTER_RA_SHIFT           (31U)
N#define ENET_MAC_FRAME_FILTER_RA(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_FRAME_FILTER_RA_SHIFT)) & ENET_MAC_FRAME_FILTER_RA_MASK)
N
N/*! @name MAC_WD_TIMEROUT - MAC watchdog Timeout register */
N#define ENET_MAC_WD_TIMEROUT_WTO_MASK            (0xFU)
N#define ENET_MAC_WD_TIMEROUT_WTO_SHIFT           (0U)
N#define ENET_MAC_WD_TIMEROUT_WTO(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_WD_TIMEROUT_WTO_SHIFT)) & ENET_MAC_WD_TIMEROUT_WTO_MASK)
N#define ENET_MAC_WD_TIMEROUT_PWE_MASK            (0x100U)
N#define ENET_MAC_WD_TIMEROUT_PWE_SHIFT           (8U)
N#define ENET_MAC_WD_TIMEROUT_PWE(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_WD_TIMEROUT_PWE_SHIFT)) & ENET_MAC_WD_TIMEROUT_PWE_MASK)
N
N/*! @name MAC_VLAN_TAG - MAC vlan tag register */
N#define ENET_MAC_VLAN_TAG_VL_MASK                (0xFFFFU)
N#define ENET_MAC_VLAN_TAG_VL_SHIFT               (0U)
N#define ENET_MAC_VLAN_TAG_VL(x)                  (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_VL_SHIFT)) & ENET_MAC_VLAN_TAG_VL_MASK)
N#define ENET_MAC_VLAN_TAG_ETV_MASK               (0x10000U)
N#define ENET_MAC_VLAN_TAG_ETV_SHIFT              (16U)
N#define ENET_MAC_VLAN_TAG_ETV(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_ETV_SHIFT)) & ENET_MAC_VLAN_TAG_ETV_MASK)
N#define ENET_MAC_VLAN_TAG_VTIM_MASK              (0x20000U)
N#define ENET_MAC_VLAN_TAG_VTIM_SHIFT             (17U)
N#define ENET_MAC_VLAN_TAG_VTIM(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_VTIM_SHIFT)) & ENET_MAC_VLAN_TAG_VTIM_MASK)
N#define ENET_MAC_VLAN_TAG_ESVL_MASK              (0x40000U)
N#define ENET_MAC_VLAN_TAG_ESVL_SHIFT             (18U)
N#define ENET_MAC_VLAN_TAG_ESVL(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_ESVL_SHIFT)) & ENET_MAC_VLAN_TAG_ESVL_MASK)
N#define ENET_MAC_VLAN_TAG_ERSVLM_MASK            (0x80000U)
N#define ENET_MAC_VLAN_TAG_ERSVLM_SHIFT           (19U)
N#define ENET_MAC_VLAN_TAG_ERSVLM(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_ERSVLM_SHIFT)) & ENET_MAC_VLAN_TAG_ERSVLM_MASK)
N#define ENET_MAC_VLAN_TAG_DOVLTC_MASK            (0x100000U)
N#define ENET_MAC_VLAN_TAG_DOVLTC_SHIFT           (20U)
N#define ENET_MAC_VLAN_TAG_DOVLTC(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_DOVLTC_SHIFT)) & ENET_MAC_VLAN_TAG_DOVLTC_MASK)
N#define ENET_MAC_VLAN_TAG_EVLS_MASK              (0x600000U)
N#define ENET_MAC_VLAN_TAG_EVLS_SHIFT             (21U)
N#define ENET_MAC_VLAN_TAG_EVLS(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_EVLS_SHIFT)) & ENET_MAC_VLAN_TAG_EVLS_MASK)
N#define ENET_MAC_VLAN_TAG_EVLRXS_MASK            (0x1000000U)
N#define ENET_MAC_VLAN_TAG_EVLRXS_SHIFT           (24U)
N#define ENET_MAC_VLAN_TAG_EVLRXS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_EVLRXS_SHIFT)) & ENET_MAC_VLAN_TAG_EVLRXS_MASK)
N#define ENET_MAC_VLAN_TAG_VTHM_MASK              (0x2000000U)
N#define ENET_MAC_VLAN_TAG_VTHM_SHIFT             (25U)
N#define ENET_MAC_VLAN_TAG_VTHM(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_VTHM_SHIFT)) & ENET_MAC_VLAN_TAG_VTHM_MASK)
N#define ENET_MAC_VLAN_TAG_EDVLP_MASK             (0x4000000U)
N#define ENET_MAC_VLAN_TAG_EDVLP_SHIFT            (26U)
N#define ENET_MAC_VLAN_TAG_EDVLP(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_EDVLP_SHIFT)) & ENET_MAC_VLAN_TAG_EDVLP_MASK)
N#define ENET_MAC_VLAN_TAG_ERIVLT_MASK            (0x8000000U)
N#define ENET_MAC_VLAN_TAG_ERIVLT_SHIFT           (27U)
N#define ENET_MAC_VLAN_TAG_ERIVLT(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_ERIVLT_SHIFT)) & ENET_MAC_VLAN_TAG_ERIVLT_MASK)
N#define ENET_MAC_VLAN_TAG_EIVLS_MASK             (0x30000000U)
N#define ENET_MAC_VLAN_TAG_EIVLS_SHIFT            (28U)
N#define ENET_MAC_VLAN_TAG_EIVLS(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_EIVLS_SHIFT)) & ENET_MAC_VLAN_TAG_EIVLS_MASK)
N#define ENET_MAC_VLAN_TAG_EIVLRXS_MASK           (0x80000000U)
N#define ENET_MAC_VLAN_TAG_EIVLRXS_SHIFT          (31U)
N#define ENET_MAC_VLAN_TAG_EIVLRXS(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VLAN_TAG_EIVLRXS_SHIFT)) & ENET_MAC_VLAN_TAG_EIVLRXS_MASK)
N
N/*! @name MAC_TX_FLOW_CTRL_Q - Transmit flow control register */
N#define ENET_MAC_TX_FLOW_CTRL_Q_FCB_MASK         (0x1U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_FCB_SHIFT        (0U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_FCB(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TX_FLOW_CTRL_Q_FCB_SHIFT)) & ENET_MAC_TX_FLOW_CTRL_Q_FCB_MASK)
N#define ENET_MAC_TX_FLOW_CTRL_Q_TFE_MASK         (0x2U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_TFE_SHIFT        (1U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_TFE(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TX_FLOW_CTRL_Q_TFE_SHIFT)) & ENET_MAC_TX_FLOW_CTRL_Q_TFE_MASK)
N#define ENET_MAC_TX_FLOW_CTRL_Q_PLT_MASK         (0x70U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_PLT_SHIFT        (4U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_PLT(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TX_FLOW_CTRL_Q_PLT_SHIFT)) & ENET_MAC_TX_FLOW_CTRL_Q_PLT_MASK)
N#define ENET_MAC_TX_FLOW_CTRL_Q_DZPQ_MASK        (0x80U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_DZPQ_SHIFT       (7U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_DZPQ(x)          (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TX_FLOW_CTRL_Q_DZPQ_SHIFT)) & ENET_MAC_TX_FLOW_CTRL_Q_DZPQ_MASK)
N#define ENET_MAC_TX_FLOW_CTRL_Q_PT_MASK          (0xFFFF0000U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_PT_SHIFT         (16U)
N#define ENET_MAC_TX_FLOW_CTRL_Q_PT(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TX_FLOW_CTRL_Q_PT_SHIFT)) & ENET_MAC_TX_FLOW_CTRL_Q_PT_MASK)
N
N/* The count of ENET_MAC_TX_FLOW_CTRL_Q */
N#define ENET_MAC_TX_FLOW_CTRL_Q_COUNT            (2U)
N
N/*! @name MAC_RX_FLOW_CTRL - Receive flow control register */
N#define ENET_MAC_RX_FLOW_CTRL_RFE_MASK           (0x1U)
N#define ENET_MAC_RX_FLOW_CTRL_RFE_SHIFT          (0U)
N#define ENET_MAC_RX_FLOW_CTRL_RFE(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RX_FLOW_CTRL_RFE_SHIFT)) & ENET_MAC_RX_FLOW_CTRL_RFE_MASK)
N#define ENET_MAC_RX_FLOW_CTRL_UP_MASK            (0x2U)
N#define ENET_MAC_RX_FLOW_CTRL_UP_SHIFT           (1U)
N#define ENET_MAC_RX_FLOW_CTRL_UP(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RX_FLOW_CTRL_UP_SHIFT)) & ENET_MAC_RX_FLOW_CTRL_UP_MASK)
N
N/*! @name MAC_TXQ_PRIO_MAP -  */
N#define ENET_MAC_TXQ_PRIO_MAP_PSTQ0_MASK         (0xFFU)
N#define ENET_MAC_TXQ_PRIO_MAP_PSTQ0_SHIFT        (0U)
N#define ENET_MAC_TXQ_PRIO_MAP_PSTQ0(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TXQ_PRIO_MAP_PSTQ0_SHIFT)) & ENET_MAC_TXQ_PRIO_MAP_PSTQ0_MASK)
N#define ENET_MAC_TXQ_PRIO_MAP_PSTQ1_MASK         (0xFF00U)
N#define ENET_MAC_TXQ_PRIO_MAP_PSTQ1_SHIFT        (8U)
N#define ENET_MAC_TXQ_PRIO_MAP_PSTQ1(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TXQ_PRIO_MAP_PSTQ1_SHIFT)) & ENET_MAC_TXQ_PRIO_MAP_PSTQ1_MASK)
N
N/*! @name MAC_RXQ_CTRL - Receive Queue Control 0 register 0x0000 */
N#define ENET_MAC_RXQ_CTRL_RXQ0EN_MASK            (0x3U)
N#define ENET_MAC_RXQ_CTRL_RXQ0EN_SHIFT           (0U)
N#define ENET_MAC_RXQ_CTRL_RXQ0EN(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_RXQ0EN_SHIFT)) & ENET_MAC_RXQ_CTRL_RXQ0EN_MASK)
N#define ENET_MAC_RXQ_CTRL_PSRQ0_MASK             (0xFFU)
N#define ENET_MAC_RXQ_CTRL_PSRQ0_SHIFT            (0U)
N#define ENET_MAC_RXQ_CTRL_PSRQ0(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_PSRQ0_SHIFT)) & ENET_MAC_RXQ_CTRL_PSRQ0_MASK)
N#define ENET_MAC_RXQ_CTRL_AVCPQ_MASK             (0x7U)
N#define ENET_MAC_RXQ_CTRL_AVCPQ_SHIFT            (0U)
N#define ENET_MAC_RXQ_CTRL_AVCPQ(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_AVCPQ_SHIFT)) & ENET_MAC_RXQ_CTRL_AVCPQ_MASK)
N#define ENET_MAC_RXQ_CTRL_RXQ1EN_MASK            (0xCU)
N#define ENET_MAC_RXQ_CTRL_RXQ1EN_SHIFT           (2U)
N#define ENET_MAC_RXQ_CTRL_RXQ1EN(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_RXQ1EN_SHIFT)) & ENET_MAC_RXQ_CTRL_RXQ1EN_MASK)
N#define ENET_MAC_RXQ_CTRL_AVPTPQ_MASK            (0x70U)
N#define ENET_MAC_RXQ_CTRL_AVPTPQ_SHIFT           (4U)
N#define ENET_MAC_RXQ_CTRL_AVPTPQ(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_AVPTPQ_SHIFT)) & ENET_MAC_RXQ_CTRL_AVPTPQ_MASK)
N#define ENET_MAC_RXQ_CTRL_PSRQ1_MASK             (0xFF00U)
N#define ENET_MAC_RXQ_CTRL_PSRQ1_SHIFT            (8U)
N#define ENET_MAC_RXQ_CTRL_PSRQ1(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_PSRQ1_SHIFT)) & ENET_MAC_RXQ_CTRL_PSRQ1_MASK)
N#define ENET_MAC_RXQ_CTRL_UPQ_MASK               (0x7000U)
N#define ENET_MAC_RXQ_CTRL_UPQ_SHIFT              (12U)
N#define ENET_MAC_RXQ_CTRL_UPQ(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_UPQ_SHIFT)) & ENET_MAC_RXQ_CTRL_UPQ_MASK)
N#define ENET_MAC_RXQ_CTRL_PSRQ2_MASK             (0xFF0000U)
N#define ENET_MAC_RXQ_CTRL_PSRQ2_SHIFT            (16U)
N#define ENET_MAC_RXQ_CTRL_PSRQ2(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_PSRQ2_SHIFT)) & ENET_MAC_RXQ_CTRL_PSRQ2_MASK)
N#define ENET_MAC_RXQ_CTRL_MCBCQ_MASK             (0x70000U)
N#define ENET_MAC_RXQ_CTRL_MCBCQ_SHIFT            (16U)
N#define ENET_MAC_RXQ_CTRL_MCBCQ(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_MCBCQ_SHIFT)) & ENET_MAC_RXQ_CTRL_MCBCQ_MASK)
N#define ENET_MAC_RXQ_CTRL_MCBCQEN_MASK           (0x100000U)
N#define ENET_MAC_RXQ_CTRL_MCBCQEN_SHIFT          (20U)
N#define ENET_MAC_RXQ_CTRL_MCBCQEN(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_MCBCQEN_SHIFT)) & ENET_MAC_RXQ_CTRL_MCBCQEN_MASK)
N#define ENET_MAC_RXQ_CTRL_PSRQ3_MASK             (0xFF000000U)
N#define ENET_MAC_RXQ_CTRL_PSRQ3_SHIFT            (24U)
N#define ENET_MAC_RXQ_CTRL_PSRQ3(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXQ_CTRL_PSRQ3_SHIFT)) & ENET_MAC_RXQ_CTRL_PSRQ3_MASK)
N
N/* The count of ENET_MAC_RXQ_CTRL */
N#define ENET_MAC_RXQ_CTRL_COUNT                  (3U)
N
N/*! @name MAC_INTR_STAT - Interrupt status register 0x0000 */
N#define ENET_MAC_INTR_STAT_PHYIS_MASK            (0x8U)
N#define ENET_MAC_INTR_STAT_PHYIS_SHIFT           (3U)
N#define ENET_MAC_INTR_STAT_PHYIS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_STAT_PHYIS_SHIFT)) & ENET_MAC_INTR_STAT_PHYIS_MASK)
N#define ENET_MAC_INTR_STAT_PMTIS_MASK            (0x10U)
N#define ENET_MAC_INTR_STAT_PMTIS_SHIFT           (4U)
N#define ENET_MAC_INTR_STAT_PMTIS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_STAT_PMTIS_SHIFT)) & ENET_MAC_INTR_STAT_PMTIS_MASK)
N#define ENET_MAC_INTR_STAT_LPIIS_MASK            (0x20U)
N#define ENET_MAC_INTR_STAT_LPIIS_SHIFT           (5U)
N#define ENET_MAC_INTR_STAT_LPIIS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_STAT_LPIIS_SHIFT)) & ENET_MAC_INTR_STAT_LPIIS_MASK)
N#define ENET_MAC_INTR_STAT_TSIS_MASK             (0x1000U)
N#define ENET_MAC_INTR_STAT_TSIS_SHIFT            (12U)
N#define ENET_MAC_INTR_STAT_TSIS(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_STAT_TSIS_SHIFT)) & ENET_MAC_INTR_STAT_TSIS_MASK)
N#define ENET_MAC_INTR_STAT_TXSTSIS_MASK          (0x2000U)
N#define ENET_MAC_INTR_STAT_TXSTSIS_SHIFT         (13U)
N#define ENET_MAC_INTR_STAT_TXSTSIS(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_STAT_TXSTSIS_SHIFT)) & ENET_MAC_INTR_STAT_TXSTSIS_MASK)
N#define ENET_MAC_INTR_STAT_RXSTSIS_MASK          (0x4000U)
N#define ENET_MAC_INTR_STAT_RXSTSIS_SHIFT         (14U)
N#define ENET_MAC_INTR_STAT_RXSTSIS(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_STAT_RXSTSIS_SHIFT)) & ENET_MAC_INTR_STAT_RXSTSIS_MASK)
N
N/*! @name MAC_INTR_EN - Interrupt enable register 0x0000 */
N#define ENET_MAC_INTR_EN_PHYIE_MASK              (0x8U)
N#define ENET_MAC_INTR_EN_PHYIE_SHIFT             (3U)
N#define ENET_MAC_INTR_EN_PHYIE(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_EN_PHYIE_SHIFT)) & ENET_MAC_INTR_EN_PHYIE_MASK)
N#define ENET_MAC_INTR_EN_PMTIE_MASK              (0x10U)
N#define ENET_MAC_INTR_EN_PMTIE_SHIFT             (4U)
N#define ENET_MAC_INTR_EN_PMTIE(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_EN_PMTIE_SHIFT)) & ENET_MAC_INTR_EN_PMTIE_MASK)
N#define ENET_MAC_INTR_EN_LPIIE_MASK              (0x20U)
N#define ENET_MAC_INTR_EN_LPIIE_SHIFT             (5U)
N#define ENET_MAC_INTR_EN_LPIIE(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_EN_LPIIE_SHIFT)) & ENET_MAC_INTR_EN_LPIIE_MASK)
N#define ENET_MAC_INTR_EN_TSIE_MASK               (0x1000U)
N#define ENET_MAC_INTR_EN_TSIE_SHIFT              (12U)
N#define ENET_MAC_INTR_EN_TSIE(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_EN_TSIE_SHIFT)) & ENET_MAC_INTR_EN_TSIE_MASK)
N#define ENET_MAC_INTR_EN_TXSTSIE_MASK            (0x2000U)
N#define ENET_MAC_INTR_EN_TXSTSIE_SHIFT           (13U)
N#define ENET_MAC_INTR_EN_TXSTSIE(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_EN_TXSTSIE_SHIFT)) & ENET_MAC_INTR_EN_TXSTSIE_MASK)
N#define ENET_MAC_INTR_EN_RXSTSIS_MASK            (0x4000U)
N#define ENET_MAC_INTR_EN_RXSTSIS_SHIFT           (14U)
N#define ENET_MAC_INTR_EN_RXSTSIS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_INTR_EN_RXSTSIS_SHIFT)) & ENET_MAC_INTR_EN_RXSTSIS_MASK)
N
N/*! @name MAC_RXTX_STAT - Receive Transmit Status register */
N#define ENET_MAC_RXTX_STAT_TJT_MASK              (0x1U)
N#define ENET_MAC_RXTX_STAT_TJT_SHIFT             (0U)
N#define ENET_MAC_RXTX_STAT_TJT(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_TJT_SHIFT)) & ENET_MAC_RXTX_STAT_TJT_MASK)
N#define ENET_MAC_RXTX_STAT_NCARR_MASK            (0x2U)
N#define ENET_MAC_RXTX_STAT_NCARR_SHIFT           (1U)
N#define ENET_MAC_RXTX_STAT_NCARR(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_NCARR_SHIFT)) & ENET_MAC_RXTX_STAT_NCARR_MASK)
N#define ENET_MAC_RXTX_STAT_LCARR_MASK            (0x4U)
N#define ENET_MAC_RXTX_STAT_LCARR_SHIFT           (2U)
N#define ENET_MAC_RXTX_STAT_LCARR(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_LCARR_SHIFT)) & ENET_MAC_RXTX_STAT_LCARR_MASK)
N#define ENET_MAC_RXTX_STAT_EXDEF_MASK            (0x8U)
N#define ENET_MAC_RXTX_STAT_EXDEF_SHIFT           (3U)
N#define ENET_MAC_RXTX_STAT_EXDEF(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_EXDEF_SHIFT)) & ENET_MAC_RXTX_STAT_EXDEF_MASK)
N#define ENET_MAC_RXTX_STAT_LCOL_MASK             (0x10U)
N#define ENET_MAC_RXTX_STAT_LCOL_SHIFT            (4U)
N#define ENET_MAC_RXTX_STAT_LCOL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_LCOL_SHIFT)) & ENET_MAC_RXTX_STAT_LCOL_MASK)
N#define ENET_MAC_RXTX_STAT_EXCOL_MASK            (0x20U)
N#define ENET_MAC_RXTX_STAT_EXCOL_SHIFT           (5U)
N#define ENET_MAC_RXTX_STAT_EXCOL(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_EXCOL_SHIFT)) & ENET_MAC_RXTX_STAT_EXCOL_MASK)
N#define ENET_MAC_RXTX_STAT_RWT_MASK              (0x100U)
N#define ENET_MAC_RXTX_STAT_RWT_SHIFT             (8U)
N#define ENET_MAC_RXTX_STAT_RWT(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RXTX_STAT_RWT_SHIFT)) & ENET_MAC_RXTX_STAT_RWT_MASK)
N
N/*! @name MAC_PMT_CRTL_STAT -  */
N#define ENET_MAC_PMT_CRTL_STAT_PWRDWN_MASK       (0x1U)
N#define ENET_MAC_PMT_CRTL_STAT_PWRDWN_SHIFT      (0U)
N#define ENET_MAC_PMT_CRTL_STAT_PWRDWN(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_PWRDWN_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_PWRDWN_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_MGKPKTEN_MASK     (0x2U)
N#define ENET_MAC_PMT_CRTL_STAT_MGKPKTEN_SHIFT    (1U)
N#define ENET_MAC_PMT_CRTL_STAT_MGKPKTEN(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_MGKPKTEN_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_MGKPKTEN_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPKTEN_MASK     (0x4U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPKTEN_SHIFT    (2U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPKTEN(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_RWKPKTEN_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_RWKPKTEN_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_MGKPRCVD_MASK     (0x20U)
N#define ENET_MAC_PMT_CRTL_STAT_MGKPRCVD_SHIFT    (5U)
N#define ENET_MAC_PMT_CRTL_STAT_MGKPRCVD(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_MGKPRCVD_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_MGKPRCVD_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPRCVD_MASK     (0x40U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPRCVD_SHIFT    (6U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPRCVD(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_RWKPRCVD_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_RWKPRCVD_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_GLBLUCAST_MASK    (0x200U)
N#define ENET_MAC_PMT_CRTL_STAT_GLBLUCAST_SHIFT   (9U)
N#define ENET_MAC_PMT_CRTL_STAT_GLBLUCAST(x)      (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_GLBLUCAST_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_GLBLUCAST_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPFE_MASK       (0x400U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPFE_SHIFT      (10U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPFE(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_RWKPFE_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_RWKPFE_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPTR_MASK       (0x1F000000U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPTR_SHIFT      (24U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKPTR(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_RWKPTR_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_RWKPTR_MASK)
N#define ENET_MAC_PMT_CRTL_STAT_RWKFILTRST_MASK   (0x80000000U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKFILTRST_SHIFT  (31U)
N#define ENET_MAC_PMT_CRTL_STAT_RWKFILTRST(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_PMT_CRTL_STAT_RWKFILTRST_SHIFT)) & ENET_MAC_PMT_CRTL_STAT_RWKFILTRST_MASK)
N
N/*! @name MAC_RWAKE_FRFLT - Remote wake-up frame filter */
N#define ENET_MAC_RWAKE_FRFLT_ADDR_MASK           (0xFFFFFFFFU)
N#define ENET_MAC_RWAKE_FRFLT_ADDR_SHIFT          (0U)
N#define ENET_MAC_RWAKE_FRFLT_ADDR(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_RWAKE_FRFLT_ADDR_SHIFT)) & ENET_MAC_RWAKE_FRFLT_ADDR_MASK)
N
N/*! @name MAC_LPI_CTRL_STAT - LPI Control and Status Register */
N#define ENET_MAC_LPI_CTRL_STAT_TLPIEN_MASK       (0x1U)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIEN_SHIFT      (0U)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIEN(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_TLPIEN_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_TLPIEN_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIEX_MASK       (0x2U)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIEX_SHIFT      (1U)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIEX(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_TLPIEX_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_TLPIEX_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIEN_MASK       (0x4U)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIEN_SHIFT      (2U)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIEN(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_RLPIEN_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_RLPIEN_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIEX_MASK       (0x8U)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIEX_SHIFT      (3U)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIEX(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_RLPIEX_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_RLPIEX_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIST_MASK       (0x100U)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIST_SHIFT      (8U)
N#define ENET_MAC_LPI_CTRL_STAT_TLPIST(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_TLPIST_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_TLPIST_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIST_MASK       (0x200U)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIST_SHIFT      (9U)
N#define ENET_MAC_LPI_CTRL_STAT_RLPIST(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_RLPIST_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_RLPIST_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_LPIEN_MASK        (0x10000U)
N#define ENET_MAC_LPI_CTRL_STAT_LPIEN_SHIFT       (16U)
N#define ENET_MAC_LPI_CTRL_STAT_LPIEN(x)          (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_LPIEN_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_LPIEN_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_PLS_MASK          (0x20000U)
N#define ENET_MAC_LPI_CTRL_STAT_PLS_SHIFT         (17U)
N#define ENET_MAC_LPI_CTRL_STAT_PLS(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_PLS_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_PLS_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_LPITXA_MASK       (0x80000U)
N#define ENET_MAC_LPI_CTRL_STAT_LPITXA_SHIFT      (19U)
N#define ENET_MAC_LPI_CTRL_STAT_LPITXA(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_LPITXA_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_LPITXA_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_LPIATE_MASK       (0x100000U)
N#define ENET_MAC_LPI_CTRL_STAT_LPIATE_SHIFT      (20U)
N#define ENET_MAC_LPI_CTRL_STAT_LPIATE(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_LPIATE_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_LPIATE_MASK)
N#define ENET_MAC_LPI_CTRL_STAT_LPITCSE_MASK      (0x200000U)
N#define ENET_MAC_LPI_CTRL_STAT_LPITCSE_SHIFT     (21U)
N#define ENET_MAC_LPI_CTRL_STAT_LPITCSE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_CTRL_STAT_LPITCSE_SHIFT)) & ENET_MAC_LPI_CTRL_STAT_LPITCSE_MASK)
N
N/*! @name MAC_LPI_TIMER_CTRL - LPI Timers Control register */
N#define ENET_MAC_LPI_TIMER_CTRL_TWT_MASK         (0xFFFFU)
N#define ENET_MAC_LPI_TIMER_CTRL_TWT_SHIFT        (0U)
N#define ENET_MAC_LPI_TIMER_CTRL_TWT(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_TIMER_CTRL_TWT_SHIFT)) & ENET_MAC_LPI_TIMER_CTRL_TWT_MASK)
N#define ENET_MAC_LPI_TIMER_CTRL_LST_MASK         (0x3FF0000U)
N#define ENET_MAC_LPI_TIMER_CTRL_LST_SHIFT        (16U)
N#define ENET_MAC_LPI_TIMER_CTRL_LST(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_TIMER_CTRL_LST_SHIFT)) & ENET_MAC_LPI_TIMER_CTRL_LST_MASK)
N
N/*! @name MAC_LPI_ENTR_TIMR - LPI entry Timer register */
N#define ENET_MAC_LPI_ENTR_TIMR_LPIET_MASK        (0xFFFF8U)
N#define ENET_MAC_LPI_ENTR_TIMR_LPIET_SHIFT       (3U)
N#define ENET_MAC_LPI_ENTR_TIMR_LPIET(x)          (((uint32_t)(((uint32_t)(x)) << ENET_MAC_LPI_ENTR_TIMR_LPIET_SHIFT)) & ENET_MAC_LPI_ENTR_TIMR_LPIET_MASK)
N
N/*! @name MAC_1US_TIC_COUNTR -  */
N#define ENET_MAC_1US_TIC_COUNTR_TIC_1US_CNTR_MASK (0xFFFU)
N#define ENET_MAC_1US_TIC_COUNTR_TIC_1US_CNTR_SHIFT (0U)
N#define ENET_MAC_1US_TIC_COUNTR_TIC_1US_CNTR(x)  (((uint32_t)(((uint32_t)(x)) << ENET_MAC_1US_TIC_COUNTR_TIC_1US_CNTR_SHIFT)) & ENET_MAC_1US_TIC_COUNTR_TIC_1US_CNTR_MASK)
N
N/*! @name MAC_VERSION - MAC version register */
N#define ENET_MAC_VERSION_SNPVER_MASK             (0xFFU)
N#define ENET_MAC_VERSION_SNPVER_SHIFT            (0U)
N#define ENET_MAC_VERSION_SNPVER(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VERSION_SNPVER_SHIFT)) & ENET_MAC_VERSION_SNPVER_MASK)
N#define ENET_MAC_VERSION_USERVER_MASK            (0xFF00U)
N#define ENET_MAC_VERSION_USERVER_SHIFT           (8U)
N#define ENET_MAC_VERSION_USERVER(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_VERSION_USERVER_SHIFT)) & ENET_MAC_VERSION_USERVER_MASK)
N
N/*! @name MAC_DBG - MAC debug register */
N#define ENET_MAC_DBG_REPESTS_MASK                (0x1U)
N#define ENET_MAC_DBG_REPESTS_SHIFT               (0U)
N#define ENET_MAC_DBG_REPESTS(x)                  (((uint32_t)(((uint32_t)(x)) << ENET_MAC_DBG_REPESTS_SHIFT)) & ENET_MAC_DBG_REPESTS_MASK)
N#define ENET_MAC_DBG_RFCFCSTS_MASK               (0x6U)
N#define ENET_MAC_DBG_RFCFCSTS_SHIFT              (1U)
N#define ENET_MAC_DBG_RFCFCSTS(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_DBG_RFCFCSTS_SHIFT)) & ENET_MAC_DBG_RFCFCSTS_MASK)
N#define ENET_MAC_DBG_TPESTS_MASK                 (0x10000U)
N#define ENET_MAC_DBG_TPESTS_SHIFT                (16U)
N#define ENET_MAC_DBG_TPESTS(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_DBG_TPESTS_SHIFT)) & ENET_MAC_DBG_TPESTS_MASK)
N#define ENET_MAC_DBG_TFCSTS_MASK                 (0x60000U)
N#define ENET_MAC_DBG_TFCSTS_SHIFT                (17U)
N#define ENET_MAC_DBG_TFCSTS(x)                   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_DBG_TFCSTS_SHIFT)) & ENET_MAC_DBG_TFCSTS_MASK)
N
N/*! @name MAC_HW_FEAT - MAC hardware feature register 0x0201 */
N#define ENET_MAC_HW_FEAT_RXFIFOSIZE_MASK         (0x1FU)
N#define ENET_MAC_HW_FEAT_RXFIFOSIZE_SHIFT        (0U)
N#define ENET_MAC_HW_FEAT_RXFIFOSIZE(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_RXFIFOSIZE_SHIFT)) & ENET_MAC_HW_FEAT_RXFIFOSIZE_MASK)
N#define ENET_MAC_HW_FEAT_RXQCNT_MASK             (0xFU)
N#define ENET_MAC_HW_FEAT_RXQCNT_SHIFT            (0U)
N#define ENET_MAC_HW_FEAT_RXQCNT(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_RXQCNT_SHIFT)) & ENET_MAC_HW_FEAT_RXQCNT_MASK)
N#define ENET_MAC_HW_FEAT_MIISEL_MASK             (0x1U)
N#define ENET_MAC_HW_FEAT_MIISEL_SHIFT            (0U)
N#define ENET_MAC_HW_FEAT_MIISEL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_MIISEL_SHIFT)) & ENET_MAC_HW_FEAT_MIISEL_MASK)
N#define ENET_MAC_HW_FEAT_HDSEL_MASK              (0x4U)
N#define ENET_MAC_HW_FEAT_HDSEL_SHIFT             (2U)
N#define ENET_MAC_HW_FEAT_HDSEL(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_HDSEL_SHIFT)) & ENET_MAC_HW_FEAT_HDSEL_MASK)
N#define ENET_MAC_HW_FEAT_VLHASH_MASK             (0x10U)
N#define ENET_MAC_HW_FEAT_VLHASH_SHIFT            (4U)
N#define ENET_MAC_HW_FEAT_VLHASH(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_VLHASH_SHIFT)) & ENET_MAC_HW_FEAT_VLHASH_MASK)
N#define ENET_MAC_HW_FEAT_SMASEL_MASK             (0x20U)
N#define ENET_MAC_HW_FEAT_SMASEL_SHIFT            (5U)
N#define ENET_MAC_HW_FEAT_SMASEL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_SMASEL_SHIFT)) & ENET_MAC_HW_FEAT_SMASEL_MASK)
N#define ENET_MAC_HW_FEAT_TXQCNT_MASK             (0x3C0U)
N#define ENET_MAC_HW_FEAT_TXQCNT_SHIFT            (6U)
N#define ENET_MAC_HW_FEAT_TXQCNT(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TXQCNT_SHIFT)) & ENET_MAC_HW_FEAT_TXQCNT_MASK)
N#define ENET_MAC_HW_FEAT_RWKSEL_MASK             (0x40U)
N#define ENET_MAC_HW_FEAT_RWKSEL_SHIFT            (6U)
N#define ENET_MAC_HW_FEAT_RWKSEL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_RWKSEL_SHIFT)) & ENET_MAC_HW_FEAT_RWKSEL_MASK)
N#define ENET_MAC_HW_FEAT_TXFIFOSIZE_MASK         (0x7C0U)
N#define ENET_MAC_HW_FEAT_TXFIFOSIZE_SHIFT        (6U)
N#define ENET_MAC_HW_FEAT_TXFIFOSIZE(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TXFIFOSIZE_SHIFT)) & ENET_MAC_HW_FEAT_TXFIFOSIZE_MASK)
N#define ENET_MAC_HW_FEAT_MGKSEL_MASK             (0x80U)
N#define ENET_MAC_HW_FEAT_MGKSEL_SHIFT            (7U)
N#define ENET_MAC_HW_FEAT_MGKSEL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_MGKSEL_SHIFT)) & ENET_MAC_HW_FEAT_MGKSEL_MASK)
N#define ENET_MAC_HW_FEAT_MMCSEL_MASK             (0x100U)
N#define ENET_MAC_HW_FEAT_MMCSEL_SHIFT            (8U)
N#define ENET_MAC_HW_FEAT_MMCSEL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_MMCSEL_SHIFT)) & ENET_MAC_HW_FEAT_MMCSEL_MASK)
N#define ENET_MAC_HW_FEAT_ARPOFFSEL_MASK          (0x200U)
N#define ENET_MAC_HW_FEAT_ARPOFFSEL_SHIFT         (9U)
N#define ENET_MAC_HW_FEAT_ARPOFFSEL(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_ARPOFFSEL_SHIFT)) & ENET_MAC_HW_FEAT_ARPOFFSEL_MASK)
N#define ENET_MAC_HW_FEAT_OSTEN_MASK              (0x800U)
N#define ENET_MAC_HW_FEAT_OSTEN_SHIFT             (11U)
N#define ENET_MAC_HW_FEAT_OSTEN(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_OSTEN_SHIFT)) & ENET_MAC_HW_FEAT_OSTEN_MASK)
N#define ENET_MAC_HW_FEAT_RXCHCNT_MASK            (0xF000U)
N#define ENET_MAC_HW_FEAT_RXCHCNT_SHIFT           (12U)
N#define ENET_MAC_HW_FEAT_RXCHCNT(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_RXCHCNT_SHIFT)) & ENET_MAC_HW_FEAT_RXCHCNT_MASK)
N#define ENET_MAC_HW_FEAT_TSSEL_MASK              (0x1000U)
N#define ENET_MAC_HW_FEAT_TSSEL_SHIFT             (12U)
N#define ENET_MAC_HW_FEAT_TSSEL(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TSSEL_SHIFT)) & ENET_MAC_HW_FEAT_TSSEL_MASK)
N#define ENET_MAC_HW_FEAT_PTOEN_MASK              (0x1000U)
N#define ENET_MAC_HW_FEAT_PTOEN_SHIFT             (12U)
N#define ENET_MAC_HW_FEAT_PTOEN(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_PTOEN_SHIFT)) & ENET_MAC_HW_FEAT_PTOEN_MASK)
N#define ENET_MAC_HW_FEAT_EEESEL_MASK             (0x2000U)
N#define ENET_MAC_HW_FEAT_EEESEL_SHIFT            (13U)
N#define ENET_MAC_HW_FEAT_EEESEL(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_EEESEL_SHIFT)) & ENET_MAC_HW_FEAT_EEESEL_MASK)
N#define ENET_MAC_HW_FEAT_ADVTHWORD_MASK          (0x2000U)
N#define ENET_MAC_HW_FEAT_ADVTHWORD_SHIFT         (13U)
N#define ENET_MAC_HW_FEAT_ADVTHWORD(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_ADVTHWORD_SHIFT)) & ENET_MAC_HW_FEAT_ADVTHWORD_MASK)
N#define ENET_MAC_HW_FEAT_ADDR64_MASK             (0xC000U)
N#define ENET_MAC_HW_FEAT_ADDR64_SHIFT            (14U)
N#define ENET_MAC_HW_FEAT_ADDR64(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_ADDR64_SHIFT)) & ENET_MAC_HW_FEAT_ADDR64_MASK)
N#define ENET_MAC_HW_FEAT_TXCOESEL_MASK           (0x4000U)
N#define ENET_MAC_HW_FEAT_TXCOESEL_SHIFT          (14U)
N#define ENET_MAC_HW_FEAT_TXCOESEL(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TXCOESEL_SHIFT)) & ENET_MAC_HW_FEAT_TXCOESEL_MASK)
N#define ENET_MAC_HW_FEAT_DCBEN_MASK              (0x10000U)
N#define ENET_MAC_HW_FEAT_DCBEN_SHIFT             (16U)
N#define ENET_MAC_HW_FEAT_DCBEN(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_DCBEN_SHIFT)) & ENET_MAC_HW_FEAT_DCBEN_MASK)
N#define ENET_MAC_HW_FEAT_RXCOESEL_MASK           (0x10000U)
N#define ENET_MAC_HW_FEAT_RXCOESEL_SHIFT          (16U)
N#define ENET_MAC_HW_FEAT_RXCOESEL(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_RXCOESEL_SHIFT)) & ENET_MAC_HW_FEAT_RXCOESEL_MASK)
N#define ENET_MAC_HW_FEAT_SPEN_MASK               (0x20000U)
N#define ENET_MAC_HW_FEAT_SPEN_SHIFT              (17U)
N#define ENET_MAC_HW_FEAT_SPEN(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_SPEN_SHIFT)) & ENET_MAC_HW_FEAT_SPEN_MASK)
N#define ENET_MAC_HW_FEAT_TXCHCNT_MASK            (0x3C0000U)
N#define ENET_MAC_HW_FEAT_TXCHCNT_SHIFT           (18U)
N#define ENET_MAC_HW_FEAT_TXCHCNT(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TXCHCNT_SHIFT)) & ENET_MAC_HW_FEAT_TXCHCNT_MASK)
N#define ENET_MAC_HW_FEAT_TSOEN_MASK              (0x40000U)
N#define ENET_MAC_HW_FEAT_TSOEN_SHIFT             (18U)
N#define ENET_MAC_HW_FEAT_TSOEN(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TSOEN_SHIFT)) & ENET_MAC_HW_FEAT_TSOEN_MASK)
N#define ENET_MAC_HW_FEAT_DBGMEMA_MASK            (0x80000U)
N#define ENET_MAC_HW_FEAT_DBGMEMA_SHIFT           (19U)
N#define ENET_MAC_HW_FEAT_DBGMEMA(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_DBGMEMA_SHIFT)) & ENET_MAC_HW_FEAT_DBGMEMA_MASK)
N#define ENET_MAC_HW_FEAT_AVSEL_MASK              (0x100000U)
N#define ENET_MAC_HW_FEAT_AVSEL_SHIFT             (20U)
N#define ENET_MAC_HW_FEAT_AVSEL(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_AVSEL_SHIFT)) & ENET_MAC_HW_FEAT_AVSEL_MASK)
N#define ENET_MAC_HW_FEAT_LPMODEEN_MASK           (0x800000U)
N#define ENET_MAC_HW_FEAT_LPMODEEN_SHIFT          (23U)
N#define ENET_MAC_HW_FEAT_LPMODEEN(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_LPMODEEN_SHIFT)) & ENET_MAC_HW_FEAT_LPMODEEN_MASK)
N#define ENET_MAC_HW_FEAT_PPSOUTNUM_MASK          (0x7000000U)
N#define ENET_MAC_HW_FEAT_PPSOUTNUM_SHIFT         (24U)
N#define ENET_MAC_HW_FEAT_PPSOUTNUM(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_PPSOUTNUM_SHIFT)) & ENET_MAC_HW_FEAT_PPSOUTNUM_MASK)
N#define ENET_MAC_HW_FEAT_HASHTBLSZ_MASK          (0x3000000U)
N#define ENET_MAC_HW_FEAT_HASHTBLSZ_SHIFT         (24U)
N#define ENET_MAC_HW_FEAT_HASHTBLSZ(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_HASHTBLSZ_SHIFT)) & ENET_MAC_HW_FEAT_HASHTBLSZ_MASK)
N#define ENET_MAC_HW_FEAT_TSSTSSEL_MASK           (0x6000000U)
N#define ENET_MAC_HW_FEAT_TSSTSSEL_SHIFT          (25U)
N#define ENET_MAC_HW_FEAT_TSSTSSEL(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_TSSTSSEL_SHIFT)) & ENET_MAC_HW_FEAT_TSSTSSEL_MASK)
N#define ENET_MAC_HW_FEAT_L3_L4_FILTER_MASK       (0x78000000U)
N#define ENET_MAC_HW_FEAT_L3_L4_FILTER_SHIFT      (27U)
N#define ENET_MAC_HW_FEAT_L3_L4_FILTER(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_L3_L4_FILTER_SHIFT)) & ENET_MAC_HW_FEAT_L3_L4_FILTER_MASK)
N#define ENET_MAC_HW_FEAT_AUXSNAPNUM_MASK         (0x70000000U)
N#define ENET_MAC_HW_FEAT_AUXSNAPNUM_SHIFT        (28U)
N#define ENET_MAC_HW_FEAT_AUXSNAPNUM(x)           (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_AUXSNAPNUM_SHIFT)) & ENET_MAC_HW_FEAT_AUXSNAPNUM_MASK)
N#define ENET_MAC_HW_FEAT_ACTPHYSEL_MASK          (0x70000000U)
N#define ENET_MAC_HW_FEAT_ACTPHYSEL_SHIFT         (28U)
N#define ENET_MAC_HW_FEAT_ACTPHYSEL(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_HW_FEAT_ACTPHYSEL_SHIFT)) & ENET_MAC_HW_FEAT_ACTPHYSEL_MASK)
N
N/* The count of ENET_MAC_HW_FEAT */
N#define ENET_MAC_HW_FEAT_COUNT                   (3U)
N
N/*! @name MAC_MDIO_ADDR - MIDO address Register */
N#define ENET_MAC_MDIO_ADDR_MB_MASK               (0x1U)
N#define ENET_MAC_MDIO_ADDR_MB_SHIFT              (0U)
N#define ENET_MAC_MDIO_ADDR_MB(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_MB_SHIFT)) & ENET_MAC_MDIO_ADDR_MB_MASK)
N#define ENET_MAC_MDIO_ADDR_MOC_MASK              (0xCU)
N#define ENET_MAC_MDIO_ADDR_MOC_SHIFT             (2U)
N#define ENET_MAC_MDIO_ADDR_MOC(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_MOC_SHIFT)) & ENET_MAC_MDIO_ADDR_MOC_MASK)
N#define ENET_MAC_MDIO_ADDR_CR_MASK               (0xF00U)
N#define ENET_MAC_MDIO_ADDR_CR_SHIFT              (8U)
N#define ENET_MAC_MDIO_ADDR_CR(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_CR_SHIFT)) & ENET_MAC_MDIO_ADDR_CR_MASK)
N#define ENET_MAC_MDIO_ADDR_NTC_MASK              (0x7000U)
N#define ENET_MAC_MDIO_ADDR_NTC_SHIFT             (12U)
N#define ENET_MAC_MDIO_ADDR_NTC(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_NTC_SHIFT)) & ENET_MAC_MDIO_ADDR_NTC_MASK)
N#define ENET_MAC_MDIO_ADDR_RDA_MASK              (0x1F0000U)
N#define ENET_MAC_MDIO_ADDR_RDA_SHIFT             (16U)
N#define ENET_MAC_MDIO_ADDR_RDA(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_RDA_SHIFT)) & ENET_MAC_MDIO_ADDR_RDA_MASK)
N#define ENET_MAC_MDIO_ADDR_PA_MASK               (0x3E00000U)
N#define ENET_MAC_MDIO_ADDR_PA_SHIFT              (21U)
N#define ENET_MAC_MDIO_ADDR_PA(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_PA_SHIFT)) & ENET_MAC_MDIO_ADDR_PA_MASK)
N#define ENET_MAC_MDIO_ADDR_BTB_MASK              (0x4000000U)
N#define ENET_MAC_MDIO_ADDR_BTB_SHIFT             (26U)
N#define ENET_MAC_MDIO_ADDR_BTB(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_BTB_SHIFT)) & ENET_MAC_MDIO_ADDR_BTB_MASK)
N#define ENET_MAC_MDIO_ADDR_PSE_MASK              (0x8000000U)
N#define ENET_MAC_MDIO_ADDR_PSE_SHIFT             (27U)
N#define ENET_MAC_MDIO_ADDR_PSE(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_ADDR_PSE_SHIFT)) & ENET_MAC_MDIO_ADDR_PSE_MASK)
N
N/*! @name MAC_MDIO_DATA - MDIO Data register */
N#define ENET_MAC_MDIO_DATA_MD_MASK               (0xFFFFU)
N#define ENET_MAC_MDIO_DATA_MD_SHIFT              (0U)
N#define ENET_MAC_MDIO_DATA_MD(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_MDIO_DATA_MD_SHIFT)) & ENET_MAC_MDIO_DATA_MD_MASK)
N
N/*! @name MAC_ADDR_HIGH - MAC address0 high register */
N#define ENET_MAC_ADDR_HIGH_A47_32_MASK           (0xFFFFU)
N#define ENET_MAC_ADDR_HIGH_A47_32_SHIFT          (0U)
N#define ENET_MAC_ADDR_HIGH_A47_32(x)             (((uint32_t)(((uint32_t)(x)) << ENET_MAC_ADDR_HIGH_A47_32_SHIFT)) & ENET_MAC_ADDR_HIGH_A47_32_MASK)
N#define ENET_MAC_ADDR_HIGH_DCS_MASK              (0x10000U)
N#define ENET_MAC_ADDR_HIGH_DCS_SHIFT             (16U)
N#define ENET_MAC_ADDR_HIGH_DCS(x)                (((uint32_t)(((uint32_t)(x)) << ENET_MAC_ADDR_HIGH_DCS_SHIFT)) & ENET_MAC_ADDR_HIGH_DCS_MASK)
N#define ENET_MAC_ADDR_HIGH_AE_MASK               (0x80000000U)
N#define ENET_MAC_ADDR_HIGH_AE_SHIFT              (31U)
N#define ENET_MAC_ADDR_HIGH_AE(x)                 (((uint32_t)(((uint32_t)(x)) << ENET_MAC_ADDR_HIGH_AE_SHIFT)) & ENET_MAC_ADDR_HIGH_AE_MASK)
N
N/*! @name MAC_ADDR_LOW - MAC address0 low register */
N#define ENET_MAC_ADDR_LOW_A31_0_MASK             (0xFFFFFFFFU)
N#define ENET_MAC_ADDR_LOW_A31_0_SHIFT            (0U)
N#define ENET_MAC_ADDR_LOW_A31_0(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MAC_ADDR_LOW_A31_0_SHIFT)) & ENET_MAC_ADDR_LOW_A31_0_MASK)
N
N/*! @name MAC_TIMESTAMP_CTRL - Time stamp control register */
N#define ENET_MAC_TIMESTAMP_CTRL_TSENA_MASK       (0x1U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENA_SHIFT      (0U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENA(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSCFUPDT_MASK    (0x2U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSCFUPDT_SHIFT   (1U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSCFUPDT(x)      (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSCFUPDT_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSCFUPDT_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSINIT_MASK      (0x4U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSINIT_SHIFT     (2U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSINIT(x)        (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSINIT_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSINIT_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSUPDT_MASK      (0x8U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSUPDT_SHIFT     (3U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSUPDT(x)        (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSUPDT_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSUPDT_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSTRIG_MASK      (0x10U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSTRIG_SHIFT     (4U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSTRIG(x)        (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSTRIG_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSTRIG_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TADDREG_MASK     (0x20U)
N#define ENET_MAC_TIMESTAMP_CTRL_TADDREG_SHIFT    (5U)
N#define ENET_MAC_TIMESTAMP_CTRL_TADDREG(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TADDREG_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TADDREG_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENALL_MASK     (0x100U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENALL_SHIFT    (8U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENALL(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSENALL_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSENALL_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSCTRLSSR_MASK   (0x200U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSCTRLSSR_SHIFT  (9U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSCTRLSSR(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSCTRLSSR_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSCTRLSSR_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSVER2ENA_MASK   (0x400U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSVER2ENA_SHIFT  (10U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSVER2ENA(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSVER2ENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSVER2ENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPENA_MASK     (0x800U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPENA_SHIFT    (11U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPENA(x)       (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSIPENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSIPENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPV6ENA_MASK   (0x1000U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPV6ENA_SHIFT  (12U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPV6ENA(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSIPV6ENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSIPV6ENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPV4ENA_MASK   (0x2000U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPV4ENA_SHIFT  (13U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSIPV4ENA(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSIPV4ENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSIPV4ENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSEVTENA_MASK    (0x4000U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSEVTENA_SHIFT   (14U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSEVTENA(x)      (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSEVTENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSEVTENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSMSTRENA_MASK   (0x8000U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSMSTRENA_SHIFT  (15U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSMSTRENA(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSMSTRENA_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSMSTRENA_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_SNAPTYPSEL_MASK  (0x30000U)
N#define ENET_MAC_TIMESTAMP_CTRL_SNAPTYPSEL_SHIFT (16U)
N#define ENET_MAC_TIMESTAMP_CTRL_SNAPTYPSEL(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_SNAPTYPSEL_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_SNAPTYPSEL_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENMACADDR_MASK (0x40000U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENMACADDR_SHIFT (18U)
N#define ENET_MAC_TIMESTAMP_CTRL_TSENMACADDR(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TSENMACADDR_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TSENMACADDR_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_TXTTSSTSM_MASK   (0x1000000U)
N#define ENET_MAC_TIMESTAMP_CTRL_TXTTSSTSM_SHIFT  (24U)
N#define ENET_MAC_TIMESTAMP_CTRL_TXTTSSTSM(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_TXTTSSTSM_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_TXTTSSTSM_MASK)
N#define ENET_MAC_TIMESTAMP_CTRL_AV8021ASMEN_MASK (0x10000000U)
N#define ENET_MAC_TIMESTAMP_CTRL_AV8021ASMEN_SHIFT (28U)
N#define ENET_MAC_TIMESTAMP_CTRL_AV8021ASMEN(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MAC_TIMESTAMP_CTRL_AV8021ASMEN_SHIFT)) & ENET_MAC_TIMESTAMP_CTRL_AV8021ASMEN_MASK)
N
N/*! @name MAC_SUB_SCND_INCR - Sub-second increment register */
N#define ENET_MAC_SUB_SCND_INCR_SSINC_MASK        (0xFF0000U)
N#define ENET_MAC_SUB_SCND_INCR_SSINC_SHIFT       (16U)
N#define ENET_MAC_SUB_SCND_INCR_SSINC(x)          (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SUB_SCND_INCR_SSINC_SHIFT)) & ENET_MAC_SUB_SCND_INCR_SSINC_MASK)
N
N/*! @name MAC_SYS_TIME_SCND - System time seconds register */
N#define ENET_MAC_SYS_TIME_SCND_TSS_MASK          (0xFFFFFFFFU)
N#define ENET_MAC_SYS_TIME_SCND_TSS_SHIFT         (0U)
N#define ENET_MAC_SYS_TIME_SCND_TSS(x)            (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIME_SCND_TSS_SHIFT)) & ENET_MAC_SYS_TIME_SCND_TSS_MASK)
N
N/*! @name MAC_SYS_TIME_NSCND - System time nanoseconds register */
N#define ENET_MAC_SYS_TIME_NSCND_TSSS_MASK        (0x7FFFFFFFU)
N#define ENET_MAC_SYS_TIME_NSCND_TSSS_SHIFT       (0U)
N#define ENET_MAC_SYS_TIME_NSCND_TSSS(x)          (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIME_NSCND_TSSS_SHIFT)) & ENET_MAC_SYS_TIME_NSCND_TSSS_MASK)
N
N/*! @name MAC_SYS_TIME_SCND_UPD -  */
N#define ENET_MAC_SYS_TIME_SCND_UPD_TSS_MASK      (0xFFFFFFFFU)
N#define ENET_MAC_SYS_TIME_SCND_UPD_TSS_SHIFT     (0U)
N#define ENET_MAC_SYS_TIME_SCND_UPD_TSS(x)        (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIME_SCND_UPD_TSS_SHIFT)) & ENET_MAC_SYS_TIME_SCND_UPD_TSS_MASK)
N
N/*! @name MAC_SYS_TIME_NSCND_UPD -  */
N#define ENET_MAC_SYS_TIME_NSCND_UPD_TSSS_MASK    (0x7FFFFFFFU)
N#define ENET_MAC_SYS_TIME_NSCND_UPD_TSSS_SHIFT   (0U)
N#define ENET_MAC_SYS_TIME_NSCND_UPD_TSSS(x)      (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIME_NSCND_UPD_TSSS_SHIFT)) & ENET_MAC_SYS_TIME_NSCND_UPD_TSSS_MASK)
N#define ENET_MAC_SYS_TIME_NSCND_UPD_ADDSUB_MASK  (0x80000000U)
N#define ENET_MAC_SYS_TIME_NSCND_UPD_ADDSUB_SHIFT (31U)
N#define ENET_MAC_SYS_TIME_NSCND_UPD_ADDSUB(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIME_NSCND_UPD_ADDSUB_SHIFT)) & ENET_MAC_SYS_TIME_NSCND_UPD_ADDSUB_MASK)
N
N/*! @name MAC_SYS_TIMESTMP_ADDEND - Time stamp addend register */
N#define ENET_MAC_SYS_TIMESTMP_ADDEND_TSAR_MASK   (0xFFFFFFFFU)
N#define ENET_MAC_SYS_TIMESTMP_ADDEND_TSAR_SHIFT  (0U)
N#define ENET_MAC_SYS_TIMESTMP_ADDEND_TSAR(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIMESTMP_ADDEND_TSAR_SHIFT)) & ENET_MAC_SYS_TIMESTMP_ADDEND_TSAR_MASK)
N
N/*! @name MAC_SYS_TIME_HWORD_SCND -  */
N#define ENET_MAC_SYS_TIME_HWORD_SCND_TSHWR_MASK  (0xFFFFU)
N#define ENET_MAC_SYS_TIME_HWORD_SCND_TSHWR_SHIFT (0U)
N#define ENET_MAC_SYS_TIME_HWORD_SCND_TSHWR(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIME_HWORD_SCND_TSHWR_SHIFT)) & ENET_MAC_SYS_TIME_HWORD_SCND_TSHWR_MASK)
N
N/*! @name MAC_SYS_TIMESTMP_STAT - Time stamp status register */
N#define ENET_MAC_SYS_TIMESTMP_STAT_TSSOVF_MASK   (0x1U)
N#define ENET_MAC_SYS_TIMESTMP_STAT_TSSOVF_SHIFT  (0U)
N#define ENET_MAC_SYS_TIMESTMP_STAT_TSSOVF(x)     (((uint32_t)(((uint32_t)(x)) << ENET_MAC_SYS_TIMESTMP_STAT_TSSOVF_SHIFT)) & ENET_MAC_SYS_TIMESTMP_STAT_TSSOVF_MASK)
N
N/*! @name MTL_OP_MODE - MTL Operation Mode Register */
N#define ENET_MTL_OP_MODE_DTXSTS_MASK             (0x2U)
N#define ENET_MTL_OP_MODE_DTXSTS_SHIFT            (1U)
N#define ENET_MTL_OP_MODE_DTXSTS(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MTL_OP_MODE_DTXSTS_SHIFT)) & ENET_MTL_OP_MODE_DTXSTS_MASK)
N#define ENET_MTL_OP_MODE_RAA_MASK                (0x4U)
N#define ENET_MTL_OP_MODE_RAA_SHIFT               (2U)
N#define ENET_MTL_OP_MODE_RAA(x)                  (((uint32_t)(((uint32_t)(x)) << ENET_MTL_OP_MODE_RAA_SHIFT)) & ENET_MTL_OP_MODE_RAA_MASK)
N#define ENET_MTL_OP_MODE_SCHALG_MASK             (0x60U)
N#define ENET_MTL_OP_MODE_SCHALG_SHIFT            (5U)
N#define ENET_MTL_OP_MODE_SCHALG(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MTL_OP_MODE_SCHALG_SHIFT)) & ENET_MTL_OP_MODE_SCHALG_MASK)
N#define ENET_MTL_OP_MODE_CNTPRST_MASK            (0x100U)
N#define ENET_MTL_OP_MODE_CNTPRST_SHIFT           (8U)
N#define ENET_MTL_OP_MODE_CNTPRST(x)              (((uint32_t)(((uint32_t)(x)) << ENET_MTL_OP_MODE_CNTPRST_SHIFT)) & ENET_MTL_OP_MODE_CNTPRST_MASK)
N#define ENET_MTL_OP_MODE_CNTCLR_MASK             (0x200U)
N#define ENET_MTL_OP_MODE_CNTCLR_SHIFT            (9U)
N#define ENET_MTL_OP_MODE_CNTCLR(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MTL_OP_MODE_CNTCLR_SHIFT)) & ENET_MTL_OP_MODE_CNTCLR_MASK)
N
N/*! @name MTL_INTR_STAT - MTL Interrupt Status register */
N#define ENET_MTL_INTR_STAT_Q0IS_MASK             (0x1U)
N#define ENET_MTL_INTR_STAT_Q0IS_SHIFT            (0U)
N#define ENET_MTL_INTR_STAT_Q0IS(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MTL_INTR_STAT_Q0IS_SHIFT)) & ENET_MTL_INTR_STAT_Q0IS_MASK)
N#define ENET_MTL_INTR_STAT_Q1IS_MASK             (0x2U)
N#define ENET_MTL_INTR_STAT_Q1IS_SHIFT            (1U)
N#define ENET_MTL_INTR_STAT_Q1IS(x)               (((uint32_t)(((uint32_t)(x)) << ENET_MTL_INTR_STAT_Q1IS_SHIFT)) & ENET_MTL_INTR_STAT_Q1IS_MASK)
N
N/*! @name MTL_RXQ_DMA_MAP - MTL Receive Queue and DMA Channel Mapping register */
N#define ENET_MTL_RXQ_DMA_MAP_Q0MDMACH_MASK       (0x1U)
N#define ENET_MTL_RXQ_DMA_MAP_Q0MDMACH_SHIFT      (0U)
N#define ENET_MTL_RXQ_DMA_MAP_Q0MDMACH(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MTL_RXQ_DMA_MAP_Q0MDMACH_SHIFT)) & ENET_MTL_RXQ_DMA_MAP_Q0MDMACH_MASK)
N#define ENET_MTL_RXQ_DMA_MAP_Q0DDMACH_MASK       (0x10U)
N#define ENET_MTL_RXQ_DMA_MAP_Q0DDMACH_SHIFT      (4U)
N#define ENET_MTL_RXQ_DMA_MAP_Q0DDMACH(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MTL_RXQ_DMA_MAP_Q0DDMACH_SHIFT)) & ENET_MTL_RXQ_DMA_MAP_Q0DDMACH_MASK)
N#define ENET_MTL_RXQ_DMA_MAP_Q1MDMACH_MASK       (0x100U)
N#define ENET_MTL_RXQ_DMA_MAP_Q1MDMACH_SHIFT      (8U)
N#define ENET_MTL_RXQ_DMA_MAP_Q1MDMACH(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MTL_RXQ_DMA_MAP_Q1MDMACH_SHIFT)) & ENET_MTL_RXQ_DMA_MAP_Q1MDMACH_MASK)
N#define ENET_MTL_RXQ_DMA_MAP_Q1DDMACH_MASK       (0x1000U)
N#define ENET_MTL_RXQ_DMA_MAP_Q1DDMACH_SHIFT      (12U)
N#define ENET_MTL_RXQ_DMA_MAP_Q1DDMACH(x)         (((uint32_t)(((uint32_t)(x)) << ENET_MTL_RXQ_DMA_MAP_Q1DDMACH_SHIFT)) & ENET_MTL_RXQ_DMA_MAP_Q1DDMACH_MASK)
N
N/*! @name MTL_QUEUE_MTL_TXQX_OP_MODE - MTL TxQx Operation Mode register */
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_FTQ_MASK (0x1U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_FTQ_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_FTQ(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_FTQ_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_FTQ_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TSF_MASK (0x2U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TSF_SHIFT (1U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TSF(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TSF_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TSF_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN_MASK (0xCU)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN_SHIFT (2U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TTC_MASK (0x70U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TTC_SHIFT (4U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TTC(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TTC_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TTC_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TQS_MASK (0x70000U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TQS_SHIFT (16U)
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TQS(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TQS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TQS_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_TXQX_OP_MODE */
N#define ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_COUNT    (2U)
N
N/*! @name MTL_QUEUE_MTL_TXQX_UNDRFLW - MTL TxQx Underflow register */
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFFRMCNT_MASK (0x7FFU)
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFFRMCNT_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFFRMCNT(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFFRMCNT_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFFRMCNT_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFCNTOVF_MASK (0x800U)
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFCNTOVF_SHIFT (11U)
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFCNTOVF(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFCNTOVF_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_UFCNTOVF_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW */
N#define ENET_MTL_QUEUE_MTL_TXQX_UNDRFLW_COUNT    (2U)
N
N/*! @name MTL_QUEUE_MTL_TXQX_DBG - MTL TxQx Debug register */
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQPAUSED_MASK (0x1U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQPAUSED_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQPAUSED(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQPAUSED_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQPAUSED_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TRCSTS_MASK  (0x6U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TRCSTS_SHIFT (1U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TRCSTS(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_TRCSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_TRCSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TWCSTS_MASK  (0x8U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TWCSTS_SHIFT (3U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TWCSTS(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_TWCSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_TWCSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQSTS_MASK  (0x10U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQSTS_SHIFT (4U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQSTS(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_TXQSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXSTSFSTS_MASK (0x20U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXSTSFSTS_SHIFT (5U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_TXSTSFSTS(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_TXSTSFSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_TXSTSFSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_PTXQ_MASK    (0x70000U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_PTXQ_SHIFT   (16U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_PTXQ(x)      (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_PTXQ_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_PTXQ_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_STSXSTSF_MASK (0x700000U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_STSXSTSF_SHIFT (20U)
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_STSXSTSF(x)  (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_DBG_STSXSTSF_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_DBG_STSXSTSF_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_TXQX_DBG */
N#define ENET_MTL_QUEUE_MTL_TXQX_DBG_COUNT        (2U)
N
N/*! @name MTL_QUEUE_MTL_TXQX_ETS_STAT - MTL TxQx ETS Status register */
N#define ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT_ABS_MASK (0xFFFFFFU)
N#define ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT_ABS_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT_ABS(x)  (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT_ABS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT_ABS_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT */
N#define ENET_MTL_QUEUE_MTL_TXQX_ETS_STAT_COUNT   (2U)
N
N/*! @name MTL_QUEUE_MTL_TXQX_QNTM_WGHT -  */
N#define ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT_ISCQW_MASK (0x1FFFFFU)
N#define ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT_ISCQW_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT_ISCQW(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT_ISCQW_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT_ISCQW_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT */
N#define ENET_MTL_QUEUE_MTL_TXQX_QNTM_WGHT_COUNT  (2U)
N
N/*! @name MTL_QUEUE_MTL_TXQX_INTCTRL_STAT -  */
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUNFIS_MASK (0x1U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUNFIS_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUNFIS(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUNFIS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUNFIS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIS_MASK (0x2U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIS_SHIFT (1U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIS(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUIE_MASK (0x100U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUIE_SHIFT (8U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUIE(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUIE_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_TXUIE_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIE_MASK (0x200U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIE_SHIFT (9U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIE(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIE_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_ABPSIE_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOVFIS_MASK (0x10000U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOVFIS_SHIFT (16U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOVFIS(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOVFIS_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOVFIS_MASK)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOIE_MASK (0x1000000U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOIE_SHIFT (24U)
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOIE(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOIE_SHIFT)) & ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_RXOIE_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT */
N#define ENET_MTL_QUEUE_MTL_TXQX_INTCTRL_STAT_COUNT (2U)
N
N/*! @name MTL_QUEUE_MTL_RXQX_OP_MODE - MTL RxQx Operation Mode register */
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RTC_MASK (0x3U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RTC_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RTC(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RTC_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RTC_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FUP_MASK (0x8U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FUP_SHIFT (3U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FUP(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FUP_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FUP_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FEP_MASK (0x10U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FEP_SHIFT (4U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FEP(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FEP_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FEP_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RSF_MASK (0x20U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RSF_SHIFT (5U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RSF(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RSF_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RSF_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_DIS_TCP_EF_MASK (0x40U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_DIS_TCP_EF_SHIFT (6U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_DIS_TCP_EF(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_DIS_TCP_EF_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_DIS_TCP_EF_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RQS_MASK (0x700000U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RQS_SHIFT (20U)
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RQS(x)   (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RQS_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RQS_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_RXQX_OP_MODE */
N#define ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_COUNT    (2U)
N
N/*! @name MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT - MTL RxQx Missed Packet Overflow Counter register */
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFPKTCNT_MASK (0x7FFU)
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFPKTCNT_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFPKTCNT(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFPKTCNT_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFPKTCNT_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFCNTOVF_MASK (0x800U)
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFCNTOVF_SHIFT (11U)
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFCNTOVF(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFCNTOVF_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_OVFCNTOVF_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT */
N#define ENET_MTL_QUEUE_MTL_RXQX_MISSPKT_OVRFLW_CNT_COUNT (2U)
N
N/*! @name MTL_QUEUE_MTL_RXQX_DBG - MTL RxQx Debug register */
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RWCSTS_MASK  (0x1U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RWCSTS_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RWCSTS(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_DBG_RWCSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_DBG_RWCSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RRCSTS_MASK  (0x6U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RRCSTS_SHIFT (1U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RRCSTS(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_DBG_RRCSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_DBG_RRCSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RXQSTS_MASK  (0x30U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RXQSTS_SHIFT (4U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_RXQSTS(x)    (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_DBG_RXQSTS_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_DBG_RXQSTS_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_PRXQ_MASK    (0x3FFF0000U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_PRXQ_SHIFT   (16U)
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_PRXQ(x)      (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_DBG_PRXQ_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_DBG_PRXQ_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_RXQX_DBG */
N#define ENET_MTL_QUEUE_MTL_RXQX_DBG_COUNT        (2U)
N
N/*! @name MTL_QUEUE_MTL_RXQX_CTRL - MTL RxQx Control register */
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_WEGT_MASK (0x7U)
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_WEGT_SHIFT (0U)
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_WEGT(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_WEGT_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_WEGT_MASK)
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_FRM_ARBIT_MASK (0x8U)
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_FRM_ARBIT_SHIFT (3U)
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_FRM_ARBIT(x) (((uint32_t)(((uint32_t)(x)) << ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_FRM_ARBIT_SHIFT)) & ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_FRM_ARBIT_MASK)
N
N/* The count of ENET_MTL_QUEUE_MTL_RXQX_CTRL */
N#define ENET_MTL_QUEUE_MTL_RXQX_CTRL_COUNT       (2U)
N
N/*! @name DMA_MODE - DMA mode register */
N#define ENET_DMA_MODE_SWR_MASK                   (0x1U)
N#define ENET_DMA_MODE_SWR_SHIFT                  (0U)
N#define ENET_DMA_MODE_SWR(x)                     (((uint32_t)(((uint32_t)(x)) << ENET_DMA_MODE_SWR_SHIFT)) & ENET_DMA_MODE_SWR_MASK)
N#define ENET_DMA_MODE_DA_MASK                    (0x2U)
N#define ENET_DMA_MODE_DA_SHIFT                   (1U)
N#define ENET_DMA_MODE_DA(x)                      (((uint32_t)(((uint32_t)(x)) << ENET_DMA_MODE_DA_SHIFT)) & ENET_DMA_MODE_DA_MASK)
N#define ENET_DMA_MODE_TAA_MASK                   (0x1CU)
N#define ENET_DMA_MODE_TAA_SHIFT                  (2U)
N#define ENET_DMA_MODE_TAA(x)                     (((uint32_t)(((uint32_t)(x)) << ENET_DMA_MODE_TAA_SHIFT)) & ENET_DMA_MODE_TAA_MASK)
N#define ENET_DMA_MODE_TXPR_MASK                  (0x800U)
N#define ENET_DMA_MODE_TXPR_SHIFT                 (11U)
N#define ENET_DMA_MODE_TXPR(x)                    (((uint32_t)(((uint32_t)(x)) << ENET_DMA_MODE_TXPR_SHIFT)) & ENET_DMA_MODE_TXPR_MASK)
N#define ENET_DMA_MODE_PR_MASK                    (0x7000U)
N#define ENET_DMA_MODE_PR_SHIFT                   (12U)
N#define ENET_DMA_MODE_PR(x)                      (((uint32_t)(((uint32_t)(x)) << ENET_DMA_MODE_PR_SHIFT)) & ENET_DMA_MODE_PR_MASK)
N
N/*! @name DMA_SYSBUS_MODE - DMA System Bus mode */
N#define ENET_DMA_SYSBUS_MODE_FB_MASK             (0x1U)
N#define ENET_DMA_SYSBUS_MODE_FB_SHIFT            (0U)
N#define ENET_DMA_SYSBUS_MODE_FB(x)               (((uint32_t)(((uint32_t)(x)) << ENET_DMA_SYSBUS_MODE_FB_SHIFT)) & ENET_DMA_SYSBUS_MODE_FB_MASK)
N#define ENET_DMA_SYSBUS_MODE_AAL_MASK            (0x1000U)
N#define ENET_DMA_SYSBUS_MODE_AAL_SHIFT           (12U)
N#define ENET_DMA_SYSBUS_MODE_AAL(x)              (((uint32_t)(((uint32_t)(x)) << ENET_DMA_SYSBUS_MODE_AAL_SHIFT)) & ENET_DMA_SYSBUS_MODE_AAL_MASK)
N#define ENET_DMA_SYSBUS_MODE_MB_MASK             (0x4000U)
N#define ENET_DMA_SYSBUS_MODE_MB_SHIFT            (14U)
N#define ENET_DMA_SYSBUS_MODE_MB(x)               (((uint32_t)(((uint32_t)(x)) << ENET_DMA_SYSBUS_MODE_MB_SHIFT)) & ENET_DMA_SYSBUS_MODE_MB_MASK)
N#define ENET_DMA_SYSBUS_MODE_RB_MASK             (0x8000U)
N#define ENET_DMA_SYSBUS_MODE_RB_SHIFT            (15U)
N#define ENET_DMA_SYSBUS_MODE_RB(x)               (((uint32_t)(((uint32_t)(x)) << ENET_DMA_SYSBUS_MODE_RB_SHIFT)) & ENET_DMA_SYSBUS_MODE_RB_MASK)
N
N/*! @name DMA_INTR_STAT - DMA Interrupt status */
N#define ENET_DMA_INTR_STAT_DC0IS_MASK            (0x1U)
N#define ENET_DMA_INTR_STAT_DC0IS_SHIFT           (0U)
N#define ENET_DMA_INTR_STAT_DC0IS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_DMA_INTR_STAT_DC0IS_SHIFT)) & ENET_DMA_INTR_STAT_DC0IS_MASK)
N#define ENET_DMA_INTR_STAT_DC1IS_MASK            (0x2U)
N#define ENET_DMA_INTR_STAT_DC1IS_SHIFT           (1U)
N#define ENET_DMA_INTR_STAT_DC1IS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_DMA_INTR_STAT_DC1IS_SHIFT)) & ENET_DMA_INTR_STAT_DC1IS_MASK)
N#define ENET_DMA_INTR_STAT_MTLIS_MASK            (0x10000U)
N#define ENET_DMA_INTR_STAT_MTLIS_SHIFT           (16U)
N#define ENET_DMA_INTR_STAT_MTLIS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_DMA_INTR_STAT_MTLIS_SHIFT)) & ENET_DMA_INTR_STAT_MTLIS_MASK)
N#define ENET_DMA_INTR_STAT_MACIS_MASK            (0x20000U)
N#define ENET_DMA_INTR_STAT_MACIS_SHIFT           (17U)
N#define ENET_DMA_INTR_STAT_MACIS(x)              (((uint32_t)(((uint32_t)(x)) << ENET_DMA_INTR_STAT_MACIS_SHIFT)) & ENET_DMA_INTR_STAT_MACIS_MASK)
N
N/*! @name DMA_DBG_STAT - DMA Debug Status */
N#define ENET_DMA_DBG_STAT_AHSTS_MASK             (0x1U)
N#define ENET_DMA_DBG_STAT_AHSTS_SHIFT            (0U)
N#define ENET_DMA_DBG_STAT_AHSTS(x)               (((uint32_t)(((uint32_t)(x)) << ENET_DMA_DBG_STAT_AHSTS_SHIFT)) & ENET_DMA_DBG_STAT_AHSTS_MASK)
N#define ENET_DMA_DBG_STAT_RPS0_MASK              (0xF00U)
N#define ENET_DMA_DBG_STAT_RPS0_SHIFT             (8U)
N#define ENET_DMA_DBG_STAT_RPS0(x)                (((uint32_t)(((uint32_t)(x)) << ENET_DMA_DBG_STAT_RPS0_SHIFT)) & ENET_DMA_DBG_STAT_RPS0_MASK)
N#define ENET_DMA_DBG_STAT_TPS0_MASK              (0xF000U)
N#define ENET_DMA_DBG_STAT_TPS0_SHIFT             (12U)
N#define ENET_DMA_DBG_STAT_TPS0(x)                (((uint32_t)(((uint32_t)(x)) << ENET_DMA_DBG_STAT_TPS0_SHIFT)) & ENET_DMA_DBG_STAT_TPS0_MASK)
N#define ENET_DMA_DBG_STAT_RPS1_MASK              (0xF0000U)
N#define ENET_DMA_DBG_STAT_RPS1_SHIFT             (16U)
N#define ENET_DMA_DBG_STAT_RPS1(x)                (((uint32_t)(((uint32_t)(x)) << ENET_DMA_DBG_STAT_RPS1_SHIFT)) & ENET_DMA_DBG_STAT_RPS1_MASK)
N#define ENET_DMA_DBG_STAT_TPS1_MASK              (0xF00000U)
N#define ENET_DMA_DBG_STAT_TPS1_SHIFT             (20U)
N#define ENET_DMA_DBG_STAT_TPS1(x)                (((uint32_t)(((uint32_t)(x)) << ENET_DMA_DBG_STAT_TPS1_SHIFT)) & ENET_DMA_DBG_STAT_TPS1_MASK)
N
N/*! @name DMA_CH_DMA_CHX_CTRL - DMA Channelx Control */
N#define ENET_DMA_CH_DMA_CHX_CTRL_PBLx8_MASK      (0x10000U)
N#define ENET_DMA_CH_DMA_CHX_CTRL_PBLx8_SHIFT     (16U)
N#define ENET_DMA_CH_DMA_CHX_CTRL_PBLx8(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_CTRL_PBLx8_SHIFT)) & ENET_DMA_CH_DMA_CHX_CTRL_PBLx8_MASK)
N#define ENET_DMA_CH_DMA_CHX_CTRL_DSL_MASK        (0x1C0000U)
N#define ENET_DMA_CH_DMA_CHX_CTRL_DSL_SHIFT       (18U)
N#define ENET_DMA_CH_DMA_CHX_CTRL_DSL(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_CTRL_DSL_SHIFT)) & ENET_DMA_CH_DMA_CHX_CTRL_DSL_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_CTRL */
N#define ENET_DMA_CH_DMA_CHX_CTRL_COUNT           (2U)
N
N/*! @name DMA_CH_DMA_CHX_TX_CTRL - DMA Channelx Transmit Control */
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_MASK      (0x1U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_SHIFT     (0U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_ST(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_SHIFT)) & ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_MASK)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_TCW_MASK     (0xEU)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_TCW_SHIFT    (1U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_TCW(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TX_CTRL_TCW_SHIFT)) & ENET_DMA_CH_DMA_CHX_TX_CTRL_TCW_MASK)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_OSF_MASK     (0x10U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_OSF_SHIFT    (4U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_OSF(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TX_CTRL_OSF_SHIFT)) & ENET_DMA_CH_DMA_CHX_TX_CTRL_OSF_MASK)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL_MASK   (0x3F0000U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL_SHIFT  (16U)
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL(x)     (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL_SHIFT)) & ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_TX_CTRL */
N#define ENET_DMA_CH_DMA_CHX_TX_CTRL_COUNT        (2U)
N
N/*! @name DMA_CH_DMA_CHX_RX_CTRL - DMA Channelx Receive Control */
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_SR_MASK      (0x1U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_SR_SHIFT     (0U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_SR(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RX_CTRL_SR_SHIFT)) & ENET_DMA_CH_DMA_CHX_RX_CTRL_SR_MASK)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ_MASK    (0x7FF8U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ_SHIFT   (3U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ(x)      (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ_SHIFT)) & ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ_MASK)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL_MASK   (0x3F0000U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL_SHIFT  (16U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL(x)     (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL_SHIFT)) & ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL_MASK)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RPF_MASK     (0x80000000U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RPF_SHIFT    (31U)
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_RPF(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RX_CTRL_RPF_SHIFT)) & ENET_DMA_CH_DMA_CHX_RX_CTRL_RPF_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_RX_CTRL */
N#define ENET_DMA_CH_DMA_CHX_RX_CTRL_COUNT        (2U)
N
N/*! @name DMA_CH_DMA_CHX_TXDESC_LIST_ADDR -  */
N#define ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL_MASK (0xFFFFFFFCU)
N#define ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL_SHIFT (2U)
N#define ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL_SHIFT)) & ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR */
N#define ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_RXDESC_LIST_ADDR -  */
N#define ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL_MASK (0xFFFFFFFCU)
N#define ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL_SHIFT (2U)
N#define ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL_SHIFT)) & ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR */
N#define ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_TXDESC_TAIL_PTR -  */
N#define ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR_TDTP_MASK (0xFFFFFFFCU)
N#define ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR_TDTP_SHIFT (2U)
N#define ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR_TDTP(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR_TDTP_SHIFT)) & ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR_TDTP_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR */
N#define ENET_DMA_CH_DMA_CHX_TXDESC_TAIL_PTR_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_RXDESC_TAIL_PTR -  */
N#define ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR_RDTP_MASK (0xFFFFFFFCU)
N#define ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR_RDTP_SHIFT (2U)
N#define ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR_RDTP(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR_RDTP_SHIFT)) & ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR_RDTP_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR */
N#define ENET_DMA_CH_DMA_CHX_RXDESC_TAIL_PTR_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_TXDESC_RING_LENGTH -  */
N#define ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_TDRL_MASK (0x3FFU)
N#define ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_TDRL_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_TDRL(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_TDRL_SHIFT)) & ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_TDRL_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH */
N#define ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_RXDESC_RING_LENGTH - Channelx Rx descriptor Ring Length */
N#define ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_RDRL_MASK (0x3FFU)
N#define ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_RDRL_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_RDRL(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_RDRL_SHIFT)) & ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_RDRL_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH */
N#define ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_INT_EN - Channelx Interrupt Enable */
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TIE_MASK      (0x1U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TIE_SHIFT     (0U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TIE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_TIE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_TIE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TSE_MASK      (0x2U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TSE_SHIFT     (1U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TSE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_TSE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_TSE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TBUE_MASK     (0x4U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TBUE_SHIFT    (2U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_TBUE(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_TBUE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_TBUE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RIE_MASK      (0x40U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RIE_SHIFT     (6U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RIE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_RIE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_RIE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RBUE_MASK     (0x80U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RBUE_SHIFT    (7U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RBUE(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_RBUE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_RBUE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RSE_MASK      (0x100U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RSE_SHIFT     (8U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RSE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_RSE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_RSE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RWTE_MASK     (0x200U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RWTE_SHIFT    (9U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_RWTE(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_RWTE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_RWTE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_ETIE_MASK     (0x400U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_ETIE_SHIFT    (10U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_ETIE(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_ETIE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_ETIE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_ERIE_MASK     (0x800U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_ERIE_SHIFT    (11U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_ERIE(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_ERIE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_ERIE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_FBEE_MASK     (0x1000U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_FBEE_SHIFT    (12U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_FBEE(x)       (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_FBEE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_FBEE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_AIE_MASK      (0x4000U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_AIE_SHIFT     (14U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_AIE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_AIE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_AIE_MASK)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_NIE_MASK      (0x8000U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_NIE_SHIFT     (15U)
N#define ENET_DMA_CH_DMA_CHX_INT_EN_NIE(x)        (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_INT_EN_NIE_SHIFT)) & ENET_DMA_CH_DMA_CHX_INT_EN_NIE_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_INT_EN */
N#define ENET_DMA_CH_DMA_CHX_INT_EN_COUNT         (2U)
N
N/*! @name DMA_CH_DMA_CHX_RX_INT_WDTIMER - Receive Interrupt Watchdog Timer */
N#define ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER_RIWT_MASK (0xFFU)
N#define ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER_RIWT_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER_RIWT(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER_RIWT_SHIFT)) & ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER_RIWT_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER */
N#define ENET_DMA_CH_DMA_CHX_RX_INT_WDTIMER_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT - Slot Function Control and Status */
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ESC_MASK (0x1U)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ESC_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ESC(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ESC_SHIFT)) & ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ESC_MASK)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ASC_MASK (0x2U)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ASC_SHIFT (1U)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ASC(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ASC_SHIFT)) & ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_ASC_MASK)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_RSN_MASK (0xF0000U)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_RSN_SHIFT (16U)
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_RSN(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_RSN_SHIFT)) & ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_RSN_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT */
N#define ENET_DMA_CH_DMA_CHX_SLOT_FUNC_CTRL_STAT_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_CUR_HST_TXDESC - Channelx Current Host Transmit descriptor */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC_HTD_MASK (0xFFFFFFFFU)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC_HTD_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC_HTD(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC_HTD_SHIFT)) & ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC_HTD_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXDESC_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_CUR_HST_RXDESC -  */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC_HRD_MASK (0xFFFFFFFFU)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC_HRD_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC_HRD(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC_HRD_SHIFT)) & ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC_HRD_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXDESC_COUNT (2U)
N
N/*! @name DMA_CH_DMA_CHX_CUR_HST_TXBUF -  */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF_HTB_MASK (0xFFFFFFFFU)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF_HTB_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF_HTB(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF_HTB_SHIFT)) & ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF_HTB_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_TXBUF_COUNT  (2U)
N
N/*! @name DMA_CH_DMA_CHX_CUR_HST_RXBUF - Channelx Current Application Receive Buffer Address */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF_HRB_MASK (0xFFFFFFFFU)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF_HRB_SHIFT (0U)
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF_HRB(x) (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF_HRB_SHIFT)) & ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF_HRB_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF */
N#define ENET_DMA_CH_DMA_CHX_CUR_HST_RXBUF_COUNT  (2U)
N
N/*! @name DMA_CH_DMA_CHX_STAT - Channelx DMA status register */
N#define ENET_DMA_CH_DMA_CHX_STAT_TI_MASK         (0x1U)
N#define ENET_DMA_CH_DMA_CHX_STAT_TI_SHIFT        (0U)
N#define ENET_DMA_CH_DMA_CHX_STAT_TI(x)           (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_TI_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_TI_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_TPS_MASK        (0x2U)
N#define ENET_DMA_CH_DMA_CHX_STAT_TPS_SHIFT       (1U)
N#define ENET_DMA_CH_DMA_CHX_STAT_TPS(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_TPS_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_TPS_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_TBU_MASK        (0x4U)
N#define ENET_DMA_CH_DMA_CHX_STAT_TBU_SHIFT       (2U)
N#define ENET_DMA_CH_DMA_CHX_STAT_TBU(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_TBU_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_TBU_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_RI_MASK         (0x40U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RI_SHIFT        (6U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RI(x)           (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_RI_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_RI_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_RBU_MASK        (0x80U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RBU_SHIFT       (7U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RBU(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_RBU_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_RBU_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_RPS_MASK        (0x100U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RPS_SHIFT       (8U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RPS(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_RPS_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_RPS_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_RWT_MASK        (0x200U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RWT_SHIFT       (9U)
N#define ENET_DMA_CH_DMA_CHX_STAT_RWT(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_RWT_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_RWT_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_ETI_MASK        (0x400U)
N#define ENET_DMA_CH_DMA_CHX_STAT_ETI_SHIFT       (10U)
N#define ENET_DMA_CH_DMA_CHX_STAT_ETI(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_ETI_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_ETI_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_ERI_MASK        (0x800U)
N#define ENET_DMA_CH_DMA_CHX_STAT_ERI_SHIFT       (11U)
N#define ENET_DMA_CH_DMA_CHX_STAT_ERI(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_ERI_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_ERI_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_FBE_MASK        (0x1000U)
N#define ENET_DMA_CH_DMA_CHX_STAT_FBE_SHIFT       (12U)
N#define ENET_DMA_CH_DMA_CHX_STAT_FBE(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_FBE_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_FBE_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_AIS_MASK        (0x4000U)
N#define ENET_DMA_CH_DMA_CHX_STAT_AIS_SHIFT       (14U)
N#define ENET_DMA_CH_DMA_CHX_STAT_AIS(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_AIS_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_AIS_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_NIS_MASK        (0x8000U)
N#define ENET_DMA_CH_DMA_CHX_STAT_NIS_SHIFT       (15U)
N#define ENET_DMA_CH_DMA_CHX_STAT_NIS(x)          (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_NIS_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_NIS_MASK)
N#define ENET_DMA_CH_DMA_CHX_STAT_EB_MASK         (0x70000U)
N#define ENET_DMA_CH_DMA_CHX_STAT_EB_SHIFT        (16U)
N#define ENET_DMA_CH_DMA_CHX_STAT_EB(x)           (((uint32_t)(((uint32_t)(x)) << ENET_DMA_CH_DMA_CHX_STAT_EB_SHIFT)) & ENET_DMA_CH_DMA_CHX_STAT_EB_MASK)
N
N/* The count of ENET_DMA_CH_DMA_CHX_STAT */
N#define ENET_DMA_CH_DMA_CHX_STAT_COUNT           (2U)
N
N
N/*!
N * @}
N */ /* end of group ENET_Register_Masks */
N
N
N/* ENET - Peripheral instance base addresses */
N/** Peripheral ENET base address */
N#define ENET_BASE                                (0x40092000u)
N/** Peripheral ENET base pointer */
N#define ENET                                     ((ENET_Type *)ENET_BASE)
N/** Array initializer of ENET peripheral base addresses */
N#define ENET_BASE_ADDRS                          { ENET_BASE }
N/** Array initializer of ENET peripheral base pointers */
N#define ENET_BASE_PTRS                           { ENET }
N/** Interrupt vectors for the ENET peripheral type */
N#define ENET_IRQS                                { ETHERNET_IRQn }
N#define ENET_PMT_IRQS                            { ETHERNET_PMT_IRQn }
N#define ENET_MACLP_IRQS                          { ETHERNET_MACLP_IRQn }
N
N/*!
N * @}
N */ /* end of group ENET_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- FLEXCOMM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup FLEXCOMM_Peripheral_Access_Layer FLEXCOMM Peripheral Access Layer
N * @{
N */
N
N/** FLEXCOMM - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[4088];
N  __IO uint32_t PSELID;                            /**< Peripheral Select and Flexcomm ID register., offset: 0xFF8 */
X  volatile uint32_t PSELID;                             
N  __IO uint32_t PID;                               /**< Peripheral identification register., offset: 0xFFC */
X  volatile uint32_t PID;                                
N} FLEXCOMM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- FLEXCOMM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup FLEXCOMM_Register_Masks FLEXCOMM Register Masks
N * @{
N */
N
N/*! @name PSELID - Peripheral Select and Flexcomm ID register. */
N#define FLEXCOMM_PSELID_PERSEL_MASK              (0x7U)
N#define FLEXCOMM_PSELID_PERSEL_SHIFT             (0U)
N#define FLEXCOMM_PSELID_PERSEL(x)                (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_PERSEL_SHIFT)) & FLEXCOMM_PSELID_PERSEL_MASK)
N#define FLEXCOMM_PSELID_LOCK_MASK                (0x8U)
N#define FLEXCOMM_PSELID_LOCK_SHIFT               (3U)
N#define FLEXCOMM_PSELID_LOCK(x)                  (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_LOCK_SHIFT)) & FLEXCOMM_PSELID_LOCK_MASK)
N#define FLEXCOMM_PSELID_USARTPRESENT_MASK        (0x10U)
N#define FLEXCOMM_PSELID_USARTPRESENT_SHIFT       (4U)
N#define FLEXCOMM_PSELID_USARTPRESENT(x)          (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_USARTPRESENT_SHIFT)) & FLEXCOMM_PSELID_USARTPRESENT_MASK)
N#define FLEXCOMM_PSELID_SPIPRESENT_MASK          (0x20U)
N#define FLEXCOMM_PSELID_SPIPRESENT_SHIFT         (5U)
N#define FLEXCOMM_PSELID_SPIPRESENT(x)            (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_SPIPRESENT_SHIFT)) & FLEXCOMM_PSELID_SPIPRESENT_MASK)
N#define FLEXCOMM_PSELID_I2CPRESENT_MASK          (0x40U)
N#define FLEXCOMM_PSELID_I2CPRESENT_SHIFT         (6U)
N#define FLEXCOMM_PSELID_I2CPRESENT(x)            (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_I2CPRESENT_SHIFT)) & FLEXCOMM_PSELID_I2CPRESENT_MASK)
N#define FLEXCOMM_PSELID_I2SPRESENT_MASK          (0x80U)
N#define FLEXCOMM_PSELID_I2SPRESENT_SHIFT         (7U)
N#define FLEXCOMM_PSELID_I2SPRESENT(x)            (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_I2SPRESENT_SHIFT)) & FLEXCOMM_PSELID_I2SPRESENT_MASK)
N#define FLEXCOMM_PSELID_ID_MASK                  (0xFFFFF000U)
N#define FLEXCOMM_PSELID_ID_SHIFT                 (12U)
N#define FLEXCOMM_PSELID_ID(x)                    (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PSELID_ID_SHIFT)) & FLEXCOMM_PSELID_ID_MASK)
N
N/*! @name PID - Peripheral identification register. */
N#define FLEXCOMM_PID_Minor_Rev_MASK              (0xF00U)
N#define FLEXCOMM_PID_Minor_Rev_SHIFT             (8U)
N#define FLEXCOMM_PID_Minor_Rev(x)                (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PID_Minor_Rev_SHIFT)) & FLEXCOMM_PID_Minor_Rev_MASK)
N#define FLEXCOMM_PID_Major_Rev_MASK              (0xF000U)
N#define FLEXCOMM_PID_Major_Rev_SHIFT             (12U)
N#define FLEXCOMM_PID_Major_Rev(x)                (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PID_Major_Rev_SHIFT)) & FLEXCOMM_PID_Major_Rev_MASK)
N#define FLEXCOMM_PID_ID_MASK                     (0xFFFF0000U)
N#define FLEXCOMM_PID_ID_SHIFT                    (16U)
N#define FLEXCOMM_PID_ID(x)                       (((uint32_t)(((uint32_t)(x)) << FLEXCOMM_PID_ID_SHIFT)) & FLEXCOMM_PID_ID_MASK)
N
N
N/*!
N * @}
N */ /* end of group FLEXCOMM_Register_Masks */
N
N
N/* FLEXCOMM - Peripheral instance base addresses */
N/** Peripheral FLEXCOMM0 base address */
N#define FLEXCOMM0_BASE                           (0x40086000u)
N/** Peripheral FLEXCOMM0 base pointer */
N#define FLEXCOMM0                                ((FLEXCOMM_Type *)FLEXCOMM0_BASE)
N/** Peripheral FLEXCOMM1 base address */
N#define FLEXCOMM1_BASE                           (0x40087000u)
N/** Peripheral FLEXCOMM1 base pointer */
N#define FLEXCOMM1                                ((FLEXCOMM_Type *)FLEXCOMM1_BASE)
N/** Peripheral FLEXCOMM2 base address */
N#define FLEXCOMM2_BASE                           (0x40088000u)
N/** Peripheral FLEXCOMM2 base pointer */
N#define FLEXCOMM2                                ((FLEXCOMM_Type *)FLEXCOMM2_BASE)
N/** Peripheral FLEXCOMM3 base address */
N#define FLEXCOMM3_BASE                           (0x40089000u)
N/** Peripheral FLEXCOMM3 base pointer */
N#define FLEXCOMM3                                ((FLEXCOMM_Type *)FLEXCOMM3_BASE)
N/** Peripheral FLEXCOMM4 base address */
N#define FLEXCOMM4_BASE                           (0x4008A000u)
N/** Peripheral FLEXCOMM4 base pointer */
N#define FLEXCOMM4                                ((FLEXCOMM_Type *)FLEXCOMM4_BASE)
N/** Peripheral FLEXCOMM5 base address */
N#define FLEXCOMM5_BASE                           (0x40096000u)
N/** Peripheral FLEXCOMM5 base pointer */
N#define FLEXCOMM5                                ((FLEXCOMM_Type *)FLEXCOMM5_BASE)
N/** Peripheral FLEXCOMM6 base address */
N#define FLEXCOMM6_BASE                           (0x40097000u)
N/** Peripheral FLEXCOMM6 base pointer */
N#define FLEXCOMM6                                ((FLEXCOMM_Type *)FLEXCOMM6_BASE)
N/** Peripheral FLEXCOMM7 base address */
N#define FLEXCOMM7_BASE                           (0x40098000u)
N/** Peripheral FLEXCOMM7 base pointer */
N#define FLEXCOMM7                                ((FLEXCOMM_Type *)FLEXCOMM7_BASE)
N/** Peripheral FLEXCOMM8 base address */
N#define FLEXCOMM8_BASE                           (0x40099000u)
N/** Peripheral FLEXCOMM8 base pointer */
N#define FLEXCOMM8                                ((FLEXCOMM_Type *)FLEXCOMM8_BASE)
N/** Peripheral FLEXCOMM9 base address */
N#define FLEXCOMM9_BASE                           (0x4009A000u)
N/** Peripheral FLEXCOMM9 base pointer */
N#define FLEXCOMM9                                ((FLEXCOMM_Type *)FLEXCOMM9_BASE)
N/** Array initializer of FLEXCOMM peripheral base addresses */
N#define FLEXCOMM_BASE_ADDRS                      { FLEXCOMM0_BASE, FLEXCOMM1_BASE, FLEXCOMM2_BASE, FLEXCOMM3_BASE, FLEXCOMM4_BASE, FLEXCOMM5_BASE, FLEXCOMM6_BASE, FLEXCOMM7_BASE, FLEXCOMM8_BASE, FLEXCOMM9_BASE }
N/** Array initializer of FLEXCOMM peripheral base pointers */
N#define FLEXCOMM_BASE_PTRS                       { FLEXCOMM0, FLEXCOMM1, FLEXCOMM2, FLEXCOMM3, FLEXCOMM4, FLEXCOMM5, FLEXCOMM6, FLEXCOMM7, FLEXCOMM8, FLEXCOMM9 }
N/** Interrupt vectors for the FLEXCOMM peripheral type */
N#define FLEXCOMM_IRQS                            { FLEXCOMM0_IRQn, FLEXCOMM1_IRQn, FLEXCOMM2_IRQn, FLEXCOMM3_IRQn, FLEXCOMM4_IRQn, FLEXCOMM5_IRQn, FLEXCOMM6_IRQn, FLEXCOMM7_IRQn, FLEXCOMM8_IRQn, FLEXCOMM9_IRQn }
N
N/*!
N * @}
N */ /* end of group FLEXCOMM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- FMC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup FMC_Peripheral_Access_Layer FMC Peripheral Access Layer
N * @{
N */
N
N/** FMC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t FCTR;                              /**< Control register, offset: 0x0 */
X  volatile uint32_t FCTR;                               
N       uint8_t RESERVED_0[12];
N  __IO uint32_t FBWST;                             /**< Wait state register, offset: 0x10 */
X  volatile uint32_t FBWST;                              
N       uint8_t RESERVED_1[12];
N  __IO uint32_t FMSSTART;                          /**< Signature start address register, offset: 0x20 */
X  volatile uint32_t FMSSTART;                           
N  __IO uint32_t FMSSTOP;                           /**< Signature stop-address register, offset: 0x24 */
X  volatile uint32_t FMSSTOP;                            
N       uint8_t RESERVED_2[4];
N  __I  uint32_t FMSW[4];                           /**< Words of 128-bit signature word, array offset: 0x2C, array step: 0x4 */
X  volatile const  uint32_t FMSW[4];                            
N       uint8_t RESERVED_3[4004];
N  __I  uint32_t FMSTAT;                            /**< Signature generation status register, offset: 0xFE0 */
X  volatile const  uint32_t FMSTAT;                             
N       uint8_t RESERVED_4[4];
N  __O  uint32_t FMSTATCLR;                         /**< Signature generation status clear register, offset: 0xFE8 */
X  volatile  uint32_t FMSTATCLR;                          
N} FMC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- FMC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup FMC_Register_Masks FMC Register Masks
N * @{
N */
N
N/*! @name FCTR - Control register */
N#define FMC_FCTR_FS_RD0_MASK                     (0x8U)
N#define FMC_FCTR_FS_RD0_SHIFT                    (3U)
N#define FMC_FCTR_FS_RD0(x)                       (((uint32_t)(((uint32_t)(x)) << FMC_FCTR_FS_RD0_SHIFT)) & FMC_FCTR_FS_RD0_MASK)
N#define FMC_FCTR_FS_RD1_MASK                     (0x10U)
N#define FMC_FCTR_FS_RD1_SHIFT                    (4U)
N#define FMC_FCTR_FS_RD1(x)                       (((uint32_t)(((uint32_t)(x)) << FMC_FCTR_FS_RD1_SHIFT)) & FMC_FCTR_FS_RD1_MASK)
N
N/*! @name FBWST - Wait state register */
N#define FMC_FBWST_WAITSTATES_MASK                (0xFFU)
N#define FMC_FBWST_WAITSTATES_SHIFT               (0U)
N#define FMC_FBWST_WAITSTATES(x)                  (((uint32_t)(((uint32_t)(x)) << FMC_FBWST_WAITSTATES_SHIFT)) & FMC_FBWST_WAITSTATES_MASK)
N
N/*! @name FMSSTART - Signature start address register */
N#define FMC_FMSSTART_START_MASK                  (0x1FFFFU)
N#define FMC_FMSSTART_START_SHIFT                 (0U)
N#define FMC_FMSSTART_START(x)                    (((uint32_t)(((uint32_t)(x)) << FMC_FMSSTART_START_SHIFT)) & FMC_FMSSTART_START_MASK)
N
N/*! @name FMSSTOP - Signature stop-address register */
N#define FMC_FMSSTOP_STOP_MASK                    (0x1FFFFU)
N#define FMC_FMSSTOP_STOP_SHIFT                   (0U)
N#define FMC_FMSSTOP_STOP(x)                      (((uint32_t)(((uint32_t)(x)) << FMC_FMSSTOP_STOP_SHIFT)) & FMC_FMSSTOP_STOP_MASK)
N#define FMC_FMSSTOP_SIG_START_MASK               (0x20000U)
N#define FMC_FMSSTOP_SIG_START_SHIFT              (17U)
N#define FMC_FMSSTOP_SIG_START(x)                 (((uint32_t)(((uint32_t)(x)) << FMC_FMSSTOP_SIG_START_SHIFT)) & FMC_FMSSTOP_SIG_START_MASK)
N
N/*! @name FMSW - Words of 128-bit signature word */
N#define FMC_FMSW_SW_MASK                         (0xFFFFFFFFU)
N#define FMC_FMSW_SW_SHIFT                        (0U)
N#define FMC_FMSW_SW(x)                           (((uint32_t)(((uint32_t)(x)) << FMC_FMSW_SW_SHIFT)) & FMC_FMSW_SW_MASK)
N
N/* The count of FMC_FMSW */
N#define FMC_FMSW_COUNT                           (4U)
N
N/*! @name FMSTAT - Signature generation status register */
N#define FMC_FMSTAT_SIG_DONE_MASK                 (0x4U)
N#define FMC_FMSTAT_SIG_DONE_SHIFT                (2U)
N#define FMC_FMSTAT_SIG_DONE(x)                   (((uint32_t)(((uint32_t)(x)) << FMC_FMSTAT_SIG_DONE_SHIFT)) & FMC_FMSTAT_SIG_DONE_MASK)
N
N/*! @name FMSTATCLR - Signature generation status clear register */
N#define FMC_FMSTATCLR_SIG_DONE_CLR_MASK          (0x4U)
N#define FMC_FMSTATCLR_SIG_DONE_CLR_SHIFT         (2U)
N#define FMC_FMSTATCLR_SIG_DONE_CLR(x)            (((uint32_t)(((uint32_t)(x)) << FMC_FMSTATCLR_SIG_DONE_CLR_SHIFT)) & FMC_FMSTATCLR_SIG_DONE_CLR_MASK)
N
N
N/*!
N * @}
N */ /* end of group FMC_Register_Masks */
N
N
N/* FMC - Peripheral instance base addresses */
N/** Peripheral FMC base address */
N#define FMC_BASE                                 (0x40034000u)
N/** Peripheral FMC base pointer */
N#define FMC                                      ((FMC_Type *)FMC_BASE)
N/** Array initializer of FMC peripheral base addresses */
N#define FMC_BASE_ADDRS                           { FMC_BASE }
N/** Array initializer of FMC peripheral base pointers */
N#define FMC_BASE_PTRS                            { FMC }
N
N/*!
N * @}
N */ /* end of group FMC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- GINT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup GINT_Peripheral_Access_Layer GINT Peripheral Access Layer
N * @{
N */
N
N/** GINT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< GPIO grouped interrupt control register, offset: 0x0 */
X  volatile uint32_t CTRL;                               
N       uint8_t RESERVED_0[28];
N  __IO uint32_t PORT_POL[2];                       /**< GPIO grouped interrupt port 0 polarity register, array offset: 0x20, array step: 0x4 */
X  volatile uint32_t PORT_POL[2];                        
N       uint8_t RESERVED_1[24];
N  __IO uint32_t PORT_ENA[2];                       /**< GPIO grouped interrupt port 0 enable register, array offset: 0x40, array step: 0x4 */
X  volatile uint32_t PORT_ENA[2];                        
N} GINT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- GINT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup GINT_Register_Masks GINT Register Masks
N * @{
N */
N
N/*! @name CTRL - GPIO grouped interrupt control register */
N#define GINT_CTRL_INT_MASK                       (0x1U)
N#define GINT_CTRL_INT_SHIFT                      (0U)
N#define GINT_CTRL_INT(x)                         (((uint32_t)(((uint32_t)(x)) << GINT_CTRL_INT_SHIFT)) & GINT_CTRL_INT_MASK)
N#define GINT_CTRL_COMB_MASK                      (0x2U)
N#define GINT_CTRL_COMB_SHIFT                     (1U)
N#define GINT_CTRL_COMB(x)                        (((uint32_t)(((uint32_t)(x)) << GINT_CTRL_COMB_SHIFT)) & GINT_CTRL_COMB_MASK)
N#define GINT_CTRL_TRIG_MASK                      (0x4U)
N#define GINT_CTRL_TRIG_SHIFT                     (2U)
N#define GINT_CTRL_TRIG(x)                        (((uint32_t)(((uint32_t)(x)) << GINT_CTRL_TRIG_SHIFT)) & GINT_CTRL_TRIG_MASK)
N
N/*! @name PORT_POL - GPIO grouped interrupt port 0 polarity register */
N#define GINT_PORT_POL_POL_MASK                   (0xFFFFFFFFU)
N#define GINT_PORT_POL_POL_SHIFT                  (0U)
N#define GINT_PORT_POL_POL(x)                     (((uint32_t)(((uint32_t)(x)) << GINT_PORT_POL_POL_SHIFT)) & GINT_PORT_POL_POL_MASK)
N
N/* The count of GINT_PORT_POL */
N#define GINT_PORT_POL_COUNT                      (2U)
N
N/*! @name PORT_ENA - GPIO grouped interrupt port 0 enable register */
N#define GINT_PORT_ENA_ENA_MASK                   (0xFFFFFFFFU)
N#define GINT_PORT_ENA_ENA_SHIFT                  (0U)
N#define GINT_PORT_ENA_ENA(x)                     (((uint32_t)(((uint32_t)(x)) << GINT_PORT_ENA_ENA_SHIFT)) & GINT_PORT_ENA_ENA_MASK)
N
N/* The count of GINT_PORT_ENA */
N#define GINT_PORT_ENA_COUNT                      (2U)
N
N
N/*!
N * @}
N */ /* end of group GINT_Register_Masks */
N
N
N/* GINT - Peripheral instance base addresses */
N/** Peripheral GINT0 base address */
N#define GINT0_BASE                               (0x40002000u)
N/** Peripheral GINT0 base pointer */
N#define GINT0                                    ((GINT_Type *)GINT0_BASE)
N/** Peripheral GINT1 base address */
N#define GINT1_BASE                               (0x40003000u)
N/** Peripheral GINT1 base pointer */
N#define GINT1                                    ((GINT_Type *)GINT1_BASE)
N/** Array initializer of GINT peripheral base addresses */
N#define GINT_BASE_ADDRS                          { GINT0_BASE, GINT1_BASE }
N/** Array initializer of GINT peripheral base pointers */
N#define GINT_BASE_PTRS                           { GINT0, GINT1 }
N/** Interrupt vectors for the GINT peripheral type */
N#define GINT_IRQS                                { GINT0_IRQn, GINT1_IRQn }
N
N/*!
N * @}
N */ /* end of group GINT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- GPIO Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer
N * @{
N */
N
N/** GPIO - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t B[6][32];                           /**< Byte pin registers for all port 0 and 1 GPIO pins, array offset: 0x0, array step: index*0x20, index2*0x1 */
X  volatile uint8_t B[6][32];                            
N       uint8_t RESERVED_0[3904];
N  __IO uint32_t W[6][32];                          /**< Word pin registers for all port 0 and 1 GPIO pins, array offset: 0x1000, array step: index*0x80, index2*0x4 */
X  volatile uint32_t W[6][32];                           
N       uint8_t RESERVED_1[3328];
N  __IO uint32_t DIR[6];                            /**< Direction registers, array offset: 0x2000, array step: 0x4 */
X  volatile uint32_t DIR[6];                             
N       uint8_t RESERVED_2[104];
N  __IO uint32_t MASK[6];                           /**< Mask register, array offset: 0x2080, array step: 0x4 */
X  volatile uint32_t MASK[6];                            
N       uint8_t RESERVED_3[104];
N  __IO uint32_t PIN[6];                            /**< Port pin register, array offset: 0x2100, array step: 0x4 */
X  volatile uint32_t PIN[6];                             
N       uint8_t RESERVED_4[104];
N  __IO uint32_t MPIN[6];                           /**< Masked port register, array offset: 0x2180, array step: 0x4 */
X  volatile uint32_t MPIN[6];                            
N       uint8_t RESERVED_5[104];
N  __IO uint32_t SET[6];                            /**< Write: Set register for port Read: output bits for port, array offset: 0x2200, array step: 0x4 */
X  volatile uint32_t SET[6];                             
N       uint8_t RESERVED_6[104];
N  __O  uint32_t CLR[6];                            /**< Clear port, array offset: 0x2280, array step: 0x4 */
X  volatile  uint32_t CLR[6];                             
N       uint8_t RESERVED_7[104];
N  __O  uint32_t NOT[6];                            /**< Toggle port, array offset: 0x2300, array step: 0x4 */
X  volatile  uint32_t NOT[6];                             
N       uint8_t RESERVED_8[104];
N  __O  uint32_t DIRSET[6];                         /**< Set pin direction bits for port, array offset: 0x2380, array step: 0x4 */
X  volatile  uint32_t DIRSET[6];                          
N       uint8_t RESERVED_9[104];
N  __O  uint32_t DIRCLR[6];                         /**< Clear pin direction bits for port, array offset: 0x2400, array step: 0x4 */
X  volatile  uint32_t DIRCLR[6];                          
N       uint8_t RESERVED_10[104];
N  __O  uint32_t DIRNOT[6];                         /**< Toggle pin direction bits for port, array offset: 0x2480, array step: 0x4 */
X  volatile  uint32_t DIRNOT[6];                          
N} GPIO_Type;
N
N/* ----------------------------------------------------------------------------
N   -- GPIO Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup GPIO_Register_Masks GPIO Register Masks
N * @{
N */
N
N/*! @name B - Byte pin registers for all port 0 and 1 GPIO pins */
N#define GPIO_B_PBYTE_MASK                        (0x1U)
N#define GPIO_B_PBYTE_SHIFT                       (0U)
N#define GPIO_B_PBYTE(x)                          (((uint8_t)(((uint8_t)(x)) << GPIO_B_PBYTE_SHIFT)) & GPIO_B_PBYTE_MASK)
N
N/* The count of GPIO_B */
N#define GPIO_B_COUNT                             (6U)
N
N/* The count of GPIO_B */
N#define GPIO_B_COUNT2                            (32U)
N
N/*! @name W - Word pin registers for all port 0 and 1 GPIO pins */
N#define GPIO_W_PWORD_MASK                        (0xFFFFFFFFU)
N#define GPIO_W_PWORD_SHIFT                       (0U)
N#define GPIO_W_PWORD(x)                          (((uint32_t)(((uint32_t)(x)) << GPIO_W_PWORD_SHIFT)) & GPIO_W_PWORD_MASK)
N
N/* The count of GPIO_W */
N#define GPIO_W_COUNT                             (6U)
N
N/* The count of GPIO_W */
N#define GPIO_W_COUNT2                            (32U)
N
N/*! @name DIR - Direction registers */
N#define GPIO_DIR_DIRP_MASK                       (0xFFFFFFFFU)
N#define GPIO_DIR_DIRP_SHIFT                      (0U)
N#define GPIO_DIR_DIRP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_DIR_DIRP_SHIFT)) & GPIO_DIR_DIRP_MASK)
N
N/* The count of GPIO_DIR */
N#define GPIO_DIR_COUNT                           (6U)
N
N/*! @name MASK - Mask register */
N#define GPIO_MASK_MASKP_MASK                     (0xFFFFFFFFU)
N#define GPIO_MASK_MASKP_SHIFT                    (0U)
N#define GPIO_MASK_MASKP(x)                       (((uint32_t)(((uint32_t)(x)) << GPIO_MASK_MASKP_SHIFT)) & GPIO_MASK_MASKP_MASK)
N
N/* The count of GPIO_MASK */
N#define GPIO_MASK_COUNT                          (6U)
N
N/*! @name PIN - Port pin register */
N#define GPIO_PIN_PORT_MASK                       (0xFFFFFFFFU)
N#define GPIO_PIN_PORT_SHIFT                      (0U)
N#define GPIO_PIN_PORT(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_PIN_PORT_SHIFT)) & GPIO_PIN_PORT_MASK)
N
N/* The count of GPIO_PIN */
N#define GPIO_PIN_COUNT                           (6U)
N
N/*! @name MPIN - Masked port register */
N#define GPIO_MPIN_MPORTP_MASK                    (0xFFFFFFFFU)
N#define GPIO_MPIN_MPORTP_SHIFT                   (0U)
N#define GPIO_MPIN_MPORTP(x)                      (((uint32_t)(((uint32_t)(x)) << GPIO_MPIN_MPORTP_SHIFT)) & GPIO_MPIN_MPORTP_MASK)
N
N/* The count of GPIO_MPIN */
N#define GPIO_MPIN_COUNT                          (6U)
N
N/*! @name SET - Write: Set register for port Read: output bits for port */
N#define GPIO_SET_SETP_MASK                       (0xFFFFFFFFU)
N#define GPIO_SET_SETP_SHIFT                      (0U)
N#define GPIO_SET_SETP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_SET_SETP_SHIFT)) & GPIO_SET_SETP_MASK)
N
N/* The count of GPIO_SET */
N#define GPIO_SET_COUNT                           (6U)
N
N/*! @name CLR - Clear port */
N#define GPIO_CLR_CLRP_MASK                       (0xFFFFFFFFU)
N#define GPIO_CLR_CLRP_SHIFT                      (0U)
N#define GPIO_CLR_CLRP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_CLR_CLRP_SHIFT)) & GPIO_CLR_CLRP_MASK)
N
N/* The count of GPIO_CLR */
N#define GPIO_CLR_COUNT                           (6U)
N
N/*! @name NOT - Toggle port */
N#define GPIO_NOT_NOTP_MASK                       (0xFFFFFFFFU)
N#define GPIO_NOT_NOTP_SHIFT                      (0U)
N#define GPIO_NOT_NOTP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_NOT_NOTP_SHIFT)) & GPIO_NOT_NOTP_MASK)
N
N/* The count of GPIO_NOT */
N#define GPIO_NOT_COUNT                           (6U)
N
N/*! @name DIRSET - Set pin direction bits for port */
N#define GPIO_DIRSET_DIRSETP_MASK                 (0x1FFFFFFFU)
N#define GPIO_DIRSET_DIRSETP_SHIFT                (0U)
N#define GPIO_DIRSET_DIRSETP(x)                   (((uint32_t)(((uint32_t)(x)) << GPIO_DIRSET_DIRSETP_SHIFT)) & GPIO_DIRSET_DIRSETP_MASK)
N
N/* The count of GPIO_DIRSET */
N#define GPIO_DIRSET_COUNT                        (6U)
N
N/*! @name DIRCLR - Clear pin direction bits for port */
N#define GPIO_DIRCLR_DIRCLRP_MASK                 (0x1FFFFFFFU)
N#define GPIO_DIRCLR_DIRCLRP_SHIFT                (0U)
N#define GPIO_DIRCLR_DIRCLRP(x)                   (((uint32_t)(((uint32_t)(x)) << GPIO_DIRCLR_DIRCLRP_SHIFT)) & GPIO_DIRCLR_DIRCLRP_MASK)
N
N/* The count of GPIO_DIRCLR */
N#define GPIO_DIRCLR_COUNT                        (6U)
N
N/*! @name DIRNOT - Toggle pin direction bits for port */
N#define GPIO_DIRNOT_DIRNOTP_MASK                 (0x1FFFFFFFU)
N#define GPIO_DIRNOT_DIRNOTP_SHIFT                (0U)
N#define GPIO_DIRNOT_DIRNOTP(x)                   (((uint32_t)(((uint32_t)(x)) << GPIO_DIRNOT_DIRNOTP_SHIFT)) & GPIO_DIRNOT_DIRNOTP_MASK)
N
N/* The count of GPIO_DIRNOT */
N#define GPIO_DIRNOT_COUNT                        (6U)
N
N
N/*!
N * @}
N */ /* end of group GPIO_Register_Masks */
N
N
N/* GPIO - Peripheral instance base addresses */
N/** Peripheral GPIO base address */
N#define GPIO_BASE                                (0x4008C000u)
N/** Peripheral GPIO base pointer */
N#define GPIO                                     ((GPIO_Type *)GPIO_BASE)
N/** Array initializer of GPIO peripheral base addresses */
N#define GPIO_BASE_ADDRS                          { GPIO_BASE }
N/** Array initializer of GPIO peripheral base pointers */
N#define GPIO_BASE_PTRS                           { GPIO }
N
N/*!
N * @}
N */ /* end of group GPIO_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- I2C Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup I2C_Peripheral_Access_Layer I2C Peripheral Access Layer
N * @{
N */
N
N/** I2C - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[2048];
N  __IO uint32_t CFG;                               /**< Configuration for shared functions., offset: 0x800 */
X  volatile uint32_t CFG;                                
N  __IO uint32_t STAT;                              /**< Status register for Master, Slave, and Monitor functions., offset: 0x804 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t INTENSET;                          /**< Interrupt Enable Set and read register., offset: 0x808 */
X  volatile uint32_t INTENSET;                           
N  __O  uint32_t INTENCLR;                          /**< Interrupt Enable Clear register., offset: 0x80C */
X  volatile  uint32_t INTENCLR;                           
N  __IO uint32_t TIMEOUT;                           /**< Time-out value register., offset: 0x810 */
X  volatile uint32_t TIMEOUT;                            
N  __IO uint32_t CLKDIV;                            /**< Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function., offset: 0x814 */
X  volatile uint32_t CLKDIV;                             
N  __I  uint32_t INTSTAT;                           /**< Interrupt Status register for Master, Slave, and Monitor functions., offset: 0x818 */
X  volatile const  uint32_t INTSTAT;                            
N       uint8_t RESERVED_1[4];
N  __IO uint32_t MSTCTL;                            /**< Master control register., offset: 0x820 */
X  volatile uint32_t MSTCTL;                             
N  __IO uint32_t MSTTIME;                           /**< Master timing configuration., offset: 0x824 */
X  volatile uint32_t MSTTIME;                            
N  __IO uint32_t MSTDAT;                            /**< Combined Master receiver and transmitter data register., offset: 0x828 */
X  volatile uint32_t MSTDAT;                             
N       uint8_t RESERVED_2[20];
N  __IO uint32_t SLVCTL;                            /**< Slave control register., offset: 0x840 */
X  volatile uint32_t SLVCTL;                             
N  __IO uint32_t SLVDAT;                            /**< Combined Slave receiver and transmitter data register., offset: 0x844 */
X  volatile uint32_t SLVDAT;                             
N  __IO uint32_t SLVADR[4];                         /**< Slave address register., array offset: 0x848, array step: 0x4 */
X  volatile uint32_t SLVADR[4];                          
N  __IO uint32_t SLVQUAL0;                          /**< Slave Qualification for address 0., offset: 0x858 */
X  volatile uint32_t SLVQUAL0;                           
N       uint8_t RESERVED_3[36];
N  __I  uint32_t MONRXDAT;                          /**< Monitor receiver data register., offset: 0x880 */
X  volatile const  uint32_t MONRXDAT;                           
N       uint8_t RESERVED_4[1912];
N  __I  uint32_t ID;                                /**< Peripheral identification register., offset: 0xFFC */
X  volatile const  uint32_t ID;                                 
N} I2C_Type;
N
N/* ----------------------------------------------------------------------------
N   -- I2C Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup I2C_Register_Masks I2C Register Masks
N * @{
N */
N
N/*! @name CFG - Configuration for shared functions. */
N#define I2C_CFG_MSTEN_MASK                       (0x1U)
N#define I2C_CFG_MSTEN_SHIFT                      (0U)
N#define I2C_CFG_MSTEN(x)                         (((uint32_t)(((uint32_t)(x)) << I2C_CFG_MSTEN_SHIFT)) & I2C_CFG_MSTEN_MASK)
N#define I2C_CFG_SLVEN_MASK                       (0x2U)
N#define I2C_CFG_SLVEN_SHIFT                      (1U)
N#define I2C_CFG_SLVEN(x)                         (((uint32_t)(((uint32_t)(x)) << I2C_CFG_SLVEN_SHIFT)) & I2C_CFG_SLVEN_MASK)
N#define I2C_CFG_MONEN_MASK                       (0x4U)
N#define I2C_CFG_MONEN_SHIFT                      (2U)
N#define I2C_CFG_MONEN(x)                         (((uint32_t)(((uint32_t)(x)) << I2C_CFG_MONEN_SHIFT)) & I2C_CFG_MONEN_MASK)
N#define I2C_CFG_TIMEOUTEN_MASK                   (0x8U)
N#define I2C_CFG_TIMEOUTEN_SHIFT                  (3U)
N#define I2C_CFG_TIMEOUTEN(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CFG_TIMEOUTEN_SHIFT)) & I2C_CFG_TIMEOUTEN_MASK)
N#define I2C_CFG_MONCLKSTR_MASK                   (0x10U)
N#define I2C_CFG_MONCLKSTR_SHIFT                  (4U)
N#define I2C_CFG_MONCLKSTR(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CFG_MONCLKSTR_SHIFT)) & I2C_CFG_MONCLKSTR_MASK)
N#define I2C_CFG_HSCAPABLE_MASK                   (0x20U)
N#define I2C_CFG_HSCAPABLE_SHIFT                  (5U)
N#define I2C_CFG_HSCAPABLE(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CFG_HSCAPABLE_SHIFT)) & I2C_CFG_HSCAPABLE_MASK)
N
N/*! @name STAT - Status register for Master, Slave, and Monitor functions. */
N#define I2C_STAT_MSTPENDING_MASK                 (0x1U)
N#define I2C_STAT_MSTPENDING_SHIFT                (0U)
N#define I2C_STAT_MSTPENDING(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTPENDING_SHIFT)) & I2C_STAT_MSTPENDING_MASK)
N#define I2C_STAT_MSTSTATE_MASK                   (0xEU)
N#define I2C_STAT_MSTSTATE_SHIFT                  (1U)
N#define I2C_STAT_MSTSTATE(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTSTATE_SHIFT)) & I2C_STAT_MSTSTATE_MASK)
N#define I2C_STAT_MSTARBLOSS_MASK                 (0x10U)
N#define I2C_STAT_MSTARBLOSS_SHIFT                (4U)
N#define I2C_STAT_MSTARBLOSS(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTARBLOSS_SHIFT)) & I2C_STAT_MSTARBLOSS_MASK)
N#define I2C_STAT_MSTSTSTPERR_MASK                (0x40U)
N#define I2C_STAT_MSTSTSTPERR_SHIFT               (6U)
N#define I2C_STAT_MSTSTSTPERR(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTSTSTPERR_SHIFT)) & I2C_STAT_MSTSTSTPERR_MASK)
N#define I2C_STAT_SLVPENDING_MASK                 (0x100U)
N#define I2C_STAT_SLVPENDING_SHIFT                (8U)
N#define I2C_STAT_SLVPENDING(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVPENDING_SHIFT)) & I2C_STAT_SLVPENDING_MASK)
N#define I2C_STAT_SLVSTATE_MASK                   (0x600U)
N#define I2C_STAT_SLVSTATE_SHIFT                  (9U)
N#define I2C_STAT_SLVSTATE(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVSTATE_SHIFT)) & I2C_STAT_SLVSTATE_MASK)
N#define I2C_STAT_SLVNOTSTR_MASK                  (0x800U)
N#define I2C_STAT_SLVNOTSTR_SHIFT                 (11U)
N#define I2C_STAT_SLVNOTSTR(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVNOTSTR_SHIFT)) & I2C_STAT_SLVNOTSTR_MASK)
N#define I2C_STAT_SLVIDX_MASK                     (0x3000U)
N#define I2C_STAT_SLVIDX_SHIFT                    (12U)
N#define I2C_STAT_SLVIDX(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVIDX_SHIFT)) & I2C_STAT_SLVIDX_MASK)
N#define I2C_STAT_SLVSEL_MASK                     (0x4000U)
N#define I2C_STAT_SLVSEL_SHIFT                    (14U)
N#define I2C_STAT_SLVSEL(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVSEL_SHIFT)) & I2C_STAT_SLVSEL_MASK)
N#define I2C_STAT_SLVDESEL_MASK                   (0x8000U)
N#define I2C_STAT_SLVDESEL_SHIFT                  (15U)
N#define I2C_STAT_SLVDESEL(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVDESEL_SHIFT)) & I2C_STAT_SLVDESEL_MASK)
N#define I2C_STAT_MONRDY_MASK                     (0x10000U)
N#define I2C_STAT_MONRDY_SHIFT                    (16U)
N#define I2C_STAT_MONRDY(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONRDY_SHIFT)) & I2C_STAT_MONRDY_MASK)
N#define I2C_STAT_MONOV_MASK                      (0x20000U)
N#define I2C_STAT_MONOV_SHIFT                     (17U)
N#define I2C_STAT_MONOV(x)                        (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONOV_SHIFT)) & I2C_STAT_MONOV_MASK)
N#define I2C_STAT_MONACTIVE_MASK                  (0x40000U)
N#define I2C_STAT_MONACTIVE_SHIFT                 (18U)
N#define I2C_STAT_MONACTIVE(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONACTIVE_SHIFT)) & I2C_STAT_MONACTIVE_MASK)
N#define I2C_STAT_MONIDLE_MASK                    (0x80000U)
N#define I2C_STAT_MONIDLE_SHIFT                   (19U)
N#define I2C_STAT_MONIDLE(x)                      (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONIDLE_SHIFT)) & I2C_STAT_MONIDLE_MASK)
N#define I2C_STAT_EVENTTIMEOUT_MASK               (0x1000000U)
N#define I2C_STAT_EVENTTIMEOUT_SHIFT              (24U)
N#define I2C_STAT_EVENTTIMEOUT(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_STAT_EVENTTIMEOUT_SHIFT)) & I2C_STAT_EVENTTIMEOUT_MASK)
N#define I2C_STAT_SCLTIMEOUT_MASK                 (0x2000000U)
N#define I2C_STAT_SCLTIMEOUT_SHIFT                (25U)
N#define I2C_STAT_SCLTIMEOUT(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SCLTIMEOUT_SHIFT)) & I2C_STAT_SCLTIMEOUT_MASK)
N
N/*! @name INTENSET - Interrupt Enable Set and read register. */
N#define I2C_INTENSET_MSTPENDINGEN_MASK           (0x1U)
N#define I2C_INTENSET_MSTPENDINGEN_SHIFT          (0U)
N#define I2C_INTENSET_MSTPENDINGEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MSTPENDINGEN_SHIFT)) & I2C_INTENSET_MSTPENDINGEN_MASK)
N#define I2C_INTENSET_MSTARBLOSSEN_MASK           (0x10U)
N#define I2C_INTENSET_MSTARBLOSSEN_SHIFT          (4U)
N#define I2C_INTENSET_MSTARBLOSSEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MSTARBLOSSEN_SHIFT)) & I2C_INTENSET_MSTARBLOSSEN_MASK)
N#define I2C_INTENSET_MSTSTSTPERREN_MASK          (0x40U)
N#define I2C_INTENSET_MSTSTSTPERREN_SHIFT         (6U)
N#define I2C_INTENSET_MSTSTSTPERREN(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MSTSTSTPERREN_SHIFT)) & I2C_INTENSET_MSTSTSTPERREN_MASK)
N#define I2C_INTENSET_SLVPENDINGEN_MASK           (0x100U)
N#define I2C_INTENSET_SLVPENDINGEN_SHIFT          (8U)
N#define I2C_INTENSET_SLVPENDINGEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SLVPENDINGEN_SHIFT)) & I2C_INTENSET_SLVPENDINGEN_MASK)
N#define I2C_INTENSET_SLVNOTSTREN_MASK            (0x800U)
N#define I2C_INTENSET_SLVNOTSTREN_SHIFT           (11U)
N#define I2C_INTENSET_SLVNOTSTREN(x)              (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SLVNOTSTREN_SHIFT)) & I2C_INTENSET_SLVNOTSTREN_MASK)
N#define I2C_INTENSET_SLVDESELEN_MASK             (0x8000U)
N#define I2C_INTENSET_SLVDESELEN_SHIFT            (15U)
N#define I2C_INTENSET_SLVDESELEN(x)               (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SLVDESELEN_SHIFT)) & I2C_INTENSET_SLVDESELEN_MASK)
N#define I2C_INTENSET_MONRDYEN_MASK               (0x10000U)
N#define I2C_INTENSET_MONRDYEN_SHIFT              (16U)
N#define I2C_INTENSET_MONRDYEN(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MONRDYEN_SHIFT)) & I2C_INTENSET_MONRDYEN_MASK)
N#define I2C_INTENSET_MONOVEN_MASK                (0x20000U)
N#define I2C_INTENSET_MONOVEN_SHIFT               (17U)
N#define I2C_INTENSET_MONOVEN(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MONOVEN_SHIFT)) & I2C_INTENSET_MONOVEN_MASK)
N#define I2C_INTENSET_MONIDLEEN_MASK              (0x80000U)
N#define I2C_INTENSET_MONIDLEEN_SHIFT             (19U)
N#define I2C_INTENSET_MONIDLEEN(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MONIDLEEN_SHIFT)) & I2C_INTENSET_MONIDLEEN_MASK)
N#define I2C_INTENSET_EVENTTIMEOUTEN_MASK         (0x1000000U)
N#define I2C_INTENSET_EVENTTIMEOUTEN_SHIFT        (24U)
N#define I2C_INTENSET_EVENTTIMEOUTEN(x)           (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_EVENTTIMEOUTEN_SHIFT)) & I2C_INTENSET_EVENTTIMEOUTEN_MASK)
N#define I2C_INTENSET_SCLTIMEOUTEN_MASK           (0x2000000U)
N#define I2C_INTENSET_SCLTIMEOUTEN_SHIFT          (25U)
N#define I2C_INTENSET_SCLTIMEOUTEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SCLTIMEOUTEN_SHIFT)) & I2C_INTENSET_SCLTIMEOUTEN_MASK)
N
N/*! @name INTENCLR - Interrupt Enable Clear register. */
N#define I2C_INTENCLR_MSTPENDINGCLR_MASK          (0x1U)
N#define I2C_INTENCLR_MSTPENDINGCLR_SHIFT         (0U)
N#define I2C_INTENCLR_MSTPENDINGCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MSTPENDINGCLR_SHIFT)) & I2C_INTENCLR_MSTPENDINGCLR_MASK)
N#define I2C_INTENCLR_MSTARBLOSSCLR_MASK          (0x10U)
N#define I2C_INTENCLR_MSTARBLOSSCLR_SHIFT         (4U)
N#define I2C_INTENCLR_MSTARBLOSSCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MSTARBLOSSCLR_SHIFT)) & I2C_INTENCLR_MSTARBLOSSCLR_MASK)
N#define I2C_INTENCLR_MSTSTSTPERRCLR_MASK         (0x40U)
N#define I2C_INTENCLR_MSTSTSTPERRCLR_SHIFT        (6U)
N#define I2C_INTENCLR_MSTSTSTPERRCLR(x)           (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MSTSTSTPERRCLR_SHIFT)) & I2C_INTENCLR_MSTSTSTPERRCLR_MASK)
N#define I2C_INTENCLR_SLVPENDINGCLR_MASK          (0x100U)
N#define I2C_INTENCLR_SLVPENDINGCLR_SHIFT         (8U)
N#define I2C_INTENCLR_SLVPENDINGCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SLVPENDINGCLR_SHIFT)) & I2C_INTENCLR_SLVPENDINGCLR_MASK)
N#define I2C_INTENCLR_SLVNOTSTRCLR_MASK           (0x800U)
N#define I2C_INTENCLR_SLVNOTSTRCLR_SHIFT          (11U)
N#define I2C_INTENCLR_SLVNOTSTRCLR(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SLVNOTSTRCLR_SHIFT)) & I2C_INTENCLR_SLVNOTSTRCLR_MASK)
N#define I2C_INTENCLR_SLVDESELCLR_MASK            (0x8000U)
N#define I2C_INTENCLR_SLVDESELCLR_SHIFT           (15U)
N#define I2C_INTENCLR_SLVDESELCLR(x)              (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SLVDESELCLR_SHIFT)) & I2C_INTENCLR_SLVDESELCLR_MASK)
N#define I2C_INTENCLR_MONRDYCLR_MASK              (0x10000U)
N#define I2C_INTENCLR_MONRDYCLR_SHIFT             (16U)
N#define I2C_INTENCLR_MONRDYCLR(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MONRDYCLR_SHIFT)) & I2C_INTENCLR_MONRDYCLR_MASK)
N#define I2C_INTENCLR_MONOVCLR_MASK               (0x20000U)
N#define I2C_INTENCLR_MONOVCLR_SHIFT              (17U)
N#define I2C_INTENCLR_MONOVCLR(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MONOVCLR_SHIFT)) & I2C_INTENCLR_MONOVCLR_MASK)
N#define I2C_INTENCLR_MONIDLECLR_MASK             (0x80000U)
N#define I2C_INTENCLR_MONIDLECLR_SHIFT            (19U)
N#define I2C_INTENCLR_MONIDLECLR(x)               (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MONIDLECLR_SHIFT)) & I2C_INTENCLR_MONIDLECLR_MASK)
N#define I2C_INTENCLR_EVENTTIMEOUTCLR_MASK        (0x1000000U)
N#define I2C_INTENCLR_EVENTTIMEOUTCLR_SHIFT       (24U)
N#define I2C_INTENCLR_EVENTTIMEOUTCLR(x)          (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_EVENTTIMEOUTCLR_SHIFT)) & I2C_INTENCLR_EVENTTIMEOUTCLR_MASK)
N#define I2C_INTENCLR_SCLTIMEOUTCLR_MASK          (0x2000000U)
N#define I2C_INTENCLR_SCLTIMEOUTCLR_SHIFT         (25U)
N#define I2C_INTENCLR_SCLTIMEOUTCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SCLTIMEOUTCLR_SHIFT)) & I2C_INTENCLR_SCLTIMEOUTCLR_MASK)
N
N/*! @name TIMEOUT - Time-out value register. */
N#define I2C_TIMEOUT_TOMIN_MASK                   (0xFU)
N#define I2C_TIMEOUT_TOMIN_SHIFT                  (0U)
N#define I2C_TIMEOUT_TOMIN(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_TIMEOUT_TOMIN_SHIFT)) & I2C_TIMEOUT_TOMIN_MASK)
N#define I2C_TIMEOUT_TO_MASK                      (0xFFF0U)
N#define I2C_TIMEOUT_TO_SHIFT                     (4U)
N#define I2C_TIMEOUT_TO(x)                        (((uint32_t)(((uint32_t)(x)) << I2C_TIMEOUT_TO_SHIFT)) & I2C_TIMEOUT_TO_MASK)
N
N/*! @name CLKDIV - Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function. */
N#define I2C_CLKDIV_DIVVAL_MASK                   (0xFFFFU)
N#define I2C_CLKDIV_DIVVAL_SHIFT                  (0U)
N#define I2C_CLKDIV_DIVVAL(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CLKDIV_DIVVAL_SHIFT)) & I2C_CLKDIV_DIVVAL_MASK)
N
N/*! @name INTSTAT - Interrupt Status register for Master, Slave, and Monitor functions. */
N#define I2C_INTSTAT_MSTPENDING_MASK              (0x1U)
N#define I2C_INTSTAT_MSTPENDING_SHIFT             (0U)
N#define I2C_INTSTAT_MSTPENDING(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MSTPENDING_SHIFT)) & I2C_INTSTAT_MSTPENDING_MASK)
N#define I2C_INTSTAT_MSTARBLOSS_MASK              (0x10U)
N#define I2C_INTSTAT_MSTARBLOSS_SHIFT             (4U)
N#define I2C_INTSTAT_MSTARBLOSS(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MSTARBLOSS_SHIFT)) & I2C_INTSTAT_MSTARBLOSS_MASK)
N#define I2C_INTSTAT_MSTSTSTPERR_MASK             (0x40U)
N#define I2C_INTSTAT_MSTSTSTPERR_SHIFT            (6U)
N#define I2C_INTSTAT_MSTSTSTPERR(x)               (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MSTSTSTPERR_SHIFT)) & I2C_INTSTAT_MSTSTSTPERR_MASK)
N#define I2C_INTSTAT_SLVPENDING_MASK              (0x100U)
N#define I2C_INTSTAT_SLVPENDING_SHIFT             (8U)
N#define I2C_INTSTAT_SLVPENDING(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SLVPENDING_SHIFT)) & I2C_INTSTAT_SLVPENDING_MASK)
N#define I2C_INTSTAT_SLVNOTSTR_MASK               (0x800U)
N#define I2C_INTSTAT_SLVNOTSTR_SHIFT              (11U)
N#define I2C_INTSTAT_SLVNOTSTR(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SLVNOTSTR_SHIFT)) & I2C_INTSTAT_SLVNOTSTR_MASK)
N#define I2C_INTSTAT_SLVDESEL_MASK                (0x8000U)
N#define I2C_INTSTAT_SLVDESEL_SHIFT               (15U)
N#define I2C_INTSTAT_SLVDESEL(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SLVDESEL_SHIFT)) & I2C_INTSTAT_SLVDESEL_MASK)
N#define I2C_INTSTAT_MONRDY_MASK                  (0x10000U)
N#define I2C_INTSTAT_MONRDY_SHIFT                 (16U)
N#define I2C_INTSTAT_MONRDY(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MONRDY_SHIFT)) & I2C_INTSTAT_MONRDY_MASK)
N#define I2C_INTSTAT_MONOV_MASK                   (0x20000U)
N#define I2C_INTSTAT_MONOV_SHIFT                  (17U)
N#define I2C_INTSTAT_MONOV(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MONOV_SHIFT)) & I2C_INTSTAT_MONOV_MASK)
N#define I2C_INTSTAT_MONIDLE_MASK                 (0x80000U)
N#define I2C_INTSTAT_MONIDLE_SHIFT                (19U)
N#define I2C_INTSTAT_MONIDLE(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MONIDLE_SHIFT)) & I2C_INTSTAT_MONIDLE_MASK)
N#define I2C_INTSTAT_EVENTTIMEOUT_MASK            (0x1000000U)
N#define I2C_INTSTAT_EVENTTIMEOUT_SHIFT           (24U)
N#define I2C_INTSTAT_EVENTTIMEOUT(x)              (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_EVENTTIMEOUT_SHIFT)) & I2C_INTSTAT_EVENTTIMEOUT_MASK)
N#define I2C_INTSTAT_SCLTIMEOUT_MASK              (0x2000000U)
N#define I2C_INTSTAT_SCLTIMEOUT_SHIFT             (25U)
N#define I2C_INTSTAT_SCLTIMEOUT(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SCLTIMEOUT_SHIFT)) & I2C_INTSTAT_SCLTIMEOUT_MASK)
N
N/*! @name MSTCTL - Master control register. */
N#define I2C_MSTCTL_MSTCONTINUE_MASK              (0x1U)
N#define I2C_MSTCTL_MSTCONTINUE_SHIFT             (0U)
N#define I2C_MSTCTL_MSTCONTINUE(x)                (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTCONTINUE_SHIFT)) & I2C_MSTCTL_MSTCONTINUE_MASK)
N#define I2C_MSTCTL_MSTSTART_MASK                 (0x2U)
N#define I2C_MSTCTL_MSTSTART_SHIFT                (1U)
N#define I2C_MSTCTL_MSTSTART(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTSTART_SHIFT)) & I2C_MSTCTL_MSTSTART_MASK)
N#define I2C_MSTCTL_MSTSTOP_MASK                  (0x4U)
N#define I2C_MSTCTL_MSTSTOP_SHIFT                 (2U)
N#define I2C_MSTCTL_MSTSTOP(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTSTOP_SHIFT)) & I2C_MSTCTL_MSTSTOP_MASK)
N#define I2C_MSTCTL_MSTDMA_MASK                   (0x8U)
N#define I2C_MSTCTL_MSTDMA_SHIFT                  (3U)
N#define I2C_MSTCTL_MSTDMA(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTDMA_SHIFT)) & I2C_MSTCTL_MSTDMA_MASK)
N
N/*! @name MSTTIME - Master timing configuration. */
N#define I2C_MSTTIME_MSTSCLLOW_MASK               (0x7U)
N#define I2C_MSTTIME_MSTSCLLOW_SHIFT              (0U)
N#define I2C_MSTTIME_MSTSCLLOW(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_MSTTIME_MSTSCLLOW_SHIFT)) & I2C_MSTTIME_MSTSCLLOW_MASK)
N#define I2C_MSTTIME_MSTSCLHIGH_MASK              (0x70U)
N#define I2C_MSTTIME_MSTSCLHIGH_SHIFT             (4U)
N#define I2C_MSTTIME_MSTSCLHIGH(x)                (((uint32_t)(((uint32_t)(x)) << I2C_MSTTIME_MSTSCLHIGH_SHIFT)) & I2C_MSTTIME_MSTSCLHIGH_MASK)
N
N/*! @name MSTDAT - Combined Master receiver and transmitter data register. */
N#define I2C_MSTDAT_DATA_MASK                     (0xFFU)
N#define I2C_MSTDAT_DATA_SHIFT                    (0U)
N#define I2C_MSTDAT_DATA(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_MSTDAT_DATA_SHIFT)) & I2C_MSTDAT_DATA_MASK)
N
N/*! @name SLVCTL - Slave control register. */
N#define I2C_SLVCTL_SLVCONTINUE_MASK              (0x1U)
N#define I2C_SLVCTL_SLVCONTINUE_SHIFT             (0U)
N#define I2C_SLVCTL_SLVCONTINUE(x)                (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_SLVCONTINUE_SHIFT)) & I2C_SLVCTL_SLVCONTINUE_MASK)
N#define I2C_SLVCTL_SLVNACK_MASK                  (0x2U)
N#define I2C_SLVCTL_SLVNACK_SHIFT                 (1U)
N#define I2C_SLVCTL_SLVNACK(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_SLVNACK_SHIFT)) & I2C_SLVCTL_SLVNACK_MASK)
N#define I2C_SLVCTL_SLVDMA_MASK                   (0x8U)
N#define I2C_SLVCTL_SLVDMA_SHIFT                  (3U)
N#define I2C_SLVCTL_SLVDMA(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_SLVDMA_SHIFT)) & I2C_SLVCTL_SLVDMA_MASK)
N#define I2C_SLVCTL_AUTOACK_MASK                  (0x100U)
N#define I2C_SLVCTL_AUTOACK_SHIFT                 (8U)
N#define I2C_SLVCTL_AUTOACK(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_AUTOACK_SHIFT)) & I2C_SLVCTL_AUTOACK_MASK)
N#define I2C_SLVCTL_AUTOMATCHREAD_MASK            (0x200U)
N#define I2C_SLVCTL_AUTOMATCHREAD_SHIFT           (9U)
N#define I2C_SLVCTL_AUTOMATCHREAD(x)              (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_AUTOMATCHREAD_SHIFT)) & I2C_SLVCTL_AUTOMATCHREAD_MASK)
N
N/*! @name SLVDAT - Combined Slave receiver and transmitter data register. */
N#define I2C_SLVDAT_DATA_MASK                     (0xFFU)
N#define I2C_SLVDAT_DATA_SHIFT                    (0U)
N#define I2C_SLVDAT_DATA(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_SLVDAT_DATA_SHIFT)) & I2C_SLVDAT_DATA_MASK)
N
N/*! @name SLVADR - Slave address register. */
N#define I2C_SLVADR_SADISABLE_MASK                (0x1U)
N#define I2C_SLVADR_SADISABLE_SHIFT               (0U)
N#define I2C_SLVADR_SADISABLE(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_SLVADR_SADISABLE_SHIFT)) & I2C_SLVADR_SADISABLE_MASK)
N#define I2C_SLVADR_SLVADR_MASK                   (0xFEU)
N#define I2C_SLVADR_SLVADR_SHIFT                  (1U)
N#define I2C_SLVADR_SLVADR(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_SLVADR_SLVADR_SHIFT)) & I2C_SLVADR_SLVADR_MASK)
N#define I2C_SLVADR_AUTONACK_MASK                 (0x8000U)
N#define I2C_SLVADR_AUTONACK_SHIFT                (15U)
N#define I2C_SLVADR_AUTONACK(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_SLVADR_AUTONACK_SHIFT)) & I2C_SLVADR_AUTONACK_MASK)
N
N/* The count of I2C_SLVADR */
N#define I2C_SLVADR_COUNT                         (4U)
N
N/*! @name SLVQUAL0 - Slave Qualification for address 0. */
N#define I2C_SLVQUAL0_QUALMODE0_MASK              (0x1U)
N#define I2C_SLVQUAL0_QUALMODE0_SHIFT             (0U)
N#define I2C_SLVQUAL0_QUALMODE0(x)                (((uint32_t)(((uint32_t)(x)) << I2C_SLVQUAL0_QUALMODE0_SHIFT)) & I2C_SLVQUAL0_QUALMODE0_MASK)
N#define I2C_SLVQUAL0_SLVQUAL0_MASK               (0xFEU)
N#define I2C_SLVQUAL0_SLVQUAL0_SHIFT              (1U)
N#define I2C_SLVQUAL0_SLVQUAL0(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_SLVQUAL0_SLVQUAL0_SHIFT)) & I2C_SLVQUAL0_SLVQUAL0_MASK)
N
N/*! @name MONRXDAT - Monitor receiver data register. */
N#define I2C_MONRXDAT_MONRXDAT_MASK               (0xFFU)
N#define I2C_MONRXDAT_MONRXDAT_SHIFT              (0U)
N#define I2C_MONRXDAT_MONRXDAT(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONRXDAT_SHIFT)) & I2C_MONRXDAT_MONRXDAT_MASK)
N#define I2C_MONRXDAT_MONSTART_MASK               (0x100U)
N#define I2C_MONRXDAT_MONSTART_SHIFT              (8U)
N#define I2C_MONRXDAT_MONSTART(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONSTART_SHIFT)) & I2C_MONRXDAT_MONSTART_MASK)
N#define I2C_MONRXDAT_MONRESTART_MASK             (0x200U)
N#define I2C_MONRXDAT_MONRESTART_SHIFT            (9U)
N#define I2C_MONRXDAT_MONRESTART(x)               (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONRESTART_SHIFT)) & I2C_MONRXDAT_MONRESTART_MASK)
N#define I2C_MONRXDAT_MONNACK_MASK                (0x400U)
N#define I2C_MONRXDAT_MONNACK_SHIFT               (10U)
N#define I2C_MONRXDAT_MONNACK(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONNACK_SHIFT)) & I2C_MONRXDAT_MONNACK_MASK)
N
N/*! @name ID - Peripheral identification register. */
N#define I2C_ID_APERTURE_MASK                     (0xFFU)
N#define I2C_ID_APERTURE_SHIFT                    (0U)
N#define I2C_ID_APERTURE(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_ID_APERTURE_SHIFT)) & I2C_ID_APERTURE_MASK)
N#define I2C_ID_MINOR_REV_MASK                    (0xF00U)
N#define I2C_ID_MINOR_REV_SHIFT                   (8U)
N#define I2C_ID_MINOR_REV(x)                      (((uint32_t)(((uint32_t)(x)) << I2C_ID_MINOR_REV_SHIFT)) & I2C_ID_MINOR_REV_MASK)
N#define I2C_ID_MAJOR_REV_MASK                    (0xF000U)
N#define I2C_ID_MAJOR_REV_SHIFT                   (12U)
N#define I2C_ID_MAJOR_REV(x)                      (((uint32_t)(((uint32_t)(x)) << I2C_ID_MAJOR_REV_SHIFT)) & I2C_ID_MAJOR_REV_MASK)
N#define I2C_ID_ID_MASK                           (0xFFFF0000U)
N#define I2C_ID_ID_SHIFT                          (16U)
N#define I2C_ID_ID(x)                             (((uint32_t)(((uint32_t)(x)) << I2C_ID_ID_SHIFT)) & I2C_ID_ID_MASK)
N
N
N/*!
N * @}
N */ /* end of group I2C_Register_Masks */
N
N
N/* I2C - Peripheral instance base addresses */
N/** Peripheral I2C0 base address */
N#define I2C0_BASE                                (0x40086000u)
N/** Peripheral I2C0 base pointer */
N#define I2C0                                     ((I2C_Type *)I2C0_BASE)
N/** Peripheral I2C1 base address */
N#define I2C1_BASE                                (0x40087000u)
N/** Peripheral I2C1 base pointer */
N#define I2C1                                     ((I2C_Type *)I2C1_BASE)
N/** Peripheral I2C2 base address */
N#define I2C2_BASE                                (0x40088000u)
N/** Peripheral I2C2 base pointer */
N#define I2C2                                     ((I2C_Type *)I2C2_BASE)
N/** Peripheral I2C3 base address */
N#define I2C3_BASE                                (0x40089000u)
N/** Peripheral I2C3 base pointer */
N#define I2C3                                     ((I2C_Type *)I2C3_BASE)
N/** Peripheral I2C4 base address */
N#define I2C4_BASE                                (0x4008A000u)
N/** Peripheral I2C4 base pointer */
N#define I2C4                                     ((I2C_Type *)I2C4_BASE)
N/** Peripheral I2C5 base address */
N#define I2C5_BASE                                (0x40096000u)
N/** Peripheral I2C5 base pointer */
N#define I2C5                                     ((I2C_Type *)I2C5_BASE)
N/** Peripheral I2C6 base address */
N#define I2C6_BASE                                (0x40097000u)
N/** Peripheral I2C6 base pointer */
N#define I2C6                                     ((I2C_Type *)I2C6_BASE)
N/** Peripheral I2C7 base address */
N#define I2C7_BASE                                (0x40098000u)
N/** Peripheral I2C7 base pointer */
N#define I2C7                                     ((I2C_Type *)I2C7_BASE)
N/** Peripheral I2C8 base address */
N#define I2C8_BASE                                (0x40099000u)
N/** Peripheral I2C8 base pointer */
N#define I2C8                                     ((I2C_Type *)I2C8_BASE)
N/** Peripheral I2C9 base address */
N#define I2C9_BASE                                (0x4009A000u)
N/** Peripheral I2C9 base pointer */
N#define I2C9                                     ((I2C_Type *)I2C9_BASE)
N/** Array initializer of I2C peripheral base addresses */
N#define I2C_BASE_ADDRS                           { I2C0_BASE, I2C1_BASE, I2C2_BASE, I2C3_BASE, I2C4_BASE, I2C5_BASE, I2C6_BASE, I2C7_BASE, I2C8_BASE, I2C9_BASE }
N/** Array initializer of I2C peripheral base pointers */
N#define I2C_BASE_PTRS                            { I2C0, I2C1, I2C2, I2C3, I2C4, I2C5, I2C6, I2C7, I2C8, I2C9 }
N/** Interrupt vectors for the I2C peripheral type */
N#define I2C_IRQS                                 { FLEXCOMM0_IRQn, FLEXCOMM1_IRQn, FLEXCOMM2_IRQn, FLEXCOMM3_IRQn, FLEXCOMM4_IRQn, FLEXCOMM5_IRQn, FLEXCOMM6_IRQn, FLEXCOMM7_IRQn, FLEXCOMM8_IRQn, FLEXCOMM9_IRQn }
N
N/*!
N * @}
N */ /* end of group I2C_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- I2S Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup I2S_Peripheral_Access_Layer I2S Peripheral Access Layer
N * @{
N */
N
N/** I2S - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[32];
N  struct {                                         /* offset: 0x20, array step: 0x20 */
N    __IO uint32_t PCFG1;                             /**< Configuration register 1 for channel pair, array offset: 0x20, array step: 0x20 */
X    volatile uint32_t PCFG1;                              
N    __IO uint32_t PCFG2;                             /**< Configuration register 2 for channel pair, array offset: 0x24, array step: 0x20 */
X    volatile uint32_t PCFG2;                              
N    __IO uint32_t PSTAT;                             /**< Status register for channel pair, array offset: 0x28, array step: 0x20 */
X    volatile uint32_t PSTAT;                              
N         uint8_t RESERVED_0[20];
N  } SECCHANNEL[3];
N       uint8_t RESERVED_1[2944];
N  __IO uint32_t CFG1;                              /**< Configuration register 1 for the primary channel pair., offset: 0xC00 */
X  volatile uint32_t CFG1;                               
N  __IO uint32_t CFG2;                              /**< Configuration register 2 for the primary channel pair., offset: 0xC04 */
X  volatile uint32_t CFG2;                               
N  __IO uint32_t STAT;                              /**< Status register for the primary channel pair., offset: 0xC08 */
X  volatile uint32_t STAT;                               
N       uint8_t RESERVED_2[16];
N  __IO uint32_t DIV;                               /**< Clock divider, used by all channel pairs., offset: 0xC1C */
X  volatile uint32_t DIV;                                
N       uint8_t RESERVED_3[480];
N  __IO uint32_t FIFOCFG;                           /**< FIFO configuration and enable register., offset: 0xE00 */
X  volatile uint32_t FIFOCFG;                            
N  __IO uint32_t FIFOSTAT;                          /**< FIFO status register., offset: 0xE04 */
X  volatile uint32_t FIFOSTAT;                           
N  __IO uint32_t FIFOTRIG;                          /**< FIFO trigger settings for interrupt and DMA request., offset: 0xE08 */
X  volatile uint32_t FIFOTRIG;                           
N       uint8_t RESERVED_4[4];
N  __IO uint32_t FIFOINTENSET;                      /**< FIFO interrupt enable set (enable) and read register., offset: 0xE10 */
X  volatile uint32_t FIFOINTENSET;                       
N  __IO uint32_t FIFOINTENCLR;                      /**< FIFO interrupt enable clear (disable) and read register., offset: 0xE14 */
X  volatile uint32_t FIFOINTENCLR;                       
N  __I  uint32_t FIFOINTSTAT;                       /**< FIFO interrupt status register., offset: 0xE18 */
X  volatile const  uint32_t FIFOINTSTAT;                        
N       uint8_t RESERVED_5[4];
N  __O  uint32_t FIFOWR;                            /**< FIFO write data., offset: 0xE20 */
X  volatile  uint32_t FIFOWR;                             
N  __O  uint32_t FIFOWR48H;                         /**< FIFO write data for upper data bits. May only be used if the I2S is configured for 2x 24-bit data and not using DMA., offset: 0xE24 */
X  volatile  uint32_t FIFOWR48H;                          
N       uint8_t RESERVED_6[8];
N  __I  uint32_t FIFORD;                            /**< FIFO read data., offset: 0xE30 */
X  volatile const  uint32_t FIFORD;                             
N  __I  uint32_t FIFORD48H;                         /**< FIFO read data for upper data bits. May only be used if the I2S is configured for 2x 24-bit data and not using DMA., offset: 0xE34 */
X  volatile const  uint32_t FIFORD48H;                          
N       uint8_t RESERVED_7[8];
N  __I  uint32_t FIFORDNOPOP;                       /**< FIFO data read with no FIFO pop., offset: 0xE40 */
X  volatile const  uint32_t FIFORDNOPOP;                        
N  __I  uint32_t FIFORD48HNOPOP;                    /**< FIFO data read for upper data bits with no FIFO pop. May only be used if the I2S is configured for 2x 24-bit data and not using DMA., offset: 0xE44 */
X  volatile const  uint32_t FIFORD48HNOPOP;                     
N       uint8_t RESERVED_8[4020];
N  __I  uint32_t ID;                                /**< I2S Module identification, offset: 0x1DFC */
X  volatile const  uint32_t ID;                                 
N} I2S_Type;
N
N/* ----------------------------------------------------------------------------
N   -- I2S Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup I2S_Register_Masks I2S Register Masks
N * @{
N */
N
N/*! @name SECCHANNEL_PCFG1 - Configuration register 1 for channel pair */
N#define I2S_SECCHANNEL_PCFG1_PAIRENABLE_MASK     (0x1U)
N#define I2S_SECCHANNEL_PCFG1_PAIRENABLE_SHIFT    (0U)
N#define I2S_SECCHANNEL_PCFG1_PAIRENABLE(x)       (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PCFG1_PAIRENABLE_SHIFT)) & I2S_SECCHANNEL_PCFG1_PAIRENABLE_MASK)
N#define I2S_SECCHANNEL_PCFG1_ONECHANNEL_MASK     (0x400U)
N#define I2S_SECCHANNEL_PCFG1_ONECHANNEL_SHIFT    (10U)
N#define I2S_SECCHANNEL_PCFG1_ONECHANNEL(x)       (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PCFG1_ONECHANNEL_SHIFT)) & I2S_SECCHANNEL_PCFG1_ONECHANNEL_MASK)
N
N/* The count of I2S_SECCHANNEL_PCFG1 */
N#define I2S_SECCHANNEL_PCFG1_COUNT               (3U)
N
N/*! @name SECCHANNEL_PCFG2 - Configuration register 2 for channel pair */
N#define I2S_SECCHANNEL_PCFG2_POSITION_MASK       (0x1FF0000U)
N#define I2S_SECCHANNEL_PCFG2_POSITION_SHIFT      (16U)
N#define I2S_SECCHANNEL_PCFG2_POSITION(x)         (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PCFG2_POSITION_SHIFT)) & I2S_SECCHANNEL_PCFG2_POSITION_MASK)
N
N/* The count of I2S_SECCHANNEL_PCFG2 */
N#define I2S_SECCHANNEL_PCFG2_COUNT               (3U)
N
N/*! @name SECCHANNEL_PSTAT - Status register for channel pair */
N#define I2S_SECCHANNEL_PSTAT_BUSY_MASK           (0x1U)
N#define I2S_SECCHANNEL_PSTAT_BUSY_SHIFT          (0U)
N#define I2S_SECCHANNEL_PSTAT_BUSY(x)             (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PSTAT_BUSY_SHIFT)) & I2S_SECCHANNEL_PSTAT_BUSY_MASK)
N#define I2S_SECCHANNEL_PSTAT_SLVFRMERR_MASK      (0x2U)
N#define I2S_SECCHANNEL_PSTAT_SLVFRMERR_SHIFT     (1U)
N#define I2S_SECCHANNEL_PSTAT_SLVFRMERR(x)        (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PSTAT_SLVFRMERR_SHIFT)) & I2S_SECCHANNEL_PSTAT_SLVFRMERR_MASK)
N#define I2S_SECCHANNEL_PSTAT_LR_MASK             (0x4U)
N#define I2S_SECCHANNEL_PSTAT_LR_SHIFT            (2U)
N#define I2S_SECCHANNEL_PSTAT_LR(x)               (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PSTAT_LR_SHIFT)) & I2S_SECCHANNEL_PSTAT_LR_MASK)
N#define I2S_SECCHANNEL_PSTAT_DATAPAUSED_MASK     (0x8U)
N#define I2S_SECCHANNEL_PSTAT_DATAPAUSED_SHIFT    (3U)
N#define I2S_SECCHANNEL_PSTAT_DATAPAUSED(x)       (((uint32_t)(((uint32_t)(x)) << I2S_SECCHANNEL_PSTAT_DATAPAUSED_SHIFT)) & I2S_SECCHANNEL_PSTAT_DATAPAUSED_MASK)
N
N/* The count of I2S_SECCHANNEL_PSTAT */
N#define I2S_SECCHANNEL_PSTAT_COUNT               (3U)
N
N/*! @name CFG1 - Configuration register 1 for the primary channel pair. */
N#define I2S_CFG1_MAINENABLE_MASK                 (0x1U)
N#define I2S_CFG1_MAINENABLE_SHIFT                (0U)
N#define I2S_CFG1_MAINENABLE(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_MAINENABLE_SHIFT)) & I2S_CFG1_MAINENABLE_MASK)
N#define I2S_CFG1_DATAPAUSE_MASK                  (0x2U)
N#define I2S_CFG1_DATAPAUSE_SHIFT                 (1U)
N#define I2S_CFG1_DATAPAUSE(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_DATAPAUSE_SHIFT)) & I2S_CFG1_DATAPAUSE_MASK)
N#define I2S_CFG1_PAIRCOUNT_MASK                  (0xCU)
N#define I2S_CFG1_PAIRCOUNT_SHIFT                 (2U)
N#define I2S_CFG1_PAIRCOUNT(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_PAIRCOUNT_SHIFT)) & I2S_CFG1_PAIRCOUNT_MASK)
N#define I2S_CFG1_MSTSLVCFG_MASK                  (0x30U)
N#define I2S_CFG1_MSTSLVCFG_SHIFT                 (4U)
N#define I2S_CFG1_MSTSLVCFG(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_MSTSLVCFG_SHIFT)) & I2S_CFG1_MSTSLVCFG_MASK)
N#define I2S_CFG1_MODE_MASK                       (0xC0U)
N#define I2S_CFG1_MODE_SHIFT                      (6U)
N#define I2S_CFG1_MODE(x)                         (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_MODE_SHIFT)) & I2S_CFG1_MODE_MASK)
N#define I2S_CFG1_RIGHTLOW_MASK                   (0x100U)
N#define I2S_CFG1_RIGHTLOW_SHIFT                  (8U)
N#define I2S_CFG1_RIGHTLOW(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_RIGHTLOW_SHIFT)) & I2S_CFG1_RIGHTLOW_MASK)
N#define I2S_CFG1_LEFTJUST_MASK                   (0x200U)
N#define I2S_CFG1_LEFTJUST_SHIFT                  (9U)
N#define I2S_CFG1_LEFTJUST(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_LEFTJUST_SHIFT)) & I2S_CFG1_LEFTJUST_MASK)
N#define I2S_CFG1_ONECHANNEL_MASK                 (0x400U)
N#define I2S_CFG1_ONECHANNEL_SHIFT                (10U)
N#define I2S_CFG1_ONECHANNEL(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_ONECHANNEL_SHIFT)) & I2S_CFG1_ONECHANNEL_MASK)
N#define I2S_CFG1_PDMDATA_MASK                    (0x800U)
N#define I2S_CFG1_PDMDATA_SHIFT                   (11U)
N#define I2S_CFG1_PDMDATA(x)                      (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_PDMDATA_SHIFT)) & I2S_CFG1_PDMDATA_MASK)
N#define I2S_CFG1_SCK_POL_MASK                    (0x1000U)
N#define I2S_CFG1_SCK_POL_SHIFT                   (12U)
N#define I2S_CFG1_SCK_POL(x)                      (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_SCK_POL_SHIFT)) & I2S_CFG1_SCK_POL_MASK)
N#define I2S_CFG1_WS_POL_MASK                     (0x2000U)
N#define I2S_CFG1_WS_POL_SHIFT                    (13U)
N#define I2S_CFG1_WS_POL(x)                       (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_WS_POL_SHIFT)) & I2S_CFG1_WS_POL_MASK)
N#define I2S_CFG1_DATALEN_MASK                    (0x1F0000U)
N#define I2S_CFG1_DATALEN_SHIFT                   (16U)
N#define I2S_CFG1_DATALEN(x)                      (((uint32_t)(((uint32_t)(x)) << I2S_CFG1_DATALEN_SHIFT)) & I2S_CFG1_DATALEN_MASK)
N
N/*! @name CFG2 - Configuration register 2 for the primary channel pair. */
N#define I2S_CFG2_FRAMELEN_MASK                   (0x1FFU)
N#define I2S_CFG2_FRAMELEN_SHIFT                  (0U)
N#define I2S_CFG2_FRAMELEN(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_CFG2_FRAMELEN_SHIFT)) & I2S_CFG2_FRAMELEN_MASK)
N#define I2S_CFG2_POSITION_MASK                   (0x1FF0000U)
N#define I2S_CFG2_POSITION_SHIFT                  (16U)
N#define I2S_CFG2_POSITION(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_CFG2_POSITION_SHIFT)) & I2S_CFG2_POSITION_MASK)
N
N/*! @name STAT - Status register for the primary channel pair. */
N#define I2S_STAT_BUSY_MASK                       (0x1U)
N#define I2S_STAT_BUSY_SHIFT                      (0U)
N#define I2S_STAT_BUSY(x)                         (((uint32_t)(((uint32_t)(x)) << I2S_STAT_BUSY_SHIFT)) & I2S_STAT_BUSY_MASK)
N#define I2S_STAT_SLVFRMERR_MASK                  (0x2U)
N#define I2S_STAT_SLVFRMERR_SHIFT                 (1U)
N#define I2S_STAT_SLVFRMERR(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_STAT_SLVFRMERR_SHIFT)) & I2S_STAT_SLVFRMERR_MASK)
N#define I2S_STAT_LR_MASK                         (0x4U)
N#define I2S_STAT_LR_SHIFT                        (2U)
N#define I2S_STAT_LR(x)                           (((uint32_t)(((uint32_t)(x)) << I2S_STAT_LR_SHIFT)) & I2S_STAT_LR_MASK)
N#define I2S_STAT_DATAPAUSED_MASK                 (0x8U)
N#define I2S_STAT_DATAPAUSED_SHIFT                (3U)
N#define I2S_STAT_DATAPAUSED(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_STAT_DATAPAUSED_SHIFT)) & I2S_STAT_DATAPAUSED_MASK)
N
N/*! @name DIV - Clock divider, used by all channel pairs. */
N#define I2S_DIV_DIV_MASK                         (0xFFFU)
N#define I2S_DIV_DIV_SHIFT                        (0U)
N#define I2S_DIV_DIV(x)                           (((uint32_t)(((uint32_t)(x)) << I2S_DIV_DIV_SHIFT)) & I2S_DIV_DIV_MASK)
N
N/*! @name FIFOCFG - FIFO configuration and enable register. */
N#define I2S_FIFOCFG_ENABLETX_MASK                (0x1U)
N#define I2S_FIFOCFG_ENABLETX_SHIFT               (0U)
N#define I2S_FIFOCFG_ENABLETX(x)                  (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_ENABLETX_SHIFT)) & I2S_FIFOCFG_ENABLETX_MASK)
N#define I2S_FIFOCFG_ENABLERX_MASK                (0x2U)
N#define I2S_FIFOCFG_ENABLERX_SHIFT               (1U)
N#define I2S_FIFOCFG_ENABLERX(x)                  (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_ENABLERX_SHIFT)) & I2S_FIFOCFG_ENABLERX_MASK)
N#define I2S_FIFOCFG_TXI2SE0_MASK                 (0x4U)
N#define I2S_FIFOCFG_TXI2SE0_SHIFT                (2U)
N#define I2S_FIFOCFG_TXI2SE0(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_TXI2SE0_SHIFT)) & I2S_FIFOCFG_TXI2SE0_MASK)
N#define I2S_FIFOCFG_PACK48_MASK                  (0x8U)
N#define I2S_FIFOCFG_PACK48_SHIFT                 (3U)
N#define I2S_FIFOCFG_PACK48(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_PACK48_SHIFT)) & I2S_FIFOCFG_PACK48_MASK)
N#define I2S_FIFOCFG_SIZE_MASK                    (0x30U)
N#define I2S_FIFOCFG_SIZE_SHIFT                   (4U)
N#define I2S_FIFOCFG_SIZE(x)                      (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_SIZE_SHIFT)) & I2S_FIFOCFG_SIZE_MASK)
N#define I2S_FIFOCFG_DMATX_MASK                   (0x1000U)
N#define I2S_FIFOCFG_DMATX_SHIFT                  (12U)
N#define I2S_FIFOCFG_DMATX(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_DMATX_SHIFT)) & I2S_FIFOCFG_DMATX_MASK)
N#define I2S_FIFOCFG_DMARX_MASK                   (0x2000U)
N#define I2S_FIFOCFG_DMARX_SHIFT                  (13U)
N#define I2S_FIFOCFG_DMARX(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_DMARX_SHIFT)) & I2S_FIFOCFG_DMARX_MASK)
N#define I2S_FIFOCFG_WAKETX_MASK                  (0x4000U)
N#define I2S_FIFOCFG_WAKETX_SHIFT                 (14U)
N#define I2S_FIFOCFG_WAKETX(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_WAKETX_SHIFT)) & I2S_FIFOCFG_WAKETX_MASK)
N#define I2S_FIFOCFG_WAKERX_MASK                  (0x8000U)
N#define I2S_FIFOCFG_WAKERX_SHIFT                 (15U)
N#define I2S_FIFOCFG_WAKERX(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_WAKERX_SHIFT)) & I2S_FIFOCFG_WAKERX_MASK)
N#define I2S_FIFOCFG_EMPTYTX_MASK                 (0x10000U)
N#define I2S_FIFOCFG_EMPTYTX_SHIFT                (16U)
N#define I2S_FIFOCFG_EMPTYTX(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_EMPTYTX_SHIFT)) & I2S_FIFOCFG_EMPTYTX_MASK)
N#define I2S_FIFOCFG_EMPTYRX_MASK                 (0x20000U)
N#define I2S_FIFOCFG_EMPTYRX_SHIFT                (17U)
N#define I2S_FIFOCFG_EMPTYRX(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_EMPTYRX_SHIFT)) & I2S_FIFOCFG_EMPTYRX_MASK)
N#define I2S_FIFOCFG_POPDBG_MASK                  (0x40000U)
N#define I2S_FIFOCFG_POPDBG_SHIFT                 (18U)
N#define I2S_FIFOCFG_POPDBG(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOCFG_POPDBG_SHIFT)) & I2S_FIFOCFG_POPDBG_MASK)
N
N/*! @name FIFOSTAT - FIFO status register. */
N#define I2S_FIFOSTAT_TXERR_MASK                  (0x1U)
N#define I2S_FIFOSTAT_TXERR_SHIFT                 (0U)
N#define I2S_FIFOSTAT_TXERR(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_TXERR_SHIFT)) & I2S_FIFOSTAT_TXERR_MASK)
N#define I2S_FIFOSTAT_RXERR_MASK                  (0x2U)
N#define I2S_FIFOSTAT_RXERR_SHIFT                 (1U)
N#define I2S_FIFOSTAT_RXERR(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_RXERR_SHIFT)) & I2S_FIFOSTAT_RXERR_MASK)
N#define I2S_FIFOSTAT_PERINT_MASK                 (0x8U)
N#define I2S_FIFOSTAT_PERINT_SHIFT                (3U)
N#define I2S_FIFOSTAT_PERINT(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_PERINT_SHIFT)) & I2S_FIFOSTAT_PERINT_MASK)
N#define I2S_FIFOSTAT_TXEMPTY_MASK                (0x10U)
N#define I2S_FIFOSTAT_TXEMPTY_SHIFT               (4U)
N#define I2S_FIFOSTAT_TXEMPTY(x)                  (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_TXEMPTY_SHIFT)) & I2S_FIFOSTAT_TXEMPTY_MASK)
N#define I2S_FIFOSTAT_TXNOTFULL_MASK              (0x20U)
N#define I2S_FIFOSTAT_TXNOTFULL_SHIFT             (5U)
N#define I2S_FIFOSTAT_TXNOTFULL(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_TXNOTFULL_SHIFT)) & I2S_FIFOSTAT_TXNOTFULL_MASK)
N#define I2S_FIFOSTAT_RXNOTEMPTY_MASK             (0x40U)
N#define I2S_FIFOSTAT_RXNOTEMPTY_SHIFT            (6U)
N#define I2S_FIFOSTAT_RXNOTEMPTY(x)               (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_RXNOTEMPTY_SHIFT)) & I2S_FIFOSTAT_RXNOTEMPTY_MASK)
N#define I2S_FIFOSTAT_RXFULL_MASK                 (0x80U)
N#define I2S_FIFOSTAT_RXFULL_SHIFT                (7U)
N#define I2S_FIFOSTAT_RXFULL(x)                   (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_RXFULL_SHIFT)) & I2S_FIFOSTAT_RXFULL_MASK)
N#define I2S_FIFOSTAT_TXLVL_MASK                  (0x1F00U)
N#define I2S_FIFOSTAT_TXLVL_SHIFT                 (8U)
N#define I2S_FIFOSTAT_TXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_TXLVL_SHIFT)) & I2S_FIFOSTAT_TXLVL_MASK)
N#define I2S_FIFOSTAT_RXLVL_MASK                  (0x1F0000U)
N#define I2S_FIFOSTAT_RXLVL_SHIFT                 (16U)
N#define I2S_FIFOSTAT_RXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOSTAT_RXLVL_SHIFT)) & I2S_FIFOSTAT_RXLVL_MASK)
N
N/*! @name FIFOTRIG - FIFO trigger settings for interrupt and DMA request. */
N#define I2S_FIFOTRIG_TXLVLENA_MASK               (0x1U)
N#define I2S_FIFOTRIG_TXLVLENA_SHIFT              (0U)
N#define I2S_FIFOTRIG_TXLVLENA(x)                 (((uint32_t)(((uint32_t)(x)) << I2S_FIFOTRIG_TXLVLENA_SHIFT)) & I2S_FIFOTRIG_TXLVLENA_MASK)
N#define I2S_FIFOTRIG_RXLVLENA_MASK               (0x2U)
N#define I2S_FIFOTRIG_RXLVLENA_SHIFT              (1U)
N#define I2S_FIFOTRIG_RXLVLENA(x)                 (((uint32_t)(((uint32_t)(x)) << I2S_FIFOTRIG_RXLVLENA_SHIFT)) & I2S_FIFOTRIG_RXLVLENA_MASK)
N#define I2S_FIFOTRIG_TXLVL_MASK                  (0xF00U)
N#define I2S_FIFOTRIG_TXLVL_SHIFT                 (8U)
N#define I2S_FIFOTRIG_TXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOTRIG_TXLVL_SHIFT)) & I2S_FIFOTRIG_TXLVL_MASK)
N#define I2S_FIFOTRIG_RXLVL_MASK                  (0xF0000U)
N#define I2S_FIFOTRIG_RXLVL_SHIFT                 (16U)
N#define I2S_FIFOTRIG_RXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << I2S_FIFOTRIG_RXLVL_SHIFT)) & I2S_FIFOTRIG_RXLVL_MASK)
N
N/*! @name FIFOINTENSET - FIFO interrupt enable set (enable) and read register. */
N#define I2S_FIFOINTENSET_TXERR_MASK              (0x1U)
N#define I2S_FIFOINTENSET_TXERR_SHIFT             (0U)
N#define I2S_FIFOINTENSET_TXERR(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENSET_TXERR_SHIFT)) & I2S_FIFOINTENSET_TXERR_MASK)
N#define I2S_FIFOINTENSET_RXERR_MASK              (0x2U)
N#define I2S_FIFOINTENSET_RXERR_SHIFT             (1U)
N#define I2S_FIFOINTENSET_RXERR(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENSET_RXERR_SHIFT)) & I2S_FIFOINTENSET_RXERR_MASK)
N#define I2S_FIFOINTENSET_TXLVL_MASK              (0x4U)
N#define I2S_FIFOINTENSET_TXLVL_SHIFT             (2U)
N#define I2S_FIFOINTENSET_TXLVL(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENSET_TXLVL_SHIFT)) & I2S_FIFOINTENSET_TXLVL_MASK)
N#define I2S_FIFOINTENSET_RXLVL_MASK              (0x8U)
N#define I2S_FIFOINTENSET_RXLVL_SHIFT             (3U)
N#define I2S_FIFOINTENSET_RXLVL(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENSET_RXLVL_SHIFT)) & I2S_FIFOINTENSET_RXLVL_MASK)
N
N/*! @name FIFOINTENCLR - FIFO interrupt enable clear (disable) and read register. */
N#define I2S_FIFOINTENCLR_TXERR_MASK              (0x1U)
N#define I2S_FIFOINTENCLR_TXERR_SHIFT             (0U)
N#define I2S_FIFOINTENCLR_TXERR(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENCLR_TXERR_SHIFT)) & I2S_FIFOINTENCLR_TXERR_MASK)
N#define I2S_FIFOINTENCLR_RXERR_MASK              (0x2U)
N#define I2S_FIFOINTENCLR_RXERR_SHIFT             (1U)
N#define I2S_FIFOINTENCLR_RXERR(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENCLR_RXERR_SHIFT)) & I2S_FIFOINTENCLR_RXERR_MASK)
N#define I2S_FIFOINTENCLR_TXLVL_MASK              (0x4U)
N#define I2S_FIFOINTENCLR_TXLVL_SHIFT             (2U)
N#define I2S_FIFOINTENCLR_TXLVL(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENCLR_TXLVL_SHIFT)) & I2S_FIFOINTENCLR_TXLVL_MASK)
N#define I2S_FIFOINTENCLR_RXLVL_MASK              (0x8U)
N#define I2S_FIFOINTENCLR_RXLVL_SHIFT             (3U)
N#define I2S_FIFOINTENCLR_RXLVL(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTENCLR_RXLVL_SHIFT)) & I2S_FIFOINTENCLR_RXLVL_MASK)
N
N/*! @name FIFOINTSTAT - FIFO interrupt status register. */
N#define I2S_FIFOINTSTAT_TXERR_MASK               (0x1U)
N#define I2S_FIFOINTSTAT_TXERR_SHIFT              (0U)
N#define I2S_FIFOINTSTAT_TXERR(x)                 (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTSTAT_TXERR_SHIFT)) & I2S_FIFOINTSTAT_TXERR_MASK)
N#define I2S_FIFOINTSTAT_RXERR_MASK               (0x2U)
N#define I2S_FIFOINTSTAT_RXERR_SHIFT              (1U)
N#define I2S_FIFOINTSTAT_RXERR(x)                 (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTSTAT_RXERR_SHIFT)) & I2S_FIFOINTSTAT_RXERR_MASK)
N#define I2S_FIFOINTSTAT_TXLVL_MASK               (0x4U)
N#define I2S_FIFOINTSTAT_TXLVL_SHIFT              (2U)
N#define I2S_FIFOINTSTAT_TXLVL(x)                 (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTSTAT_TXLVL_SHIFT)) & I2S_FIFOINTSTAT_TXLVL_MASK)
N#define I2S_FIFOINTSTAT_RXLVL_MASK               (0x8U)
N#define I2S_FIFOINTSTAT_RXLVL_SHIFT              (3U)
N#define I2S_FIFOINTSTAT_RXLVL(x)                 (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTSTAT_RXLVL_SHIFT)) & I2S_FIFOINTSTAT_RXLVL_MASK)
N#define I2S_FIFOINTSTAT_PERINT_MASK              (0x10U)
N#define I2S_FIFOINTSTAT_PERINT_SHIFT             (4U)
N#define I2S_FIFOINTSTAT_PERINT(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFOINTSTAT_PERINT_SHIFT)) & I2S_FIFOINTSTAT_PERINT_MASK)
N
N/*! @name FIFOWR - FIFO write data. */
N#define I2S_FIFOWR_TXDATA_MASK                   (0xFFFFFFFFU)
N#define I2S_FIFOWR_TXDATA_SHIFT                  (0U)
N#define I2S_FIFOWR_TXDATA(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_FIFOWR_TXDATA_SHIFT)) & I2S_FIFOWR_TXDATA_MASK)
N
N/*! @name FIFOWR48H - FIFO write data for upper data bits. May only be used if the I2S is configured for 2x 24-bit data and not using DMA. */
N#define I2S_FIFOWR48H_TXDATA_MASK                (0xFFFFFFU)
N#define I2S_FIFOWR48H_TXDATA_SHIFT               (0U)
N#define I2S_FIFOWR48H_TXDATA(x)                  (((uint32_t)(((uint32_t)(x)) << I2S_FIFOWR48H_TXDATA_SHIFT)) & I2S_FIFOWR48H_TXDATA_MASK)
N
N/*! @name FIFORD - FIFO read data. */
N#define I2S_FIFORD_RXDATA_MASK                   (0xFFFFFFFFU)
N#define I2S_FIFORD_RXDATA_SHIFT                  (0U)
N#define I2S_FIFORD_RXDATA(x)                     (((uint32_t)(((uint32_t)(x)) << I2S_FIFORD_RXDATA_SHIFT)) & I2S_FIFORD_RXDATA_MASK)
N
N/*! @name FIFORD48H - FIFO read data for upper data bits. May only be used if the I2S is configured for 2x 24-bit data and not using DMA. */
N#define I2S_FIFORD48H_RXDATA_MASK                (0xFFFFFFU)
N#define I2S_FIFORD48H_RXDATA_SHIFT               (0U)
N#define I2S_FIFORD48H_RXDATA(x)                  (((uint32_t)(((uint32_t)(x)) << I2S_FIFORD48H_RXDATA_SHIFT)) & I2S_FIFORD48H_RXDATA_MASK)
N
N/*! @name FIFORDNOPOP - FIFO data read with no FIFO pop. */
N#define I2S_FIFORDNOPOP_RXDATA_MASK              (0xFFFFFFFFU)
N#define I2S_FIFORDNOPOP_RXDATA_SHIFT             (0U)
N#define I2S_FIFORDNOPOP_RXDATA(x)                (((uint32_t)(((uint32_t)(x)) << I2S_FIFORDNOPOP_RXDATA_SHIFT)) & I2S_FIFORDNOPOP_RXDATA_MASK)
N
N/*! @name FIFORD48HNOPOP - FIFO data read for upper data bits with no FIFO pop. May only be used if the I2S is configured for 2x 24-bit data and not using DMA. */
N#define I2S_FIFORD48HNOPOP_RXDATA_MASK           (0xFFFFFFU)
N#define I2S_FIFORD48HNOPOP_RXDATA_SHIFT          (0U)
N#define I2S_FIFORD48HNOPOP_RXDATA(x)             (((uint32_t)(((uint32_t)(x)) << I2S_FIFORD48HNOPOP_RXDATA_SHIFT)) & I2S_FIFORD48HNOPOP_RXDATA_MASK)
N
N/*! @name ID - I2S Module identification */
N#define I2S_ID_Aperture_MASK                     (0xFFU)
N#define I2S_ID_Aperture_SHIFT                    (0U)
N#define I2S_ID_Aperture(x)                       (((uint32_t)(((uint32_t)(x)) << I2S_ID_Aperture_SHIFT)) & I2S_ID_Aperture_MASK)
N#define I2S_ID_Minor_Rev_MASK                    (0xF00U)
N#define I2S_ID_Minor_Rev_SHIFT                   (8U)
N#define I2S_ID_Minor_Rev(x)                      (((uint32_t)(((uint32_t)(x)) << I2S_ID_Minor_Rev_SHIFT)) & I2S_ID_Minor_Rev_MASK)
N#define I2S_ID_Major_Rev_MASK                    (0xF000U)
N#define I2S_ID_Major_Rev_SHIFT                   (12U)
N#define I2S_ID_Major_Rev(x)                      (((uint32_t)(((uint32_t)(x)) << I2S_ID_Major_Rev_SHIFT)) & I2S_ID_Major_Rev_MASK)
N#define I2S_ID_ID_MASK                           (0xFFFF0000U)
N#define I2S_ID_ID_SHIFT                          (16U)
N#define I2S_ID_ID(x)                             (((uint32_t)(((uint32_t)(x)) << I2S_ID_ID_SHIFT)) & I2S_ID_ID_MASK)
N
N
N/*!
N * @}
N */ /* end of group I2S_Register_Masks */
N
N
N/* I2S - Peripheral instance base addresses */
N/** Peripheral I2S0 base address */
N#define I2S0_BASE                                (0x40097000u)
N/** Peripheral I2S0 base pointer */
N#define I2S0                                     ((I2S_Type *)I2S0_BASE)
N/** Peripheral I2S1 base address */
N#define I2S1_BASE                                (0x40098000u)
N/** Peripheral I2S1 base pointer */
N#define I2S1                                     ((I2S_Type *)I2S1_BASE)
N/** Array initializer of I2S peripheral base addresses */
N#define I2S_BASE_ADDRS                           { I2S0_BASE, I2S1_BASE }
N/** Array initializer of I2S peripheral base pointers */
N#define I2S_BASE_PTRS                            { I2S0, I2S1 }
N/** Interrupt vectors for the I2S peripheral type */
N#define I2S_IRQS                                 { FLEXCOMM6_IRQn, FLEXCOMM7_IRQn }
N
N/*!
N * @}
N */ /* end of group I2S_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- INPUTMUX Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup INPUTMUX_Peripheral_Access_Layer INPUTMUX Peripheral Access Layer
N * @{
N */
N
N/** INPUTMUX - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t SCT0_INMUX[7];                     /**< Trigger select register for DMA channel, array offset: 0x0, array step: 0x4 */
X  volatile uint32_t SCT0_INMUX[7];                      
N       uint8_t RESERVED_0[164];
N  __IO uint32_t PINTSEL[8];                        /**< Pin interrupt select register, array offset: 0xC0, array step: 0x4 */
X  volatile uint32_t PINTSEL[8];                         
N  __IO uint32_t DMA_ITRIG_INMUX[30];               /**< Trigger select register for DMA channel, array offset: 0xE0, array step: 0x4 */
X  volatile uint32_t DMA_ITRIG_INMUX[30];                
N       uint8_t RESERVED_1[8];
N  __IO uint32_t DMA_OTRIG_INMUX[4];                /**< DMA output trigger selection to become DMA trigger, array offset: 0x160, array step: 0x4 */
X  volatile uint32_t DMA_OTRIG_INMUX[4];                 
N       uint8_t RESERVED_2[16];
N  __IO uint32_t FREQMEAS_REF;                      /**< Selection for frequency measurement reference clock, offset: 0x180 */
X  volatile uint32_t FREQMEAS_REF;                       
N  __IO uint32_t FREQMEAS_TARGET;                   /**< Selection for frequency measurement target clock, offset: 0x184 */
X  volatile uint32_t FREQMEAS_TARGET;                    
N} INPUTMUX_Type;
N
N/* ----------------------------------------------------------------------------
N   -- INPUTMUX Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup INPUTMUX_Register_Masks INPUTMUX Register Masks
N * @{
N */
N
N/*! @name SCT0_INMUX - Trigger select register for DMA channel */
N#define INPUTMUX_SCT0_INMUX_INP_N_MASK           (0x1FU)
N#define INPUTMUX_SCT0_INMUX_INP_N_SHIFT          (0U)
N#define INPUTMUX_SCT0_INMUX_INP_N(x)             (((uint32_t)(((uint32_t)(x)) << INPUTMUX_SCT0_INMUX_INP_N_SHIFT)) & INPUTMUX_SCT0_INMUX_INP_N_MASK)
N
N/* The count of INPUTMUX_SCT0_INMUX */
N#define INPUTMUX_SCT0_INMUX_COUNT                (7U)
N
N/*! @name PINTSEL - Pin interrupt select register */
N#define INPUTMUX_PINTSEL_INTPIN_MASK             (0xFFU)
N#define INPUTMUX_PINTSEL_INTPIN_SHIFT            (0U)
N#define INPUTMUX_PINTSEL_INTPIN(x)               (((uint32_t)(((uint32_t)(x)) << INPUTMUX_PINTSEL_INTPIN_SHIFT)) & INPUTMUX_PINTSEL_INTPIN_MASK)
N
N/* The count of INPUTMUX_PINTSEL */
N#define INPUTMUX_PINTSEL_COUNT                   (8U)
N
N/*! @name DMA_ITRIG_INMUX - Trigger select register for DMA channel */
N#define INPUTMUX_DMA_ITRIG_INMUX_INP_MASK        (0x1FU)
N#define INPUTMUX_DMA_ITRIG_INMUX_INP_SHIFT       (0U)
N#define INPUTMUX_DMA_ITRIG_INMUX_INP(x)          (((uint32_t)(((uint32_t)(x)) << INPUTMUX_DMA_ITRIG_INMUX_INP_SHIFT)) & INPUTMUX_DMA_ITRIG_INMUX_INP_MASK)
N
N/* The count of INPUTMUX_DMA_ITRIG_INMUX */
N#define INPUTMUX_DMA_ITRIG_INMUX_COUNT           (30U)
N
N/*! @name DMA_OTRIG_INMUX - DMA output trigger selection to become DMA trigger */
N#define INPUTMUX_DMA_OTRIG_INMUX_INP_MASK        (0x1FU)
N#define INPUTMUX_DMA_OTRIG_INMUX_INP_SHIFT       (0U)
N#define INPUTMUX_DMA_OTRIG_INMUX_INP(x)          (((uint32_t)(((uint32_t)(x)) << INPUTMUX_DMA_OTRIG_INMUX_INP_SHIFT)) & INPUTMUX_DMA_OTRIG_INMUX_INP_MASK)
N
N/* The count of INPUTMUX_DMA_OTRIG_INMUX */
N#define INPUTMUX_DMA_OTRIG_INMUX_COUNT           (4U)
N
N/*! @name FREQMEAS_REF - Selection for frequency measurement reference clock */
N#define INPUTMUX_FREQMEAS_REF_CLKIN_MASK         (0x1FU)
N#define INPUTMUX_FREQMEAS_REF_CLKIN_SHIFT        (0U)
N#define INPUTMUX_FREQMEAS_REF_CLKIN(x)           (((uint32_t)(((uint32_t)(x)) << INPUTMUX_FREQMEAS_REF_CLKIN_SHIFT)) & INPUTMUX_FREQMEAS_REF_CLKIN_MASK)
N
N/*! @name FREQMEAS_TARGET - Selection for frequency measurement target clock */
N#define INPUTMUX_FREQMEAS_TARGET_CLKIN_MASK      (0x1FU)
N#define INPUTMUX_FREQMEAS_TARGET_CLKIN_SHIFT     (0U)
N#define INPUTMUX_FREQMEAS_TARGET_CLKIN(x)        (((uint32_t)(((uint32_t)(x)) << INPUTMUX_FREQMEAS_TARGET_CLKIN_SHIFT)) & INPUTMUX_FREQMEAS_TARGET_CLKIN_MASK)
N
N
N/*!
N * @}
N */ /* end of group INPUTMUX_Register_Masks */
N
N
N/* INPUTMUX - Peripheral instance base addresses */
N/** Peripheral INPUTMUX base address */
N#define INPUTMUX_BASE                            (0x40005000u)
N/** Peripheral INPUTMUX base pointer */
N#define INPUTMUX                                 ((INPUTMUX_Type *)INPUTMUX_BASE)
N/** Array initializer of INPUTMUX peripheral base addresses */
N#define INPUTMUX_BASE_ADDRS                      { INPUTMUX_BASE }
N/** Array initializer of INPUTMUX peripheral base pointers */
N#define INPUTMUX_BASE_PTRS                       { INPUTMUX }
N
N/*!
N * @}
N */ /* end of group INPUTMUX_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- IOCON Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup IOCON_Peripheral_Access_Layer IOCON Peripheral Access Layer
N * @{
N */
N
N/** IOCON - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t PIO[6][32];                        /**< Digital I/O control for port 0 pins PIO0_0..Digital I/O control for port 5 pins PIO5_31, array offset: 0x0, array step: index*0x80, index2*0x4 */
X  volatile uint32_t PIO[6][32];                         
N} IOCON_Type;
N
N/* ----------------------------------------------------------------------------
N   -- IOCON Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup IOCON_Register_Masks IOCON Register Masks
N * @{
N */
N
N/*! @name PIO - Digital I/O control for port 0 pins PIO0_0..Digital I/O control for port 5 pins PIO5_31 */
N#define IOCON_PIO_FUNC_MASK                      (0xFU)
N#define IOCON_PIO_FUNC_SHIFT                     (0U)
N#define IOCON_PIO_FUNC(x)                        (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_FUNC_SHIFT)) & IOCON_PIO_FUNC_MASK)
N#define IOCON_PIO_MODE_MASK                      (0x30U)
N#define IOCON_PIO_MODE_SHIFT                     (4U)
N#define IOCON_PIO_MODE(x)                        (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_MODE_SHIFT)) & IOCON_PIO_MODE_MASK)
N#define IOCON_PIO_I2CSLEW_MASK                   (0x40U)
N#define IOCON_PIO_I2CSLEW_SHIFT                  (6U)
N#define IOCON_PIO_I2CSLEW(x)                     (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_I2CSLEW_SHIFT)) & IOCON_PIO_I2CSLEW_MASK)
N#define IOCON_PIO_INVERT_MASK                    (0x80U)
N#define IOCON_PIO_INVERT_SHIFT                   (7U)
N#define IOCON_PIO_INVERT(x)                      (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_INVERT_SHIFT)) & IOCON_PIO_INVERT_MASK)
N#define IOCON_PIO_DIGIMODE_MASK                  (0x100U)
N#define IOCON_PIO_DIGIMODE_SHIFT                 (8U)
N#define IOCON_PIO_DIGIMODE(x)                    (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_DIGIMODE_SHIFT)) & IOCON_PIO_DIGIMODE_MASK)
N#define IOCON_PIO_FILTEROFF_MASK                 (0x200U)
N#define IOCON_PIO_FILTEROFF_SHIFT                (9U)
N#define IOCON_PIO_FILTEROFF(x)                   (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_FILTEROFF_SHIFT)) & IOCON_PIO_FILTEROFF_MASK)
N#define IOCON_PIO_I2CDRIVE_MASK                  (0x400U)
N#define IOCON_PIO_I2CDRIVE_SHIFT                 (10U)
N#define IOCON_PIO_I2CDRIVE(x)                    (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_I2CDRIVE_SHIFT)) & IOCON_PIO_I2CDRIVE_MASK)
N#define IOCON_PIO_SLEW_MASK                      (0x400U)
N#define IOCON_PIO_SLEW_SHIFT                     (10U)
N#define IOCON_PIO_SLEW(x)                        (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_SLEW_SHIFT)) & IOCON_PIO_SLEW_MASK)
N#define IOCON_PIO_OD_MASK                        (0x800U)
N#define IOCON_PIO_OD_SHIFT                       (11U)
N#define IOCON_PIO_OD(x)                          (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_OD_SHIFT)) & IOCON_PIO_OD_MASK)
N#define IOCON_PIO_I2CFILTER_MASK                 (0x800U)
N#define IOCON_PIO_I2CFILTER_SHIFT                (11U)
N#define IOCON_PIO_I2CFILTER(x)                   (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_I2CFILTER_SHIFT)) & IOCON_PIO_I2CFILTER_MASK)
N
N/* The count of IOCON_PIO */
N#define IOCON_PIO_COUNT                          (6U)
N
N/* The count of IOCON_PIO */
N#define IOCON_PIO_COUNT2                         (32U)
N
N
N/*!
N * @}
N */ /* end of group IOCON_Register_Masks */
N
N
N/* IOCON - Peripheral instance base addresses */
N/** Peripheral IOCON base address */
N#define IOCON_BASE                               (0x40001000u)
N/** Peripheral IOCON base pointer */
N#define IOCON                                    ((IOCON_Type *)IOCON_BASE)
N/** Array initializer of IOCON peripheral base addresses */
N#define IOCON_BASE_ADDRS                         { IOCON_BASE }
N/** Array initializer of IOCON peripheral base pointers */
N#define IOCON_BASE_PTRS                          { IOCON }
N
N/*!
N * @}
N */ /* end of group IOCON_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- LCD Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup LCD_Peripheral_Access_Layer LCD Peripheral Access Layer
N * @{
N */
N
N/** LCD - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t TIMH;                              /**< Horizontal Timing Control register, offset: 0x0 */
X  volatile uint32_t TIMH;                               
N  __IO uint32_t TIMV;                              /**< Vertical Timing Control register, offset: 0x4 */
X  volatile uint32_t TIMV;                               
N  __IO uint32_t POL;                               /**< Clock and Signal Polarity Control register, offset: 0x8 */
X  volatile uint32_t POL;                                
N  __IO uint32_t LE;                                /**< Line End Control register, offset: 0xC */
X  volatile uint32_t LE;                                 
N  __IO uint32_t UPBASE;                            /**< Upper Panel Frame Base Address register, offset: 0x10 */
X  volatile uint32_t UPBASE;                             
N  __IO uint32_t LPBASE;                            /**< Lower Panel Frame Base Address register, offset: 0x14 */
X  volatile uint32_t LPBASE;                             
N  __IO uint32_t CTRL;                              /**< LCD Control register, offset: 0x18 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t INTMSK;                            /**< Interrupt Mask register, offset: 0x1C */
X  volatile uint32_t INTMSK;                             
N  __I  uint32_t INTRAW;                            /**< Raw Interrupt Status register, offset: 0x20 */
X  volatile const  uint32_t INTRAW;                             
N  __I  uint32_t INTSTAT;                           /**< Masked Interrupt Status register, offset: 0x24 */
X  volatile const  uint32_t INTSTAT;                            
N  __IO uint32_t INTCLR;                            /**< Interrupt Clear register, offset: 0x28 */
X  volatile uint32_t INTCLR;                             
N  __I  uint32_t UPCURR;                            /**< Upper Panel Current Address Value register, offset: 0x2C */
X  volatile const  uint32_t UPCURR;                             
N  __I  uint32_t LPCURR;                            /**< Lower Panel Current Address Value register, offset: 0x30 */
X  volatile const  uint32_t LPCURR;                             
N       uint8_t RESERVED_0[460];
N  __IO uint32_t PAL[128];                          /**< 256x16-bit Color Palette registers, array offset: 0x200, array step: 0x4 */
X  volatile uint32_t PAL[128];                           
N       uint8_t RESERVED_1[1024];
N  __IO uint32_t CRSR_IMG[256];                     /**< Cursor Image registers, array offset: 0x800, array step: 0x4 */
X  volatile uint32_t CRSR_IMG[256];                      
N  __IO uint32_t CRSR_CTRL;                         /**< Cursor Control register, offset: 0xC00 */
X  volatile uint32_t CRSR_CTRL;                          
N  __IO uint32_t CRSR_CFG;                          /**< Cursor Configuration register, offset: 0xC04 */
X  volatile uint32_t CRSR_CFG;                           
N  __IO uint32_t CRSR_PAL0;                         /**< Cursor Palette register 0, offset: 0xC08 */
X  volatile uint32_t CRSR_PAL0;                          
N  __IO uint32_t CRSR_PAL1;                         /**< Cursor Palette register 1, offset: 0xC0C */
X  volatile uint32_t CRSR_PAL1;                          
N  __IO uint32_t CRSR_XY;                           /**< Cursor XY Position register, offset: 0xC10 */
X  volatile uint32_t CRSR_XY;                            
N  __IO uint32_t CRSR_CLIP;                         /**< Cursor Clip Position register, offset: 0xC14 */
X  volatile uint32_t CRSR_CLIP;                          
N       uint8_t RESERVED_2[8];
N  __IO uint32_t CRSR_INTMSK;                       /**< Cursor Interrupt Mask register, offset: 0xC20 */
X  volatile uint32_t CRSR_INTMSK;                        
N  __O  uint32_t CRSR_INTCLR;                       /**< Cursor Interrupt Clear register, offset: 0xC24 */
X  volatile  uint32_t CRSR_INTCLR;                        
N  __I  uint32_t CRSR_INTRAW;                       /**< Cursor Raw Interrupt Status register, offset: 0xC28 */
X  volatile const  uint32_t CRSR_INTRAW;                        
N  __I  uint32_t CRSR_INTSTAT;                      /**< Cursor Masked Interrupt Status register, offset: 0xC2C */
X  volatile const  uint32_t CRSR_INTSTAT;                       
N} LCD_Type;
N
N/* ----------------------------------------------------------------------------
N   -- LCD Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup LCD_Register_Masks LCD Register Masks
N * @{
N */
N
N/*! @name TIMH - Horizontal Timing Control register */
N#define LCD_TIMH_PPL_MASK                        (0xFCU)
N#define LCD_TIMH_PPL_SHIFT                       (2U)
N#define LCD_TIMH_PPL(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMH_PPL_SHIFT)) & LCD_TIMH_PPL_MASK)
N#define LCD_TIMH_HSW_MASK                        (0xFF00U)
N#define LCD_TIMH_HSW_SHIFT                       (8U)
N#define LCD_TIMH_HSW(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMH_HSW_SHIFT)) & LCD_TIMH_HSW_MASK)
N#define LCD_TIMH_HFP_MASK                        (0xFF0000U)
N#define LCD_TIMH_HFP_SHIFT                       (16U)
N#define LCD_TIMH_HFP(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMH_HFP_SHIFT)) & LCD_TIMH_HFP_MASK)
N#define LCD_TIMH_HBP_MASK                        (0xFF000000U)
N#define LCD_TIMH_HBP_SHIFT                       (24U)
N#define LCD_TIMH_HBP(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMH_HBP_SHIFT)) & LCD_TIMH_HBP_MASK)
N
N/*! @name TIMV - Vertical Timing Control register */
N#define LCD_TIMV_LPP_MASK                        (0x3FFU)
N#define LCD_TIMV_LPP_SHIFT                       (0U)
N#define LCD_TIMV_LPP(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMV_LPP_SHIFT)) & LCD_TIMV_LPP_MASK)
N#define LCD_TIMV_VSW_MASK                        (0xFC00U)
N#define LCD_TIMV_VSW_SHIFT                       (10U)
N#define LCD_TIMV_VSW(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMV_VSW_SHIFT)) & LCD_TIMV_VSW_MASK)
N#define LCD_TIMV_VFP_MASK                        (0xFF0000U)
N#define LCD_TIMV_VFP_SHIFT                       (16U)
N#define LCD_TIMV_VFP(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMV_VFP_SHIFT)) & LCD_TIMV_VFP_MASK)
N#define LCD_TIMV_VBP_MASK                        (0xFF000000U)
N#define LCD_TIMV_VBP_SHIFT                       (24U)
N#define LCD_TIMV_VBP(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_TIMV_VBP_SHIFT)) & LCD_TIMV_VBP_MASK)
N
N/*! @name POL - Clock and Signal Polarity Control register */
N#define LCD_POL_PCD_LO_MASK                      (0x1FU)
N#define LCD_POL_PCD_LO_SHIFT                     (0U)
N#define LCD_POL_PCD_LO(x)                        (((uint32_t)(((uint32_t)(x)) << LCD_POL_PCD_LO_SHIFT)) & LCD_POL_PCD_LO_MASK)
N#define LCD_POL_ACB_MASK                         (0x7C0U)
N#define LCD_POL_ACB_SHIFT                        (6U)
N#define LCD_POL_ACB(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_ACB_SHIFT)) & LCD_POL_ACB_MASK)
N#define LCD_POL_IVS_MASK                         (0x800U)
N#define LCD_POL_IVS_SHIFT                        (11U)
N#define LCD_POL_IVS(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_IVS_SHIFT)) & LCD_POL_IVS_MASK)
N#define LCD_POL_IHS_MASK                         (0x1000U)
N#define LCD_POL_IHS_SHIFT                        (12U)
N#define LCD_POL_IHS(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_IHS_SHIFT)) & LCD_POL_IHS_MASK)
N#define LCD_POL_IPC_MASK                         (0x2000U)
N#define LCD_POL_IPC_SHIFT                        (13U)
N#define LCD_POL_IPC(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_IPC_SHIFT)) & LCD_POL_IPC_MASK)
N#define LCD_POL_IOE_MASK                         (0x4000U)
N#define LCD_POL_IOE_SHIFT                        (14U)
N#define LCD_POL_IOE(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_IOE_SHIFT)) & LCD_POL_IOE_MASK)
N#define LCD_POL_CPL_MASK                         (0x3FF0000U)
N#define LCD_POL_CPL_SHIFT                        (16U)
N#define LCD_POL_CPL(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_CPL_SHIFT)) & LCD_POL_CPL_MASK)
N#define LCD_POL_BCD_MASK                         (0x4000000U)
N#define LCD_POL_BCD_SHIFT                        (26U)
N#define LCD_POL_BCD(x)                           (((uint32_t)(((uint32_t)(x)) << LCD_POL_BCD_SHIFT)) & LCD_POL_BCD_MASK)
N#define LCD_POL_PCD_HI_MASK                      (0xF8000000U)
N#define LCD_POL_PCD_HI_SHIFT                     (27U)
N#define LCD_POL_PCD_HI(x)                        (((uint32_t)(((uint32_t)(x)) << LCD_POL_PCD_HI_SHIFT)) & LCD_POL_PCD_HI_MASK)
N
N/*! @name LE - Line End Control register */
N#define LCD_LE_LED_MASK                          (0x7FU)
N#define LCD_LE_LED_SHIFT                         (0U)
N#define LCD_LE_LED(x)                            (((uint32_t)(((uint32_t)(x)) << LCD_LE_LED_SHIFT)) & LCD_LE_LED_MASK)
N#define LCD_LE_LEE_MASK                          (0x10000U)
N#define LCD_LE_LEE_SHIFT                         (16U)
N#define LCD_LE_LEE(x)                            (((uint32_t)(((uint32_t)(x)) << LCD_LE_LEE_SHIFT)) & LCD_LE_LEE_MASK)
N
N/*! @name UPBASE - Upper Panel Frame Base Address register */
N#define LCD_UPBASE_LCDUPBASE_MASK                (0xFFFFFFF8U)
N#define LCD_UPBASE_LCDUPBASE_SHIFT               (3U)
N#define LCD_UPBASE_LCDUPBASE(x)                  (((uint32_t)(((uint32_t)(x)) << LCD_UPBASE_LCDUPBASE_SHIFT)) & LCD_UPBASE_LCDUPBASE_MASK)
N
N/*! @name LPBASE - Lower Panel Frame Base Address register */
N#define LCD_LPBASE_LCDLPBASE_MASK                (0xFFFFFFF8U)
N#define LCD_LPBASE_LCDLPBASE_SHIFT               (3U)
N#define LCD_LPBASE_LCDLPBASE(x)                  (((uint32_t)(((uint32_t)(x)) << LCD_LPBASE_LCDLPBASE_SHIFT)) & LCD_LPBASE_LCDLPBASE_MASK)
N
N/*! @name CTRL - LCD Control register */
N#define LCD_CTRL_LCDEN_MASK                      (0x1U)
N#define LCD_CTRL_LCDEN_SHIFT                     (0U)
N#define LCD_CTRL_LCDEN(x)                        (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDEN_SHIFT)) & LCD_CTRL_LCDEN_MASK)
N#define LCD_CTRL_LCDBPP_MASK                     (0xEU)
N#define LCD_CTRL_LCDBPP_SHIFT                    (1U)
N#define LCD_CTRL_LCDBPP(x)                       (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDBPP_SHIFT)) & LCD_CTRL_LCDBPP_MASK)
N#define LCD_CTRL_LCDBW_MASK                      (0x10U)
N#define LCD_CTRL_LCDBW_SHIFT                     (4U)
N#define LCD_CTRL_LCDBW(x)                        (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDBW_SHIFT)) & LCD_CTRL_LCDBW_MASK)
N#define LCD_CTRL_LCDTFT_MASK                     (0x20U)
N#define LCD_CTRL_LCDTFT_SHIFT                    (5U)
N#define LCD_CTRL_LCDTFT(x)                       (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDTFT_SHIFT)) & LCD_CTRL_LCDTFT_MASK)
N#define LCD_CTRL_LCDMONO8_MASK                   (0x40U)
N#define LCD_CTRL_LCDMONO8_SHIFT                  (6U)
N#define LCD_CTRL_LCDMONO8(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDMONO8_SHIFT)) & LCD_CTRL_LCDMONO8_MASK)
N#define LCD_CTRL_LCDDUAL_MASK                    (0x80U)
N#define LCD_CTRL_LCDDUAL_SHIFT                   (7U)
N#define LCD_CTRL_LCDDUAL(x)                      (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDDUAL_SHIFT)) & LCD_CTRL_LCDDUAL_MASK)
N#define LCD_CTRL_BGR_MASK                        (0x100U)
N#define LCD_CTRL_BGR_SHIFT                       (8U)
N#define LCD_CTRL_BGR(x)                          (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_BGR_SHIFT)) & LCD_CTRL_BGR_MASK)
N#define LCD_CTRL_BEBO_MASK                       (0x200U)
N#define LCD_CTRL_BEBO_SHIFT                      (9U)
N#define LCD_CTRL_BEBO(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_BEBO_SHIFT)) & LCD_CTRL_BEBO_MASK)
N#define LCD_CTRL_BEPO_MASK                       (0x400U)
N#define LCD_CTRL_BEPO_SHIFT                      (10U)
N#define LCD_CTRL_BEPO(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_BEPO_SHIFT)) & LCD_CTRL_BEPO_MASK)
N#define LCD_CTRL_LCDPWR_MASK                     (0x800U)
N#define LCD_CTRL_LCDPWR_SHIFT                    (11U)
N#define LCD_CTRL_LCDPWR(x)                       (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDPWR_SHIFT)) & LCD_CTRL_LCDPWR_MASK)
N#define LCD_CTRL_LCDVCOMP_MASK                   (0x3000U)
N#define LCD_CTRL_LCDVCOMP_SHIFT                  (12U)
N#define LCD_CTRL_LCDVCOMP(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_LCDVCOMP_SHIFT)) & LCD_CTRL_LCDVCOMP_MASK)
N#define LCD_CTRL_WATERMARK_MASK                  (0x10000U)
N#define LCD_CTRL_WATERMARK_SHIFT                 (16U)
N#define LCD_CTRL_WATERMARK(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_CTRL_WATERMARK_SHIFT)) & LCD_CTRL_WATERMARK_MASK)
N
N/*! @name INTMSK - Interrupt Mask register */
N#define LCD_INTMSK_FUFIM_MASK                    (0x2U)
N#define LCD_INTMSK_FUFIM_SHIFT                   (1U)
N#define LCD_INTMSK_FUFIM(x)                      (((uint32_t)(((uint32_t)(x)) << LCD_INTMSK_FUFIM_SHIFT)) & LCD_INTMSK_FUFIM_MASK)
N#define LCD_INTMSK_LNBUIM_MASK                   (0x4U)
N#define LCD_INTMSK_LNBUIM_SHIFT                  (2U)
N#define LCD_INTMSK_LNBUIM(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_INTMSK_LNBUIM_SHIFT)) & LCD_INTMSK_LNBUIM_MASK)
N#define LCD_INTMSK_VCOMPIM_MASK                  (0x8U)
N#define LCD_INTMSK_VCOMPIM_SHIFT                 (3U)
N#define LCD_INTMSK_VCOMPIM(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_INTMSK_VCOMPIM_SHIFT)) & LCD_INTMSK_VCOMPIM_MASK)
N#define LCD_INTMSK_BERIM_MASK                    (0x10U)
N#define LCD_INTMSK_BERIM_SHIFT                   (4U)
N#define LCD_INTMSK_BERIM(x)                      (((uint32_t)(((uint32_t)(x)) << LCD_INTMSK_BERIM_SHIFT)) & LCD_INTMSK_BERIM_MASK)
N
N/*! @name INTRAW - Raw Interrupt Status register */
N#define LCD_INTRAW_FUFRIS_MASK                   (0x2U)
N#define LCD_INTRAW_FUFRIS_SHIFT                  (1U)
N#define LCD_INTRAW_FUFRIS(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_INTRAW_FUFRIS_SHIFT)) & LCD_INTRAW_FUFRIS_MASK)
N#define LCD_INTRAW_LNBURIS_MASK                  (0x4U)
N#define LCD_INTRAW_LNBURIS_SHIFT                 (2U)
N#define LCD_INTRAW_LNBURIS(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_INTRAW_LNBURIS_SHIFT)) & LCD_INTRAW_LNBURIS_MASK)
N#define LCD_INTRAW_VCOMPRIS_MASK                 (0x8U)
N#define LCD_INTRAW_VCOMPRIS_SHIFT                (3U)
N#define LCD_INTRAW_VCOMPRIS(x)                   (((uint32_t)(((uint32_t)(x)) << LCD_INTRAW_VCOMPRIS_SHIFT)) & LCD_INTRAW_VCOMPRIS_MASK)
N#define LCD_INTRAW_BERRAW_MASK                   (0x10U)
N#define LCD_INTRAW_BERRAW_SHIFT                  (4U)
N#define LCD_INTRAW_BERRAW(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_INTRAW_BERRAW_SHIFT)) & LCD_INTRAW_BERRAW_MASK)
N
N/*! @name INTSTAT - Masked Interrupt Status register */
N#define LCD_INTSTAT_FUFMIS_MASK                  (0x2U)
N#define LCD_INTSTAT_FUFMIS_SHIFT                 (1U)
N#define LCD_INTSTAT_FUFMIS(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_INTSTAT_FUFMIS_SHIFT)) & LCD_INTSTAT_FUFMIS_MASK)
N#define LCD_INTSTAT_LNBUMIS_MASK                 (0x4U)
N#define LCD_INTSTAT_LNBUMIS_SHIFT                (2U)
N#define LCD_INTSTAT_LNBUMIS(x)                   (((uint32_t)(((uint32_t)(x)) << LCD_INTSTAT_LNBUMIS_SHIFT)) & LCD_INTSTAT_LNBUMIS_MASK)
N#define LCD_INTSTAT_VCOMPMIS_MASK                (0x8U)
N#define LCD_INTSTAT_VCOMPMIS_SHIFT               (3U)
N#define LCD_INTSTAT_VCOMPMIS(x)                  (((uint32_t)(((uint32_t)(x)) << LCD_INTSTAT_VCOMPMIS_SHIFT)) & LCD_INTSTAT_VCOMPMIS_MASK)
N#define LCD_INTSTAT_BERMIS_MASK                  (0x10U)
N#define LCD_INTSTAT_BERMIS_SHIFT                 (4U)
N#define LCD_INTSTAT_BERMIS(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_INTSTAT_BERMIS_SHIFT)) & LCD_INTSTAT_BERMIS_MASK)
N
N/*! @name INTCLR - Interrupt Clear register */
N#define LCD_INTCLR_FUFIC_MASK                    (0x2U)
N#define LCD_INTCLR_FUFIC_SHIFT                   (1U)
N#define LCD_INTCLR_FUFIC(x)                      (((uint32_t)(((uint32_t)(x)) << LCD_INTCLR_FUFIC_SHIFT)) & LCD_INTCLR_FUFIC_MASK)
N#define LCD_INTCLR_LNBUIC_MASK                   (0x4U)
N#define LCD_INTCLR_LNBUIC_SHIFT                  (2U)
N#define LCD_INTCLR_LNBUIC(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_INTCLR_LNBUIC_SHIFT)) & LCD_INTCLR_LNBUIC_MASK)
N#define LCD_INTCLR_VCOMPIC_MASK                  (0x8U)
N#define LCD_INTCLR_VCOMPIC_SHIFT                 (3U)
N#define LCD_INTCLR_VCOMPIC(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_INTCLR_VCOMPIC_SHIFT)) & LCD_INTCLR_VCOMPIC_MASK)
N#define LCD_INTCLR_BERIC_MASK                    (0x10U)
N#define LCD_INTCLR_BERIC_SHIFT                   (4U)
N#define LCD_INTCLR_BERIC(x)                      (((uint32_t)(((uint32_t)(x)) << LCD_INTCLR_BERIC_SHIFT)) & LCD_INTCLR_BERIC_MASK)
N
N/*! @name UPCURR - Upper Panel Current Address Value register */
N#define LCD_UPCURR_LCDUPCURR_MASK                (0xFFFFFFFFU)
N#define LCD_UPCURR_LCDUPCURR_SHIFT               (0U)
N#define LCD_UPCURR_LCDUPCURR(x)                  (((uint32_t)(((uint32_t)(x)) << LCD_UPCURR_LCDUPCURR_SHIFT)) & LCD_UPCURR_LCDUPCURR_MASK)
N
N/*! @name LPCURR - Lower Panel Current Address Value register */
N#define LCD_LPCURR_LCDLPCURR_MASK                (0xFFFFFFFFU)
N#define LCD_LPCURR_LCDLPCURR_SHIFT               (0U)
N#define LCD_LPCURR_LCDLPCURR(x)                  (((uint32_t)(((uint32_t)(x)) << LCD_LPCURR_LCDLPCURR_SHIFT)) & LCD_LPCURR_LCDLPCURR_MASK)
N
N/*! @name PAL - 256x16-bit Color Palette registers */
N#define LCD_PAL_R04_0_MASK                       (0x1FU)
N#define LCD_PAL_R04_0_SHIFT                      (0U)
N#define LCD_PAL_R04_0(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_PAL_R04_0_SHIFT)) & LCD_PAL_R04_0_MASK)
N#define LCD_PAL_G04_0_MASK                       (0x3E0U)
N#define LCD_PAL_G04_0_SHIFT                      (5U)
N#define LCD_PAL_G04_0(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_PAL_G04_0_SHIFT)) & LCD_PAL_G04_0_MASK)
N#define LCD_PAL_B04_0_MASK                       (0x7C00U)
N#define LCD_PAL_B04_0_SHIFT                      (10U)
N#define LCD_PAL_B04_0(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_PAL_B04_0_SHIFT)) & LCD_PAL_B04_0_MASK)
N#define LCD_PAL_I0_MASK                          (0x8000U)
N#define LCD_PAL_I0_SHIFT                         (15U)
N#define LCD_PAL_I0(x)                            (((uint32_t)(((uint32_t)(x)) << LCD_PAL_I0_SHIFT)) & LCD_PAL_I0_MASK)
N#define LCD_PAL_R14_0_MASK                       (0x1F0000U)
N#define LCD_PAL_R14_0_SHIFT                      (16U)
N#define LCD_PAL_R14_0(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_PAL_R14_0_SHIFT)) & LCD_PAL_R14_0_MASK)
N#define LCD_PAL_G14_0_MASK                       (0x3E00000U)
N#define LCD_PAL_G14_0_SHIFT                      (21U)
N#define LCD_PAL_G14_0(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_PAL_G14_0_SHIFT)) & LCD_PAL_G14_0_MASK)
N#define LCD_PAL_B14_0_MASK                       (0x7C000000U)
N#define LCD_PAL_B14_0_SHIFT                      (26U)
N#define LCD_PAL_B14_0(x)                         (((uint32_t)(((uint32_t)(x)) << LCD_PAL_B14_0_SHIFT)) & LCD_PAL_B14_0_MASK)
N#define LCD_PAL_I1_MASK                          (0x80000000U)
N#define LCD_PAL_I1_SHIFT                         (31U)
N#define LCD_PAL_I1(x)                            (((uint32_t)(((uint32_t)(x)) << LCD_PAL_I1_SHIFT)) & LCD_PAL_I1_MASK)
N
N/* The count of LCD_PAL */
N#define LCD_PAL_COUNT                            (128U)
N
N/*! @name CRSR_IMG - Cursor Image registers */
N#define LCD_CRSR_IMG_CRSR_IMG_MASK               (0xFFFFFFFFU)
N#define LCD_CRSR_IMG_CRSR_IMG_SHIFT              (0U)
N#define LCD_CRSR_IMG_CRSR_IMG(x)                 (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_IMG_CRSR_IMG_SHIFT)) & LCD_CRSR_IMG_CRSR_IMG_MASK)
N
N/* The count of LCD_CRSR_IMG */
N#define LCD_CRSR_IMG_COUNT                       (256U)
N
N/*! @name CRSR_CTRL - Cursor Control register */
N#define LCD_CRSR_CTRL_CRSRON_MASK                (0x1U)
N#define LCD_CRSR_CTRL_CRSRON_SHIFT               (0U)
N#define LCD_CRSR_CTRL_CRSRON(x)                  (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_CTRL_CRSRON_SHIFT)) & LCD_CRSR_CTRL_CRSRON_MASK)
N#define LCD_CRSR_CTRL_CRSRNUM1_0_MASK            (0x30U)
N#define LCD_CRSR_CTRL_CRSRNUM1_0_SHIFT           (4U)
N#define LCD_CRSR_CTRL_CRSRNUM1_0(x)              (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_CTRL_CRSRNUM1_0_SHIFT)) & LCD_CRSR_CTRL_CRSRNUM1_0_MASK)
N
N/*! @name CRSR_CFG - Cursor Configuration register */
N#define LCD_CRSR_CFG_CRSRSIZE_MASK               (0x1U)
N#define LCD_CRSR_CFG_CRSRSIZE_SHIFT              (0U)
N#define LCD_CRSR_CFG_CRSRSIZE(x)                 (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_CFG_CRSRSIZE_SHIFT)) & LCD_CRSR_CFG_CRSRSIZE_MASK)
N#define LCD_CRSR_CFG_FRAMESYNC_MASK              (0x2U)
N#define LCD_CRSR_CFG_FRAMESYNC_SHIFT             (1U)
N#define LCD_CRSR_CFG_FRAMESYNC(x)                (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_CFG_FRAMESYNC_SHIFT)) & LCD_CRSR_CFG_FRAMESYNC_MASK)
N
N/*! @name CRSR_PAL0 - Cursor Palette register 0 */
N#define LCD_CRSR_PAL0_RED_MASK                   (0xFFU)
N#define LCD_CRSR_PAL0_RED_SHIFT                  (0U)
N#define LCD_CRSR_PAL0_RED(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_PAL0_RED_SHIFT)) & LCD_CRSR_PAL0_RED_MASK)
N#define LCD_CRSR_PAL0_GREEN_MASK                 (0xFF00U)
N#define LCD_CRSR_PAL0_GREEN_SHIFT                (8U)
N#define LCD_CRSR_PAL0_GREEN(x)                   (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_PAL0_GREEN_SHIFT)) & LCD_CRSR_PAL0_GREEN_MASK)
N#define LCD_CRSR_PAL0_BLUE_MASK                  (0xFF0000U)
N#define LCD_CRSR_PAL0_BLUE_SHIFT                 (16U)
N#define LCD_CRSR_PAL0_BLUE(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_PAL0_BLUE_SHIFT)) & LCD_CRSR_PAL0_BLUE_MASK)
N
N/*! @name CRSR_PAL1 - Cursor Palette register 1 */
N#define LCD_CRSR_PAL1_RED_MASK                   (0xFFU)
N#define LCD_CRSR_PAL1_RED_SHIFT                  (0U)
N#define LCD_CRSR_PAL1_RED(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_PAL1_RED_SHIFT)) & LCD_CRSR_PAL1_RED_MASK)
N#define LCD_CRSR_PAL1_GREEN_MASK                 (0xFF00U)
N#define LCD_CRSR_PAL1_GREEN_SHIFT                (8U)
N#define LCD_CRSR_PAL1_GREEN(x)                   (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_PAL1_GREEN_SHIFT)) & LCD_CRSR_PAL1_GREEN_MASK)
N#define LCD_CRSR_PAL1_BLUE_MASK                  (0xFF0000U)
N#define LCD_CRSR_PAL1_BLUE_SHIFT                 (16U)
N#define LCD_CRSR_PAL1_BLUE(x)                    (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_PAL1_BLUE_SHIFT)) & LCD_CRSR_PAL1_BLUE_MASK)
N
N/*! @name CRSR_XY - Cursor XY Position register */
N#define LCD_CRSR_XY_CRSRX_MASK                   (0x3FFU)
N#define LCD_CRSR_XY_CRSRX_SHIFT                  (0U)
N#define LCD_CRSR_XY_CRSRX(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_XY_CRSRX_SHIFT)) & LCD_CRSR_XY_CRSRX_MASK)
N#define LCD_CRSR_XY_CRSRY_MASK                   (0x3FF0000U)
N#define LCD_CRSR_XY_CRSRY_SHIFT                  (16U)
N#define LCD_CRSR_XY_CRSRY(x)                     (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_XY_CRSRY_SHIFT)) & LCD_CRSR_XY_CRSRY_MASK)
N
N/*! @name CRSR_CLIP - Cursor Clip Position register */
N#define LCD_CRSR_CLIP_CRSRCLIPX_MASK             (0x3FU)
N#define LCD_CRSR_CLIP_CRSRCLIPX_SHIFT            (0U)
N#define LCD_CRSR_CLIP_CRSRCLIPX(x)               (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_CLIP_CRSRCLIPX_SHIFT)) & LCD_CRSR_CLIP_CRSRCLIPX_MASK)
N#define LCD_CRSR_CLIP_CRSRCLIPY_MASK             (0x3F00U)
N#define LCD_CRSR_CLIP_CRSRCLIPY_SHIFT            (8U)
N#define LCD_CRSR_CLIP_CRSRCLIPY(x)               (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_CLIP_CRSRCLIPY_SHIFT)) & LCD_CRSR_CLIP_CRSRCLIPY_MASK)
N
N/*! @name CRSR_INTMSK - Cursor Interrupt Mask register */
N#define LCD_CRSR_INTMSK_CRSRIM_MASK              (0x1U)
N#define LCD_CRSR_INTMSK_CRSRIM_SHIFT             (0U)
N#define LCD_CRSR_INTMSK_CRSRIM(x)                (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_INTMSK_CRSRIM_SHIFT)) & LCD_CRSR_INTMSK_CRSRIM_MASK)
N
N/*! @name CRSR_INTCLR - Cursor Interrupt Clear register */
N#define LCD_CRSR_INTCLR_CRSRIC_MASK              (0x1U)
N#define LCD_CRSR_INTCLR_CRSRIC_SHIFT             (0U)
N#define LCD_CRSR_INTCLR_CRSRIC(x)                (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_INTCLR_CRSRIC_SHIFT)) & LCD_CRSR_INTCLR_CRSRIC_MASK)
N
N/*! @name CRSR_INTRAW - Cursor Raw Interrupt Status register */
N#define LCD_CRSR_INTRAW_CRSRRIS_MASK             (0x1U)
N#define LCD_CRSR_INTRAW_CRSRRIS_SHIFT            (0U)
N#define LCD_CRSR_INTRAW_CRSRRIS(x)               (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_INTRAW_CRSRRIS_SHIFT)) & LCD_CRSR_INTRAW_CRSRRIS_MASK)
N
N/*! @name CRSR_INTSTAT - Cursor Masked Interrupt Status register */
N#define LCD_CRSR_INTSTAT_CRSRMIS_MASK            (0x1U)
N#define LCD_CRSR_INTSTAT_CRSRMIS_SHIFT           (0U)
N#define LCD_CRSR_INTSTAT_CRSRMIS(x)              (((uint32_t)(((uint32_t)(x)) << LCD_CRSR_INTSTAT_CRSRMIS_SHIFT)) & LCD_CRSR_INTSTAT_CRSRMIS_MASK)
N
N
N/*!
N * @}
N */ /* end of group LCD_Register_Masks */
N
N
N/* LCD - Peripheral instance base addresses */
N/** Peripheral LCD base address */
N#define LCD_BASE                                 (0x40083000u)
N/** Peripheral LCD base pointer */
N#define LCD                                      ((LCD_Type *)LCD_BASE)
N/** Array initializer of LCD peripheral base addresses */
N#define LCD_BASE_ADDRS                           { LCD_BASE }
N/** Array initializer of LCD peripheral base pointers */
N#define LCD_BASE_PTRS                            { LCD }
N/** Interrupt vectors for the LCD peripheral type */
N#define LCD_IRQS                                 { LCD_IRQn }
N
N/*!
N * @}
N */ /* end of group LCD_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MRT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup MRT_Peripheral_Access_Layer MRT Peripheral Access Layer
N * @{
N */
N
N/** MRT - Register Layout Typedef */
Ntypedef struct {
N  struct {                                         /* offset: 0x0, array step: 0x10 */
N    __IO uint32_t INTVAL;                            /**< MRT Time interval value register. This value is loaded into the TIMER register., array offset: 0x0, array step: 0x10 */
X    volatile uint32_t INTVAL;                             
N    __I  uint32_t TIMER;                             /**< MRT Timer register. This register reads the value of the down-counter., array offset: 0x4, array step: 0x10 */
X    volatile const  uint32_t TIMER;                              
N    __IO uint32_t CTRL;                              /**< MRT Control register. This register controls the MRT modes., array offset: 0x8, array step: 0x10 */
X    volatile uint32_t CTRL;                               
N    __IO uint32_t STAT;                              /**< MRT Status register., array offset: 0xC, array step: 0x10 */
X    volatile uint32_t STAT;                               
N  } CHANNEL[4];
N       uint8_t RESERVED_0[176];
N  __IO uint32_t MODCFG;                            /**< Module Configuration register. This register provides information about this particular MRT instance, and allows choosing an overall mode for the idle channel feature., offset: 0xF0 */
X  volatile uint32_t MODCFG;                             
N  __I  uint32_t IDLE_CH;                           /**< Idle channel register. This register returns the number of the first idle channel., offset: 0xF4 */
X  volatile const  uint32_t IDLE_CH;                            
N  __IO uint32_t IRQ_FLAG;                          /**< Global interrupt flag register, offset: 0xF8 */
X  volatile uint32_t IRQ_FLAG;                           
N} MRT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MRT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup MRT_Register_Masks MRT Register Masks
N * @{
N */
N
N/*! @name CHANNEL_INTVAL - MRT Time interval value register. This value is loaded into the TIMER register. */
N#define MRT_CHANNEL_INTVAL_IVALUE_MASK           (0xFFFFFFU)
N#define MRT_CHANNEL_INTVAL_IVALUE_SHIFT          (0U)
N#define MRT_CHANNEL_INTVAL_IVALUE(x)             (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_INTVAL_IVALUE_SHIFT)) & MRT_CHANNEL_INTVAL_IVALUE_MASK)
N#define MRT_CHANNEL_INTVAL_LOAD_MASK             (0x80000000U)
N#define MRT_CHANNEL_INTVAL_LOAD_SHIFT            (31U)
N#define MRT_CHANNEL_INTVAL_LOAD(x)               (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_INTVAL_LOAD_SHIFT)) & MRT_CHANNEL_INTVAL_LOAD_MASK)
N
N/* The count of MRT_CHANNEL_INTVAL */
N#define MRT_CHANNEL_INTVAL_COUNT                 (4U)
N
N/*! @name CHANNEL_TIMER - MRT Timer register. This register reads the value of the down-counter. */
N#define MRT_CHANNEL_TIMER_VALUE_MASK             (0xFFFFFFU)
N#define MRT_CHANNEL_TIMER_VALUE_SHIFT            (0U)
N#define MRT_CHANNEL_TIMER_VALUE(x)               (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_TIMER_VALUE_SHIFT)) & MRT_CHANNEL_TIMER_VALUE_MASK)
N
N/* The count of MRT_CHANNEL_TIMER */
N#define MRT_CHANNEL_TIMER_COUNT                  (4U)
N
N/*! @name CHANNEL_CTRL - MRT Control register. This register controls the MRT modes. */
N#define MRT_CHANNEL_CTRL_INTEN_MASK              (0x1U)
N#define MRT_CHANNEL_CTRL_INTEN_SHIFT             (0U)
N#define MRT_CHANNEL_CTRL_INTEN(x)                (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_CTRL_INTEN_SHIFT)) & MRT_CHANNEL_CTRL_INTEN_MASK)
N#define MRT_CHANNEL_CTRL_MODE_MASK               (0x6U)
N#define MRT_CHANNEL_CTRL_MODE_SHIFT              (1U)
N#define MRT_CHANNEL_CTRL_MODE(x)                 (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_CTRL_MODE_SHIFT)) & MRT_CHANNEL_CTRL_MODE_MASK)
N
N/* The count of MRT_CHANNEL_CTRL */
N#define MRT_CHANNEL_CTRL_COUNT                   (4U)
N
N/*! @name CHANNEL_STAT - MRT Status register. */
N#define MRT_CHANNEL_STAT_INTFLAG_MASK            (0x1U)
N#define MRT_CHANNEL_STAT_INTFLAG_SHIFT           (0U)
N#define MRT_CHANNEL_STAT_INTFLAG(x)              (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_STAT_INTFLAG_SHIFT)) & MRT_CHANNEL_STAT_INTFLAG_MASK)
N#define MRT_CHANNEL_STAT_RUN_MASK                (0x2U)
N#define MRT_CHANNEL_STAT_RUN_SHIFT               (1U)
N#define MRT_CHANNEL_STAT_RUN(x)                  (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_STAT_RUN_SHIFT)) & MRT_CHANNEL_STAT_RUN_MASK)
N#define MRT_CHANNEL_STAT_INUSE_MASK              (0x4U)
N#define MRT_CHANNEL_STAT_INUSE_SHIFT             (2U)
N#define MRT_CHANNEL_STAT_INUSE(x)                (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_STAT_INUSE_SHIFT)) & MRT_CHANNEL_STAT_INUSE_MASK)
N
N/* The count of MRT_CHANNEL_STAT */
N#define MRT_CHANNEL_STAT_COUNT                   (4U)
N
N/*! @name MODCFG - Module Configuration register. This register provides information about this particular MRT instance, and allows choosing an overall mode for the idle channel feature. */
N#define MRT_MODCFG_NOC_MASK                      (0xFU)
N#define MRT_MODCFG_NOC_SHIFT                     (0U)
N#define MRT_MODCFG_NOC(x)                        (((uint32_t)(((uint32_t)(x)) << MRT_MODCFG_NOC_SHIFT)) & MRT_MODCFG_NOC_MASK)
N#define MRT_MODCFG_NOB_MASK                      (0x1F0U)
N#define MRT_MODCFG_NOB_SHIFT                     (4U)
N#define MRT_MODCFG_NOB(x)                        (((uint32_t)(((uint32_t)(x)) << MRT_MODCFG_NOB_SHIFT)) & MRT_MODCFG_NOB_MASK)
N#define MRT_MODCFG_MULTITASK_MASK                (0x80000000U)
N#define MRT_MODCFG_MULTITASK_SHIFT               (31U)
N#define MRT_MODCFG_MULTITASK(x)                  (((uint32_t)(((uint32_t)(x)) << MRT_MODCFG_MULTITASK_SHIFT)) & MRT_MODCFG_MULTITASK_MASK)
N
N/*! @name IDLE_CH - Idle channel register. This register returns the number of the first idle channel. */
N#define MRT_IDLE_CH_CHAN_MASK                    (0xF0U)
N#define MRT_IDLE_CH_CHAN_SHIFT                   (4U)
N#define MRT_IDLE_CH_CHAN(x)                      (((uint32_t)(((uint32_t)(x)) << MRT_IDLE_CH_CHAN_SHIFT)) & MRT_IDLE_CH_CHAN_MASK)
N
N/*! @name IRQ_FLAG - Global interrupt flag register */
N#define MRT_IRQ_FLAG_GFLAG0_MASK                 (0x1U)
N#define MRT_IRQ_FLAG_GFLAG0_SHIFT                (0U)
N#define MRT_IRQ_FLAG_GFLAG0(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG0_SHIFT)) & MRT_IRQ_FLAG_GFLAG0_MASK)
N#define MRT_IRQ_FLAG_GFLAG1_MASK                 (0x2U)
N#define MRT_IRQ_FLAG_GFLAG1_SHIFT                (1U)
N#define MRT_IRQ_FLAG_GFLAG1(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG1_SHIFT)) & MRT_IRQ_FLAG_GFLAG1_MASK)
N#define MRT_IRQ_FLAG_GFLAG2_MASK                 (0x4U)
N#define MRT_IRQ_FLAG_GFLAG2_SHIFT                (2U)
N#define MRT_IRQ_FLAG_GFLAG2(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG2_SHIFT)) & MRT_IRQ_FLAG_GFLAG2_MASK)
N#define MRT_IRQ_FLAG_GFLAG3_MASK                 (0x8U)
N#define MRT_IRQ_FLAG_GFLAG3_SHIFT                (3U)
N#define MRT_IRQ_FLAG_GFLAG3(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG3_SHIFT)) & MRT_IRQ_FLAG_GFLAG3_MASK)
N
N
N/*!
N * @}
N */ /* end of group MRT_Register_Masks */
N
N
N/* MRT - Peripheral instance base addresses */
N/** Peripheral MRT0 base address */
N#define MRT0_BASE                                (0x4000D000u)
N/** Peripheral MRT0 base pointer */
N#define MRT0                                     ((MRT_Type *)MRT0_BASE)
N/** Array initializer of MRT peripheral base addresses */
N#define MRT_BASE_ADDRS                           { MRT0_BASE }
N/** Array initializer of MRT peripheral base pointers */
N#define MRT_BASE_PTRS                            { MRT0 }
N/** Interrupt vectors for the MRT peripheral type */
N#define MRT_IRQS                                 { MRT0_IRQn }
N
N/*!
N * @}
N */ /* end of group MRT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- OTPC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup OTPC_Peripheral_Access_Layer OTPC Peripheral Access Layer
N * @{
N */
N
N/** OTPC - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[16];
N  __I  uint32_t AESKEY[8];                         /**< Register for reading the AES key., array offset: 0x10, array step: 0x4 */
X  volatile const  uint32_t AESKEY[8];                          
N  __I  uint32_t ECRP;                              /**< ECRP options., offset: 0x30 */
X  volatile const  uint32_t ECRP;                               
N       uint8_t RESERVED_1[4];
N  __I  uint32_t USER0;                             /**< User application specific options., offset: 0x38 */
X  volatile const  uint32_t USER0;                              
N  __I  uint32_t USER1;                             /**< User application specific options., offset: 0x3C */
X  volatile const  uint32_t USER1;                              
N} OTPC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- OTPC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup OTPC_Register_Masks OTPC Register Masks
N * @{
N */
N
N/*! @name AESKEY - Register for reading the AES key. */
N#define OTPC_AESKEY_KEY_MASK                     (0xFFFFFFFFU)
N#define OTPC_AESKEY_KEY_SHIFT                    (0U)
N#define OTPC_AESKEY_KEY(x)                       (((uint32_t)(((uint32_t)(x)) << OTPC_AESKEY_KEY_SHIFT)) & OTPC_AESKEY_KEY_MASK)
N
N/* The count of OTPC_AESKEY */
N#define OTPC_AESKEY_COUNT                        (8U)
N
N/*! @name ECRP - ECRP options. */
N#define OTPC_ECRP_CRP_MASS_ERASE_DISABLE_MASK    (0x10U)
N#define OTPC_ECRP_CRP_MASS_ERASE_DISABLE_SHIFT   (4U)
N#define OTPC_ECRP_CRP_MASS_ERASE_DISABLE(x)      (((uint32_t)(((uint32_t)(x)) << OTPC_ECRP_CRP_MASS_ERASE_DISABLE_SHIFT)) & OTPC_ECRP_CRP_MASS_ERASE_DISABLE_MASK)
N#define OTPC_ECRP_IAP_PROTECTION_ENABLE_MASK     (0x20U)
N#define OTPC_ECRP_IAP_PROTECTION_ENABLE_SHIFT    (5U)
N#define OTPC_ECRP_IAP_PROTECTION_ENABLE(x)       (((uint32_t)(((uint32_t)(x)) << OTPC_ECRP_IAP_PROTECTION_ENABLE_SHIFT)) & OTPC_ECRP_IAP_PROTECTION_ENABLE_MASK)
N#define OTPC_ECRP_CRP_ISP_DISABLE_PIN_MASK       (0x40U)
N#define OTPC_ECRP_CRP_ISP_DISABLE_PIN_SHIFT      (6U)
N#define OTPC_ECRP_CRP_ISP_DISABLE_PIN(x)         (((uint32_t)(((uint32_t)(x)) << OTPC_ECRP_CRP_ISP_DISABLE_PIN_SHIFT)) & OTPC_ECRP_CRP_ISP_DISABLE_PIN_MASK)
N#define OTPC_ECRP_CRP_ISP_DISABLE_IAP_MASK       (0x80U)
N#define OTPC_ECRP_CRP_ISP_DISABLE_IAP_SHIFT      (7U)
N#define OTPC_ECRP_CRP_ISP_DISABLE_IAP(x)         (((uint32_t)(((uint32_t)(x)) << OTPC_ECRP_CRP_ISP_DISABLE_IAP_SHIFT)) & OTPC_ECRP_CRP_ISP_DISABLE_IAP_MASK)
N#define OTPC_ECRP_CRP_ALLOW_ZERO_MASK            (0x200U)
N#define OTPC_ECRP_CRP_ALLOW_ZERO_SHIFT           (9U)
N#define OTPC_ECRP_CRP_ALLOW_ZERO(x)              (((uint32_t)(((uint32_t)(x)) << OTPC_ECRP_CRP_ALLOW_ZERO_SHIFT)) & OTPC_ECRP_CRP_ALLOW_ZERO_MASK)
N#define OTPC_ECRP_JTAG_DISABLE_MASK              (0x80000000U)
N#define OTPC_ECRP_JTAG_DISABLE_SHIFT             (31U)
N#define OTPC_ECRP_JTAG_DISABLE(x)                (((uint32_t)(((uint32_t)(x)) << OTPC_ECRP_JTAG_DISABLE_SHIFT)) & OTPC_ECRP_JTAG_DISABLE_MASK)
N
N/*! @name USER0 - User application specific options. */
N#define OTPC_USER0_USER0_MASK                    (0xFFFFFFFFU)
N#define OTPC_USER0_USER0_SHIFT                   (0U)
N#define OTPC_USER0_USER0(x)                      (((uint32_t)(((uint32_t)(x)) << OTPC_USER0_USER0_SHIFT)) & OTPC_USER0_USER0_MASK)
N
N/*! @name USER1 - User application specific options. */
N#define OTPC_USER1_USER1_MASK                    (0xFFFFFFFFU)
N#define OTPC_USER1_USER1_SHIFT                   (0U)
N#define OTPC_USER1_USER1(x)                      (((uint32_t)(((uint32_t)(x)) << OTPC_USER1_USER1_SHIFT)) & OTPC_USER1_USER1_MASK)
N
N
N/*!
N * @}
N */ /* end of group OTPC_Register_Masks */
N
N
N/* OTPC - Peripheral instance base addresses */
N/** Peripheral OTPC base address */
N#define OTPC_BASE                                (0x40015000u)
N/** Peripheral OTPC base pointer */
N#define OTPC                                     ((OTPC_Type *)OTPC_BASE)
N/** Array initializer of OTPC peripheral base addresses */
N#define OTPC_BASE_ADDRS                          { OTPC_BASE }
N/** Array initializer of OTPC peripheral base pointers */
N#define OTPC_BASE_PTRS                           { OTPC }
N
N/*!
N * @}
N */ /* end of group OTPC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- PINT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup PINT_Peripheral_Access_Layer PINT Peripheral Access Layer
N * @{
N */
N
N/** PINT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t ISEL;                              /**< Pin Interrupt Mode register, offset: 0x0 */
X  volatile uint32_t ISEL;                               
N  __IO uint32_t IENR;                              /**< Pin interrupt level or rising edge interrupt enable register, offset: 0x4 */
X  volatile uint32_t IENR;                               
N  __O  uint32_t SIENR;                             /**< Pin interrupt level or rising edge interrupt set register, offset: 0x8 */
X  volatile  uint32_t SIENR;                              
N  __O  uint32_t CIENR;                             /**< Pin interrupt level (rising edge interrupt) clear register, offset: 0xC */
X  volatile  uint32_t CIENR;                              
N  __IO uint32_t IENF;                              /**< Pin interrupt active level or falling edge interrupt enable register, offset: 0x10 */
X  volatile uint32_t IENF;                               
N  __O  uint32_t SIENF;                             /**< Pin interrupt active level or falling edge interrupt set register, offset: 0x14 */
X  volatile  uint32_t SIENF;                              
N  __O  uint32_t CIENF;                             /**< Pin interrupt active level or falling edge interrupt clear register, offset: 0x18 */
X  volatile  uint32_t CIENF;                              
N  __IO uint32_t RISE;                              /**< Pin interrupt rising edge register, offset: 0x1C */
X  volatile uint32_t RISE;                               
N  __IO uint32_t FALL;                              /**< Pin interrupt falling edge register, offset: 0x20 */
X  volatile uint32_t FALL;                               
N  __IO uint32_t IST;                               /**< Pin interrupt status register, offset: 0x24 */
X  volatile uint32_t IST;                                
N  __IO uint32_t PMCTRL;                            /**< Pattern match interrupt control register, offset: 0x28 */
X  volatile uint32_t PMCTRL;                             
N  __IO uint32_t PMSRC;                             /**< Pattern match interrupt bit-slice source register, offset: 0x2C */
X  volatile uint32_t PMSRC;                              
N  __IO uint32_t PMCFG;                             /**< Pattern match interrupt bit slice configuration register, offset: 0x30 */
X  volatile uint32_t PMCFG;                              
N} PINT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- PINT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup PINT_Register_Masks PINT Register Masks
N * @{
N */
N
N/*! @name ISEL - Pin Interrupt Mode register */
N#define PINT_ISEL_PMODE_MASK                     (0xFFU)
N#define PINT_ISEL_PMODE_SHIFT                    (0U)
N#define PINT_ISEL_PMODE(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_ISEL_PMODE_SHIFT)) & PINT_ISEL_PMODE_MASK)
N
N/*! @name IENR - Pin interrupt level or rising edge interrupt enable register */
N#define PINT_IENR_ENRL_MASK                      (0xFFU)
N#define PINT_IENR_ENRL_SHIFT                     (0U)
N#define PINT_IENR_ENRL(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_IENR_ENRL_SHIFT)) & PINT_IENR_ENRL_MASK)
N
N/*! @name SIENR - Pin interrupt level or rising edge interrupt set register */
N#define PINT_SIENR_SETENRL_MASK                  (0xFFU)
N#define PINT_SIENR_SETENRL_SHIFT                 (0U)
N#define PINT_SIENR_SETENRL(x)                    (((uint32_t)(((uint32_t)(x)) << PINT_SIENR_SETENRL_SHIFT)) & PINT_SIENR_SETENRL_MASK)
N
N/*! @name CIENR - Pin interrupt level (rising edge interrupt) clear register */
N#define PINT_CIENR_CENRL_MASK                    (0xFFU)
N#define PINT_CIENR_CENRL_SHIFT                   (0U)
N#define PINT_CIENR_CENRL(x)                      (((uint32_t)(((uint32_t)(x)) << PINT_CIENR_CENRL_SHIFT)) & PINT_CIENR_CENRL_MASK)
N
N/*! @name IENF - Pin interrupt active level or falling edge interrupt enable register */
N#define PINT_IENF_ENAF_MASK                      (0xFFU)
N#define PINT_IENF_ENAF_SHIFT                     (0U)
N#define PINT_IENF_ENAF(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_IENF_ENAF_SHIFT)) & PINT_IENF_ENAF_MASK)
N
N/*! @name SIENF - Pin interrupt active level or falling edge interrupt set register */
N#define PINT_SIENF_SETENAF_MASK                  (0xFFU)
N#define PINT_SIENF_SETENAF_SHIFT                 (0U)
N#define PINT_SIENF_SETENAF(x)                    (((uint32_t)(((uint32_t)(x)) << PINT_SIENF_SETENAF_SHIFT)) & PINT_SIENF_SETENAF_MASK)
N
N/*! @name CIENF - Pin interrupt active level or falling edge interrupt clear register */
N#define PINT_CIENF_CENAF_MASK                    (0xFFU)
N#define PINT_CIENF_CENAF_SHIFT                   (0U)
N#define PINT_CIENF_CENAF(x)                      (((uint32_t)(((uint32_t)(x)) << PINT_CIENF_CENAF_SHIFT)) & PINT_CIENF_CENAF_MASK)
N
N/*! @name RISE - Pin interrupt rising edge register */
N#define PINT_RISE_RDET_MASK                      (0xFFU)
N#define PINT_RISE_RDET_SHIFT                     (0U)
N#define PINT_RISE_RDET(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_RISE_RDET_SHIFT)) & PINT_RISE_RDET_MASK)
N
N/*! @name FALL - Pin interrupt falling edge register */
N#define PINT_FALL_FDET_MASK                      (0xFFU)
N#define PINT_FALL_FDET_SHIFT                     (0U)
N#define PINT_FALL_FDET(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_FALL_FDET_SHIFT)) & PINT_FALL_FDET_MASK)
N
N/*! @name IST - Pin interrupt status register */
N#define PINT_IST_PSTAT_MASK                      (0xFFU)
N#define PINT_IST_PSTAT_SHIFT                     (0U)
N#define PINT_IST_PSTAT(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_IST_PSTAT_SHIFT)) & PINT_IST_PSTAT_MASK)
N
N/*! @name PMCTRL - Pattern match interrupt control register */
N#define PINT_PMCTRL_SEL_PMATCH_MASK              (0x1U)
N#define PINT_PMCTRL_SEL_PMATCH_SHIFT             (0U)
N#define PINT_PMCTRL_SEL_PMATCH(x)                (((uint32_t)(((uint32_t)(x)) << PINT_PMCTRL_SEL_PMATCH_SHIFT)) & PINT_PMCTRL_SEL_PMATCH_MASK)
N#define PINT_PMCTRL_ENA_RXEV_MASK                (0x2U)
N#define PINT_PMCTRL_ENA_RXEV_SHIFT               (1U)
N#define PINT_PMCTRL_ENA_RXEV(x)                  (((uint32_t)(((uint32_t)(x)) << PINT_PMCTRL_ENA_RXEV_SHIFT)) & PINT_PMCTRL_ENA_RXEV_MASK)
N#define PINT_PMCTRL_PMAT_MASK                    (0xFF000000U)
N#define PINT_PMCTRL_PMAT_SHIFT                   (24U)
N#define PINT_PMCTRL_PMAT(x)                      (((uint32_t)(((uint32_t)(x)) << PINT_PMCTRL_PMAT_SHIFT)) & PINT_PMCTRL_PMAT_MASK)
N
N/*! @name PMSRC - Pattern match interrupt bit-slice source register */
N#define PINT_PMSRC_SRC0_MASK                     (0x700U)
N#define PINT_PMSRC_SRC0_SHIFT                    (8U)
N#define PINT_PMSRC_SRC0(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC0_SHIFT)) & PINT_PMSRC_SRC0_MASK)
N#define PINT_PMSRC_SRC1_MASK                     (0x3800U)
N#define PINT_PMSRC_SRC1_SHIFT                    (11U)
N#define PINT_PMSRC_SRC1(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC1_SHIFT)) & PINT_PMSRC_SRC1_MASK)
N#define PINT_PMSRC_SRC2_MASK                     (0x1C000U)
N#define PINT_PMSRC_SRC2_SHIFT                    (14U)
N#define PINT_PMSRC_SRC2(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC2_SHIFT)) & PINT_PMSRC_SRC2_MASK)
N#define PINT_PMSRC_SRC3_MASK                     (0xE0000U)
N#define PINT_PMSRC_SRC3_SHIFT                    (17U)
N#define PINT_PMSRC_SRC3(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC3_SHIFT)) & PINT_PMSRC_SRC3_MASK)
N#define PINT_PMSRC_SRC4_MASK                     (0x700000U)
N#define PINT_PMSRC_SRC4_SHIFT                    (20U)
N#define PINT_PMSRC_SRC4(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC4_SHIFT)) & PINT_PMSRC_SRC4_MASK)
N#define PINT_PMSRC_SRC5_MASK                     (0x3800000U)
N#define PINT_PMSRC_SRC5_SHIFT                    (23U)
N#define PINT_PMSRC_SRC5(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC5_SHIFT)) & PINT_PMSRC_SRC5_MASK)
N#define PINT_PMSRC_SRC6_MASK                     (0x1C000000U)
N#define PINT_PMSRC_SRC6_SHIFT                    (26U)
N#define PINT_PMSRC_SRC6(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC6_SHIFT)) & PINT_PMSRC_SRC6_MASK)
N#define PINT_PMSRC_SRC7_MASK                     (0xE0000000U)
N#define PINT_PMSRC_SRC7_SHIFT                    (29U)
N#define PINT_PMSRC_SRC7(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC7_SHIFT)) & PINT_PMSRC_SRC7_MASK)
N
N/*! @name PMCFG - Pattern match interrupt bit slice configuration register */
N#define PINT_PMCFG_PROD_ENDPTS0_MASK             (0x1U)
N#define PINT_PMCFG_PROD_ENDPTS0_SHIFT            (0U)
N#define PINT_PMCFG_PROD_ENDPTS0(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS0_SHIFT)) & PINT_PMCFG_PROD_ENDPTS0_MASK)
N#define PINT_PMCFG_PROD_ENDPTS1_MASK             (0x2U)
N#define PINT_PMCFG_PROD_ENDPTS1_SHIFT            (1U)
N#define PINT_PMCFG_PROD_ENDPTS1(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS1_SHIFT)) & PINT_PMCFG_PROD_ENDPTS1_MASK)
N#define PINT_PMCFG_PROD_ENDPTS2_MASK             (0x4U)
N#define PINT_PMCFG_PROD_ENDPTS2_SHIFT            (2U)
N#define PINT_PMCFG_PROD_ENDPTS2(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS2_SHIFT)) & PINT_PMCFG_PROD_ENDPTS2_MASK)
N#define PINT_PMCFG_PROD_ENDPTS3_MASK             (0x8U)
N#define PINT_PMCFG_PROD_ENDPTS3_SHIFT            (3U)
N#define PINT_PMCFG_PROD_ENDPTS3(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS3_SHIFT)) & PINT_PMCFG_PROD_ENDPTS3_MASK)
N#define PINT_PMCFG_PROD_ENDPTS4_MASK             (0x10U)
N#define PINT_PMCFG_PROD_ENDPTS4_SHIFT            (4U)
N#define PINT_PMCFG_PROD_ENDPTS4(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS4_SHIFT)) & PINT_PMCFG_PROD_ENDPTS4_MASK)
N#define PINT_PMCFG_PROD_ENDPTS5_MASK             (0x20U)
N#define PINT_PMCFG_PROD_ENDPTS5_SHIFT            (5U)
N#define PINT_PMCFG_PROD_ENDPTS5(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS5_SHIFT)) & PINT_PMCFG_PROD_ENDPTS5_MASK)
N#define PINT_PMCFG_PROD_ENDPTS6_MASK             (0x40U)
N#define PINT_PMCFG_PROD_ENDPTS6_SHIFT            (6U)
N#define PINT_PMCFG_PROD_ENDPTS6(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS6_SHIFT)) & PINT_PMCFG_PROD_ENDPTS6_MASK)
N#define PINT_PMCFG_CFG0_MASK                     (0x700U)
N#define PINT_PMCFG_CFG0_SHIFT                    (8U)
N#define PINT_PMCFG_CFG0(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG0_SHIFT)) & PINT_PMCFG_CFG0_MASK)
N#define PINT_PMCFG_CFG1_MASK                     (0x3800U)
N#define PINT_PMCFG_CFG1_SHIFT                    (11U)
N#define PINT_PMCFG_CFG1(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG1_SHIFT)) & PINT_PMCFG_CFG1_MASK)
N#define PINT_PMCFG_CFG2_MASK                     (0x1C000U)
N#define PINT_PMCFG_CFG2_SHIFT                    (14U)
N#define PINT_PMCFG_CFG2(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG2_SHIFT)) & PINT_PMCFG_CFG2_MASK)
N#define PINT_PMCFG_CFG3_MASK                     (0xE0000U)
N#define PINT_PMCFG_CFG3_SHIFT                    (17U)
N#define PINT_PMCFG_CFG3(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG3_SHIFT)) & PINT_PMCFG_CFG3_MASK)
N#define PINT_PMCFG_CFG4_MASK                     (0x700000U)
N#define PINT_PMCFG_CFG4_SHIFT                    (20U)
N#define PINT_PMCFG_CFG4(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG4_SHIFT)) & PINT_PMCFG_CFG4_MASK)
N#define PINT_PMCFG_CFG5_MASK                     (0x3800000U)
N#define PINT_PMCFG_CFG5_SHIFT                    (23U)
N#define PINT_PMCFG_CFG5(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG5_SHIFT)) & PINT_PMCFG_CFG5_MASK)
N#define PINT_PMCFG_CFG6_MASK                     (0x1C000000U)
N#define PINT_PMCFG_CFG6_SHIFT                    (26U)
N#define PINT_PMCFG_CFG6(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG6_SHIFT)) & PINT_PMCFG_CFG6_MASK)
N#define PINT_PMCFG_CFG7_MASK                     (0xE0000000U)
N#define PINT_PMCFG_CFG7_SHIFT                    (29U)
N#define PINT_PMCFG_CFG7(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG7_SHIFT)) & PINT_PMCFG_CFG7_MASK)
N
N
N/*!
N * @}
N */ /* end of group PINT_Register_Masks */
N
N
N/* PINT - Peripheral instance base addresses */
N/** Peripheral PINT base address */
N#define PINT_BASE                                (0x40004000u)
N/** Peripheral PINT base pointer */
N#define PINT                                     ((PINT_Type *)PINT_BASE)
N/** Array initializer of PINT peripheral base addresses */
N#define PINT_BASE_ADDRS                          { PINT_BASE }
N/** Array initializer of PINT peripheral base pointers */
N#define PINT_BASE_PTRS                           { PINT }
N/** Interrupt vectors for the PINT peripheral type */
N#define PINT_IRQS                                { PIN_INT0_IRQn, PIN_INT1_IRQn, PIN_INT2_IRQn, PIN_INT3_IRQn, PIN_INT4_IRQn, PIN_INT5_IRQn, PIN_INT6_IRQn, PIN_INT7_IRQn }
N
N/*!
N * @}
N */ /* end of group PINT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- RIT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup RIT_Peripheral_Access_Layer RIT Peripheral Access Layer
N * @{
N */
N
N/** RIT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t COMPVAL;                           /**< Compare value LSB register, offset: 0x0 */
X  volatile uint32_t COMPVAL;                            
N  __IO uint32_t MASK;                              /**< Mask LSB register, offset: 0x4 */
X  volatile uint32_t MASK;                               
N  __IO uint32_t CTRL;                              /**< Control register, offset: 0x8 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t COUNTER;                           /**< Counter LSB register, offset: 0xC */
X  volatile uint32_t COUNTER;                            
N  __IO uint32_t COMPVAL_H;                         /**< Compare value MSB register, offset: 0x10 */
X  volatile uint32_t COMPVAL_H;                          
N  __IO uint32_t MASK_H;                            /**< Mask MSB register, offset: 0x14 */
X  volatile uint32_t MASK_H;                             
N       uint8_t RESERVED_0[4];
N  __IO uint32_t COUNTER_H;                         /**< Counter MSB register, offset: 0x1C */
X  volatile uint32_t COUNTER_H;                          
N} RIT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- RIT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup RIT_Register_Masks RIT Register Masks
N * @{
N */
N
N/*! @name COMPVAL - Compare value LSB register */
N#define RIT_COMPVAL_RICOMP_MASK                  (0xFFFFFFFFU)
N#define RIT_COMPVAL_RICOMP_SHIFT                 (0U)
N#define RIT_COMPVAL_RICOMP(x)                    (((uint32_t)(((uint32_t)(x)) << RIT_COMPVAL_RICOMP_SHIFT)) & RIT_COMPVAL_RICOMP_MASK)
N
N/*! @name MASK - Mask LSB register */
N#define RIT_MASK_RIMASK_MASK                     (0xFFFFFFFFU)
N#define RIT_MASK_RIMASK_SHIFT                    (0U)
N#define RIT_MASK_RIMASK(x)                       (((uint32_t)(((uint32_t)(x)) << RIT_MASK_RIMASK_SHIFT)) & RIT_MASK_RIMASK_MASK)
N
N/*! @name CTRL - Control register */
N#define RIT_CTRL_RITINT_MASK                     (0x1U)
N#define RIT_CTRL_RITINT_SHIFT                    (0U)
N#define RIT_CTRL_RITINT(x)                       (((uint32_t)(((uint32_t)(x)) << RIT_CTRL_RITINT_SHIFT)) & RIT_CTRL_RITINT_MASK)
N#define RIT_CTRL_RITENCLR_MASK                   (0x2U)
N#define RIT_CTRL_RITENCLR_SHIFT                  (1U)
N#define RIT_CTRL_RITENCLR(x)                     (((uint32_t)(((uint32_t)(x)) << RIT_CTRL_RITENCLR_SHIFT)) & RIT_CTRL_RITENCLR_MASK)
N#define RIT_CTRL_RITENBR_MASK                    (0x4U)
N#define RIT_CTRL_RITENBR_SHIFT                   (2U)
N#define RIT_CTRL_RITENBR(x)                      (((uint32_t)(((uint32_t)(x)) << RIT_CTRL_RITENBR_SHIFT)) & RIT_CTRL_RITENBR_MASK)
N#define RIT_CTRL_RITEN_MASK                      (0x8U)
N#define RIT_CTRL_RITEN_SHIFT                     (3U)
N#define RIT_CTRL_RITEN(x)                        (((uint32_t)(((uint32_t)(x)) << RIT_CTRL_RITEN_SHIFT)) & RIT_CTRL_RITEN_MASK)
N
N/*! @name COUNTER - Counter LSB register */
N#define RIT_COUNTER_RICOUNTER_MASK               (0xFFFFFFFFU)
N#define RIT_COUNTER_RICOUNTER_SHIFT              (0U)
N#define RIT_COUNTER_RICOUNTER(x)                 (((uint32_t)(((uint32_t)(x)) << RIT_COUNTER_RICOUNTER_SHIFT)) & RIT_COUNTER_RICOUNTER_MASK)
N
N/*! @name COMPVAL_H - Compare value MSB register */
N#define RIT_COMPVAL_H_RICOMP_MASK                (0xFFFFU)
N#define RIT_COMPVAL_H_RICOMP_SHIFT               (0U)
N#define RIT_COMPVAL_H_RICOMP(x)                  (((uint32_t)(((uint32_t)(x)) << RIT_COMPVAL_H_RICOMP_SHIFT)) & RIT_COMPVAL_H_RICOMP_MASK)
N
N/*! @name MASK_H - Mask MSB register */
N#define RIT_MASK_H_RIMASK_MASK                   (0xFFFFU)
N#define RIT_MASK_H_RIMASK_SHIFT                  (0U)
N#define RIT_MASK_H_RIMASK(x)                     (((uint32_t)(((uint32_t)(x)) << RIT_MASK_H_RIMASK_SHIFT)) & RIT_MASK_H_RIMASK_MASK)
N
N/*! @name COUNTER_H - Counter MSB register */
N#define RIT_COUNTER_H_RICOUNTER_MASK             (0xFFFFU)
N#define RIT_COUNTER_H_RICOUNTER_SHIFT            (0U)
N#define RIT_COUNTER_H_RICOUNTER(x)               (((uint32_t)(((uint32_t)(x)) << RIT_COUNTER_H_RICOUNTER_SHIFT)) & RIT_COUNTER_H_RICOUNTER_MASK)
N
N
N/*!
N * @}
N */ /* end of group RIT_Register_Masks */
N
N
N/* RIT - Peripheral instance base addresses */
N/** Peripheral RIT base address */
N#define RIT_BASE                                 (0x4002D000u)
N/** Peripheral RIT base pointer */
N#define RIT                                      ((RIT_Type *)RIT_BASE)
N/** Array initializer of RIT peripheral base addresses */
N#define RIT_BASE_ADDRS                           { RIT_BASE }
N/** Array initializer of RIT peripheral base pointers */
N#define RIT_BASE_PTRS                            { RIT }
N/** Interrupt vectors for the RIT peripheral type */
N#define RIT_IRQS                                 { RIT_IRQn }
N
N/*!
N * @}
N */ /* end of group RIT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- RTC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup RTC_Peripheral_Access_Layer RTC Peripheral Access Layer
N * @{
N */
N
N/** RTC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< RTC control register, offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t MATCH;                             /**< RTC match register, offset: 0x4 */
X  volatile uint32_t MATCH;                              
N  __IO uint32_t COUNT;                             /**< RTC counter register, offset: 0x8 */
X  volatile uint32_t COUNT;                              
N  __IO uint32_t WAKE;                              /**< High-resolution/wake-up timer control register, offset: 0xC */
X  volatile uint32_t WAKE;                               
N       uint8_t RESERVED_0[48];
N  __IO uint32_t GPREG[8];                          /**< General Purpose register, array offset: 0x40, array step: 0x4 */
X  volatile uint32_t GPREG[8];                           
N} RTC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- RTC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup RTC_Register_Masks RTC Register Masks
N * @{
N */
N
N/*! @name CTRL - RTC control register */
N#define RTC_CTRL_SWRESET_MASK                    (0x1U)
N#define RTC_CTRL_SWRESET_SHIFT                   (0U)
N#define RTC_CTRL_SWRESET(x)                      (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_SWRESET_SHIFT)) & RTC_CTRL_SWRESET_MASK)
N#define RTC_CTRL_ALARM1HZ_MASK                   (0x4U)
N#define RTC_CTRL_ALARM1HZ_SHIFT                  (2U)
N#define RTC_CTRL_ALARM1HZ(x)                     (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_ALARM1HZ_SHIFT)) & RTC_CTRL_ALARM1HZ_MASK)
N#define RTC_CTRL_WAKE1KHZ_MASK                   (0x8U)
N#define RTC_CTRL_WAKE1KHZ_SHIFT                  (3U)
N#define RTC_CTRL_WAKE1KHZ(x)                     (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_WAKE1KHZ_SHIFT)) & RTC_CTRL_WAKE1KHZ_MASK)
N#define RTC_CTRL_ALARMDPD_EN_MASK                (0x10U)
N#define RTC_CTRL_ALARMDPD_EN_SHIFT               (4U)
N#define RTC_CTRL_ALARMDPD_EN(x)                  (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_ALARMDPD_EN_SHIFT)) & RTC_CTRL_ALARMDPD_EN_MASK)
N#define RTC_CTRL_WAKEDPD_EN_MASK                 (0x20U)
N#define RTC_CTRL_WAKEDPD_EN_SHIFT                (5U)
N#define RTC_CTRL_WAKEDPD_EN(x)                   (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_WAKEDPD_EN_SHIFT)) & RTC_CTRL_WAKEDPD_EN_MASK)
N#define RTC_CTRL_RTC1KHZ_EN_MASK                 (0x40U)
N#define RTC_CTRL_RTC1KHZ_EN_SHIFT                (6U)
N#define RTC_CTRL_RTC1KHZ_EN(x)                   (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_RTC1KHZ_EN_SHIFT)) & RTC_CTRL_RTC1KHZ_EN_MASK)
N#define RTC_CTRL_RTC_EN_MASK                     (0x80U)
N#define RTC_CTRL_RTC_EN_SHIFT                    (7U)
N#define RTC_CTRL_RTC_EN(x)                       (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_RTC_EN_SHIFT)) & RTC_CTRL_RTC_EN_MASK)
N#define RTC_CTRL_RTC_OSC_PD_MASK                 (0x100U)
N#define RTC_CTRL_RTC_OSC_PD_SHIFT                (8U)
N#define RTC_CTRL_RTC_OSC_PD(x)                   (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_RTC_OSC_PD_SHIFT)) & RTC_CTRL_RTC_OSC_PD_MASK)
N#define RTC_CTRL_RTC_OSC_BYPASS_MASK             (0x200U)
N#define RTC_CTRL_RTC_OSC_BYPASS_SHIFT            (9U)
N#define RTC_CTRL_RTC_OSC_BYPASS(x)               (((uint32_t)(((uint32_t)(x)) << RTC_CTRL_RTC_OSC_BYPASS_SHIFT)) & RTC_CTRL_RTC_OSC_BYPASS_MASK)
N
N/*! @name MATCH - RTC match register */
N#define RTC_MATCH_MATVAL_MASK                    (0xFFFFFFFFU)
N#define RTC_MATCH_MATVAL_SHIFT                   (0U)
N#define RTC_MATCH_MATVAL(x)                      (((uint32_t)(((uint32_t)(x)) << RTC_MATCH_MATVAL_SHIFT)) & RTC_MATCH_MATVAL_MASK)
N
N/*! @name COUNT - RTC counter register */
N#define RTC_COUNT_VAL_MASK                       (0xFFFFFFFFU)
N#define RTC_COUNT_VAL_SHIFT                      (0U)
N#define RTC_COUNT_VAL(x)                         (((uint32_t)(((uint32_t)(x)) << RTC_COUNT_VAL_SHIFT)) & RTC_COUNT_VAL_MASK)
N
N/*! @name WAKE - High-resolution/wake-up timer control register */
N#define RTC_WAKE_VAL_MASK                        (0xFFFFU)
N#define RTC_WAKE_VAL_SHIFT                       (0U)
N#define RTC_WAKE_VAL(x)                          (((uint32_t)(((uint32_t)(x)) << RTC_WAKE_VAL_SHIFT)) & RTC_WAKE_VAL_MASK)
N
N/*! @name GPREG - General Purpose register */
N#define RTC_GPREG_GPDATA_MASK                    (0xFFFFFFFFU)
N#define RTC_GPREG_GPDATA_SHIFT                   (0U)
N#define RTC_GPREG_GPDATA(x)                      (((uint32_t)(((uint32_t)(x)) << RTC_GPREG_GPDATA_SHIFT)) & RTC_GPREG_GPDATA_MASK)
N
N/* The count of RTC_GPREG */
N#define RTC_GPREG_COUNT                          (8U)
N
N
N/*!
N * @}
N */ /* end of group RTC_Register_Masks */
N
N
N/* RTC - Peripheral instance base addresses */
N/** Peripheral RTC base address */
N#define RTC_BASE                                 (0x4002C000u)
N/** Peripheral RTC base pointer */
N#define RTC                                      ((RTC_Type *)RTC_BASE)
N/** Array initializer of RTC peripheral base addresses */
N#define RTC_BASE_ADDRS                           { RTC_BASE }
N/** Array initializer of RTC peripheral base pointers */
N#define RTC_BASE_PTRS                            { RTC }
N/** Interrupt vectors for the RTC peripheral type */
N#define RTC_IRQS                                 { RTC_IRQn }
N
N/*!
N * @}
N */ /* end of group RTC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SCT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SCT_Peripheral_Access_Layer SCT Peripheral Access Layer
N * @{
N */
N
N/** SCT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CONFIG;                            /**< SCT configuration register, offset: 0x0 */
X  volatile uint32_t CONFIG;                             
N  __IO uint32_t CTRL;                              /**< SCT control register, offset: 0x4 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t LIMIT;                             /**< SCT limit event select register, offset: 0x8 */
X  volatile uint32_t LIMIT;                              
N  __IO uint32_t HALT;                              /**< SCT halt event select register, offset: 0xC */
X  volatile uint32_t HALT;                               
N  __IO uint32_t STOP;                              /**< SCT stop event select register, offset: 0x10 */
X  volatile uint32_t STOP;                               
N  __IO uint32_t START;                             /**< SCT start event select register, offset: 0x14 */
X  volatile uint32_t START;                              
N       uint8_t RESERVED_0[40];
N  __IO uint32_t COUNT;                             /**< SCT counter register, offset: 0x40 */
X  volatile uint32_t COUNT;                              
N  __IO uint32_t STATE;                             /**< SCT state register, offset: 0x44 */
X  volatile uint32_t STATE;                              
N  __I  uint32_t INPUT;                             /**< SCT input register, offset: 0x48 */
X  volatile const  uint32_t INPUT;                              
N  __IO uint32_t REGMODE;                           /**< SCT match/capture mode register, offset: 0x4C */
X  volatile uint32_t REGMODE;                            
N  __IO uint32_t OUTPUT;                            /**< SCT output register, offset: 0x50 */
X  volatile uint32_t OUTPUT;                             
N  __IO uint32_t OUTPUTDIRCTRL;                     /**< SCT output counter direction control register, offset: 0x54 */
X  volatile uint32_t OUTPUTDIRCTRL;                      
N  __IO uint32_t RES;                               /**< SCT conflict resolution register, offset: 0x58 */
X  volatile uint32_t RES;                                
N  __IO uint32_t DMA0REQUEST;                       /**< SCT DMA request 0 register, offset: 0x5C */
X  volatile uint32_t DMA0REQUEST;                        
N  __IO uint32_t DMA1REQUEST;                       /**< SCT DMA request 1 register, offset: 0x60 */
X  volatile uint32_t DMA1REQUEST;                        
N       uint8_t RESERVED_1[140];
N  __IO uint32_t EVEN;                              /**< SCT event interrupt enable register, offset: 0xF0 */
X  volatile uint32_t EVEN;                               
N  __IO uint32_t EVFLAG;                            /**< SCT event flag register, offset: 0xF4 */
X  volatile uint32_t EVFLAG;                             
N  __IO uint32_t CONEN;                             /**< SCT conflict interrupt enable register, offset: 0xF8 */
X  volatile uint32_t CONEN;                              
N  __IO uint32_t CONFLAG;                           /**< SCT conflict flag register, offset: 0xFC */
X  volatile uint32_t CONFLAG;                            
N  union {                                          /* offset: 0x100 */
N    __IO uint32_t SCTCAP[10];                        /**< SCT capture register of capture channel, array offset: 0x100, array step: 0x4 */
X    volatile uint32_t SCTCAP[10];                         
N    __IO uint32_t SCTMATCH[10];                      /**< SCT match value register of match channels, array offset: 0x100, array step: 0x4 */
X    volatile uint32_t SCTMATCH[10];                       
N  };
N       uint8_t RESERVED_2[216];
N  union {                                          /* offset: 0x200 */
N    __IO uint32_t SCTCAPCTRL[10];                    /**< SCT capture control register, array offset: 0x200, array step: 0x4 */
X    volatile uint32_t SCTCAPCTRL[10];                     
N    __IO uint32_t SCTMATCHREL[10];                   /**< SCT match reload value register, array offset: 0x200, array step: 0x4 */
X    volatile uint32_t SCTMATCHREL[10];                    
N  };
N       uint8_t RESERVED_3[216];
N  struct {                                         /* offset: 0x300, array step: 0x8 */
N    __IO uint32_t STATE;                             /**< SCT event state register 0, array offset: 0x300, array step: 0x8 */
X    volatile uint32_t STATE;                              
N    __IO uint32_t CTRL;                              /**< SCT event control register 0, array offset: 0x304, array step: 0x8 */
X    volatile uint32_t CTRL;                               
N  } EVENT[10];
N       uint8_t RESERVED_4[432];
N  struct {                                         /* offset: 0x500, array step: 0x8 */
N    __IO uint32_t SET;                               /**< SCT output 0 set register, array offset: 0x500, array step: 0x8 */
X    volatile uint32_t SET;                                
N    __IO uint32_t CLR;                               /**< SCT output 0 clear register, array offset: 0x504, array step: 0x8 */
X    volatile uint32_t CLR;                                
N  } OUT[10];
N} SCT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SCT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SCT_Register_Masks SCT Register Masks
N * @{
N */
N
N/*! @name CONFIG - SCT configuration register */
N#define SCT_CONFIG_UNIFY_MASK                    (0x1U)
N#define SCT_CONFIG_UNIFY_SHIFT                   (0U)
N#define SCT_CONFIG_UNIFY(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_UNIFY_SHIFT)) & SCT_CONFIG_UNIFY_MASK)
N#define SCT_CONFIG_CLKMODE_MASK                  (0x6U)
N#define SCT_CONFIG_CLKMODE_SHIFT                 (1U)
N#define SCT_CONFIG_CLKMODE(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_CLKMODE_SHIFT)) & SCT_CONFIG_CLKMODE_MASK)
N#define SCT_CONFIG_CKSEL_MASK                    (0x78U)
N#define SCT_CONFIG_CKSEL_SHIFT                   (3U)
N#define SCT_CONFIG_CKSEL(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_CKSEL_SHIFT)) & SCT_CONFIG_CKSEL_MASK)
N#define SCT_CONFIG_NORELAOD_L_MASK               (0x80U)
N#define SCT_CONFIG_NORELAOD_L_SHIFT              (7U)
N#define SCT_CONFIG_NORELAOD_L(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_NORELAOD_L_SHIFT)) & SCT_CONFIG_NORELAOD_L_MASK)
N#define SCT_CONFIG_NORELOAD_H_MASK               (0x100U)
N#define SCT_CONFIG_NORELOAD_H_SHIFT              (8U)
N#define SCT_CONFIG_NORELOAD_H(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_NORELOAD_H_SHIFT)) & SCT_CONFIG_NORELOAD_H_MASK)
N#define SCT_CONFIG_INSYNC_MASK                   (0x1E00U)
N#define SCT_CONFIG_INSYNC_SHIFT                  (9U)
N#define SCT_CONFIG_INSYNC(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_INSYNC_SHIFT)) & SCT_CONFIG_INSYNC_MASK)
N#define SCT_CONFIG_AUTOLIMIT_L_MASK              (0x20000U)
N#define SCT_CONFIG_AUTOLIMIT_L_SHIFT             (17U)
N#define SCT_CONFIG_AUTOLIMIT_L(x)                (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_AUTOLIMIT_L_SHIFT)) & SCT_CONFIG_AUTOLIMIT_L_MASK)
N#define SCT_CONFIG_AUTOLIMIT_H_MASK              (0x40000U)
N#define SCT_CONFIG_AUTOLIMIT_H_SHIFT             (18U)
N#define SCT_CONFIG_AUTOLIMIT_H(x)                (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_AUTOLIMIT_H_SHIFT)) & SCT_CONFIG_AUTOLIMIT_H_MASK)
N
N/*! @name CTRL - SCT control register */
N#define SCT_CTRL_DOWN_L_MASK                     (0x1U)
N#define SCT_CTRL_DOWN_L_SHIFT                    (0U)
N#define SCT_CTRL_DOWN_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_DOWN_L_SHIFT)) & SCT_CTRL_DOWN_L_MASK)
N#define SCT_CTRL_STOP_L_MASK                     (0x2U)
N#define SCT_CTRL_STOP_L_SHIFT                    (1U)
N#define SCT_CTRL_STOP_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_STOP_L_SHIFT)) & SCT_CTRL_STOP_L_MASK)
N#define SCT_CTRL_HALT_L_MASK                     (0x4U)
N#define SCT_CTRL_HALT_L_SHIFT                    (2U)
N#define SCT_CTRL_HALT_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_HALT_L_SHIFT)) & SCT_CTRL_HALT_L_MASK)
N#define SCT_CTRL_CLRCTR_L_MASK                   (0x8U)
N#define SCT_CTRL_CLRCTR_L_SHIFT                  (3U)
N#define SCT_CTRL_CLRCTR_L(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_CLRCTR_L_SHIFT)) & SCT_CTRL_CLRCTR_L_MASK)
N#define SCT_CTRL_BIDIR_L_MASK                    (0x10U)
N#define SCT_CTRL_BIDIR_L_SHIFT                   (4U)
N#define SCT_CTRL_BIDIR_L(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_BIDIR_L_SHIFT)) & SCT_CTRL_BIDIR_L_MASK)
N#define SCT_CTRL_PRE_L_MASK                      (0x1FE0U)
N#define SCT_CTRL_PRE_L_SHIFT                     (5U)
N#define SCT_CTRL_PRE_L(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_PRE_L_SHIFT)) & SCT_CTRL_PRE_L_MASK)
N#define SCT_CTRL_DOWN_H_MASK                     (0x10000U)
N#define SCT_CTRL_DOWN_H_SHIFT                    (16U)
N#define SCT_CTRL_DOWN_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_DOWN_H_SHIFT)) & SCT_CTRL_DOWN_H_MASK)
N#define SCT_CTRL_STOP_H_MASK                     (0x20000U)
N#define SCT_CTRL_STOP_H_SHIFT                    (17U)
N#define SCT_CTRL_STOP_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_STOP_H_SHIFT)) & SCT_CTRL_STOP_H_MASK)
N#define SCT_CTRL_HALT_H_MASK                     (0x40000U)
N#define SCT_CTRL_HALT_H_SHIFT                    (18U)
N#define SCT_CTRL_HALT_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_HALT_H_SHIFT)) & SCT_CTRL_HALT_H_MASK)
N#define SCT_CTRL_CLRCTR_H_MASK                   (0x80000U)
N#define SCT_CTRL_CLRCTR_H_SHIFT                  (19U)
N#define SCT_CTRL_CLRCTR_H(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_CLRCTR_H_SHIFT)) & SCT_CTRL_CLRCTR_H_MASK)
N#define SCT_CTRL_BIDIR_H_MASK                    (0x100000U)
N#define SCT_CTRL_BIDIR_H_SHIFT                   (20U)
N#define SCT_CTRL_BIDIR_H(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_BIDIR_H_SHIFT)) & SCT_CTRL_BIDIR_H_MASK)
N#define SCT_CTRL_PRE_H_MASK                      (0x1FE00000U)
N#define SCT_CTRL_PRE_H_SHIFT                     (21U)
N#define SCT_CTRL_PRE_H(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_PRE_H_SHIFT)) & SCT_CTRL_PRE_H_MASK)
N
N/*! @name LIMIT - SCT limit event select register */
N#define SCT_LIMIT_LIMMSK_L_MASK                  (0xFFFFU)
N#define SCT_LIMIT_LIMMSK_L_SHIFT                 (0U)
N#define SCT_LIMIT_LIMMSK_L(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_LIMIT_LIMMSK_L_SHIFT)) & SCT_LIMIT_LIMMSK_L_MASK)
N#define SCT_LIMIT_LIMMSK_H_MASK                  (0xFFFF0000U)
N#define SCT_LIMIT_LIMMSK_H_SHIFT                 (16U)
N#define SCT_LIMIT_LIMMSK_H(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_LIMIT_LIMMSK_H_SHIFT)) & SCT_LIMIT_LIMMSK_H_MASK)
N
N/*! @name HALT - SCT halt event select register */
N#define SCT_HALT_HALTMSK_L_MASK                  (0xFFFFU)
N#define SCT_HALT_HALTMSK_L_SHIFT                 (0U)
N#define SCT_HALT_HALTMSK_L(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_HALT_HALTMSK_L_SHIFT)) & SCT_HALT_HALTMSK_L_MASK)
N#define SCT_HALT_HALTMSK_H_MASK                  (0xFFFF0000U)
N#define SCT_HALT_HALTMSK_H_SHIFT                 (16U)
N#define SCT_HALT_HALTMSK_H(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_HALT_HALTMSK_H_SHIFT)) & SCT_HALT_HALTMSK_H_MASK)
N
N/*! @name STOP - SCT stop event select register */
N#define SCT_STOP_STOPMSK_L_MASK                  (0xFFFFU)
N#define SCT_STOP_STOPMSK_L_SHIFT                 (0U)
N#define SCT_STOP_STOPMSK_L(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_STOP_STOPMSK_L_SHIFT)) & SCT_STOP_STOPMSK_L_MASK)
N#define SCT_STOP_STOPMSK_H_MASK                  (0xFFFF0000U)
N#define SCT_STOP_STOPMSK_H_SHIFT                 (16U)
N#define SCT_STOP_STOPMSK_H(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_STOP_STOPMSK_H_SHIFT)) & SCT_STOP_STOPMSK_H_MASK)
N
N/*! @name START - SCT start event select register */
N#define SCT_START_STARTMSK_L_MASK                (0xFFFFU)
N#define SCT_START_STARTMSK_L_SHIFT               (0U)
N#define SCT_START_STARTMSK_L(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_START_STARTMSK_L_SHIFT)) & SCT_START_STARTMSK_L_MASK)
N#define SCT_START_STARTMSK_H_MASK                (0xFFFF0000U)
N#define SCT_START_STARTMSK_H_SHIFT               (16U)
N#define SCT_START_STARTMSK_H(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_START_STARTMSK_H_SHIFT)) & SCT_START_STARTMSK_H_MASK)
N
N/*! @name COUNT - SCT counter register */
N#define SCT_COUNT_CTR_L_MASK                     (0xFFFFU)
N#define SCT_COUNT_CTR_L_SHIFT                    (0U)
N#define SCT_COUNT_CTR_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_COUNT_CTR_L_SHIFT)) & SCT_COUNT_CTR_L_MASK)
N#define SCT_COUNT_CTR_H_MASK                     (0xFFFF0000U)
N#define SCT_COUNT_CTR_H_SHIFT                    (16U)
N#define SCT_COUNT_CTR_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_COUNT_CTR_H_SHIFT)) & SCT_COUNT_CTR_H_MASK)
N
N/*! @name STATE - SCT state register */
N#define SCT_STATE_STATE_L_MASK                   (0x1FU)
N#define SCT_STATE_STATE_L_SHIFT                  (0U)
N#define SCT_STATE_STATE_L(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_STATE_STATE_L_SHIFT)) & SCT_STATE_STATE_L_MASK)
N#define SCT_STATE_STATE_H_MASK                   (0x1F0000U)
N#define SCT_STATE_STATE_H_SHIFT                  (16U)
N#define SCT_STATE_STATE_H(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_STATE_STATE_H_SHIFT)) & SCT_STATE_STATE_H_MASK)
N
N/*! @name INPUT - SCT input register */
N#define SCT_INPUT_AIN0_MASK                      (0x1U)
N#define SCT_INPUT_AIN0_SHIFT                     (0U)
N#define SCT_INPUT_AIN0(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN0_SHIFT)) & SCT_INPUT_AIN0_MASK)
N#define SCT_INPUT_AIN1_MASK                      (0x2U)
N#define SCT_INPUT_AIN1_SHIFT                     (1U)
N#define SCT_INPUT_AIN1(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN1_SHIFT)) & SCT_INPUT_AIN1_MASK)
N#define SCT_INPUT_AIN2_MASK                      (0x4U)
N#define SCT_INPUT_AIN2_SHIFT                     (2U)
N#define SCT_INPUT_AIN2(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN2_SHIFT)) & SCT_INPUT_AIN2_MASK)
N#define SCT_INPUT_AIN3_MASK                      (0x8U)
N#define SCT_INPUT_AIN3_SHIFT                     (3U)
N#define SCT_INPUT_AIN3(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN3_SHIFT)) & SCT_INPUT_AIN3_MASK)
N#define SCT_INPUT_AIN4_MASK                      (0x10U)
N#define SCT_INPUT_AIN4_SHIFT                     (4U)
N#define SCT_INPUT_AIN4(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN4_SHIFT)) & SCT_INPUT_AIN4_MASK)
N#define SCT_INPUT_AIN5_MASK                      (0x20U)
N#define SCT_INPUT_AIN5_SHIFT                     (5U)
N#define SCT_INPUT_AIN5(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN5_SHIFT)) & SCT_INPUT_AIN5_MASK)
N#define SCT_INPUT_AIN6_MASK                      (0x40U)
N#define SCT_INPUT_AIN6_SHIFT                     (6U)
N#define SCT_INPUT_AIN6(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN6_SHIFT)) & SCT_INPUT_AIN6_MASK)
N#define SCT_INPUT_AIN7_MASK                      (0x80U)
N#define SCT_INPUT_AIN7_SHIFT                     (7U)
N#define SCT_INPUT_AIN7(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN7_SHIFT)) & SCT_INPUT_AIN7_MASK)
N#define SCT_INPUT_AIN8_MASK                      (0x100U)
N#define SCT_INPUT_AIN8_SHIFT                     (8U)
N#define SCT_INPUT_AIN8(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN8_SHIFT)) & SCT_INPUT_AIN8_MASK)
N#define SCT_INPUT_AIN9_MASK                      (0x200U)
N#define SCT_INPUT_AIN9_SHIFT                     (9U)
N#define SCT_INPUT_AIN9(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN9_SHIFT)) & SCT_INPUT_AIN9_MASK)
N#define SCT_INPUT_AIN10_MASK                     (0x400U)
N#define SCT_INPUT_AIN10_SHIFT                    (10U)
N#define SCT_INPUT_AIN10(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN10_SHIFT)) & SCT_INPUT_AIN10_MASK)
N#define SCT_INPUT_AIN11_MASK                     (0x800U)
N#define SCT_INPUT_AIN11_SHIFT                    (11U)
N#define SCT_INPUT_AIN11(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN11_SHIFT)) & SCT_INPUT_AIN11_MASK)
N#define SCT_INPUT_AIN12_MASK                     (0x1000U)
N#define SCT_INPUT_AIN12_SHIFT                    (12U)
N#define SCT_INPUT_AIN12(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN12_SHIFT)) & SCT_INPUT_AIN12_MASK)
N#define SCT_INPUT_AIN13_MASK                     (0x2000U)
N#define SCT_INPUT_AIN13_SHIFT                    (13U)
N#define SCT_INPUT_AIN13(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN13_SHIFT)) & SCT_INPUT_AIN13_MASK)
N#define SCT_INPUT_AIN14_MASK                     (0x4000U)
N#define SCT_INPUT_AIN14_SHIFT                    (14U)
N#define SCT_INPUT_AIN14(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN14_SHIFT)) & SCT_INPUT_AIN14_MASK)
N#define SCT_INPUT_AIN15_MASK                     (0x8000U)
N#define SCT_INPUT_AIN15_SHIFT                    (15U)
N#define SCT_INPUT_AIN15(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN15_SHIFT)) & SCT_INPUT_AIN15_MASK)
N#define SCT_INPUT_SIN0_MASK                      (0x10000U)
N#define SCT_INPUT_SIN0_SHIFT                     (16U)
N#define SCT_INPUT_SIN0(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN0_SHIFT)) & SCT_INPUT_SIN0_MASK)
N#define SCT_INPUT_SIN1_MASK                      (0x20000U)
N#define SCT_INPUT_SIN1_SHIFT                     (17U)
N#define SCT_INPUT_SIN1(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN1_SHIFT)) & SCT_INPUT_SIN1_MASK)
N#define SCT_INPUT_SIN2_MASK                      (0x40000U)
N#define SCT_INPUT_SIN2_SHIFT                     (18U)
N#define SCT_INPUT_SIN2(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN2_SHIFT)) & SCT_INPUT_SIN2_MASK)
N#define SCT_INPUT_SIN3_MASK                      (0x80000U)
N#define SCT_INPUT_SIN3_SHIFT                     (19U)
N#define SCT_INPUT_SIN3(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN3_SHIFT)) & SCT_INPUT_SIN3_MASK)
N#define SCT_INPUT_SIN4_MASK                      (0x100000U)
N#define SCT_INPUT_SIN4_SHIFT                     (20U)
N#define SCT_INPUT_SIN4(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN4_SHIFT)) & SCT_INPUT_SIN4_MASK)
N#define SCT_INPUT_SIN5_MASK                      (0x200000U)
N#define SCT_INPUT_SIN5_SHIFT                     (21U)
N#define SCT_INPUT_SIN5(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN5_SHIFT)) & SCT_INPUT_SIN5_MASK)
N#define SCT_INPUT_SIN6_MASK                      (0x400000U)
N#define SCT_INPUT_SIN6_SHIFT                     (22U)
N#define SCT_INPUT_SIN6(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN6_SHIFT)) & SCT_INPUT_SIN6_MASK)
N#define SCT_INPUT_SIN7_MASK                      (0x800000U)
N#define SCT_INPUT_SIN7_SHIFT                     (23U)
N#define SCT_INPUT_SIN7(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN7_SHIFT)) & SCT_INPUT_SIN7_MASK)
N#define SCT_INPUT_SIN8_MASK                      (0x1000000U)
N#define SCT_INPUT_SIN8_SHIFT                     (24U)
N#define SCT_INPUT_SIN8(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN8_SHIFT)) & SCT_INPUT_SIN8_MASK)
N#define SCT_INPUT_SIN9_MASK                      (0x2000000U)
N#define SCT_INPUT_SIN9_SHIFT                     (25U)
N#define SCT_INPUT_SIN9(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN9_SHIFT)) & SCT_INPUT_SIN9_MASK)
N#define SCT_INPUT_SIN10_MASK                     (0x4000000U)
N#define SCT_INPUT_SIN10_SHIFT                    (26U)
N#define SCT_INPUT_SIN10(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN10_SHIFT)) & SCT_INPUT_SIN10_MASK)
N#define SCT_INPUT_SIN11_MASK                     (0x8000000U)
N#define SCT_INPUT_SIN11_SHIFT                    (27U)
N#define SCT_INPUT_SIN11(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN11_SHIFT)) & SCT_INPUT_SIN11_MASK)
N#define SCT_INPUT_SIN12_MASK                     (0x10000000U)
N#define SCT_INPUT_SIN12_SHIFT                    (28U)
N#define SCT_INPUT_SIN12(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN12_SHIFT)) & SCT_INPUT_SIN12_MASK)
N#define SCT_INPUT_SIN13_MASK                     (0x20000000U)
N#define SCT_INPUT_SIN13_SHIFT                    (29U)
N#define SCT_INPUT_SIN13(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN13_SHIFT)) & SCT_INPUT_SIN13_MASK)
N#define SCT_INPUT_SIN14_MASK                     (0x40000000U)
N#define SCT_INPUT_SIN14_SHIFT                    (30U)
N#define SCT_INPUT_SIN14(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN14_SHIFT)) & SCT_INPUT_SIN14_MASK)
N#define SCT_INPUT_SIN15_MASK                     (0x80000000U)
N#define SCT_INPUT_SIN15_SHIFT                    (31U)
N#define SCT_INPUT_SIN15(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN15_SHIFT)) & SCT_INPUT_SIN15_MASK)
N
N/*! @name REGMODE - SCT match/capture mode register */
N#define SCT_REGMODE_REGMOD_L_MASK                (0xFFFFU)
N#define SCT_REGMODE_REGMOD_L_SHIFT               (0U)
N#define SCT_REGMODE_REGMOD_L(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_REGMODE_REGMOD_L_SHIFT)) & SCT_REGMODE_REGMOD_L_MASK)
N#define SCT_REGMODE_REGMOD_H_MASK                (0xFFFF0000U)
N#define SCT_REGMODE_REGMOD_H_SHIFT               (16U)
N#define SCT_REGMODE_REGMOD_H(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_REGMODE_REGMOD_H_SHIFT)) & SCT_REGMODE_REGMOD_H_MASK)
N
N/*! @name OUTPUT - SCT output register */
N#define SCT_OUTPUT_OUT_MASK                      (0xFFFFU)
N#define SCT_OUTPUT_OUT_SHIFT                     (0U)
N#define SCT_OUTPUT_OUT(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUT_OUT_SHIFT)) & SCT_OUTPUT_OUT_MASK)
N
N/*! @name OUTPUTDIRCTRL - SCT output counter direction control register */
N#define SCT_OUTPUTDIRCTRL_SETCLR0_MASK           (0x3U)
N#define SCT_OUTPUTDIRCTRL_SETCLR0_SHIFT          (0U)
N#define SCT_OUTPUTDIRCTRL_SETCLR0(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR0_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR0_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR1_MASK           (0xCU)
N#define SCT_OUTPUTDIRCTRL_SETCLR1_SHIFT          (2U)
N#define SCT_OUTPUTDIRCTRL_SETCLR1(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR1_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR1_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR2_MASK           (0x30U)
N#define SCT_OUTPUTDIRCTRL_SETCLR2_SHIFT          (4U)
N#define SCT_OUTPUTDIRCTRL_SETCLR2(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR2_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR2_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR3_MASK           (0xC0U)
N#define SCT_OUTPUTDIRCTRL_SETCLR3_SHIFT          (6U)
N#define SCT_OUTPUTDIRCTRL_SETCLR3(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR3_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR3_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR4_MASK           (0x300U)
N#define SCT_OUTPUTDIRCTRL_SETCLR4_SHIFT          (8U)
N#define SCT_OUTPUTDIRCTRL_SETCLR4(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR4_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR4_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR5_MASK           (0xC00U)
N#define SCT_OUTPUTDIRCTRL_SETCLR5_SHIFT          (10U)
N#define SCT_OUTPUTDIRCTRL_SETCLR5(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR5_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR5_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR6_MASK           (0x3000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR6_SHIFT          (12U)
N#define SCT_OUTPUTDIRCTRL_SETCLR6(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR6_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR6_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR7_MASK           (0xC000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR7_SHIFT          (14U)
N#define SCT_OUTPUTDIRCTRL_SETCLR7(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR7_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR7_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR8_MASK           (0x30000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR8_SHIFT          (16U)
N#define SCT_OUTPUTDIRCTRL_SETCLR8(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR8_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR8_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR9_MASK           (0xC0000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR9_SHIFT          (18U)
N#define SCT_OUTPUTDIRCTRL_SETCLR9(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR9_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR9_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR10_MASK          (0x300000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR10_SHIFT         (20U)
N#define SCT_OUTPUTDIRCTRL_SETCLR10(x)            (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR10_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR10_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR11_MASK          (0xC00000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR11_SHIFT         (22U)
N#define SCT_OUTPUTDIRCTRL_SETCLR11(x)            (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR11_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR11_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR12_MASK          (0x3000000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR12_SHIFT         (24U)
N#define SCT_OUTPUTDIRCTRL_SETCLR12(x)            (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR12_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR12_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR13_MASK          (0xC000000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR13_SHIFT         (26U)
N#define SCT_OUTPUTDIRCTRL_SETCLR13(x)            (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR13_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR13_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR14_MASK          (0x30000000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR14_SHIFT         (28U)
N#define SCT_OUTPUTDIRCTRL_SETCLR14(x)            (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR14_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR14_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR15_MASK          (0xC0000000U)
N#define SCT_OUTPUTDIRCTRL_SETCLR15_SHIFT         (30U)
N#define SCT_OUTPUTDIRCTRL_SETCLR15(x)            (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR15_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR15_MASK)
N
N/*! @name RES - SCT conflict resolution register */
N#define SCT_RES_O0RES_MASK                       (0x3U)
N#define SCT_RES_O0RES_SHIFT                      (0U)
N#define SCT_RES_O0RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O0RES_SHIFT)) & SCT_RES_O0RES_MASK)
N#define SCT_RES_O1RES_MASK                       (0xCU)
N#define SCT_RES_O1RES_SHIFT                      (2U)
N#define SCT_RES_O1RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O1RES_SHIFT)) & SCT_RES_O1RES_MASK)
N#define SCT_RES_O2RES_MASK                       (0x30U)
N#define SCT_RES_O2RES_SHIFT                      (4U)
N#define SCT_RES_O2RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O2RES_SHIFT)) & SCT_RES_O2RES_MASK)
N#define SCT_RES_O3RES_MASK                       (0xC0U)
N#define SCT_RES_O3RES_SHIFT                      (6U)
N#define SCT_RES_O3RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O3RES_SHIFT)) & SCT_RES_O3RES_MASK)
N#define SCT_RES_O4RES_MASK                       (0x300U)
N#define SCT_RES_O4RES_SHIFT                      (8U)
N#define SCT_RES_O4RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O4RES_SHIFT)) & SCT_RES_O4RES_MASK)
N#define SCT_RES_O5RES_MASK                       (0xC00U)
N#define SCT_RES_O5RES_SHIFT                      (10U)
N#define SCT_RES_O5RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O5RES_SHIFT)) & SCT_RES_O5RES_MASK)
N#define SCT_RES_O6RES_MASK                       (0x3000U)
N#define SCT_RES_O6RES_SHIFT                      (12U)
N#define SCT_RES_O6RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O6RES_SHIFT)) & SCT_RES_O6RES_MASK)
N#define SCT_RES_O7RES_MASK                       (0xC000U)
N#define SCT_RES_O7RES_SHIFT                      (14U)
N#define SCT_RES_O7RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O7RES_SHIFT)) & SCT_RES_O7RES_MASK)
N#define SCT_RES_O8RES_MASK                       (0x30000U)
N#define SCT_RES_O8RES_SHIFT                      (16U)
N#define SCT_RES_O8RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O8RES_SHIFT)) & SCT_RES_O8RES_MASK)
N#define SCT_RES_O9RES_MASK                       (0xC0000U)
N#define SCT_RES_O9RES_SHIFT                      (18U)
N#define SCT_RES_O9RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O9RES_SHIFT)) & SCT_RES_O9RES_MASK)
N#define SCT_RES_O10RES_MASK                      (0x300000U)
N#define SCT_RES_O10RES_SHIFT                     (20U)
N#define SCT_RES_O10RES(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_RES_O10RES_SHIFT)) & SCT_RES_O10RES_MASK)
N#define SCT_RES_O11RES_MASK                      (0xC00000U)
N#define SCT_RES_O11RES_SHIFT                     (22U)
N#define SCT_RES_O11RES(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_RES_O11RES_SHIFT)) & SCT_RES_O11RES_MASK)
N#define SCT_RES_O12RES_MASK                      (0x3000000U)
N#define SCT_RES_O12RES_SHIFT                     (24U)
N#define SCT_RES_O12RES(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_RES_O12RES_SHIFT)) & SCT_RES_O12RES_MASK)
N#define SCT_RES_O13RES_MASK                      (0xC000000U)
N#define SCT_RES_O13RES_SHIFT                     (26U)
N#define SCT_RES_O13RES(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_RES_O13RES_SHIFT)) & SCT_RES_O13RES_MASK)
N#define SCT_RES_O14RES_MASK                      (0x30000000U)
N#define SCT_RES_O14RES_SHIFT                     (28U)
N#define SCT_RES_O14RES(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_RES_O14RES_SHIFT)) & SCT_RES_O14RES_MASK)
N#define SCT_RES_O15RES_MASK                      (0xC0000000U)
N#define SCT_RES_O15RES_SHIFT                     (30U)
N#define SCT_RES_O15RES(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_RES_O15RES_SHIFT)) & SCT_RES_O15RES_MASK)
N
N/*! @name DMA0REQUEST - SCT DMA request 0 register */
N#define SCT_DMA0REQUEST_DEV_0_MASK               (0xFFFFU)
N#define SCT_DMA0REQUEST_DEV_0_SHIFT              (0U)
N#define SCT_DMA0REQUEST_DEV_0(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_DMA0REQUEST_DEV_0_SHIFT)) & SCT_DMA0REQUEST_DEV_0_MASK)
N#define SCT_DMA0REQUEST_DRL0_MASK                (0x40000000U)
N#define SCT_DMA0REQUEST_DRL0_SHIFT               (30U)
N#define SCT_DMA0REQUEST_DRL0(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA0REQUEST_DRL0_SHIFT)) & SCT_DMA0REQUEST_DRL0_MASK)
N#define SCT_DMA0REQUEST_DRQ0_MASK                (0x80000000U)
N#define SCT_DMA0REQUEST_DRQ0_SHIFT               (31U)
N#define SCT_DMA0REQUEST_DRQ0(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA0REQUEST_DRQ0_SHIFT)) & SCT_DMA0REQUEST_DRQ0_MASK)
N
N/*! @name DMA1REQUEST - SCT DMA request 1 register */
N#define SCT_DMA1REQUEST_DEV_1_MASK               (0xFFFFU)
N#define SCT_DMA1REQUEST_DEV_1_SHIFT              (0U)
N#define SCT_DMA1REQUEST_DEV_1(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_DMA1REQUEST_DEV_1_SHIFT)) & SCT_DMA1REQUEST_DEV_1_MASK)
N#define SCT_DMA1REQUEST_DRL1_MASK                (0x40000000U)
N#define SCT_DMA1REQUEST_DRL1_SHIFT               (30U)
N#define SCT_DMA1REQUEST_DRL1(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA1REQUEST_DRL1_SHIFT)) & SCT_DMA1REQUEST_DRL1_MASK)
N#define SCT_DMA1REQUEST_DRQ1_MASK                (0x80000000U)
N#define SCT_DMA1REQUEST_DRQ1_SHIFT               (31U)
N#define SCT_DMA1REQUEST_DRQ1(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA1REQUEST_DRQ1_SHIFT)) & SCT_DMA1REQUEST_DRQ1_MASK)
N
N/*! @name EVEN - SCT event interrupt enable register */
N#define SCT_EVEN_IEN_MASK                        (0xFFFFU)
N#define SCT_EVEN_IEN_SHIFT                       (0U)
N#define SCT_EVEN_IEN(x)                          (((uint32_t)(((uint32_t)(x)) << SCT_EVEN_IEN_SHIFT)) & SCT_EVEN_IEN_MASK)
N
N/*! @name EVFLAG - SCT event flag register */
N#define SCT_EVFLAG_FLAG_MASK                     (0xFFFFU)
N#define SCT_EVFLAG_FLAG_SHIFT                    (0U)
N#define SCT_EVFLAG_FLAG(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_EVFLAG_FLAG_SHIFT)) & SCT_EVFLAG_FLAG_MASK)
N
N/*! @name CONEN - SCT conflict interrupt enable register */
N#define SCT_CONEN_NCEN_MASK                      (0xFFFFU)
N#define SCT_CONEN_NCEN_SHIFT                     (0U)
N#define SCT_CONEN_NCEN(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_CONEN_NCEN_SHIFT)) & SCT_CONEN_NCEN_MASK)
N
N/*! @name CONFLAG - SCT conflict flag register */
N#define SCT_CONFLAG_NCFLAG_MASK                  (0xFFFFU)
N#define SCT_CONFLAG_NCFLAG_SHIFT                 (0U)
N#define SCT_CONFLAG_NCFLAG(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_CONFLAG_NCFLAG_SHIFT)) & SCT_CONFLAG_NCFLAG_MASK)
N#define SCT_CONFLAG_BUSERRL_MASK                 (0x40000000U)
N#define SCT_CONFLAG_BUSERRL_SHIFT                (30U)
N#define SCT_CONFLAG_BUSERRL(x)                   (((uint32_t)(((uint32_t)(x)) << SCT_CONFLAG_BUSERRL_SHIFT)) & SCT_CONFLAG_BUSERRL_MASK)
N#define SCT_CONFLAG_BUSERRH_MASK                 (0x80000000U)
N#define SCT_CONFLAG_BUSERRH_SHIFT                (31U)
N#define SCT_CONFLAG_BUSERRH(x)                   (((uint32_t)(((uint32_t)(x)) << SCT_CONFLAG_BUSERRH_SHIFT)) & SCT_CONFLAG_BUSERRH_MASK)
N
N/*! @name SCTCAP - SCT capture register of capture channel */
N#define SCT_SCTCAP_CAPn_L_MASK                   (0xFFFFU)
N#define SCT_SCTCAP_CAPn_L_SHIFT                  (0U)
N#define SCT_SCTCAP_CAPn_L(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAP_CAPn_L_SHIFT)) & SCT_SCTCAP_CAPn_L_MASK)
N#define SCT_SCTCAP_CAPn_H_MASK                   (0xFFFF0000U)
N#define SCT_SCTCAP_CAPn_H_SHIFT                  (16U)
N#define SCT_SCTCAP_CAPn_H(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAP_CAPn_H_SHIFT)) & SCT_SCTCAP_CAPn_H_MASK)
N
N/* The count of SCT_SCTCAP */
N#define SCT_SCTCAP_COUNT                         (10U)
N
N/*! @name SCTMATCH - SCT match value register of match channels */
N#define SCT_SCTMATCH_MATCHn_L_MASK               (0xFFFFU)
N#define SCT_SCTMATCH_MATCHn_L_SHIFT              (0U)
N#define SCT_SCTMATCH_MATCHn_L(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCH_MATCHn_L_SHIFT)) & SCT_SCTMATCH_MATCHn_L_MASK)
N#define SCT_SCTMATCH_MATCHn_H_MASK               (0xFFFF0000U)
N#define SCT_SCTMATCH_MATCHn_H_SHIFT              (16U)
N#define SCT_SCTMATCH_MATCHn_H(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCH_MATCHn_H_SHIFT)) & SCT_SCTMATCH_MATCHn_H_MASK)
N
N/* The count of SCT_SCTMATCH */
N#define SCT_SCTMATCH_COUNT                       (10U)
N
N/*! @name SCTCAPCTRL - SCT capture control register */
N#define SCT_SCTCAPCTRL_CAPCONn_L_MASK            (0xFFFFU)
N#define SCT_SCTCAPCTRL_CAPCONn_L_SHIFT           (0U)
N#define SCT_SCTCAPCTRL_CAPCONn_L(x)              (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAPCTRL_CAPCONn_L_SHIFT)) & SCT_SCTCAPCTRL_CAPCONn_L_MASK)
N#define SCT_SCTCAPCTRL_CAPCONn_H_MASK            (0xFFFF0000U)
N#define SCT_SCTCAPCTRL_CAPCONn_H_SHIFT           (16U)
N#define SCT_SCTCAPCTRL_CAPCONn_H(x)              (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAPCTRL_CAPCONn_H_SHIFT)) & SCT_SCTCAPCTRL_CAPCONn_H_MASK)
N
N/* The count of SCT_SCTCAPCTRL */
N#define SCT_SCTCAPCTRL_COUNT                     (10U)
N
N/*! @name SCTMATCHREL - SCT match reload value register */
N#define SCT_SCTMATCHREL_RELOADn_L_MASK           (0xFFFFU)
N#define SCT_SCTMATCHREL_RELOADn_L_SHIFT          (0U)
N#define SCT_SCTMATCHREL_RELOADn_L(x)             (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCHREL_RELOADn_L_SHIFT)) & SCT_SCTMATCHREL_RELOADn_L_MASK)
N#define SCT_SCTMATCHREL_RELOADn_H_MASK           (0xFFFF0000U)
N#define SCT_SCTMATCHREL_RELOADn_H_SHIFT          (16U)
N#define SCT_SCTMATCHREL_RELOADn_H(x)             (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCHREL_RELOADn_H_SHIFT)) & SCT_SCTMATCHREL_RELOADn_H_MASK)
N
N/* The count of SCT_SCTMATCHREL */
N#define SCT_SCTMATCHREL_COUNT                    (10U)
N
N/*! @name EVENT_STATE - SCT event state register 0 */
N#define SCT_EVENT_STATE_STATEMSKn_MASK           (0xFFFFU)
N#define SCT_EVENT_STATE_STATEMSKn_SHIFT          (0U)
N#define SCT_EVENT_STATE_STATEMSKn(x)             (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_STATE_STATEMSKn_SHIFT)) & SCT_EVENT_STATE_STATEMSKn_MASK)
N
N/* The count of SCT_EVENT_STATE */
N#define SCT_EVENT_STATE_COUNT                    (10U)
N
N/*! @name EVENT_CTRL - SCT event control register 0 */
N#define SCT_EVENT_CTRL_MATCHSEL_MASK             (0xFU)
N#define SCT_EVENT_CTRL_MATCHSEL_SHIFT            (0U)
N#define SCT_EVENT_CTRL_MATCHSEL(x)               (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_MATCHSEL_SHIFT)) & SCT_EVENT_CTRL_MATCHSEL_MASK)
N#define SCT_EVENT_CTRL_HEVENT_MASK               (0x10U)
N#define SCT_EVENT_CTRL_HEVENT_SHIFT              (4U)
N#define SCT_EVENT_CTRL_HEVENT(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_HEVENT_SHIFT)) & SCT_EVENT_CTRL_HEVENT_MASK)
N#define SCT_EVENT_CTRL_OUTSEL_MASK               (0x20U)
N#define SCT_EVENT_CTRL_OUTSEL_SHIFT              (5U)
N#define SCT_EVENT_CTRL_OUTSEL(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_OUTSEL_SHIFT)) & SCT_EVENT_CTRL_OUTSEL_MASK)
N#define SCT_EVENT_CTRL_IOSEL_MASK                (0x3C0U)
N#define SCT_EVENT_CTRL_IOSEL_SHIFT               (6U)
N#define SCT_EVENT_CTRL_IOSEL(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_IOSEL_SHIFT)) & SCT_EVENT_CTRL_IOSEL_MASK)
N#define SCT_EVENT_CTRL_IOCOND_MASK               (0xC00U)
N#define SCT_EVENT_CTRL_IOCOND_SHIFT              (10U)
N#define SCT_EVENT_CTRL_IOCOND(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_IOCOND_SHIFT)) & SCT_EVENT_CTRL_IOCOND_MASK)
N#define SCT_EVENT_CTRL_COMBMODE_MASK             (0x3000U)
N#define SCT_EVENT_CTRL_COMBMODE_SHIFT            (12U)
N#define SCT_EVENT_CTRL_COMBMODE(x)               (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_COMBMODE_SHIFT)) & SCT_EVENT_CTRL_COMBMODE_MASK)
N#define SCT_EVENT_CTRL_STATELD_MASK              (0x4000U)
N#define SCT_EVENT_CTRL_STATELD_SHIFT             (14U)
N#define SCT_EVENT_CTRL_STATELD(x)                (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_STATELD_SHIFT)) & SCT_EVENT_CTRL_STATELD_MASK)
N#define SCT_EVENT_CTRL_STATEV_MASK               (0xF8000U)
N#define SCT_EVENT_CTRL_STATEV_SHIFT              (15U)
N#define SCT_EVENT_CTRL_STATEV(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_STATEV_SHIFT)) & SCT_EVENT_CTRL_STATEV_MASK)
N#define SCT_EVENT_CTRL_MATCHMEM_MASK             (0x100000U)
N#define SCT_EVENT_CTRL_MATCHMEM_SHIFT            (20U)
N#define SCT_EVENT_CTRL_MATCHMEM(x)               (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_MATCHMEM_SHIFT)) & SCT_EVENT_CTRL_MATCHMEM_MASK)
N#define SCT_EVENT_CTRL_DIRECTION_MASK            (0x600000U)
N#define SCT_EVENT_CTRL_DIRECTION_SHIFT           (21U)
N#define SCT_EVENT_CTRL_DIRECTION(x)              (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_DIRECTION_SHIFT)) & SCT_EVENT_CTRL_DIRECTION_MASK)
N
N/* The count of SCT_EVENT_CTRL */
N#define SCT_EVENT_CTRL_COUNT                     (10U)
N
N/*! @name OUT_SET - SCT output 0 set register */
N#define SCT_OUT_SET_SET_MASK                     (0xFFFFU)
N#define SCT_OUT_SET_SET_SHIFT                    (0U)
N#define SCT_OUT_SET_SET(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_OUT_SET_SET_SHIFT)) & SCT_OUT_SET_SET_MASK)
N
N/* The count of SCT_OUT_SET */
N#define SCT_OUT_SET_COUNT                        (10U)
N
N/*! @name OUT_CLR - SCT output 0 clear register */
N#define SCT_OUT_CLR_CLR_MASK                     (0xFFFFU)
N#define SCT_OUT_CLR_CLR_SHIFT                    (0U)
N#define SCT_OUT_CLR_CLR(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_OUT_CLR_CLR_SHIFT)) & SCT_OUT_CLR_CLR_MASK)
N
N/* The count of SCT_OUT_CLR */
N#define SCT_OUT_CLR_COUNT                        (10U)
N
N
N/*!
N * @}
N */ /* end of group SCT_Register_Masks */
N
N
N/* SCT - Peripheral instance base addresses */
N/** Peripheral SCT0 base address */
N#define SCT0_BASE                                (0x40085000u)
N/** Peripheral SCT0 base pointer */
N#define SCT0                                     ((SCT_Type *)SCT0_BASE)
N/** Array initializer of SCT peripheral base addresses */
N#define SCT_BASE_ADDRS                           { SCT0_BASE }
N/** Array initializer of SCT peripheral base pointers */
N#define SCT_BASE_PTRS                            { SCT0 }
N/** Interrupt vectors for the SCT peripheral type */
N#define SCT_IRQS                                 { SCT0_IRQn }
N
N/*!
N * @}
N */ /* end of group SCT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SDIF Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SDIF_Peripheral_Access_Layer SDIF Peripheral Access Layer
N * @{
N */
N
N/** SDIF - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< Control register, offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t PWREN;                             /**< Power Enable register, offset: 0x4 */
X  volatile uint32_t PWREN;                              
N  __IO uint32_t CLKDIV;                            /**< Clock Divider register, offset: 0x8 */
X  volatile uint32_t CLKDIV;                             
N       uint8_t RESERVED_0[4];
N  __IO uint32_t CLKENA;                            /**< Clock Enable register, offset: 0x10 */
X  volatile uint32_t CLKENA;                             
N  __IO uint32_t TMOUT;                             /**< Time-out register, offset: 0x14 */
X  volatile uint32_t TMOUT;                              
N  __IO uint32_t CTYPE;                             /**< Card Type register, offset: 0x18 */
X  volatile uint32_t CTYPE;                              
N  __IO uint32_t BLKSIZ;                            /**< Block Size register, offset: 0x1C */
X  volatile uint32_t BLKSIZ;                             
N  __IO uint32_t BYTCNT;                            /**< Byte Count register, offset: 0x20 */
X  volatile uint32_t BYTCNT;                             
N  __IO uint32_t INTMASK;                           /**< Interrupt Mask register, offset: 0x24 */
X  volatile uint32_t INTMASK;                            
N  __IO uint32_t CMDARG;                            /**< Command Argument register, offset: 0x28 */
X  volatile uint32_t CMDARG;                             
N  __IO uint32_t CMD;                               /**< Command register, offset: 0x2C */
X  volatile uint32_t CMD;                                
N  __IO uint32_t RESP[4];                           /**< Response register, array offset: 0x30, array step: 0x4 */
X  volatile uint32_t RESP[4];                            
N  __IO uint32_t MINTSTS;                           /**< Masked Interrupt Status register, offset: 0x40 */
X  volatile uint32_t MINTSTS;                            
N  __IO uint32_t RINTSTS;                           /**< Raw Interrupt Status register, offset: 0x44 */
X  volatile uint32_t RINTSTS;                            
N  __IO uint32_t STATUS;                            /**< Status register, offset: 0x48 */
X  volatile uint32_t STATUS;                             
N  __IO uint32_t FIFOTH;                            /**< FIFO Threshold Watermark register, offset: 0x4C */
X  volatile uint32_t FIFOTH;                             
N  __IO uint32_t CDETECT;                           /**< Card Detect register, offset: 0x50 */
X  volatile uint32_t CDETECT;                            
N  __IO uint32_t WRTPRT;                            /**< Write Protect register, offset: 0x54 */
X  volatile uint32_t WRTPRT;                             
N       uint8_t RESERVED_1[4];
N  __IO uint32_t TCBCNT;                            /**< Transferred CIU Card Byte Count register, offset: 0x5C */
X  volatile uint32_t TCBCNT;                             
N  __IO uint32_t TBBCNT;                            /**< Transferred Host to BIU-FIFO Byte Count register, offset: 0x60 */
X  volatile uint32_t TBBCNT;                             
N  __IO uint32_t DEBNCE;                            /**< Debounce Count register, offset: 0x64 */
X  volatile uint32_t DEBNCE;                             
N       uint8_t RESERVED_2[16];
N  __IO uint32_t RST_N;                             /**< Hardware Reset, offset: 0x78 */
X  volatile uint32_t RST_N;                              
N       uint8_t RESERVED_3[4];
N  __IO uint32_t BMOD;                              /**< Bus Mode register, offset: 0x80 */
X  volatile uint32_t BMOD;                               
N  __IO uint32_t PLDMND;                            /**< Poll Demand register, offset: 0x84 */
X  volatile uint32_t PLDMND;                             
N  __IO uint32_t DBADDR;                            /**< Descriptor List Base Address register, offset: 0x88 */
X  volatile uint32_t DBADDR;                             
N  __IO uint32_t IDSTS;                             /**< Internal DMAC Status register, offset: 0x8C */
X  volatile uint32_t IDSTS;                              
N  __IO uint32_t IDINTEN;                           /**< Internal DMAC Interrupt Enable register, offset: 0x90 */
X  volatile uint32_t IDINTEN;                            
N  __IO uint32_t DSCADDR;                           /**< Current Host Descriptor Address register, offset: 0x94 */
X  volatile uint32_t DSCADDR;                            
N  __IO uint32_t BUFADDR;                           /**< Current Buffer Descriptor Address register, offset: 0x98 */
X  volatile uint32_t BUFADDR;                            
N       uint8_t RESERVED_4[100];
N  __IO uint32_t CARDTHRCTL;                        /**< Card Threshold Control, offset: 0x100 */
X  volatile uint32_t CARDTHRCTL;                         
N  __IO uint32_t BACKENDPWR;                        /**< Power control, offset: 0x104 */
X  volatile uint32_t BACKENDPWR;                         
N       uint8_t RESERVED_5[248];
N  __IO uint32_t FIFO[64];                          /**< SDIF FIFO, array offset: 0x200, array step: 0x4 */
X  volatile uint32_t FIFO[64];                           
N} SDIF_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SDIF Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SDIF_Register_Masks SDIF Register Masks
N * @{
N */
N
N/*! @name CTRL - Control register */
N#define SDIF_CTRL_CONTROLLER_RESET_MASK          (0x1U)
N#define SDIF_CTRL_CONTROLLER_RESET_SHIFT         (0U)
N#define SDIF_CTRL_CONTROLLER_RESET(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_CONTROLLER_RESET_SHIFT)) & SDIF_CTRL_CONTROLLER_RESET_MASK)
N#define SDIF_CTRL_FIFO_RESET_MASK                (0x2U)
N#define SDIF_CTRL_FIFO_RESET_SHIFT               (1U)
N#define SDIF_CTRL_FIFO_RESET(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_FIFO_RESET_SHIFT)) & SDIF_CTRL_FIFO_RESET_MASK)
N#define SDIF_CTRL_DMA_RESET_MASK                 (0x4U)
N#define SDIF_CTRL_DMA_RESET_SHIFT                (2U)
N#define SDIF_CTRL_DMA_RESET(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_DMA_RESET_SHIFT)) & SDIF_CTRL_DMA_RESET_MASK)
N#define SDIF_CTRL_INT_ENABLE_MASK                (0x10U)
N#define SDIF_CTRL_INT_ENABLE_SHIFT               (4U)
N#define SDIF_CTRL_INT_ENABLE(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_INT_ENABLE_SHIFT)) & SDIF_CTRL_INT_ENABLE_MASK)
N#define SDIF_CTRL_READ_WAIT_MASK                 (0x40U)
N#define SDIF_CTRL_READ_WAIT_SHIFT                (6U)
N#define SDIF_CTRL_READ_WAIT(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_READ_WAIT_SHIFT)) & SDIF_CTRL_READ_WAIT_MASK)
N#define SDIF_CTRL_SEND_IRQ_RESPONSE_MASK         (0x80U)
N#define SDIF_CTRL_SEND_IRQ_RESPONSE_SHIFT        (7U)
N#define SDIF_CTRL_SEND_IRQ_RESPONSE(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_SEND_IRQ_RESPONSE_SHIFT)) & SDIF_CTRL_SEND_IRQ_RESPONSE_MASK)
N#define SDIF_CTRL_ABORT_READ_DATA_MASK           (0x100U)
N#define SDIF_CTRL_ABORT_READ_DATA_SHIFT          (8U)
N#define SDIF_CTRL_ABORT_READ_DATA(x)             (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_ABORT_READ_DATA_SHIFT)) & SDIF_CTRL_ABORT_READ_DATA_MASK)
N#define SDIF_CTRL_SEND_CCSD_MASK                 (0x200U)
N#define SDIF_CTRL_SEND_CCSD_SHIFT                (9U)
N#define SDIF_CTRL_SEND_CCSD(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_SEND_CCSD_SHIFT)) & SDIF_CTRL_SEND_CCSD_MASK)
N#define SDIF_CTRL_SEND_AUTO_STOP_CCSD_MASK       (0x400U)
N#define SDIF_CTRL_SEND_AUTO_STOP_CCSD_SHIFT      (10U)
N#define SDIF_CTRL_SEND_AUTO_STOP_CCSD(x)         (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_SEND_AUTO_STOP_CCSD_SHIFT)) & SDIF_CTRL_SEND_AUTO_STOP_CCSD_MASK)
N#define SDIF_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_MASK (0x800U)
N#define SDIF_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_SHIFT (11U)
N#define SDIF_CTRL_CEATA_DEVICE_INTERRUPT_STATUS(x) (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_SHIFT)) & SDIF_CTRL_CEATA_DEVICE_INTERRUPT_STATUS_MASK)
N#define SDIF_CTRL_CARD_VOLTAGE_A0_MASK           (0x10000U)
N#define SDIF_CTRL_CARD_VOLTAGE_A0_SHIFT          (16U)
N#define SDIF_CTRL_CARD_VOLTAGE_A0(x)             (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_CARD_VOLTAGE_A0_SHIFT)) & SDIF_CTRL_CARD_VOLTAGE_A0_MASK)
N#define SDIF_CTRL_CARD_VOLTAGE_A1_MASK           (0x20000U)
N#define SDIF_CTRL_CARD_VOLTAGE_A1_SHIFT          (17U)
N#define SDIF_CTRL_CARD_VOLTAGE_A1(x)             (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_CARD_VOLTAGE_A1_SHIFT)) & SDIF_CTRL_CARD_VOLTAGE_A1_MASK)
N#define SDIF_CTRL_CARD_VOLTAGE_A2_MASK           (0x40000U)
N#define SDIF_CTRL_CARD_VOLTAGE_A2_SHIFT          (18U)
N#define SDIF_CTRL_CARD_VOLTAGE_A2(x)             (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_CARD_VOLTAGE_A2_SHIFT)) & SDIF_CTRL_CARD_VOLTAGE_A2_MASK)
N#define SDIF_CTRL_USE_INTERNAL_DMAC_MASK         (0x2000000U)
N#define SDIF_CTRL_USE_INTERNAL_DMAC_SHIFT        (25U)
N#define SDIF_CTRL_USE_INTERNAL_DMAC(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_CTRL_USE_INTERNAL_DMAC_SHIFT)) & SDIF_CTRL_USE_INTERNAL_DMAC_MASK)
N
N/*! @name PWREN - Power Enable register */
N#define SDIF_PWREN_POWER_ENABLE_MASK             (0x1U)
N#define SDIF_PWREN_POWER_ENABLE_SHIFT            (0U)
N#define SDIF_PWREN_POWER_ENABLE(x)               (((uint32_t)(((uint32_t)(x)) << SDIF_PWREN_POWER_ENABLE_SHIFT)) & SDIF_PWREN_POWER_ENABLE_MASK)
N
N/*! @name CLKDIV - Clock Divider register */
N#define SDIF_CLKDIV_CLK_DIVIDER0_MASK            (0xFFU)
N#define SDIF_CLKDIV_CLK_DIVIDER0_SHIFT           (0U)
N#define SDIF_CLKDIV_CLK_DIVIDER0(x)              (((uint32_t)(((uint32_t)(x)) << SDIF_CLKDIV_CLK_DIVIDER0_SHIFT)) & SDIF_CLKDIV_CLK_DIVIDER0_MASK)
N
N/*! @name CLKENA - Clock Enable register */
N#define SDIF_CLKENA_CCLK_ENABLE_MASK             (0x1U)
N#define SDIF_CLKENA_CCLK_ENABLE_SHIFT            (0U)
N#define SDIF_CLKENA_CCLK_ENABLE(x)               (((uint32_t)(((uint32_t)(x)) << SDIF_CLKENA_CCLK_ENABLE_SHIFT)) & SDIF_CLKENA_CCLK_ENABLE_MASK)
N#define SDIF_CLKENA_CCLK_LOW_POWER_MASK          (0x10000U)
N#define SDIF_CLKENA_CCLK_LOW_POWER_SHIFT         (16U)
N#define SDIF_CLKENA_CCLK_LOW_POWER(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_CLKENA_CCLK_LOW_POWER_SHIFT)) & SDIF_CLKENA_CCLK_LOW_POWER_MASK)
N
N/*! @name TMOUT - Time-out register */
N#define SDIF_TMOUT_RESPONSE_TIMEOUT_MASK         (0xFFU)
N#define SDIF_TMOUT_RESPONSE_TIMEOUT_SHIFT        (0U)
N#define SDIF_TMOUT_RESPONSE_TIMEOUT(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_TMOUT_RESPONSE_TIMEOUT_SHIFT)) & SDIF_TMOUT_RESPONSE_TIMEOUT_MASK)
N#define SDIF_TMOUT_DATA_TIMEOUT_MASK             (0xFFFFFF00U)
N#define SDIF_TMOUT_DATA_TIMEOUT_SHIFT            (8U)
N#define SDIF_TMOUT_DATA_TIMEOUT(x)               (((uint32_t)(((uint32_t)(x)) << SDIF_TMOUT_DATA_TIMEOUT_SHIFT)) & SDIF_TMOUT_DATA_TIMEOUT_MASK)
N
N/*! @name CTYPE - Card Type register */
N#define SDIF_CTYPE_CARD_WIDTH0_MASK              (0x1U)
N#define SDIF_CTYPE_CARD_WIDTH0_SHIFT             (0U)
N#define SDIF_CTYPE_CARD_WIDTH0(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_CTYPE_CARD_WIDTH0_SHIFT)) & SDIF_CTYPE_CARD_WIDTH0_MASK)
N#define SDIF_CTYPE_CARD_WIDTH1_MASK              (0x10000U)
N#define SDIF_CTYPE_CARD_WIDTH1_SHIFT             (16U)
N#define SDIF_CTYPE_CARD_WIDTH1(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_CTYPE_CARD_WIDTH1_SHIFT)) & SDIF_CTYPE_CARD_WIDTH1_MASK)
N
N/*! @name BLKSIZ - Block Size register */
N#define SDIF_BLKSIZ_BLOCK_SIZE_MASK              (0xFFFFU)
N#define SDIF_BLKSIZ_BLOCK_SIZE_SHIFT             (0U)
N#define SDIF_BLKSIZ_BLOCK_SIZE(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_BLKSIZ_BLOCK_SIZE_SHIFT)) & SDIF_BLKSIZ_BLOCK_SIZE_MASK)
N
N/*! @name BYTCNT - Byte Count register */
N#define SDIF_BYTCNT_BYTE_COUNT_MASK              (0xFFFFFFFFU)
N#define SDIF_BYTCNT_BYTE_COUNT_SHIFT             (0U)
N#define SDIF_BYTCNT_BYTE_COUNT(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_BYTCNT_BYTE_COUNT_SHIFT)) & SDIF_BYTCNT_BYTE_COUNT_MASK)
N
N/*! @name INTMASK - Interrupt Mask register */
N#define SDIF_INTMASK_CDET_MASK                   (0x1U)
N#define SDIF_INTMASK_CDET_SHIFT                  (0U)
N#define SDIF_INTMASK_CDET(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_CDET_SHIFT)) & SDIF_INTMASK_CDET_MASK)
N#define SDIF_INTMASK_RE_MASK                     (0x2U)
N#define SDIF_INTMASK_RE_SHIFT                    (1U)
N#define SDIF_INTMASK_RE(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_RE_SHIFT)) & SDIF_INTMASK_RE_MASK)
N#define SDIF_INTMASK_CDONE_MASK                  (0x4U)
N#define SDIF_INTMASK_CDONE_SHIFT                 (2U)
N#define SDIF_INTMASK_CDONE(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_CDONE_SHIFT)) & SDIF_INTMASK_CDONE_MASK)
N#define SDIF_INTMASK_DTO_MASK                    (0x8U)
N#define SDIF_INTMASK_DTO_SHIFT                   (3U)
N#define SDIF_INTMASK_DTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_DTO_SHIFT)) & SDIF_INTMASK_DTO_MASK)
N#define SDIF_INTMASK_TXDR_MASK                   (0x10U)
N#define SDIF_INTMASK_TXDR_SHIFT                  (4U)
N#define SDIF_INTMASK_TXDR(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_TXDR_SHIFT)) & SDIF_INTMASK_TXDR_MASK)
N#define SDIF_INTMASK_RXDR_MASK                   (0x20U)
N#define SDIF_INTMASK_RXDR_SHIFT                  (5U)
N#define SDIF_INTMASK_RXDR(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_RXDR_SHIFT)) & SDIF_INTMASK_RXDR_MASK)
N#define SDIF_INTMASK_RCRC_MASK                   (0x40U)
N#define SDIF_INTMASK_RCRC_SHIFT                  (6U)
N#define SDIF_INTMASK_RCRC(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_RCRC_SHIFT)) & SDIF_INTMASK_RCRC_MASK)
N#define SDIF_INTMASK_DCRC_MASK                   (0x80U)
N#define SDIF_INTMASK_DCRC_SHIFT                  (7U)
N#define SDIF_INTMASK_DCRC(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_DCRC_SHIFT)) & SDIF_INTMASK_DCRC_MASK)
N#define SDIF_INTMASK_RTO_MASK                    (0x100U)
N#define SDIF_INTMASK_RTO_SHIFT                   (8U)
N#define SDIF_INTMASK_RTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_RTO_SHIFT)) & SDIF_INTMASK_RTO_MASK)
N#define SDIF_INTMASK_DRTO_MASK                   (0x200U)
N#define SDIF_INTMASK_DRTO_SHIFT                  (9U)
N#define SDIF_INTMASK_DRTO(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_DRTO_SHIFT)) & SDIF_INTMASK_DRTO_MASK)
N#define SDIF_INTMASK_HTO_MASK                    (0x400U)
N#define SDIF_INTMASK_HTO_SHIFT                   (10U)
N#define SDIF_INTMASK_HTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_HTO_SHIFT)) & SDIF_INTMASK_HTO_MASK)
N#define SDIF_INTMASK_FRUN_MASK                   (0x800U)
N#define SDIF_INTMASK_FRUN_SHIFT                  (11U)
N#define SDIF_INTMASK_FRUN(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_FRUN_SHIFT)) & SDIF_INTMASK_FRUN_MASK)
N#define SDIF_INTMASK_HLE_MASK                    (0x1000U)
N#define SDIF_INTMASK_HLE_SHIFT                   (12U)
N#define SDIF_INTMASK_HLE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_HLE_SHIFT)) & SDIF_INTMASK_HLE_MASK)
N#define SDIF_INTMASK_SBE_MASK                    (0x2000U)
N#define SDIF_INTMASK_SBE_SHIFT                   (13U)
N#define SDIF_INTMASK_SBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_SBE_SHIFT)) & SDIF_INTMASK_SBE_MASK)
N#define SDIF_INTMASK_ACD_MASK                    (0x4000U)
N#define SDIF_INTMASK_ACD_SHIFT                   (14U)
N#define SDIF_INTMASK_ACD(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_ACD_SHIFT)) & SDIF_INTMASK_ACD_MASK)
N#define SDIF_INTMASK_EBE_MASK                    (0x8000U)
N#define SDIF_INTMASK_EBE_SHIFT                   (15U)
N#define SDIF_INTMASK_EBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_EBE_SHIFT)) & SDIF_INTMASK_EBE_MASK)
N#define SDIF_INTMASK_SDIO_INT_MASK_MASK          (0x10000U)
N#define SDIF_INTMASK_SDIO_INT_MASK_SHIFT         (16U)
N#define SDIF_INTMASK_SDIO_INT_MASK(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_INTMASK_SDIO_INT_MASK_SHIFT)) & SDIF_INTMASK_SDIO_INT_MASK_MASK)
N
N/*! @name CMDARG - Command Argument register */
N#define SDIF_CMDARG_CMD_ARG_MASK                 (0xFFFFFFFFU)
N#define SDIF_CMDARG_CMD_ARG_SHIFT                (0U)
N#define SDIF_CMDARG_CMD_ARG(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_CMDARG_CMD_ARG_SHIFT)) & SDIF_CMDARG_CMD_ARG_MASK)
N
N/*! @name CMD - Command register */
N#define SDIF_CMD_CMD_INDEX_MASK                  (0x3FU)
N#define SDIF_CMD_CMD_INDEX_SHIFT                 (0U)
N#define SDIF_CMD_CMD_INDEX(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_CMD_INDEX_SHIFT)) & SDIF_CMD_CMD_INDEX_MASK)
N#define SDIF_CMD_RESPONSE_EXPECT_MASK            (0x40U)
N#define SDIF_CMD_RESPONSE_EXPECT_SHIFT           (6U)
N#define SDIF_CMD_RESPONSE_EXPECT(x)              (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_RESPONSE_EXPECT_SHIFT)) & SDIF_CMD_RESPONSE_EXPECT_MASK)
N#define SDIF_CMD_RESPONSE_LENGTH_MASK            (0x80U)
N#define SDIF_CMD_RESPONSE_LENGTH_SHIFT           (7U)
N#define SDIF_CMD_RESPONSE_LENGTH(x)              (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_RESPONSE_LENGTH_SHIFT)) & SDIF_CMD_RESPONSE_LENGTH_MASK)
N#define SDIF_CMD_CHECK_RESPONSE_CRC_MASK         (0x100U)
N#define SDIF_CMD_CHECK_RESPONSE_CRC_SHIFT        (8U)
N#define SDIF_CMD_CHECK_RESPONSE_CRC(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_CHECK_RESPONSE_CRC_SHIFT)) & SDIF_CMD_CHECK_RESPONSE_CRC_MASK)
N#define SDIF_CMD_DATA_EXPECTED_MASK              (0x200U)
N#define SDIF_CMD_DATA_EXPECTED_SHIFT             (9U)
N#define SDIF_CMD_DATA_EXPECTED(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_DATA_EXPECTED_SHIFT)) & SDIF_CMD_DATA_EXPECTED_MASK)
N#define SDIF_CMD_READ_WRITE_MASK                 (0x400U)
N#define SDIF_CMD_READ_WRITE_SHIFT                (10U)
N#define SDIF_CMD_READ_WRITE(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_READ_WRITE_SHIFT)) & SDIF_CMD_READ_WRITE_MASK)
N#define SDIF_CMD_TRANSFER_MODE_MASK              (0x800U)
N#define SDIF_CMD_TRANSFER_MODE_SHIFT             (11U)
N#define SDIF_CMD_TRANSFER_MODE(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_TRANSFER_MODE_SHIFT)) & SDIF_CMD_TRANSFER_MODE_MASK)
N#define SDIF_CMD_SEND_AUTO_STOP_MASK             (0x1000U)
N#define SDIF_CMD_SEND_AUTO_STOP_SHIFT            (12U)
N#define SDIF_CMD_SEND_AUTO_STOP(x)               (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_SEND_AUTO_STOP_SHIFT)) & SDIF_CMD_SEND_AUTO_STOP_MASK)
N#define SDIF_CMD_WAIT_PRVDATA_COMPLETE_MASK      (0x2000U)
N#define SDIF_CMD_WAIT_PRVDATA_COMPLETE_SHIFT     (13U)
N#define SDIF_CMD_WAIT_PRVDATA_COMPLETE(x)        (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_WAIT_PRVDATA_COMPLETE_SHIFT)) & SDIF_CMD_WAIT_PRVDATA_COMPLETE_MASK)
N#define SDIF_CMD_STOP_ABORT_CMD_MASK             (0x4000U)
N#define SDIF_CMD_STOP_ABORT_CMD_SHIFT            (14U)
N#define SDIF_CMD_STOP_ABORT_CMD(x)               (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_STOP_ABORT_CMD_SHIFT)) & SDIF_CMD_STOP_ABORT_CMD_MASK)
N#define SDIF_CMD_SEND_INITIALIZATION_MASK        (0x8000U)
N#define SDIF_CMD_SEND_INITIALIZATION_SHIFT       (15U)
N#define SDIF_CMD_SEND_INITIALIZATION(x)          (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_SEND_INITIALIZATION_SHIFT)) & SDIF_CMD_SEND_INITIALIZATION_MASK)
N#define SDIF_CMD_UPDATE_CLOCK_REGISTERS_ONLY_MASK (0x200000U)
N#define SDIF_CMD_UPDATE_CLOCK_REGISTERS_ONLY_SHIFT (21U)
N#define SDIF_CMD_UPDATE_CLOCK_REGISTERS_ONLY(x)  (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_UPDATE_CLOCK_REGISTERS_ONLY_SHIFT)) & SDIF_CMD_UPDATE_CLOCK_REGISTERS_ONLY_MASK)
N#define SDIF_CMD_READ_CEATA_DEVICE_MASK          (0x400000U)
N#define SDIF_CMD_READ_CEATA_DEVICE_SHIFT         (22U)
N#define SDIF_CMD_READ_CEATA_DEVICE(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_READ_CEATA_DEVICE_SHIFT)) & SDIF_CMD_READ_CEATA_DEVICE_MASK)
N#define SDIF_CMD_CCS_EXPECTED_MASK               (0x800000U)
N#define SDIF_CMD_CCS_EXPECTED_SHIFT              (23U)
N#define SDIF_CMD_CCS_EXPECTED(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_CCS_EXPECTED_SHIFT)) & SDIF_CMD_CCS_EXPECTED_MASK)
N#define SDIF_CMD_ENABLE_BOOT_MASK                (0x1000000U)
N#define SDIF_CMD_ENABLE_BOOT_SHIFT               (24U)
N#define SDIF_CMD_ENABLE_BOOT(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_ENABLE_BOOT_SHIFT)) & SDIF_CMD_ENABLE_BOOT_MASK)
N#define SDIF_CMD_EXPECT_BOOT_ACK_MASK            (0x2000000U)
N#define SDIF_CMD_EXPECT_BOOT_ACK_SHIFT           (25U)
N#define SDIF_CMD_EXPECT_BOOT_ACK(x)              (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_EXPECT_BOOT_ACK_SHIFT)) & SDIF_CMD_EXPECT_BOOT_ACK_MASK)
N#define SDIF_CMD_DISABLE_BOOT_MASK               (0x4000000U)
N#define SDIF_CMD_DISABLE_BOOT_SHIFT              (26U)
N#define SDIF_CMD_DISABLE_BOOT(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_DISABLE_BOOT_SHIFT)) & SDIF_CMD_DISABLE_BOOT_MASK)
N#define SDIF_CMD_BOOT_MODE_MASK                  (0x8000000U)
N#define SDIF_CMD_BOOT_MODE_SHIFT                 (27U)
N#define SDIF_CMD_BOOT_MODE(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_BOOT_MODE_SHIFT)) & SDIF_CMD_BOOT_MODE_MASK)
N#define SDIF_CMD_VOLT_SWITCH_MASK                (0x10000000U)
N#define SDIF_CMD_VOLT_SWITCH_SHIFT               (28U)
N#define SDIF_CMD_VOLT_SWITCH(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_VOLT_SWITCH_SHIFT)) & SDIF_CMD_VOLT_SWITCH_MASK)
N#define SDIF_CMD_USE_HOLD_REG_MASK               (0x20000000U)
N#define SDIF_CMD_USE_HOLD_REG_SHIFT              (29U)
N#define SDIF_CMD_USE_HOLD_REG(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_USE_HOLD_REG_SHIFT)) & SDIF_CMD_USE_HOLD_REG_MASK)
N#define SDIF_CMD_START_CMD_MASK                  (0x80000000U)
N#define SDIF_CMD_START_CMD_SHIFT                 (31U)
N#define SDIF_CMD_START_CMD(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_CMD_START_CMD_SHIFT)) & SDIF_CMD_START_CMD_MASK)
N
N/*! @name RESP - Response register */
N#define SDIF_RESP_RESPONSE_MASK                  (0xFFFFFFFFU)
N#define SDIF_RESP_RESPONSE_SHIFT                 (0U)
N#define SDIF_RESP_RESPONSE(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_RESP_RESPONSE_SHIFT)) & SDIF_RESP_RESPONSE_MASK)
N
N/* The count of SDIF_RESP */
N#define SDIF_RESP_COUNT                          (4U)
N
N/*! @name MINTSTS - Masked Interrupt Status register */
N#define SDIF_MINTSTS_CDET_MASK                   (0x1U)
N#define SDIF_MINTSTS_CDET_SHIFT                  (0U)
N#define SDIF_MINTSTS_CDET(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_CDET_SHIFT)) & SDIF_MINTSTS_CDET_MASK)
N#define SDIF_MINTSTS_RE_MASK                     (0x2U)
N#define SDIF_MINTSTS_RE_SHIFT                    (1U)
N#define SDIF_MINTSTS_RE(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_RE_SHIFT)) & SDIF_MINTSTS_RE_MASK)
N#define SDIF_MINTSTS_CDONE_MASK                  (0x4U)
N#define SDIF_MINTSTS_CDONE_SHIFT                 (2U)
N#define SDIF_MINTSTS_CDONE(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_CDONE_SHIFT)) & SDIF_MINTSTS_CDONE_MASK)
N#define SDIF_MINTSTS_DTO_MASK                    (0x8U)
N#define SDIF_MINTSTS_DTO_SHIFT                   (3U)
N#define SDIF_MINTSTS_DTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_DTO_SHIFT)) & SDIF_MINTSTS_DTO_MASK)
N#define SDIF_MINTSTS_TXDR_MASK                   (0x10U)
N#define SDIF_MINTSTS_TXDR_SHIFT                  (4U)
N#define SDIF_MINTSTS_TXDR(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_TXDR_SHIFT)) & SDIF_MINTSTS_TXDR_MASK)
N#define SDIF_MINTSTS_RXDR_MASK                   (0x20U)
N#define SDIF_MINTSTS_RXDR_SHIFT                  (5U)
N#define SDIF_MINTSTS_RXDR(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_RXDR_SHIFT)) & SDIF_MINTSTS_RXDR_MASK)
N#define SDIF_MINTSTS_RCRC_MASK                   (0x40U)
N#define SDIF_MINTSTS_RCRC_SHIFT                  (6U)
N#define SDIF_MINTSTS_RCRC(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_RCRC_SHIFT)) & SDIF_MINTSTS_RCRC_MASK)
N#define SDIF_MINTSTS_DCRC_MASK                   (0x80U)
N#define SDIF_MINTSTS_DCRC_SHIFT                  (7U)
N#define SDIF_MINTSTS_DCRC(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_DCRC_SHIFT)) & SDIF_MINTSTS_DCRC_MASK)
N#define SDIF_MINTSTS_RTO_MASK                    (0x100U)
N#define SDIF_MINTSTS_RTO_SHIFT                   (8U)
N#define SDIF_MINTSTS_RTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_RTO_SHIFT)) & SDIF_MINTSTS_RTO_MASK)
N#define SDIF_MINTSTS_DRTO_MASK                   (0x200U)
N#define SDIF_MINTSTS_DRTO_SHIFT                  (9U)
N#define SDIF_MINTSTS_DRTO(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_DRTO_SHIFT)) & SDIF_MINTSTS_DRTO_MASK)
N#define SDIF_MINTSTS_HTO_MASK                    (0x400U)
N#define SDIF_MINTSTS_HTO_SHIFT                   (10U)
N#define SDIF_MINTSTS_HTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_HTO_SHIFT)) & SDIF_MINTSTS_HTO_MASK)
N#define SDIF_MINTSTS_FRUN_MASK                   (0x800U)
N#define SDIF_MINTSTS_FRUN_SHIFT                  (11U)
N#define SDIF_MINTSTS_FRUN(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_FRUN_SHIFT)) & SDIF_MINTSTS_FRUN_MASK)
N#define SDIF_MINTSTS_HLE_MASK                    (0x1000U)
N#define SDIF_MINTSTS_HLE_SHIFT                   (12U)
N#define SDIF_MINTSTS_HLE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_HLE_SHIFT)) & SDIF_MINTSTS_HLE_MASK)
N#define SDIF_MINTSTS_SBE_MASK                    (0x2000U)
N#define SDIF_MINTSTS_SBE_SHIFT                   (13U)
N#define SDIF_MINTSTS_SBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_SBE_SHIFT)) & SDIF_MINTSTS_SBE_MASK)
N#define SDIF_MINTSTS_ACD_MASK                    (0x4000U)
N#define SDIF_MINTSTS_ACD_SHIFT                   (14U)
N#define SDIF_MINTSTS_ACD(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_ACD_SHIFT)) & SDIF_MINTSTS_ACD_MASK)
N#define SDIF_MINTSTS_EBE_MASK                    (0x8000U)
N#define SDIF_MINTSTS_EBE_SHIFT                   (15U)
N#define SDIF_MINTSTS_EBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_EBE_SHIFT)) & SDIF_MINTSTS_EBE_MASK)
N#define SDIF_MINTSTS_SDIO_INTERRUPT_MASK         (0x10000U)
N#define SDIF_MINTSTS_SDIO_INTERRUPT_SHIFT        (16U)
N#define SDIF_MINTSTS_SDIO_INTERRUPT(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_MINTSTS_SDIO_INTERRUPT_SHIFT)) & SDIF_MINTSTS_SDIO_INTERRUPT_MASK)
N
N/*! @name RINTSTS - Raw Interrupt Status register */
N#define SDIF_RINTSTS_CDET_MASK                   (0x1U)
N#define SDIF_RINTSTS_CDET_SHIFT                  (0U)
N#define SDIF_RINTSTS_CDET(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_CDET_SHIFT)) & SDIF_RINTSTS_CDET_MASK)
N#define SDIF_RINTSTS_RE_MASK                     (0x2U)
N#define SDIF_RINTSTS_RE_SHIFT                    (1U)
N#define SDIF_RINTSTS_RE(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_RE_SHIFT)) & SDIF_RINTSTS_RE_MASK)
N#define SDIF_RINTSTS_CDONE_MASK                  (0x4U)
N#define SDIF_RINTSTS_CDONE_SHIFT                 (2U)
N#define SDIF_RINTSTS_CDONE(x)                    (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_CDONE_SHIFT)) & SDIF_RINTSTS_CDONE_MASK)
N#define SDIF_RINTSTS_DTO_MASK                    (0x8U)
N#define SDIF_RINTSTS_DTO_SHIFT                   (3U)
N#define SDIF_RINTSTS_DTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_DTO_SHIFT)) & SDIF_RINTSTS_DTO_MASK)
N#define SDIF_RINTSTS_TXDR_MASK                   (0x10U)
N#define SDIF_RINTSTS_TXDR_SHIFT                  (4U)
N#define SDIF_RINTSTS_TXDR(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_TXDR_SHIFT)) & SDIF_RINTSTS_TXDR_MASK)
N#define SDIF_RINTSTS_RXDR_MASK                   (0x20U)
N#define SDIF_RINTSTS_RXDR_SHIFT                  (5U)
N#define SDIF_RINTSTS_RXDR(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_RXDR_SHIFT)) & SDIF_RINTSTS_RXDR_MASK)
N#define SDIF_RINTSTS_RCRC_MASK                   (0x40U)
N#define SDIF_RINTSTS_RCRC_SHIFT                  (6U)
N#define SDIF_RINTSTS_RCRC(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_RCRC_SHIFT)) & SDIF_RINTSTS_RCRC_MASK)
N#define SDIF_RINTSTS_DCRC_MASK                   (0x80U)
N#define SDIF_RINTSTS_DCRC_SHIFT                  (7U)
N#define SDIF_RINTSTS_DCRC(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_DCRC_SHIFT)) & SDIF_RINTSTS_DCRC_MASK)
N#define SDIF_RINTSTS_RTO_BAR_MASK                (0x100U)
N#define SDIF_RINTSTS_RTO_BAR_SHIFT               (8U)
N#define SDIF_RINTSTS_RTO_BAR(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_RTO_BAR_SHIFT)) & SDIF_RINTSTS_RTO_BAR_MASK)
N#define SDIF_RINTSTS_DRTO_BDS_MASK               (0x200U)
N#define SDIF_RINTSTS_DRTO_BDS_SHIFT              (9U)
N#define SDIF_RINTSTS_DRTO_BDS(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_DRTO_BDS_SHIFT)) & SDIF_RINTSTS_DRTO_BDS_MASK)
N#define SDIF_RINTSTS_HTO_MASK                    (0x400U)
N#define SDIF_RINTSTS_HTO_SHIFT                   (10U)
N#define SDIF_RINTSTS_HTO(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_HTO_SHIFT)) & SDIF_RINTSTS_HTO_MASK)
N#define SDIF_RINTSTS_FRUN_MASK                   (0x800U)
N#define SDIF_RINTSTS_FRUN_SHIFT                  (11U)
N#define SDIF_RINTSTS_FRUN(x)                     (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_FRUN_SHIFT)) & SDIF_RINTSTS_FRUN_MASK)
N#define SDIF_RINTSTS_HLE_MASK                    (0x1000U)
N#define SDIF_RINTSTS_HLE_SHIFT                   (12U)
N#define SDIF_RINTSTS_HLE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_HLE_SHIFT)) & SDIF_RINTSTS_HLE_MASK)
N#define SDIF_RINTSTS_SBE_MASK                    (0x2000U)
N#define SDIF_RINTSTS_SBE_SHIFT                   (13U)
N#define SDIF_RINTSTS_SBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_SBE_SHIFT)) & SDIF_RINTSTS_SBE_MASK)
N#define SDIF_RINTSTS_ACD_MASK                    (0x4000U)
N#define SDIF_RINTSTS_ACD_SHIFT                   (14U)
N#define SDIF_RINTSTS_ACD(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_ACD_SHIFT)) & SDIF_RINTSTS_ACD_MASK)
N#define SDIF_RINTSTS_EBE_MASK                    (0x8000U)
N#define SDIF_RINTSTS_EBE_SHIFT                   (15U)
N#define SDIF_RINTSTS_EBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_EBE_SHIFT)) & SDIF_RINTSTS_EBE_MASK)
N#define SDIF_RINTSTS_SDIO_INTERRUPT_MASK         (0x10000U)
N#define SDIF_RINTSTS_SDIO_INTERRUPT_SHIFT        (16U)
N#define SDIF_RINTSTS_SDIO_INTERRUPT(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_RINTSTS_SDIO_INTERRUPT_SHIFT)) & SDIF_RINTSTS_SDIO_INTERRUPT_MASK)
N
N/*! @name STATUS - Status register */
N#define SDIF_STATUS_FIFO_RX_WATERMARK_MASK       (0x1U)
N#define SDIF_STATUS_FIFO_RX_WATERMARK_SHIFT      (0U)
N#define SDIF_STATUS_FIFO_RX_WATERMARK(x)         (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_FIFO_RX_WATERMARK_SHIFT)) & SDIF_STATUS_FIFO_RX_WATERMARK_MASK)
N#define SDIF_STATUS_FIFO_TX_WATERMARK_MASK       (0x2U)
N#define SDIF_STATUS_FIFO_TX_WATERMARK_SHIFT      (1U)
N#define SDIF_STATUS_FIFO_TX_WATERMARK(x)         (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_FIFO_TX_WATERMARK_SHIFT)) & SDIF_STATUS_FIFO_TX_WATERMARK_MASK)
N#define SDIF_STATUS_FIFO_EMPTY_MASK              (0x4U)
N#define SDIF_STATUS_FIFO_EMPTY_SHIFT             (2U)
N#define SDIF_STATUS_FIFO_EMPTY(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_FIFO_EMPTY_SHIFT)) & SDIF_STATUS_FIFO_EMPTY_MASK)
N#define SDIF_STATUS_FIFO_FULL_MASK               (0x8U)
N#define SDIF_STATUS_FIFO_FULL_SHIFT              (3U)
N#define SDIF_STATUS_FIFO_FULL(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_FIFO_FULL_SHIFT)) & SDIF_STATUS_FIFO_FULL_MASK)
N#define SDIF_STATUS_CMDFSMSTATES_MASK            (0xF0U)
N#define SDIF_STATUS_CMDFSMSTATES_SHIFT           (4U)
N#define SDIF_STATUS_CMDFSMSTATES(x)              (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_CMDFSMSTATES_SHIFT)) & SDIF_STATUS_CMDFSMSTATES_MASK)
N#define SDIF_STATUS_DATA_3_STATUS_MASK           (0x100U)
N#define SDIF_STATUS_DATA_3_STATUS_SHIFT          (8U)
N#define SDIF_STATUS_DATA_3_STATUS(x)             (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_DATA_3_STATUS_SHIFT)) & SDIF_STATUS_DATA_3_STATUS_MASK)
N#define SDIF_STATUS_DATA_BUSY_MASK               (0x200U)
N#define SDIF_STATUS_DATA_BUSY_SHIFT              (9U)
N#define SDIF_STATUS_DATA_BUSY(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_DATA_BUSY_SHIFT)) & SDIF_STATUS_DATA_BUSY_MASK)
N#define SDIF_STATUS_DATA_STATE_MC_BUSY_MASK      (0x400U)
N#define SDIF_STATUS_DATA_STATE_MC_BUSY_SHIFT     (10U)
N#define SDIF_STATUS_DATA_STATE_MC_BUSY(x)        (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_DATA_STATE_MC_BUSY_SHIFT)) & SDIF_STATUS_DATA_STATE_MC_BUSY_MASK)
N#define SDIF_STATUS_RESPONSE_INDEX_MASK          (0x1F800U)
N#define SDIF_STATUS_RESPONSE_INDEX_SHIFT         (11U)
N#define SDIF_STATUS_RESPONSE_INDEX(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_RESPONSE_INDEX_SHIFT)) & SDIF_STATUS_RESPONSE_INDEX_MASK)
N#define SDIF_STATUS_FIFO_COUNT_MASK              (0x3FFE0000U)
N#define SDIF_STATUS_FIFO_COUNT_SHIFT             (17U)
N#define SDIF_STATUS_FIFO_COUNT(x)                (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_FIFO_COUNT_SHIFT)) & SDIF_STATUS_FIFO_COUNT_MASK)
N#define SDIF_STATUS_DMA_ACK_MASK                 (0x40000000U)
N#define SDIF_STATUS_DMA_ACK_SHIFT                (30U)
N#define SDIF_STATUS_DMA_ACK(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_DMA_ACK_SHIFT)) & SDIF_STATUS_DMA_ACK_MASK)
N#define SDIF_STATUS_DMA_REQ_MASK                 (0x80000000U)
N#define SDIF_STATUS_DMA_REQ_SHIFT                (31U)
N#define SDIF_STATUS_DMA_REQ(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_STATUS_DMA_REQ_SHIFT)) & SDIF_STATUS_DMA_REQ_MASK)
N
N/*! @name FIFOTH - FIFO Threshold Watermark register */
N#define SDIF_FIFOTH_TX_WMARK_MASK                (0xFFFU)
N#define SDIF_FIFOTH_TX_WMARK_SHIFT               (0U)
N#define SDIF_FIFOTH_TX_WMARK(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_FIFOTH_TX_WMARK_SHIFT)) & SDIF_FIFOTH_TX_WMARK_MASK)
N#define SDIF_FIFOTH_RX_WMARK_MASK                (0xFFF0000U)
N#define SDIF_FIFOTH_RX_WMARK_SHIFT               (16U)
N#define SDIF_FIFOTH_RX_WMARK(x)                  (((uint32_t)(((uint32_t)(x)) << SDIF_FIFOTH_RX_WMARK_SHIFT)) & SDIF_FIFOTH_RX_WMARK_MASK)
N#define SDIF_FIFOTH_DMA_MTS_MASK                 (0x70000000U)
N#define SDIF_FIFOTH_DMA_MTS_SHIFT                (28U)
N#define SDIF_FIFOTH_DMA_MTS(x)                   (((uint32_t)(((uint32_t)(x)) << SDIF_FIFOTH_DMA_MTS_SHIFT)) & SDIF_FIFOTH_DMA_MTS_MASK)
N
N/*! @name CDETECT - Card Detect register */
N#define SDIF_CDETECT_CARD_DETECT_MASK            (0x1U)
N#define SDIF_CDETECT_CARD_DETECT_SHIFT           (0U)
N#define SDIF_CDETECT_CARD_DETECT(x)              (((uint32_t)(((uint32_t)(x)) << SDIF_CDETECT_CARD_DETECT_SHIFT)) & SDIF_CDETECT_CARD_DETECT_MASK)
N
N/*! @name WRTPRT - Write Protect register */
N#define SDIF_WRTPRT_WRITE_PROTECT_MASK           (0x1U)
N#define SDIF_WRTPRT_WRITE_PROTECT_SHIFT          (0U)
N#define SDIF_WRTPRT_WRITE_PROTECT(x)             (((uint32_t)(((uint32_t)(x)) << SDIF_WRTPRT_WRITE_PROTECT_SHIFT)) & SDIF_WRTPRT_WRITE_PROTECT_MASK)
N
N/*! @name TCBCNT - Transferred CIU Card Byte Count register */
N#define SDIF_TCBCNT_TRANS_CARD_BYTE_COUNT_MASK   (0xFFFFFFFFU)
N#define SDIF_TCBCNT_TRANS_CARD_BYTE_COUNT_SHIFT  (0U)
N#define SDIF_TCBCNT_TRANS_CARD_BYTE_COUNT(x)     (((uint32_t)(((uint32_t)(x)) << SDIF_TCBCNT_TRANS_CARD_BYTE_COUNT_SHIFT)) & SDIF_TCBCNT_TRANS_CARD_BYTE_COUNT_MASK)
N
N/*! @name TBBCNT - Transferred Host to BIU-FIFO Byte Count register */
N#define SDIF_TBBCNT_TRANS_FIFO_BYTE_COUNT_MASK   (0xFFFFFFFFU)
N#define SDIF_TBBCNT_TRANS_FIFO_BYTE_COUNT_SHIFT  (0U)
N#define SDIF_TBBCNT_TRANS_FIFO_BYTE_COUNT(x)     (((uint32_t)(((uint32_t)(x)) << SDIF_TBBCNT_TRANS_FIFO_BYTE_COUNT_SHIFT)) & SDIF_TBBCNT_TRANS_FIFO_BYTE_COUNT_MASK)
N
N/*! @name DEBNCE - Debounce Count register */
N#define SDIF_DEBNCE_DEBOUNCE_COUNT_MASK          (0xFFFFFFU)
N#define SDIF_DEBNCE_DEBOUNCE_COUNT_SHIFT         (0U)
N#define SDIF_DEBNCE_DEBOUNCE_COUNT(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_DEBNCE_DEBOUNCE_COUNT_SHIFT)) & SDIF_DEBNCE_DEBOUNCE_COUNT_MASK)
N
N/*! @name RST_N - Hardware Reset */
N#define SDIF_RST_N_CARD_RESET_MASK               (0x1U)
N#define SDIF_RST_N_CARD_RESET_SHIFT              (0U)
N#define SDIF_RST_N_CARD_RESET(x)                 (((uint32_t)(((uint32_t)(x)) << SDIF_RST_N_CARD_RESET_SHIFT)) & SDIF_RST_N_CARD_RESET_MASK)
N
N/*! @name BMOD - Bus Mode register */
N#define SDIF_BMOD_SWR_MASK                       (0x1U)
N#define SDIF_BMOD_SWR_SHIFT                      (0U)
N#define SDIF_BMOD_SWR(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_BMOD_SWR_SHIFT)) & SDIF_BMOD_SWR_MASK)
N#define SDIF_BMOD_FB_MASK                        (0x2U)
N#define SDIF_BMOD_FB_SHIFT                       (1U)
N#define SDIF_BMOD_FB(x)                          (((uint32_t)(((uint32_t)(x)) << SDIF_BMOD_FB_SHIFT)) & SDIF_BMOD_FB_MASK)
N#define SDIF_BMOD_DSL_MASK                       (0x7CU)
N#define SDIF_BMOD_DSL_SHIFT                      (2U)
N#define SDIF_BMOD_DSL(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_BMOD_DSL_SHIFT)) & SDIF_BMOD_DSL_MASK)
N#define SDIF_BMOD_DE_MASK                        (0x80U)
N#define SDIF_BMOD_DE_SHIFT                       (7U)
N#define SDIF_BMOD_DE(x)                          (((uint32_t)(((uint32_t)(x)) << SDIF_BMOD_DE_SHIFT)) & SDIF_BMOD_DE_MASK)
N#define SDIF_BMOD_PBL_MASK                       (0x700U)
N#define SDIF_BMOD_PBL_SHIFT                      (8U)
N#define SDIF_BMOD_PBL(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_BMOD_PBL_SHIFT)) & SDIF_BMOD_PBL_MASK)
N
N/*! @name PLDMND - Poll Demand register */
N#define SDIF_PLDMND_PD_MASK                      (0xFFFFFFFFU)
N#define SDIF_PLDMND_PD_SHIFT                     (0U)
N#define SDIF_PLDMND_PD(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_PLDMND_PD_SHIFT)) & SDIF_PLDMND_PD_MASK)
N
N/*! @name DBADDR - Descriptor List Base Address register */
N#define SDIF_DBADDR_SDL_MASK                     (0xFFFFFFFFU)
N#define SDIF_DBADDR_SDL_SHIFT                    (0U)
N#define SDIF_DBADDR_SDL(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_DBADDR_SDL_SHIFT)) & SDIF_DBADDR_SDL_MASK)
N
N/*! @name IDSTS - Internal DMAC Status register */
N#define SDIF_IDSTS_TI_MASK                       (0x1U)
N#define SDIF_IDSTS_TI_SHIFT                      (0U)
N#define SDIF_IDSTS_TI(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_TI_SHIFT)) & SDIF_IDSTS_TI_MASK)
N#define SDIF_IDSTS_RI_MASK                       (0x2U)
N#define SDIF_IDSTS_RI_SHIFT                      (1U)
N#define SDIF_IDSTS_RI(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_RI_SHIFT)) & SDIF_IDSTS_RI_MASK)
N#define SDIF_IDSTS_FBE_MASK                      (0x4U)
N#define SDIF_IDSTS_FBE_SHIFT                     (2U)
N#define SDIF_IDSTS_FBE(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_FBE_SHIFT)) & SDIF_IDSTS_FBE_MASK)
N#define SDIF_IDSTS_DU_MASK                       (0x10U)
N#define SDIF_IDSTS_DU_SHIFT                      (4U)
N#define SDIF_IDSTS_DU(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_DU_SHIFT)) & SDIF_IDSTS_DU_MASK)
N#define SDIF_IDSTS_CES_MASK                      (0x20U)
N#define SDIF_IDSTS_CES_SHIFT                     (5U)
N#define SDIF_IDSTS_CES(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_CES_SHIFT)) & SDIF_IDSTS_CES_MASK)
N#define SDIF_IDSTS_NIS_MASK                      (0x100U)
N#define SDIF_IDSTS_NIS_SHIFT                     (8U)
N#define SDIF_IDSTS_NIS(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_NIS_SHIFT)) & SDIF_IDSTS_NIS_MASK)
N#define SDIF_IDSTS_AIS_MASK                      (0x200U)
N#define SDIF_IDSTS_AIS_SHIFT                     (9U)
N#define SDIF_IDSTS_AIS(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_AIS_SHIFT)) & SDIF_IDSTS_AIS_MASK)
N#define SDIF_IDSTS_EB_MASK                       (0x1C00U)
N#define SDIF_IDSTS_EB_SHIFT                      (10U)
N#define SDIF_IDSTS_EB(x)                         (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_EB_SHIFT)) & SDIF_IDSTS_EB_MASK)
N#define SDIF_IDSTS_FSM_MASK                      (0x1E000U)
N#define SDIF_IDSTS_FSM_SHIFT                     (13U)
N#define SDIF_IDSTS_FSM(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_IDSTS_FSM_SHIFT)) & SDIF_IDSTS_FSM_MASK)
N
N/*! @name IDINTEN - Internal DMAC Interrupt Enable register */
N#define SDIF_IDINTEN_TI_MASK                     (0x1U)
N#define SDIF_IDINTEN_TI_SHIFT                    (0U)
N#define SDIF_IDINTEN_TI(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_TI_SHIFT)) & SDIF_IDINTEN_TI_MASK)
N#define SDIF_IDINTEN_RI_MASK                     (0x2U)
N#define SDIF_IDINTEN_RI_SHIFT                    (1U)
N#define SDIF_IDINTEN_RI(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_RI_SHIFT)) & SDIF_IDINTEN_RI_MASK)
N#define SDIF_IDINTEN_FBE_MASK                    (0x4U)
N#define SDIF_IDINTEN_FBE_SHIFT                   (2U)
N#define SDIF_IDINTEN_FBE(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_FBE_SHIFT)) & SDIF_IDINTEN_FBE_MASK)
N#define SDIF_IDINTEN_DU_MASK                     (0x10U)
N#define SDIF_IDINTEN_DU_SHIFT                    (4U)
N#define SDIF_IDINTEN_DU(x)                       (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_DU_SHIFT)) & SDIF_IDINTEN_DU_MASK)
N#define SDIF_IDINTEN_CES_MASK                    (0x20U)
N#define SDIF_IDINTEN_CES_SHIFT                   (5U)
N#define SDIF_IDINTEN_CES(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_CES_SHIFT)) & SDIF_IDINTEN_CES_MASK)
N#define SDIF_IDINTEN_NIS_MASK                    (0x100U)
N#define SDIF_IDINTEN_NIS_SHIFT                   (8U)
N#define SDIF_IDINTEN_NIS(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_NIS_SHIFT)) & SDIF_IDINTEN_NIS_MASK)
N#define SDIF_IDINTEN_AIS_MASK                    (0x200U)
N#define SDIF_IDINTEN_AIS_SHIFT                   (9U)
N#define SDIF_IDINTEN_AIS(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_IDINTEN_AIS_SHIFT)) & SDIF_IDINTEN_AIS_MASK)
N
N/*! @name DSCADDR - Current Host Descriptor Address register */
N#define SDIF_DSCADDR_HDA_MASK                    (0xFFFFFFFFU)
N#define SDIF_DSCADDR_HDA_SHIFT                   (0U)
N#define SDIF_DSCADDR_HDA(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_DSCADDR_HDA_SHIFT)) & SDIF_DSCADDR_HDA_MASK)
N
N/*! @name BUFADDR - Current Buffer Descriptor Address register */
N#define SDIF_BUFADDR_HBA_MASK                    (0xFFFFFFFFU)
N#define SDIF_BUFADDR_HBA_SHIFT                   (0U)
N#define SDIF_BUFADDR_HBA(x)                      (((uint32_t)(((uint32_t)(x)) << SDIF_BUFADDR_HBA_SHIFT)) & SDIF_BUFADDR_HBA_MASK)
N
N/*! @name CARDTHRCTL - Card Threshold Control */
N#define SDIF_CARDTHRCTL_CARDRDTHREN_MASK         (0x1U)
N#define SDIF_CARDTHRCTL_CARDRDTHREN_SHIFT        (0U)
N#define SDIF_CARDTHRCTL_CARDRDTHREN(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_CARDTHRCTL_CARDRDTHREN_SHIFT)) & SDIF_CARDTHRCTL_CARDRDTHREN_MASK)
N#define SDIF_CARDTHRCTL_BSYCLRINTEN_MASK         (0x2U)
N#define SDIF_CARDTHRCTL_BSYCLRINTEN_SHIFT        (1U)
N#define SDIF_CARDTHRCTL_BSYCLRINTEN(x)           (((uint32_t)(((uint32_t)(x)) << SDIF_CARDTHRCTL_BSYCLRINTEN_SHIFT)) & SDIF_CARDTHRCTL_BSYCLRINTEN_MASK)
N#define SDIF_CARDTHRCTL_CARDTHRESHOLD_MASK       (0xFF0000U)
N#define SDIF_CARDTHRCTL_CARDTHRESHOLD_SHIFT      (16U)
N#define SDIF_CARDTHRCTL_CARDTHRESHOLD(x)         (((uint32_t)(((uint32_t)(x)) << SDIF_CARDTHRCTL_CARDTHRESHOLD_SHIFT)) & SDIF_CARDTHRCTL_CARDTHRESHOLD_MASK)
N
N/*! @name BACKENDPWR - Power control */
N#define SDIF_BACKENDPWR_BACKENDPWR_MASK          (0x1U)
N#define SDIF_BACKENDPWR_BACKENDPWR_SHIFT         (0U)
N#define SDIF_BACKENDPWR_BACKENDPWR(x)            (((uint32_t)(((uint32_t)(x)) << SDIF_BACKENDPWR_BACKENDPWR_SHIFT)) & SDIF_BACKENDPWR_BACKENDPWR_MASK)
N
N/*! @name FIFO - SDIF FIFO */
N#define SDIF_FIFO_DATA_MASK                      (0xFFFFFFFFU)
N#define SDIF_FIFO_DATA_SHIFT                     (0U)
N#define SDIF_FIFO_DATA(x)                        (((uint32_t)(((uint32_t)(x)) << SDIF_FIFO_DATA_SHIFT)) & SDIF_FIFO_DATA_MASK)
N
N/* The count of SDIF_FIFO */
N#define SDIF_FIFO_COUNT                          (64U)
N
N
N/*!
N * @}
N */ /* end of group SDIF_Register_Masks */
N
N
N/* SDIF - Peripheral instance base addresses */
N/** Peripheral SDIF base address */
N#define SDIF_BASE                                (0x4009B000u)
N/** Peripheral SDIF base pointer */
N#define SDIF                                     ((SDIF_Type *)SDIF_BASE)
N/** Array initializer of SDIF peripheral base addresses */
N#define SDIF_BASE_ADDRS                          { SDIF_BASE }
N/** Array initializer of SDIF peripheral base pointers */
N#define SDIF_BASE_PTRS                           { SDIF }
N/** Interrupt vectors for the SDIF peripheral type */
N#define SDIF_IRQS                                { SDIO_IRQn }
N
N/*!
N * @}
N */ /* end of group SDIF_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SMARTCARD Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SMARTCARD_Peripheral_Access_Layer SMARTCARD Peripheral Access Layer
N * @{
N */
N
N/** SMARTCARD - Register Layout Typedef */
Ntypedef struct {
N  union {                                          /* offset: 0x0 */
N    __IO uint32_t DLL;                               /**< Divisor Latch LSB, offset: 0x0 */
X    volatile uint32_t DLL;                                
N    __I  uint32_t RBR;                               /**< Receiver Buffer Register, offset: 0x0 */
X    volatile const  uint32_t RBR;                                
N    __O  uint32_t THR;                               /**< Transmit Holding Register, offset: 0x0 */
X    volatile  uint32_t THR;                                
N  };
N  union {                                          /* offset: 0x4 */
N    __IO uint32_t DLM;                               /**< Divisor Latch MSB, offset: 0x4 */
X    volatile uint32_t DLM;                                
N    __IO uint32_t IER;                               /**< Interrupt Enable Register, offset: 0x4 */
X    volatile uint32_t IER;                                
N  };
N  union {                                          /* offset: 0x8 */
N    __O  uint32_t FCR;                               /**< FIFO Control Register, offset: 0x8 */
X    volatile  uint32_t FCR;                                
N    __I  uint32_t IIR;                               /**< Interrupt ID Register, offset: 0x8 */
X    volatile const  uint32_t IIR;                                
N  };
N  __IO uint32_t LCR;                               /**< Line Control Register, offset: 0xC */
X  volatile uint32_t LCR;                                
N       uint8_t RESERVED_0[4];
N  __I  uint32_t LSR;                               /**< Line Status Register, offset: 0x14 */
X  volatile const  uint32_t LSR;                                
N       uint8_t RESERVED_1[4];
N  __IO uint32_t SCR;                               /**< Scratch Pad Register, offset: 0x1C */
X  volatile uint32_t SCR;                                
N       uint8_t RESERVED_2[12];
N  __IO uint32_t OSR;                               /**< Oversampling register, offset: 0x2C */
X  volatile uint32_t OSR;                                
N       uint8_t RESERVED_3[24];
N  __IO uint32_t SCICTRL;                           /**< Smart Card Interface control register, offset: 0x48 */
X  volatile uint32_t SCICTRL;                            
N} SMARTCARD_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SMARTCARD Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SMARTCARD_Register_Masks SMARTCARD Register Masks
N * @{
N */
N
N/*! @name DLL - Divisor Latch LSB */
N#define SMARTCARD_DLL_DLLSB_MASK                 (0xFFU)
N#define SMARTCARD_DLL_DLLSB_SHIFT                (0U)
N#define SMARTCARD_DLL_DLLSB(x)                   (((uint32_t)(((uint32_t)(x)) << SMARTCARD_DLL_DLLSB_SHIFT)) & SMARTCARD_DLL_DLLSB_MASK)
N
N/*! @name RBR - Receiver Buffer Register */
N#define SMARTCARD_RBR_RBR_MASK                   (0xFFU)
N#define SMARTCARD_RBR_RBR_SHIFT                  (0U)
N#define SMARTCARD_RBR_RBR(x)                     (((uint32_t)(((uint32_t)(x)) << SMARTCARD_RBR_RBR_SHIFT)) & SMARTCARD_RBR_RBR_MASK)
N
N/*! @name THR - Transmit Holding Register */
N#define SMARTCARD_THR_THR_MASK                   (0xFFU)
N#define SMARTCARD_THR_THR_SHIFT                  (0U)
N#define SMARTCARD_THR_THR(x)                     (((uint32_t)(((uint32_t)(x)) << SMARTCARD_THR_THR_SHIFT)) & SMARTCARD_THR_THR_MASK)
N
N/*! @name DLM - Divisor Latch MSB */
N#define SMARTCARD_DLM_DLMSB_MASK                 (0xFFU)
N#define SMARTCARD_DLM_DLMSB_SHIFT                (0U)
N#define SMARTCARD_DLM_DLMSB(x)                   (((uint32_t)(((uint32_t)(x)) << SMARTCARD_DLM_DLMSB_SHIFT)) & SMARTCARD_DLM_DLMSB_MASK)
N
N/*! @name IER - Interrupt Enable Register */
N#define SMARTCARD_IER_RBRIE_MASK                 (0x1U)
N#define SMARTCARD_IER_RBRIE_SHIFT                (0U)
N#define SMARTCARD_IER_RBRIE(x)                   (((uint32_t)(((uint32_t)(x)) << SMARTCARD_IER_RBRIE_SHIFT)) & SMARTCARD_IER_RBRIE_MASK)
N#define SMARTCARD_IER_THREIE_MASK                (0x2U)
N#define SMARTCARD_IER_THREIE_SHIFT               (1U)
N#define SMARTCARD_IER_THREIE(x)                  (((uint32_t)(((uint32_t)(x)) << SMARTCARD_IER_THREIE_SHIFT)) & SMARTCARD_IER_THREIE_MASK)
N#define SMARTCARD_IER_RXIE_MASK                  (0x4U)
N#define SMARTCARD_IER_RXIE_SHIFT                 (2U)
N#define SMARTCARD_IER_RXIE(x)                    (((uint32_t)(((uint32_t)(x)) << SMARTCARD_IER_RXIE_SHIFT)) & SMARTCARD_IER_RXIE_MASK)
N
N/*! @name FCR - FIFO Control Register */
N#define SMARTCARD_FCR_FIFOEN_MASK                (0x1U)
N#define SMARTCARD_FCR_FIFOEN_SHIFT               (0U)
N#define SMARTCARD_FCR_FIFOEN(x)                  (((uint32_t)(((uint32_t)(x)) << SMARTCARD_FCR_FIFOEN_SHIFT)) & SMARTCARD_FCR_FIFOEN_MASK)
N#define SMARTCARD_FCR_RXFIFORES_MASK             (0x2U)
N#define SMARTCARD_FCR_RXFIFORES_SHIFT            (1U)
N#define SMARTCARD_FCR_RXFIFORES(x)               (((uint32_t)(((uint32_t)(x)) << SMARTCARD_FCR_RXFIFORES_SHIFT)) & SMARTCARD_FCR_RXFIFORES_MASK)
N#define SMARTCARD_FCR_TXFIFORES_MASK             (0x4U)
N#define SMARTCARD_FCR_TXFIFORES_SHIFT            (2U)
N#define SMARTCARD_FCR_TXFIFORES(x)               (((uint32_t)(((uint32_t)(x)) << SMARTCARD_FCR_TXFIFORES_SHIFT)) & SMARTCARD_FCR_TXFIFORES_MASK)
N#define SMARTCARD_FCR_DMAMODE_MASK               (0x8U)
N#define SMARTCARD_FCR_DMAMODE_SHIFT              (3U)
N#define SMARTCARD_FCR_DMAMODE(x)                 (((uint32_t)(((uint32_t)(x)) << SMARTCARD_FCR_DMAMODE_SHIFT)) & SMARTCARD_FCR_DMAMODE_MASK)
N#define SMARTCARD_FCR_RXTRIGLVL_MASK             (0xC0U)
N#define SMARTCARD_FCR_RXTRIGLVL_SHIFT            (6U)
N#define SMARTCARD_FCR_RXTRIGLVL(x)               (((uint32_t)(((uint32_t)(x)) << SMARTCARD_FCR_RXTRIGLVL_SHIFT)) & SMARTCARD_FCR_RXTRIGLVL_MASK)
N
N/*! @name IIR - Interrupt ID Register */
N#define SMARTCARD_IIR_INTSTATUS_MASK             (0x1U)
N#define SMARTCARD_IIR_INTSTATUS_SHIFT            (0U)
N#define SMARTCARD_IIR_INTSTATUS(x)               (((uint32_t)(((uint32_t)(x)) << SMARTCARD_IIR_INTSTATUS_SHIFT)) & SMARTCARD_IIR_INTSTATUS_MASK)
N#define SMARTCARD_IIR_INTID_MASK                 (0xEU)
N#define SMARTCARD_IIR_INTID_SHIFT                (1U)
N#define SMARTCARD_IIR_INTID(x)                   (((uint32_t)(((uint32_t)(x)) << SMARTCARD_IIR_INTID_SHIFT)) & SMARTCARD_IIR_INTID_MASK)
N#define SMARTCARD_IIR_FIFOENABLE_MASK            (0xC0U)
N#define SMARTCARD_IIR_FIFOENABLE_SHIFT           (6U)
N#define SMARTCARD_IIR_FIFOENABLE(x)              (((uint32_t)(((uint32_t)(x)) << SMARTCARD_IIR_FIFOENABLE_SHIFT)) & SMARTCARD_IIR_FIFOENABLE_MASK)
N
N/*! @name LCR - Line Control Register */
N#define SMARTCARD_LCR_WLS_MASK                   (0x3U)
N#define SMARTCARD_LCR_WLS_SHIFT                  (0U)
N#define SMARTCARD_LCR_WLS(x)                     (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LCR_WLS_SHIFT)) & SMARTCARD_LCR_WLS_MASK)
N#define SMARTCARD_LCR_SBS_MASK                   (0x4U)
N#define SMARTCARD_LCR_SBS_SHIFT                  (2U)
N#define SMARTCARD_LCR_SBS(x)                     (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LCR_SBS_SHIFT)) & SMARTCARD_LCR_SBS_MASK)
N#define SMARTCARD_LCR_PE_MASK                    (0x8U)
N#define SMARTCARD_LCR_PE_SHIFT                   (3U)
N#define SMARTCARD_LCR_PE(x)                      (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LCR_PE_SHIFT)) & SMARTCARD_LCR_PE_MASK)
N#define SMARTCARD_LCR_PS_MASK                    (0x30U)
N#define SMARTCARD_LCR_PS_SHIFT                   (4U)
N#define SMARTCARD_LCR_PS(x)                      (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LCR_PS_SHIFT)) & SMARTCARD_LCR_PS_MASK)
N#define SMARTCARD_LCR_DLAB_MASK                  (0x80U)
N#define SMARTCARD_LCR_DLAB_SHIFT                 (7U)
N#define SMARTCARD_LCR_DLAB(x)                    (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LCR_DLAB_SHIFT)) & SMARTCARD_LCR_DLAB_MASK)
N
N/*! @name LSR - Line Status Register */
N#define SMARTCARD_LSR_RDR_MASK                   (0x1U)
N#define SMARTCARD_LSR_RDR_SHIFT                  (0U)
N#define SMARTCARD_LSR_RDR(x)                     (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_RDR_SHIFT)) & SMARTCARD_LSR_RDR_MASK)
N#define SMARTCARD_LSR_OE_MASK                    (0x2U)
N#define SMARTCARD_LSR_OE_SHIFT                   (1U)
N#define SMARTCARD_LSR_OE(x)                      (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_OE_SHIFT)) & SMARTCARD_LSR_OE_MASK)
N#define SMARTCARD_LSR_PE_MASK                    (0x4U)
N#define SMARTCARD_LSR_PE_SHIFT                   (2U)
N#define SMARTCARD_LSR_PE(x)                      (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_PE_SHIFT)) & SMARTCARD_LSR_PE_MASK)
N#define SMARTCARD_LSR_FE_MASK                    (0x8U)
N#define SMARTCARD_LSR_FE_SHIFT                   (3U)
N#define SMARTCARD_LSR_FE(x)                      (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_FE_SHIFT)) & SMARTCARD_LSR_FE_MASK)
N#define SMARTCARD_LSR_THRE_MASK                  (0x20U)
N#define SMARTCARD_LSR_THRE_SHIFT                 (5U)
N#define SMARTCARD_LSR_THRE(x)                    (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_THRE_SHIFT)) & SMARTCARD_LSR_THRE_MASK)
N#define SMARTCARD_LSR_TEMT_MASK                  (0x40U)
N#define SMARTCARD_LSR_TEMT_SHIFT                 (6U)
N#define SMARTCARD_LSR_TEMT(x)                    (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_TEMT_SHIFT)) & SMARTCARD_LSR_TEMT_MASK)
N#define SMARTCARD_LSR_RXFE_MASK                  (0x80U)
N#define SMARTCARD_LSR_RXFE_SHIFT                 (7U)
N#define SMARTCARD_LSR_RXFE(x)                    (((uint32_t)(((uint32_t)(x)) << SMARTCARD_LSR_RXFE_SHIFT)) & SMARTCARD_LSR_RXFE_MASK)
N
N/*! @name SCR - Scratch Pad Register */
N#define SMARTCARD_SCR_PAD_MASK                   (0xFFU)
N#define SMARTCARD_SCR_PAD_SHIFT                  (0U)
N#define SMARTCARD_SCR_PAD(x)                     (((uint32_t)(((uint32_t)(x)) << SMARTCARD_SCR_PAD_SHIFT)) & SMARTCARD_SCR_PAD_MASK)
N
N/*! @name OSR - Oversampling register */
N#define SMARTCARD_OSR_OSFRAC_MASK                (0xEU)
N#define SMARTCARD_OSR_OSFRAC_SHIFT               (1U)
N#define SMARTCARD_OSR_OSFRAC(x)                  (((uint32_t)(((uint32_t)(x)) << SMARTCARD_OSR_OSFRAC_SHIFT)) & SMARTCARD_OSR_OSFRAC_MASK)
N#define SMARTCARD_OSR_OSINT_MASK                 (0xF0U)
N#define SMARTCARD_OSR_OSINT_SHIFT                (4U)
N#define SMARTCARD_OSR_OSINT(x)                   (((uint32_t)(((uint32_t)(x)) << SMARTCARD_OSR_OSINT_SHIFT)) & SMARTCARD_OSR_OSINT_MASK)
N#define SMARTCARD_OSR_FDINT_MASK                 (0x7F00U)
N#define SMARTCARD_OSR_FDINT_SHIFT                (8U)
N#define SMARTCARD_OSR_FDINT(x)                   (((uint32_t)(((uint32_t)(x)) << SMARTCARD_OSR_FDINT_SHIFT)) & SMARTCARD_OSR_FDINT_MASK)
N
N/*! @name SCICTRL - Smart Card Interface control register */
N#define SMARTCARD_SCICTRL_SCIEN_MASK             (0x1U)
N#define SMARTCARD_SCICTRL_SCIEN_SHIFT            (0U)
N#define SMARTCARD_SCICTRL_SCIEN(x)               (((uint32_t)(((uint32_t)(x)) << SMARTCARD_SCICTRL_SCIEN_SHIFT)) & SMARTCARD_SCICTRL_SCIEN_MASK)
N#define SMARTCARD_SCICTRL_NACKDIS_MASK           (0x2U)
N#define SMARTCARD_SCICTRL_NACKDIS_SHIFT          (1U)
N#define SMARTCARD_SCICTRL_NACKDIS(x)             (((uint32_t)(((uint32_t)(x)) << SMARTCARD_SCICTRL_NACKDIS_SHIFT)) & SMARTCARD_SCICTRL_NACKDIS_MASK)
N#define SMARTCARD_SCICTRL_PROTSEL_MASK           (0x4U)
N#define SMARTCARD_SCICTRL_PROTSEL_SHIFT          (2U)
N#define SMARTCARD_SCICTRL_PROTSEL(x)             (((uint32_t)(((uint32_t)(x)) << SMARTCARD_SCICTRL_PROTSEL_SHIFT)) & SMARTCARD_SCICTRL_PROTSEL_MASK)
N#define SMARTCARD_SCICTRL_TXRETRY_MASK           (0xE0U)
N#define SMARTCARD_SCICTRL_TXRETRY_SHIFT          (5U)
N#define SMARTCARD_SCICTRL_TXRETRY(x)             (((uint32_t)(((uint32_t)(x)) << SMARTCARD_SCICTRL_TXRETRY_SHIFT)) & SMARTCARD_SCICTRL_TXRETRY_MASK)
N#define SMARTCARD_SCICTRL_GUARDTIME_MASK         (0xFF00U)
N#define SMARTCARD_SCICTRL_GUARDTIME_SHIFT        (8U)
N#define SMARTCARD_SCICTRL_GUARDTIME(x)           (((uint32_t)(((uint32_t)(x)) << SMARTCARD_SCICTRL_GUARDTIME_SHIFT)) & SMARTCARD_SCICTRL_GUARDTIME_MASK)
N
N
N/*!
N * @}
N */ /* end of group SMARTCARD_Register_Masks */
N
N
N/* SMARTCARD - Peripheral instance base addresses */
N/** Peripheral SMARTCARD0 base address */
N#define SMARTCARD0_BASE                          (0x40036000u)
N/** Peripheral SMARTCARD0 base pointer */
N#define SMARTCARD0                               ((SMARTCARD_Type *)SMARTCARD0_BASE)
N/** Peripheral SMARTCARD1 base address */
N#define SMARTCARD1_BASE                          (0x40037000u)
N/** Peripheral SMARTCARD1 base pointer */
N#define SMARTCARD1                               ((SMARTCARD_Type *)SMARTCARD1_BASE)
N/** Array initializer of SMARTCARD peripheral base addresses */
N#define SMARTCARD_BASE_ADDRS                     { SMARTCARD0_BASE, SMARTCARD1_BASE }
N/** Array initializer of SMARTCARD peripheral base pointers */
N#define SMARTCARD_BASE_PTRS                      { SMARTCARD0, SMARTCARD1 }
N/** Interrupt vectors for the SMARTCARD peripheral type */
N#define SMARTCARD_IRQS                           { SMARTCARD0_IRQn, SMARTCARD1_IRQn }
N
N/*!
N * @}
N */ /* end of group SMARTCARD_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SPI Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SPI_Peripheral_Access_Layer SPI Peripheral Access Layer
N * @{
N */
N
N/** SPI - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[1024];
N  __IO uint32_t CFG;                               /**< SPI Configuration register, offset: 0x400 */
X  volatile uint32_t CFG;                                
N  __IO uint32_t DLY;                               /**< SPI Delay register, offset: 0x404 */
X  volatile uint32_t DLY;                                
N  __IO uint32_t STAT;                              /**< SPI Status. Some status flags can be cleared by writing a 1 to that bit position., offset: 0x408 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t INTENSET;                          /**< SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set., offset: 0x40C */
X  volatile uint32_t INTENSET;                           
N  __O  uint32_t INTENCLR;                          /**< SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared., offset: 0x410 */
X  volatile  uint32_t INTENCLR;                           
N       uint8_t RESERVED_1[16];
N  __IO uint32_t DIV;                               /**< SPI clock Divider, offset: 0x424 */
X  volatile uint32_t DIV;                                
N  __I  uint32_t INTSTAT;                           /**< SPI Interrupt Status, offset: 0x428 */
X  volatile const  uint32_t INTSTAT;                            
N       uint8_t RESERVED_2[2516];
N  __IO uint32_t FIFOCFG;                           /**< FIFO configuration and enable register., offset: 0xE00 */
X  volatile uint32_t FIFOCFG;                            
N  __IO uint32_t FIFOSTAT;                          /**< FIFO status register., offset: 0xE04 */
X  volatile uint32_t FIFOSTAT;                           
N  __IO uint32_t FIFOTRIG;                          /**< FIFO trigger settings for interrupt and DMA request., offset: 0xE08 */
X  volatile uint32_t FIFOTRIG;                           
N       uint8_t RESERVED_3[4];
N  __IO uint32_t FIFOINTENSET;                      /**< FIFO interrupt enable set (enable) and read register., offset: 0xE10 */
X  volatile uint32_t FIFOINTENSET;                       
N  __IO uint32_t FIFOINTENCLR;                      /**< FIFO interrupt enable clear (disable) and read register., offset: 0xE14 */
X  volatile uint32_t FIFOINTENCLR;                       
N  __I  uint32_t FIFOINTSTAT;                       /**< FIFO interrupt status register., offset: 0xE18 */
X  volatile const  uint32_t FIFOINTSTAT;                        
N       uint8_t RESERVED_4[4];
N  __IO uint32_t FIFOWR;                            /**< FIFO write data., offset: 0xE20 */
X  volatile uint32_t FIFOWR;                             
N       uint8_t RESERVED_5[12];
N  __I  uint32_t FIFORD;                            /**< FIFO read data., offset: 0xE30 */
X  volatile const  uint32_t FIFORD;                             
N       uint8_t RESERVED_6[12];
N  __I  uint32_t FIFORDNOPOP;                       /**< FIFO data read with no FIFO pop., offset: 0xE40 */
X  volatile const  uint32_t FIFORDNOPOP;                        
N       uint8_t RESERVED_7[440];
N  __I  uint32_t ID;                                /**< Peripheral identification register., offset: 0xFFC */
X  volatile const  uint32_t ID;                                 
N} SPI_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SPI Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SPI_Register_Masks SPI Register Masks
N * @{
N */
N
N/*! @name CFG - SPI Configuration register */
N#define SPI_CFG_ENABLE_MASK                      (0x1U)
N#define SPI_CFG_ENABLE_SHIFT                     (0U)
N#define SPI_CFG_ENABLE(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_CFG_ENABLE_SHIFT)) & SPI_CFG_ENABLE_MASK)
N#define SPI_CFG_MASTER_MASK                      (0x4U)
N#define SPI_CFG_MASTER_SHIFT                     (2U)
N#define SPI_CFG_MASTER(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_CFG_MASTER_SHIFT)) & SPI_CFG_MASTER_MASK)
N#define SPI_CFG_LSBF_MASK                        (0x8U)
N#define SPI_CFG_LSBF_SHIFT                       (3U)
N#define SPI_CFG_LSBF(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_LSBF_SHIFT)) & SPI_CFG_LSBF_MASK)
N#define SPI_CFG_CPHA_MASK                        (0x10U)
N#define SPI_CFG_CPHA_SHIFT                       (4U)
N#define SPI_CFG_CPHA(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_CPHA_SHIFT)) & SPI_CFG_CPHA_MASK)
N#define SPI_CFG_CPOL_MASK                        (0x20U)
N#define SPI_CFG_CPOL_SHIFT                       (5U)
N#define SPI_CFG_CPOL(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_CPOL_SHIFT)) & SPI_CFG_CPOL_MASK)
N#define SPI_CFG_LOOP_MASK                        (0x80U)
N#define SPI_CFG_LOOP_SHIFT                       (7U)
N#define SPI_CFG_LOOP(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_LOOP_SHIFT)) & SPI_CFG_LOOP_MASK)
N#define SPI_CFG_SPOL0_MASK                       (0x100U)
N#define SPI_CFG_SPOL0_SHIFT                      (8U)
N#define SPI_CFG_SPOL0(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL0_SHIFT)) & SPI_CFG_SPOL0_MASK)
N#define SPI_CFG_SPOL1_MASK                       (0x200U)
N#define SPI_CFG_SPOL1_SHIFT                      (9U)
N#define SPI_CFG_SPOL1(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL1_SHIFT)) & SPI_CFG_SPOL1_MASK)
N#define SPI_CFG_SPOL2_MASK                       (0x400U)
N#define SPI_CFG_SPOL2_SHIFT                      (10U)
N#define SPI_CFG_SPOL2(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL2_SHIFT)) & SPI_CFG_SPOL2_MASK)
N#define SPI_CFG_SPOL3_MASK                       (0x800U)
N#define SPI_CFG_SPOL3_SHIFT                      (11U)
N#define SPI_CFG_SPOL3(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL3_SHIFT)) & SPI_CFG_SPOL3_MASK)
N
N/*! @name DLY - SPI Delay register */
N#define SPI_DLY_PRE_DELAY_MASK                   (0xFU)
N#define SPI_DLY_PRE_DELAY_SHIFT                  (0U)
N#define SPI_DLY_PRE_DELAY(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_DLY_PRE_DELAY_SHIFT)) & SPI_DLY_PRE_DELAY_MASK)
N#define SPI_DLY_POST_DELAY_MASK                  (0xF0U)
N#define SPI_DLY_POST_DELAY_SHIFT                 (4U)
N#define SPI_DLY_POST_DELAY(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_DLY_POST_DELAY_SHIFT)) & SPI_DLY_POST_DELAY_MASK)
N#define SPI_DLY_FRAME_DELAY_MASK                 (0xF00U)
N#define SPI_DLY_FRAME_DELAY_SHIFT                (8U)
N#define SPI_DLY_FRAME_DELAY(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_DLY_FRAME_DELAY_SHIFT)) & SPI_DLY_FRAME_DELAY_MASK)
N#define SPI_DLY_TRANSFER_DELAY_MASK              (0xF000U)
N#define SPI_DLY_TRANSFER_DELAY_SHIFT             (12U)
N#define SPI_DLY_TRANSFER_DELAY(x)                (((uint32_t)(((uint32_t)(x)) << SPI_DLY_TRANSFER_DELAY_SHIFT)) & SPI_DLY_TRANSFER_DELAY_MASK)
N
N/*! @name STAT - SPI Status. Some status flags can be cleared by writing a 1 to that bit position. */
N#define SPI_STAT_SSA_MASK                        (0x10U)
N#define SPI_STAT_SSA_SHIFT                       (4U)
N#define SPI_STAT_SSA(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_STAT_SSA_SHIFT)) & SPI_STAT_SSA_MASK)
N#define SPI_STAT_SSD_MASK                        (0x20U)
N#define SPI_STAT_SSD_SHIFT                       (5U)
N#define SPI_STAT_SSD(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_STAT_SSD_SHIFT)) & SPI_STAT_SSD_MASK)
N#define SPI_STAT_STALLED_MASK                    (0x40U)
N#define SPI_STAT_STALLED_SHIFT                   (6U)
N#define SPI_STAT_STALLED(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_STAT_STALLED_SHIFT)) & SPI_STAT_STALLED_MASK)
N#define SPI_STAT_ENDTRANSFER_MASK                (0x80U)
N#define SPI_STAT_ENDTRANSFER_SHIFT               (7U)
N#define SPI_STAT_ENDTRANSFER(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_STAT_ENDTRANSFER_SHIFT)) & SPI_STAT_ENDTRANSFER_MASK)
N#define SPI_STAT_MSTIDLE_MASK                    (0x100U)
N#define SPI_STAT_MSTIDLE_SHIFT                   (8U)
N#define SPI_STAT_MSTIDLE(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_STAT_MSTIDLE_SHIFT)) & SPI_STAT_MSTIDLE_MASK)
N
N/*! @name INTENSET - SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set. */
N#define SPI_INTENSET_SSAEN_MASK                  (0x10U)
N#define SPI_INTENSET_SSAEN_SHIFT                 (4U)
N#define SPI_INTENSET_SSAEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_SSAEN_SHIFT)) & SPI_INTENSET_SSAEN_MASK)
N#define SPI_INTENSET_SSDEN_MASK                  (0x20U)
N#define SPI_INTENSET_SSDEN_SHIFT                 (5U)
N#define SPI_INTENSET_SSDEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_SSDEN_SHIFT)) & SPI_INTENSET_SSDEN_MASK)
N#define SPI_INTENSET_MSTIDLEEN_MASK              (0x100U)
N#define SPI_INTENSET_MSTIDLEEN_SHIFT             (8U)
N#define SPI_INTENSET_MSTIDLEEN(x)                (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_MSTIDLEEN_SHIFT)) & SPI_INTENSET_MSTIDLEEN_MASK)
N
N/*! @name INTENCLR - SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared. */
N#define SPI_INTENCLR_SSAEN_MASK                  (0x10U)
N#define SPI_INTENCLR_SSAEN_SHIFT                 (4U)
N#define SPI_INTENCLR_SSAEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_SSAEN_SHIFT)) & SPI_INTENCLR_SSAEN_MASK)
N#define SPI_INTENCLR_SSDEN_MASK                  (0x20U)
N#define SPI_INTENCLR_SSDEN_SHIFT                 (5U)
N#define SPI_INTENCLR_SSDEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_SSDEN_SHIFT)) & SPI_INTENCLR_SSDEN_MASK)
N#define SPI_INTENCLR_MSTIDLE_MASK                (0x100U)
N#define SPI_INTENCLR_MSTIDLE_SHIFT               (8U)
N#define SPI_INTENCLR_MSTIDLE(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_MSTIDLE_SHIFT)) & SPI_INTENCLR_MSTIDLE_MASK)
N
N/*! @name DIV - SPI clock Divider */
N#define SPI_DIV_DIVVAL_MASK                      (0xFFFFU)
N#define SPI_DIV_DIVVAL_SHIFT                     (0U)
N#define SPI_DIV_DIVVAL(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_DIV_DIVVAL_SHIFT)) & SPI_DIV_DIVVAL_MASK)
N
N/*! @name INTSTAT - SPI Interrupt Status */
N#define SPI_INTSTAT_SSA_MASK                     (0x10U)
N#define SPI_INTSTAT_SSA_SHIFT                    (4U)
N#define SPI_INTSTAT_SSA(x)                       (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_SSA_SHIFT)) & SPI_INTSTAT_SSA_MASK)
N#define SPI_INTSTAT_SSD_MASK                     (0x20U)
N#define SPI_INTSTAT_SSD_SHIFT                    (5U)
N#define SPI_INTSTAT_SSD(x)                       (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_SSD_SHIFT)) & SPI_INTSTAT_SSD_MASK)
N#define SPI_INTSTAT_MSTIDLE_MASK                 (0x100U)
N#define SPI_INTSTAT_MSTIDLE_SHIFT                (8U)
N#define SPI_INTSTAT_MSTIDLE(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_MSTIDLE_SHIFT)) & SPI_INTSTAT_MSTIDLE_MASK)
N
N/*! @name FIFOCFG - FIFO configuration and enable register. */
N#define SPI_FIFOCFG_ENABLETX_MASK                (0x1U)
N#define SPI_FIFOCFG_ENABLETX_SHIFT               (0U)
N#define SPI_FIFOCFG_ENABLETX(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_ENABLETX_SHIFT)) & SPI_FIFOCFG_ENABLETX_MASK)
N#define SPI_FIFOCFG_ENABLERX_MASK                (0x2U)
N#define SPI_FIFOCFG_ENABLERX_SHIFT               (1U)
N#define SPI_FIFOCFG_ENABLERX(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_ENABLERX_SHIFT)) & SPI_FIFOCFG_ENABLERX_MASK)
N#define SPI_FIFOCFG_SIZE_MASK                    (0x30U)
N#define SPI_FIFOCFG_SIZE_SHIFT                   (4U)
N#define SPI_FIFOCFG_SIZE(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_SIZE_SHIFT)) & SPI_FIFOCFG_SIZE_MASK)
N#define SPI_FIFOCFG_DMATX_MASK                   (0x1000U)
N#define SPI_FIFOCFG_DMATX_SHIFT                  (12U)
N#define SPI_FIFOCFG_DMATX(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_DMATX_SHIFT)) & SPI_FIFOCFG_DMATX_MASK)
N#define SPI_FIFOCFG_DMARX_MASK                   (0x2000U)
N#define SPI_FIFOCFG_DMARX_SHIFT                  (13U)
N#define SPI_FIFOCFG_DMARX(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_DMARX_SHIFT)) & SPI_FIFOCFG_DMARX_MASK)
N#define SPI_FIFOCFG_WAKETX_MASK                  (0x4000U)
N#define SPI_FIFOCFG_WAKETX_SHIFT                 (14U)
N#define SPI_FIFOCFG_WAKETX(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_WAKETX_SHIFT)) & SPI_FIFOCFG_WAKETX_MASK)
N#define SPI_FIFOCFG_WAKERX_MASK                  (0x8000U)
N#define SPI_FIFOCFG_WAKERX_SHIFT                 (15U)
N#define SPI_FIFOCFG_WAKERX(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_WAKERX_SHIFT)) & SPI_FIFOCFG_WAKERX_MASK)
N#define SPI_FIFOCFG_EMPTYTX_MASK                 (0x10000U)
N#define SPI_FIFOCFG_EMPTYTX_SHIFT                (16U)
N#define SPI_FIFOCFG_EMPTYTX(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_EMPTYTX_SHIFT)) & SPI_FIFOCFG_EMPTYTX_MASK)
N#define SPI_FIFOCFG_EMPTYRX_MASK                 (0x20000U)
N#define SPI_FIFOCFG_EMPTYRX_SHIFT                (17U)
N#define SPI_FIFOCFG_EMPTYRX(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_EMPTYRX_SHIFT)) & SPI_FIFOCFG_EMPTYRX_MASK)
N#define SPI_FIFOCFG_POPDBG_MASK                  (0x40000U)
N#define SPI_FIFOCFG_POPDBG_SHIFT                 (18U)
N#define SPI_FIFOCFG_POPDBG(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOCFG_POPDBG_SHIFT)) & SPI_FIFOCFG_POPDBG_MASK)
N
N/*! @name FIFOSTAT - FIFO status register. */
N#define SPI_FIFOSTAT_TXERR_MASK                  (0x1U)
N#define SPI_FIFOSTAT_TXERR_SHIFT                 (0U)
N#define SPI_FIFOSTAT_TXERR(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_TXERR_SHIFT)) & SPI_FIFOSTAT_TXERR_MASK)
N#define SPI_FIFOSTAT_RXERR_MASK                  (0x2U)
N#define SPI_FIFOSTAT_RXERR_SHIFT                 (1U)
N#define SPI_FIFOSTAT_RXERR(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_RXERR_SHIFT)) & SPI_FIFOSTAT_RXERR_MASK)
N#define SPI_FIFOSTAT_PERINT_MASK                 (0x8U)
N#define SPI_FIFOSTAT_PERINT_SHIFT                (3U)
N#define SPI_FIFOSTAT_PERINT(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_PERINT_SHIFT)) & SPI_FIFOSTAT_PERINT_MASK)
N#define SPI_FIFOSTAT_TXEMPTY_MASK                (0x10U)
N#define SPI_FIFOSTAT_TXEMPTY_SHIFT               (4U)
N#define SPI_FIFOSTAT_TXEMPTY(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_TXEMPTY_SHIFT)) & SPI_FIFOSTAT_TXEMPTY_MASK)
N#define SPI_FIFOSTAT_TXNOTFULL_MASK              (0x20U)
N#define SPI_FIFOSTAT_TXNOTFULL_SHIFT             (5U)
N#define SPI_FIFOSTAT_TXNOTFULL(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_TXNOTFULL_SHIFT)) & SPI_FIFOSTAT_TXNOTFULL_MASK)
N#define SPI_FIFOSTAT_RXNOTEMPTY_MASK             (0x40U)
N#define SPI_FIFOSTAT_RXNOTEMPTY_SHIFT            (6U)
N#define SPI_FIFOSTAT_RXNOTEMPTY(x)               (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_RXNOTEMPTY_SHIFT)) & SPI_FIFOSTAT_RXNOTEMPTY_MASK)
N#define SPI_FIFOSTAT_RXFULL_MASK                 (0x80U)
N#define SPI_FIFOSTAT_RXFULL_SHIFT                (7U)
N#define SPI_FIFOSTAT_RXFULL(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_RXFULL_SHIFT)) & SPI_FIFOSTAT_RXFULL_MASK)
N#define SPI_FIFOSTAT_TXLVL_MASK                  (0x1F00U)
N#define SPI_FIFOSTAT_TXLVL_SHIFT                 (8U)
N#define SPI_FIFOSTAT_TXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_TXLVL_SHIFT)) & SPI_FIFOSTAT_TXLVL_MASK)
N#define SPI_FIFOSTAT_RXLVL_MASK                  (0x1F0000U)
N#define SPI_FIFOSTAT_RXLVL_SHIFT                 (16U)
N#define SPI_FIFOSTAT_RXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOSTAT_RXLVL_SHIFT)) & SPI_FIFOSTAT_RXLVL_MASK)
N
N/*! @name FIFOTRIG - FIFO trigger settings for interrupt and DMA request. */
N#define SPI_FIFOTRIG_TXLVLENA_MASK               (0x1U)
N#define SPI_FIFOTRIG_TXLVLENA_SHIFT              (0U)
N#define SPI_FIFOTRIG_TXLVLENA(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_FIFOTRIG_TXLVLENA_SHIFT)) & SPI_FIFOTRIG_TXLVLENA_MASK)
N#define SPI_FIFOTRIG_RXLVLENA_MASK               (0x2U)
N#define SPI_FIFOTRIG_RXLVLENA_SHIFT              (1U)
N#define SPI_FIFOTRIG_RXLVLENA(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_FIFOTRIG_RXLVLENA_SHIFT)) & SPI_FIFOTRIG_RXLVLENA_MASK)
N#define SPI_FIFOTRIG_TXLVL_MASK                  (0xF00U)
N#define SPI_FIFOTRIG_TXLVL_SHIFT                 (8U)
N#define SPI_FIFOTRIG_TXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOTRIG_TXLVL_SHIFT)) & SPI_FIFOTRIG_TXLVL_MASK)
N#define SPI_FIFOTRIG_RXLVL_MASK                  (0xF0000U)
N#define SPI_FIFOTRIG_RXLVL_SHIFT                 (16U)
N#define SPI_FIFOTRIG_RXLVL(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_FIFOTRIG_RXLVL_SHIFT)) & SPI_FIFOTRIG_RXLVL_MASK)
N
N/*! @name FIFOINTENSET - FIFO interrupt enable set (enable) and read register. */
N#define SPI_FIFOINTENSET_TXERR_MASK              (0x1U)
N#define SPI_FIFOINTENSET_TXERR_SHIFT             (0U)
N#define SPI_FIFOINTENSET_TXERR(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENSET_TXERR_SHIFT)) & SPI_FIFOINTENSET_TXERR_MASK)
N#define SPI_FIFOINTENSET_RXERR_MASK              (0x2U)
N#define SPI_FIFOINTENSET_RXERR_SHIFT             (1U)
N#define SPI_FIFOINTENSET_RXERR(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENSET_RXERR_SHIFT)) & SPI_FIFOINTENSET_RXERR_MASK)
N#define SPI_FIFOINTENSET_TXLVL_MASK              (0x4U)
N#define SPI_FIFOINTENSET_TXLVL_SHIFT             (2U)
N#define SPI_FIFOINTENSET_TXLVL(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENSET_TXLVL_SHIFT)) & SPI_FIFOINTENSET_TXLVL_MASK)
N#define SPI_FIFOINTENSET_RXLVL_MASK              (0x8U)
N#define SPI_FIFOINTENSET_RXLVL_SHIFT             (3U)
N#define SPI_FIFOINTENSET_RXLVL(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENSET_RXLVL_SHIFT)) & SPI_FIFOINTENSET_RXLVL_MASK)
N
N/*! @name FIFOINTENCLR - FIFO interrupt enable clear (disable) and read register. */
N#define SPI_FIFOINTENCLR_TXERR_MASK              (0x1U)
N#define SPI_FIFOINTENCLR_TXERR_SHIFT             (0U)
N#define SPI_FIFOINTENCLR_TXERR(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENCLR_TXERR_SHIFT)) & SPI_FIFOINTENCLR_TXERR_MASK)
N#define SPI_FIFOINTENCLR_RXERR_MASK              (0x2U)
N#define SPI_FIFOINTENCLR_RXERR_SHIFT             (1U)
N#define SPI_FIFOINTENCLR_RXERR(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENCLR_RXERR_SHIFT)) & SPI_FIFOINTENCLR_RXERR_MASK)
N#define SPI_FIFOINTENCLR_TXLVL_MASK              (0x4U)
N#define SPI_FIFOINTENCLR_TXLVL_SHIFT             (2U)
N#define SPI_FIFOINTENCLR_TXLVL(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENCLR_TXLVL_SHIFT)) & SPI_FIFOINTENCLR_TXLVL_MASK)
N#define SPI_FIFOINTENCLR_RXLVL_MASK              (0x8U)
N#define SPI_FIFOINTENCLR_RXLVL_SHIFT             (3U)
N#define SPI_FIFOINTENCLR_RXLVL(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTENCLR_RXLVL_SHIFT)) & SPI_FIFOINTENCLR_RXLVL_MASK)
N
N/*! @name FIFOINTSTAT - FIFO interrupt status register. */
N#define SPI_FIFOINTSTAT_TXERR_MASK               (0x1U)
N#define SPI_FIFOINTSTAT_TXERR_SHIFT              (0U)
N#define SPI_FIFOINTSTAT_TXERR(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTSTAT_TXERR_SHIFT)) & SPI_FIFOINTSTAT_TXERR_MASK)
N#define SPI_FIFOINTSTAT_RXERR_MASK               (0x2U)
N#define SPI_FIFOINTSTAT_RXERR_SHIFT              (1U)
N#define SPI_FIFOINTSTAT_RXERR(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTSTAT_RXERR_SHIFT)) & SPI_FIFOINTSTAT_RXERR_MASK)
N#define SPI_FIFOINTSTAT_TXLVL_MASK               (0x4U)
N#define SPI_FIFOINTSTAT_TXLVL_SHIFT              (2U)
N#define SPI_FIFOINTSTAT_TXLVL(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTSTAT_TXLVL_SHIFT)) & SPI_FIFOINTSTAT_TXLVL_MASK)
N#define SPI_FIFOINTSTAT_RXLVL_MASK               (0x8U)
N#define SPI_FIFOINTSTAT_RXLVL_SHIFT              (3U)
N#define SPI_FIFOINTSTAT_RXLVL(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTSTAT_RXLVL_SHIFT)) & SPI_FIFOINTSTAT_RXLVL_MASK)
N#define SPI_FIFOINTSTAT_PERINT_MASK              (0x10U)
N#define SPI_FIFOINTSTAT_PERINT_SHIFT             (4U)
N#define SPI_FIFOINTSTAT_PERINT(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFOINTSTAT_PERINT_SHIFT)) & SPI_FIFOINTSTAT_PERINT_MASK)
N
N/*! @name FIFOWR - FIFO write data. */
N#define SPI_FIFOWR_TXDATA_MASK                   (0xFFFFU)
N#define SPI_FIFOWR_TXDATA_SHIFT                  (0U)
N#define SPI_FIFOWR_TXDATA(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_TXDATA_SHIFT)) & SPI_FIFOWR_TXDATA_MASK)
N#define SPI_FIFOWR_TXSSEL0_N_MASK                (0x10000U)
N#define SPI_FIFOWR_TXSSEL0_N_SHIFT               (16U)
N#define SPI_FIFOWR_TXSSEL0_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_TXSSEL0_N_SHIFT)) & SPI_FIFOWR_TXSSEL0_N_MASK)
N#define SPI_FIFOWR_TXSSEL1_N_MASK                (0x20000U)
N#define SPI_FIFOWR_TXSSEL1_N_SHIFT               (17U)
N#define SPI_FIFOWR_TXSSEL1_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_TXSSEL1_N_SHIFT)) & SPI_FIFOWR_TXSSEL1_N_MASK)
N#define SPI_FIFOWR_TXSSEL2_N_MASK                (0x40000U)
N#define SPI_FIFOWR_TXSSEL2_N_SHIFT               (18U)
N#define SPI_FIFOWR_TXSSEL2_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_TXSSEL2_N_SHIFT)) & SPI_FIFOWR_TXSSEL2_N_MASK)
N#define SPI_FIFOWR_TXSSEL3_N_MASK                (0x80000U)
N#define SPI_FIFOWR_TXSSEL3_N_SHIFT               (19U)
N#define SPI_FIFOWR_TXSSEL3_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_TXSSEL3_N_SHIFT)) & SPI_FIFOWR_TXSSEL3_N_MASK)
N#define SPI_FIFOWR_EOT_MASK                      (0x100000U)
N#define SPI_FIFOWR_EOT_SHIFT                     (20U)
N#define SPI_FIFOWR_EOT(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_EOT_SHIFT)) & SPI_FIFOWR_EOT_MASK)
N#define SPI_FIFOWR_EOF_MASK                      (0x200000U)
N#define SPI_FIFOWR_EOF_SHIFT                     (21U)
N#define SPI_FIFOWR_EOF(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_EOF_SHIFT)) & SPI_FIFOWR_EOF_MASK)
N#define SPI_FIFOWR_RXIGNORE_MASK                 (0x400000U)
N#define SPI_FIFOWR_RXIGNORE_SHIFT                (22U)
N#define SPI_FIFOWR_RXIGNORE(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_RXIGNORE_SHIFT)) & SPI_FIFOWR_RXIGNORE_MASK)
N#define SPI_FIFOWR_LEN_MASK                      (0xF000000U)
N#define SPI_FIFOWR_LEN_SHIFT                     (24U)
N#define SPI_FIFOWR_LEN(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_FIFOWR_LEN_SHIFT)) & SPI_FIFOWR_LEN_MASK)
N
N/*! @name FIFORD - FIFO read data. */
N#define SPI_FIFORD_RXDATA_MASK                   (0xFFFFU)
N#define SPI_FIFORD_RXDATA_SHIFT                  (0U)
N#define SPI_FIFORD_RXDATA(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_FIFORD_RXDATA_SHIFT)) & SPI_FIFORD_RXDATA_MASK)
N#define SPI_FIFORD_RXSSEL0_N_MASK                (0x10000U)
N#define SPI_FIFORD_RXSSEL0_N_SHIFT               (16U)
N#define SPI_FIFORD_RXSSEL0_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFORD_RXSSEL0_N_SHIFT)) & SPI_FIFORD_RXSSEL0_N_MASK)
N#define SPI_FIFORD_RXSSEL1_N_MASK                (0x20000U)
N#define SPI_FIFORD_RXSSEL1_N_SHIFT               (17U)
N#define SPI_FIFORD_RXSSEL1_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFORD_RXSSEL1_N_SHIFT)) & SPI_FIFORD_RXSSEL1_N_MASK)
N#define SPI_FIFORD_RXSSEL2_N_MASK                (0x40000U)
N#define SPI_FIFORD_RXSSEL2_N_SHIFT               (18U)
N#define SPI_FIFORD_RXSSEL2_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFORD_RXSSEL2_N_SHIFT)) & SPI_FIFORD_RXSSEL2_N_MASK)
N#define SPI_FIFORD_RXSSEL3_N_MASK                (0x80000U)
N#define SPI_FIFORD_RXSSEL3_N_SHIFT               (19U)
N#define SPI_FIFORD_RXSSEL3_N(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_FIFORD_RXSSEL3_N_SHIFT)) & SPI_FIFORD_RXSSEL3_N_MASK)
N#define SPI_FIFORD_SOT_MASK                      (0x100000U)
N#define SPI_FIFORD_SOT_SHIFT                     (20U)
N#define SPI_FIFORD_SOT(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_FIFORD_SOT_SHIFT)) & SPI_FIFORD_SOT_MASK)
N
N/*! @name FIFORDNOPOP - FIFO data read with no FIFO pop. */
N#define SPI_FIFORDNOPOP_RXDATA_MASK              (0xFFFFU)
N#define SPI_FIFORDNOPOP_RXDATA_SHIFT             (0U)
N#define SPI_FIFORDNOPOP_RXDATA(x)                (((uint32_t)(((uint32_t)(x)) << SPI_FIFORDNOPOP_RXDATA_SHIFT)) & SPI_FIFORDNOPOP_RXDATA_MASK)
N#define SPI_FIFORDNOPOP_RXSSEL0_N_MASK           (0x10000U)
N#define SPI_FIFORDNOPOP_RXSSEL0_N_SHIFT          (16U)
N#define SPI_FIFORDNOPOP_RXSSEL0_N(x)             (((uint32_t)(((uint32_t)(x)) << SPI_FIFORDNOPOP_RXSSEL0_N_SHIFT)) & SPI_FIFORDNOPOP_RXSSEL0_N_MASK)
N#define SPI_FIFORDNOPOP_RXSSEL1_N_MASK           (0x20000U)
N#define SPI_FIFORDNOPOP_RXSSEL1_N_SHIFT          (17U)
N#define SPI_FIFORDNOPOP_RXSSEL1_N(x)             (((uint32_t)(((uint32_t)(x)) << SPI_FIFORDNOPOP_RXSSEL1_N_SHIFT)) & SPI_FIFORDNOPOP_RXSSEL1_N_MASK)
N#define SPI_FIFORDNOPOP_RXSSEL2_N_MASK           (0x40000U)
N#define SPI_FIFORDNOPOP_RXSSEL2_N_SHIFT          (18U)
N#define SPI_FIFORDNOPOP_RXSSEL2_N(x)             (((uint32_t)(((uint32_t)(x)) << SPI_FIFORDNOPOP_RXSSEL2_N_SHIFT)) & SPI_FIFORDNOPOP_RXSSEL2_N_MASK)
N#define SPI_FIFORDNOPOP_RXSSEL3_N_MASK           (0x80000U)
N#define SPI_FIFORDNOPOP_RXSSEL3_N_SHIFT          (19U)
N#define SPI_FIFORDNOPOP_RXSSEL3_N(x)             (((uint32_t)(((uint32_t)(x)) << SPI_FIFORDNOPOP_RXSSEL3_N_SHIFT)) & SPI_FIFORDNOPOP_RXSSEL3_N_MASK)
N#define SPI_FIFORDNOPOP_SOT_MASK                 (0x100000U)
N#define SPI_FIFORDNOPOP_SOT_SHIFT                (20U)
N#define SPI_FIFORDNOPOP_SOT(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_FIFORDNOPOP_SOT_SHIFT)) & SPI_FIFORDNOPOP_SOT_MASK)
N
N/*! @name ID - Peripheral identification register. */
N#define SPI_ID_APERTURE_MASK                     (0xFFU)
N#define SPI_ID_APERTURE_SHIFT                    (0U)
N#define SPI_ID_APERTURE(x)                       (((uint32_t)(((uint32_t)(x)) << SPI_ID_APERTURE_SHIFT)) & SPI_ID_APERTURE_MASK)
N#define SPI_ID_MINOR_REV_MASK                    (0xF00U)
N#define SPI_ID_MINOR_REV_SHIFT                   (8U)
N#define SPI_ID_MINOR_REV(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_ID_MINOR_REV_SHIFT)) & SPI_ID_MINOR_REV_MASK)
N#define SPI_ID_MAJOR_REV_MASK                    (0xF000U)
N#define SPI_ID_MAJOR_REV_SHIFT                   (12U)
N#define SPI_ID_MAJOR_REV(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_ID_MAJOR_REV_SHIFT)) & SPI_ID_MAJOR_REV_MASK)
N#define SPI_ID_ID_MASK                           (0xFFFF0000U)
N#define SPI_ID_ID_SHIFT                          (16U)
N#define SPI_ID_ID(x)                             (((uint32_t)(((uint32_t)(x)) << SPI_ID_ID_SHIFT)) & SPI_ID_ID_MASK)
N
N
N/*!
N * @}
N */ /* end of group SPI_Register_Masks */
N
N
N/* SPI - Peripheral instance base addresses */
N/** Peripheral SPI0 base address */
N#define SPI0_BASE                                (0x40086000u)
N/** Peripheral SPI0 base pointer */
N#define SPI0                                     ((SPI_Type *)SPI0_BASE)
N/** Peripheral SPI1 base address */
N#define SPI1_BASE                                (0x40087000u)
N/** Peripheral SPI1 base pointer */
N#define SPI1                                     ((SPI_Type *)SPI1_BASE)
N/** Peripheral SPI2 base address */
N#define SPI2_BASE                                (0x40088000u)
N/** Peripheral SPI2 base pointer */
N#define SPI2                                     ((SPI_Type *)SPI2_BASE)
N/** Peripheral SPI3 base address */
N#define SPI3_BASE                                (0x40089000u)
N/** Peripheral SPI3 base pointer */
N#define SPI3                                     ((SPI_Type *)SPI3_BASE)
N/** Peripheral SPI4 base address */
N#define SPI4_BASE                                (0x4008A000u)
N/** Peripheral SPI4 base pointer */
N#define SPI4                                     ((SPI_Type *)SPI4_BASE)
N/** Peripheral SPI5 base address */
N#define SPI5_BASE                                (0x40096000u)
N/** Peripheral SPI5 base pointer */
N#define SPI5                                     ((SPI_Type *)SPI5_BASE)
N/** Peripheral SPI6 base address */
N#define SPI6_BASE                                (0x40097000u)
N/** Peripheral SPI6 base pointer */
N#define SPI6                                     ((SPI_Type *)SPI6_BASE)
N/** Peripheral SPI7 base address */
N#define SPI7_BASE                                (0x40098000u)
N/** Peripheral SPI7 base pointer */
N#define SPI7                                     ((SPI_Type *)SPI7_BASE)
N/** Peripheral SPI8 base address */
N#define SPI8_BASE                                (0x40099000u)
N/** Peripheral SPI8 base pointer */
N#define SPI8                                     ((SPI_Type *)SPI8_BASE)
N/** Peripheral SPI9 base address */
N#define SPI9_BASE                                (0x4009A000u)
N/** Peripheral SPI9 base pointer */
N#define SPI9                                     ((SPI_Type *)SPI9_BASE)
N/** Array initializer of SPI peripheral base addresses */
N#define SPI_BASE_ADDRS                           { SPI0_BASE, SPI1_BASE, SPI2_BASE, SPI3_BASE, SPI4_BASE, SPI5_BASE, SPI6_BASE, SPI7_BASE, SPI8_BASE, SPI9_BASE }
N/** Array initializer of SPI peripheral base pointers */
N#define SPI_BASE_PTRS                            { SPI0, SPI1, SPI2, SPI3, SPI4, SPI5, SPI6, SPI7, SPI8, SPI9 }
N/** Interrupt vectors for the SPI peripheral type */
N#define SPI_IRQS                                 { FLEXCOMM0_IRQn, FLEXCOMM1_IRQn, FLEXCOMM2_IRQn, FLEXCOMM3_IRQn, FLEXCOMM4_IRQn, FLEXCOMM5_IRQn, FLEXCOMM6_IRQn, FLEXCOMM7_IRQn, FLEXCOMM8_IRQn, FLEXCOMM9_IRQn }
N
N/*!
N * @}
N */ /* end of group SPI_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SPIFI Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SPIFI_Peripheral_Access_Layer SPIFI Peripheral Access Layer
N * @{
N */
N
N/** SPIFI - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< SPIFI control register, offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t CMD;                               /**< SPIFI command register, offset: 0x4 */
X  volatile uint32_t CMD;                                
N  __IO uint32_t ADDR;                              /**< SPIFI address register, offset: 0x8 */
X  volatile uint32_t ADDR;                               
N  __IO uint32_t IDATA;                             /**< SPIFI intermediate data register, offset: 0xC */
X  volatile uint32_t IDATA;                              
N  __IO uint32_t CLIMIT;                            /**< SPIFI limit register, offset: 0x10 */
X  volatile uint32_t CLIMIT;                             
N  __IO uint32_t DATA;                              /**< SPIFI data register, offset: 0x14 */
X  volatile uint32_t DATA;                               
N  __IO uint32_t MCMD;                              /**< SPIFI memory command register, offset: 0x18 */
X  volatile uint32_t MCMD;                               
N  __IO uint32_t STAT;                              /**< SPIFI status register, offset: 0x1C */
X  volatile uint32_t STAT;                               
N} SPIFI_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SPIFI Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SPIFI_Register_Masks SPIFI Register Masks
N * @{
N */
N
N/*! @name CTRL - SPIFI control register */
N#define SPIFI_CTRL_TIMEOUT_MASK                  (0xFFFFU)
N#define SPIFI_CTRL_TIMEOUT_SHIFT                 (0U)
N#define SPIFI_CTRL_TIMEOUT(x)                    (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_TIMEOUT_SHIFT)) & SPIFI_CTRL_TIMEOUT_MASK)
N#define SPIFI_CTRL_CSHIGH_MASK                   (0xF0000U)
N#define SPIFI_CTRL_CSHIGH_SHIFT                  (16U)
N#define SPIFI_CTRL_CSHIGH(x)                     (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_CSHIGH_SHIFT)) & SPIFI_CTRL_CSHIGH_MASK)
N#define SPIFI_CTRL_D_PRFTCH_DIS_MASK             (0x200000U)
N#define SPIFI_CTRL_D_PRFTCH_DIS_SHIFT            (21U)
N#define SPIFI_CTRL_D_PRFTCH_DIS(x)               (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_D_PRFTCH_DIS_SHIFT)) & SPIFI_CTRL_D_PRFTCH_DIS_MASK)
N#define SPIFI_CTRL_INTEN_MASK                    (0x400000U)
N#define SPIFI_CTRL_INTEN_SHIFT                   (22U)
N#define SPIFI_CTRL_INTEN(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_INTEN_SHIFT)) & SPIFI_CTRL_INTEN_MASK)
N#define SPIFI_CTRL_MODE3_MASK                    (0x800000U)
N#define SPIFI_CTRL_MODE3_SHIFT                   (23U)
N#define SPIFI_CTRL_MODE3(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_MODE3_SHIFT)) & SPIFI_CTRL_MODE3_MASK)
N#define SPIFI_CTRL_PRFTCH_DIS_MASK               (0x8000000U)
N#define SPIFI_CTRL_PRFTCH_DIS_SHIFT              (27U)
N#define SPIFI_CTRL_PRFTCH_DIS(x)                 (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_PRFTCH_DIS_SHIFT)) & SPIFI_CTRL_PRFTCH_DIS_MASK)
N#define SPIFI_CTRL_DUAL_MASK                     (0x10000000U)
N#define SPIFI_CTRL_DUAL_SHIFT                    (28U)
N#define SPIFI_CTRL_DUAL(x)                       (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_DUAL_SHIFT)) & SPIFI_CTRL_DUAL_MASK)
N#define SPIFI_CTRL_RFCLK_MASK                    (0x20000000U)
N#define SPIFI_CTRL_RFCLK_SHIFT                   (29U)
N#define SPIFI_CTRL_RFCLK(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_RFCLK_SHIFT)) & SPIFI_CTRL_RFCLK_MASK)
N#define SPIFI_CTRL_FBCLK_MASK                    (0x40000000U)
N#define SPIFI_CTRL_FBCLK_SHIFT                   (30U)
N#define SPIFI_CTRL_FBCLK(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_FBCLK_SHIFT)) & SPIFI_CTRL_FBCLK_MASK)
N#define SPIFI_CTRL_DMAEN_MASK                    (0x80000000U)
N#define SPIFI_CTRL_DMAEN_SHIFT                   (31U)
N#define SPIFI_CTRL_DMAEN(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CTRL_DMAEN_SHIFT)) & SPIFI_CTRL_DMAEN_MASK)
N
N/*! @name CMD - SPIFI command register */
N#define SPIFI_CMD_DATALEN_MASK                   (0x3FFFU)
N#define SPIFI_CMD_DATALEN_SHIFT                  (0U)
N#define SPIFI_CMD_DATALEN(x)                     (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_DATALEN_SHIFT)) & SPIFI_CMD_DATALEN_MASK)
N#define SPIFI_CMD_POLL_MASK                      (0x4000U)
N#define SPIFI_CMD_POLL_SHIFT                     (14U)
N#define SPIFI_CMD_POLL(x)                        (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_POLL_SHIFT)) & SPIFI_CMD_POLL_MASK)
N#define SPIFI_CMD_DOUT_MASK                      (0x8000U)
N#define SPIFI_CMD_DOUT_SHIFT                     (15U)
N#define SPIFI_CMD_DOUT(x)                        (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_DOUT_SHIFT)) & SPIFI_CMD_DOUT_MASK)
N#define SPIFI_CMD_INTLEN_MASK                    (0x70000U)
N#define SPIFI_CMD_INTLEN_SHIFT                   (16U)
N#define SPIFI_CMD_INTLEN(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_INTLEN_SHIFT)) & SPIFI_CMD_INTLEN_MASK)
N#define SPIFI_CMD_FIELDFORM_MASK                 (0x180000U)
N#define SPIFI_CMD_FIELDFORM_SHIFT                (19U)
N#define SPIFI_CMD_FIELDFORM(x)                   (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_FIELDFORM_SHIFT)) & SPIFI_CMD_FIELDFORM_MASK)
N#define SPIFI_CMD_FRAMEFORM_MASK                 (0xE00000U)
N#define SPIFI_CMD_FRAMEFORM_SHIFT                (21U)
N#define SPIFI_CMD_FRAMEFORM(x)                   (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_FRAMEFORM_SHIFT)) & SPIFI_CMD_FRAMEFORM_MASK)
N#define SPIFI_CMD_OPCODE_MASK                    (0xFF000000U)
N#define SPIFI_CMD_OPCODE_SHIFT                   (24U)
N#define SPIFI_CMD_OPCODE(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_CMD_OPCODE_SHIFT)) & SPIFI_CMD_OPCODE_MASK)
N
N/*! @name ADDR - SPIFI address register */
N#define SPIFI_ADDR_ADDRESS_MASK                  (0xFFFFFFFFU)
N#define SPIFI_ADDR_ADDRESS_SHIFT                 (0U)
N#define SPIFI_ADDR_ADDRESS(x)                    (((uint32_t)(((uint32_t)(x)) << SPIFI_ADDR_ADDRESS_SHIFT)) & SPIFI_ADDR_ADDRESS_MASK)
N
N/*! @name IDATA - SPIFI intermediate data register */
N#define SPIFI_IDATA_IDATA_MASK                   (0xFFFFFFFFU)
N#define SPIFI_IDATA_IDATA_SHIFT                  (0U)
N#define SPIFI_IDATA_IDATA(x)                     (((uint32_t)(((uint32_t)(x)) << SPIFI_IDATA_IDATA_SHIFT)) & SPIFI_IDATA_IDATA_MASK)
N
N/*! @name CLIMIT - SPIFI limit register */
N#define SPIFI_CLIMIT_CLIMIT_MASK                 (0xFFFFFFFFU)
N#define SPIFI_CLIMIT_CLIMIT_SHIFT                (0U)
N#define SPIFI_CLIMIT_CLIMIT(x)                   (((uint32_t)(((uint32_t)(x)) << SPIFI_CLIMIT_CLIMIT_SHIFT)) & SPIFI_CLIMIT_CLIMIT_MASK)
N
N/*! @name DATA - SPIFI data register */
N#define SPIFI_DATA_DATA_MASK                     (0xFFFFFFFFU)
N#define SPIFI_DATA_DATA_SHIFT                    (0U)
N#define SPIFI_DATA_DATA(x)                       (((uint32_t)(((uint32_t)(x)) << SPIFI_DATA_DATA_SHIFT)) & SPIFI_DATA_DATA_MASK)
N
N/*! @name MCMD - SPIFI memory command register */
N#define SPIFI_MCMD_POLL_MASK                     (0x4000U)
N#define SPIFI_MCMD_POLL_SHIFT                    (14U)
N#define SPIFI_MCMD_POLL(x)                       (((uint32_t)(((uint32_t)(x)) << SPIFI_MCMD_POLL_SHIFT)) & SPIFI_MCMD_POLL_MASK)
N#define SPIFI_MCMD_DOUT_MASK                     (0x8000U)
N#define SPIFI_MCMD_DOUT_SHIFT                    (15U)
N#define SPIFI_MCMD_DOUT(x)                       (((uint32_t)(((uint32_t)(x)) << SPIFI_MCMD_DOUT_SHIFT)) & SPIFI_MCMD_DOUT_MASK)
N#define SPIFI_MCMD_INTLEN_MASK                   (0x70000U)
N#define SPIFI_MCMD_INTLEN_SHIFT                  (16U)
N#define SPIFI_MCMD_INTLEN(x)                     (((uint32_t)(((uint32_t)(x)) << SPIFI_MCMD_INTLEN_SHIFT)) & SPIFI_MCMD_INTLEN_MASK)
N#define SPIFI_MCMD_FIELDFORM_MASK                (0x180000U)
N#define SPIFI_MCMD_FIELDFORM_SHIFT               (19U)
N#define SPIFI_MCMD_FIELDFORM(x)                  (((uint32_t)(((uint32_t)(x)) << SPIFI_MCMD_FIELDFORM_SHIFT)) & SPIFI_MCMD_FIELDFORM_MASK)
N#define SPIFI_MCMD_FRAMEFORM_MASK                (0xE00000U)
N#define SPIFI_MCMD_FRAMEFORM_SHIFT               (21U)
N#define SPIFI_MCMD_FRAMEFORM(x)                  (((uint32_t)(((uint32_t)(x)) << SPIFI_MCMD_FRAMEFORM_SHIFT)) & SPIFI_MCMD_FRAMEFORM_MASK)
N#define SPIFI_MCMD_OPCODE_MASK                   (0xFF000000U)
N#define SPIFI_MCMD_OPCODE_SHIFT                  (24U)
N#define SPIFI_MCMD_OPCODE(x)                     (((uint32_t)(((uint32_t)(x)) << SPIFI_MCMD_OPCODE_SHIFT)) & SPIFI_MCMD_OPCODE_MASK)
N
N/*! @name STAT - SPIFI status register */
N#define SPIFI_STAT_MCINIT_MASK                   (0x1U)
N#define SPIFI_STAT_MCINIT_SHIFT                  (0U)
N#define SPIFI_STAT_MCINIT(x)                     (((uint32_t)(((uint32_t)(x)) << SPIFI_STAT_MCINIT_SHIFT)) & SPIFI_STAT_MCINIT_MASK)
N#define SPIFI_STAT_CMD_MASK                      (0x2U)
N#define SPIFI_STAT_CMD_SHIFT                     (1U)
N#define SPIFI_STAT_CMD(x)                        (((uint32_t)(((uint32_t)(x)) << SPIFI_STAT_CMD_SHIFT)) & SPIFI_STAT_CMD_MASK)
N#define SPIFI_STAT_RESET_MASK                    (0x10U)
N#define SPIFI_STAT_RESET_SHIFT                   (4U)
N#define SPIFI_STAT_RESET(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_STAT_RESET_SHIFT)) & SPIFI_STAT_RESET_MASK)
N#define SPIFI_STAT_INTRQ_MASK                    (0x20U)
N#define SPIFI_STAT_INTRQ_SHIFT                   (5U)
N#define SPIFI_STAT_INTRQ(x)                      (((uint32_t)(((uint32_t)(x)) << SPIFI_STAT_INTRQ_SHIFT)) & SPIFI_STAT_INTRQ_MASK)
N
N
N/*!
N * @}
N */ /* end of group SPIFI_Register_Masks */
N
N
N/* SPIFI - Peripheral instance base addresses */
N/** Peripheral SPIFI0 base address */
N#define SPIFI0_BASE                              (0x40080000u)
N/** Peripheral SPIFI0 base pointer */
N#define SPIFI0                                   ((SPIFI_Type *)SPIFI0_BASE)
N/** Array initializer of SPIFI peripheral base addresses */
N#define SPIFI_BASE_ADDRS                         { SPIFI0_BASE }
N/** Array initializer of SPIFI peripheral base pointers */
N#define SPIFI_BASE_PTRS                          { SPIFI0 }
N/** Interrupt vectors for the SPIFI peripheral type */
N#define SPIFI_IRQS                               { SPIFI0_IRQn }
N
N/*!
N * @}
N */ /* end of group SPIFI_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SYSCON Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SYSCON_Peripheral_Access_Layer SYSCON Peripheral Access Layer
N * @{
N */
N
N/** SYSCON - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[16];
N  __IO uint32_t AHBMATPRIO;                        /**< AHB multilayer matrix priority control, offset: 0x10 */
X  volatile uint32_t AHBMATPRIO;                         
N       uint8_t RESERVED_1[44];
N  __IO uint32_t SYSTCKCAL;                         /**< System tick counter calibration, offset: 0x40 */
X  volatile uint32_t SYSTCKCAL;                          
N       uint8_t RESERVED_2[4];
N  __IO uint32_t NMISRC;                            /**< NMI Source Select, offset: 0x48 */
X  volatile uint32_t NMISRC;                             
N  __IO uint32_t ASYNCAPBCTRL;                      /**< Asynchronous APB Control, offset: 0x4C */
X  volatile uint32_t ASYNCAPBCTRL;                       
N       uint8_t RESERVED_3[112];
N  __I  uint32_t PIOPORCAP[2];                      /**< POR captured value of port n, array offset: 0xC0, array step: 0x4 */
X  volatile const  uint32_t PIOPORCAP[2];                       
N       uint8_t RESERVED_4[8];
N  __I  uint32_t PIORESCAP[2];                      /**< Reset captured value of port n, array offset: 0xD0, array step: 0x4 */
X  volatile const  uint32_t PIORESCAP[2];                       
N       uint8_t RESERVED_5[40];
N  __IO uint32_t PRESETCTRL[3];                     /**< Peripheral reset control n, array offset: 0x100, array step: 0x4 */
X  volatile uint32_t PRESETCTRL[3];                      
N       uint8_t RESERVED_6[20];
N  __O  uint32_t PRESETCTRLSET[3];                  /**< Set bits in PRESETCTRLn, array offset: 0x120, array step: 0x4 */
X  volatile  uint32_t PRESETCTRLSET[3];                   
N       uint8_t RESERVED_7[20];
N  __O  uint32_t PRESETCTRLCLR[3];                  /**< Clear bits in PRESETCTRLn, array offset: 0x140, array step: 0x4 */
X  volatile  uint32_t PRESETCTRLCLR[3];                   
N       uint8_t RESERVED_8[164];
N  __IO uint32_t SYSRSTSTAT;                        /**< System reset status register, offset: 0x1F0 */
X  volatile uint32_t SYSRSTSTAT;                         
N       uint8_t RESERVED_9[12];
N  __IO uint32_t AHBCLKCTRL[3];                     /**< AHB Clock control n, array offset: 0x200, array step: 0x4 */
X  volatile uint32_t AHBCLKCTRL[3];                      
N       uint8_t RESERVED_10[20];
N  __O  uint32_t AHBCLKCTRLSET[3];                  /**< Set bits in AHBCLKCTRLn, array offset: 0x220, array step: 0x4 */
X  volatile  uint32_t AHBCLKCTRLSET[3];                   
N       uint8_t RESERVED_11[20];
N  __O  uint32_t AHBCLKCTRLCLR[3];                  /**< Clear bits in AHBCLKCTRLn, array offset: 0x240, array step: 0x4 */
X  volatile  uint32_t AHBCLKCTRLCLR[3];                   
N       uint8_t RESERVED_12[52];
N  __IO uint32_t MAINCLKSELA;                       /**< Main clock source select A, offset: 0x280 */
X  volatile uint32_t MAINCLKSELA;                        
N  __IO uint32_t MAINCLKSELB;                       /**< Main clock source select B, offset: 0x284 */
X  volatile uint32_t MAINCLKSELB;                        
N  __IO uint32_t CLKOUTSELA;                        /**< CLKOUT clock source select A, offset: 0x288 */
X  volatile uint32_t CLKOUTSELA;                         
N       uint8_t RESERVED_13[4];
N  __IO uint32_t SYSPLLCLKSEL;                      /**< PLL clock source select, offset: 0x290 */
X  volatile uint32_t SYSPLLCLKSEL;                       
N       uint8_t RESERVED_14[4];
N  __IO uint32_t AUDPLLCLKSEL;                      /**< Audio PLL clock source select, offset: 0x298 */
X  volatile uint32_t AUDPLLCLKSEL;                       
N       uint8_t RESERVED_15[4];
N  __IO uint32_t SPIFICLKSEL;                       /**< SPIFI clock source select, offset: 0x2A0 */
X  volatile uint32_t SPIFICLKSEL;                        
N  __IO uint32_t ADCCLKSEL;                         /**< ADC clock source select, offset: 0x2A4 */
X  volatile uint32_t ADCCLKSEL;                          
N  __IO uint32_t USB0CLKSEL;                        /**< USB0 clock source select, offset: 0x2A8 */
X  volatile uint32_t USB0CLKSEL;                         
N  __IO uint32_t USB1CLKSEL;                        /**< USB1 clock source select, offset: 0x2AC */
X  volatile uint32_t USB1CLKSEL;                         
N  __IO uint32_t FCLKSEL[10];                       /**< Flexcomm 0 clock source select, array offset: 0x2B0, array step: 0x4 */
X  volatile uint32_t FCLKSEL[10];                        
N       uint8_t RESERVED_16[8];
N  __IO uint32_t MCLKCLKSEL;                        /**< MCLK clock source select, offset: 0x2E0 */
X  volatile uint32_t MCLKCLKSEL;                         
N       uint8_t RESERVED_17[4];
N  __IO uint32_t FRGCLKSEL;                         /**< Fractional Rate Generator clock source select, offset: 0x2E8 */
X  volatile uint32_t FRGCLKSEL;                          
N  __IO uint32_t DMICCLKSEL;                        /**< Digital microphone (DMIC) subsystem clock select, offset: 0x2EC */
X  volatile uint32_t DMICCLKSEL;                         
N  __IO uint32_t SCTCLKSEL;                         /**< SCTimer/PWM clock source select, offset: 0x2F0 */
X  volatile uint32_t SCTCLKSEL;                          
N  __IO uint32_t LCDCLKSEL;                         /**< LCD clock source select, offset: 0x2F4 */
X  volatile uint32_t LCDCLKSEL;                          
N  __IO uint32_t SDIOCLKSEL;                        /**< SDIO clock source select, offset: 0x2F8 */
X  volatile uint32_t SDIOCLKSEL;                         
N       uint8_t RESERVED_18[4];
N  __IO uint32_t SYSTICKCLKDIV;                     /**< SYSTICK clock divider, offset: 0x300 */
X  volatile uint32_t SYSTICKCLKDIV;                      
N  __IO uint32_t ARMTRCLKDIV;                       /**< ARM Trace clock divider, offset: 0x304 */
X  volatile uint32_t ARMTRCLKDIV;                        
N  __IO uint32_t CAN0CLKDIV;                        /**< MCAN0 clock divider, offset: 0x308 */
X  volatile uint32_t CAN0CLKDIV;                         
N  __IO uint32_t CAN1CLKDIV;                        /**< MCAN1 clock divider, offset: 0x30C */
X  volatile uint32_t CAN1CLKDIV;                         
N  __IO uint32_t SC0CLKDIV;                         /**< Smartcard0 clock divider, offset: 0x310 */
X  volatile uint32_t SC0CLKDIV;                          
N  __IO uint32_t SC1CLKDIV;                         /**< Smartcard1 clock divider, offset: 0x314 */
X  volatile uint32_t SC1CLKDIV;                          
N       uint8_t RESERVED_19[104];
N  __IO uint32_t AHBCLKDIV;                         /**< AHB clock divider, offset: 0x380 */
X  volatile uint32_t AHBCLKDIV;                          
N  __IO uint32_t CLKOUTDIV;                         /**< CLKOUT clock divider, offset: 0x384 */
X  volatile uint32_t CLKOUTDIV;                          
N  __IO uint32_t FROHFCLKDIV;                       /**< FROHF clock divider, offset: 0x388 */
X  volatile uint32_t FROHFCLKDIV;                        
N       uint8_t RESERVED_20[4];
N  __IO uint32_t SPIFICLKDIV;                       /**< SPIFI clock divider, offset: 0x390 */
X  volatile uint32_t SPIFICLKDIV;                        
N  __IO uint32_t ADCCLKDIV;                         /**< ADC clock divider, offset: 0x394 */
X  volatile uint32_t ADCCLKDIV;                          
N  __IO uint32_t USB0CLKDIV;                        /**< USB0 clock divider, offset: 0x398 */
X  volatile uint32_t USB0CLKDIV;                         
N  __IO uint32_t USB1CLKDIV;                        /**< USB1 clock divider, offset: 0x39C */
X  volatile uint32_t USB1CLKDIV;                         
N  __IO uint32_t FRGCTRL;                           /**< Fractional rate divider, offset: 0x3A0 */
X  volatile uint32_t FRGCTRL;                            
N       uint8_t RESERVED_21[4];
N  __IO uint32_t DMICCLKDIV;                        /**< DMIC clock divider, offset: 0x3A8 */
X  volatile uint32_t DMICCLKDIV;                         
N  __IO uint32_t MCLKDIV;                           /**< I2S MCLK clock divider, offset: 0x3AC */
X  volatile uint32_t MCLKDIV;                            
N  __IO uint32_t LCDCLKDIV;                         /**< LCD clock divider, offset: 0x3B0 */
X  volatile uint32_t LCDCLKDIV;                          
N  __IO uint32_t SCTCLKDIV;                         /**< SCT/PWM clock divider, offset: 0x3B4 */
X  volatile uint32_t SCTCLKDIV;                          
N  __IO uint32_t EMCCLKDIV;                         /**< EMC clock divider, offset: 0x3B8 */
X  volatile uint32_t EMCCLKDIV;                          
N  __IO uint32_t SDIOCLKDIV;                        /**< SDIO clock divider, offset: 0x3BC */
X  volatile uint32_t SDIOCLKDIV;                         
N       uint8_t RESERVED_22[64];
N  __IO uint32_t FLASHCFG;                          /**< Flash wait states configuration, offset: 0x400 */
X  volatile uint32_t FLASHCFG;                           
N       uint8_t RESERVED_23[8];
N  __IO uint32_t USB0CLKCTRL;                       /**< USB0 clock control, offset: 0x40C */
X  volatile uint32_t USB0CLKCTRL;                        
N  __IO uint32_t USB0CLKSTAT;                       /**< USB0 clock status, offset: 0x410 */
X  volatile uint32_t USB0CLKSTAT;                        
N       uint8_t RESERVED_24[4];
N  __IO uint32_t FREQMECTRL;                        /**< Frequency measure register, offset: 0x418 */
X  volatile uint32_t FREQMECTRL;                         
N       uint8_t RESERVED_25[4];
N  __IO uint32_t MCLKIO;                            /**< MCLK input/output control, offset: 0x420 */
X  volatile uint32_t MCLKIO;                             
N  __IO uint32_t USB1CLKCTRL;                       /**< USB1 clock control, offset: 0x424 */
X  volatile uint32_t USB1CLKCTRL;                        
N  __IO uint32_t USB1CLKSTAT;                       /**< USB1 clock status, offset: 0x428 */
X  volatile uint32_t USB1CLKSTAT;                        
N       uint8_t RESERVED_26[24];
N  __IO uint32_t EMCSYSCTRL;                        /**< EMC system control, offset: 0x444 */
X  volatile uint32_t EMCSYSCTRL;                         
N  __IO uint32_t EMCDLYCTRL;                        /**< EMC clock delay control, offset: 0x448 */
X  volatile uint32_t EMCDLYCTRL;                         
N  __IO uint32_t EMCDLYCAL;                         /**< EMC delay chain calibration control, offset: 0x44C */
X  volatile uint32_t EMCDLYCAL;                          
N  __IO uint32_t ETHPHYSEL;                         /**< Ethernet PHY Selection, offset: 0x450 */
X  volatile uint32_t ETHPHYSEL;                          
N  __IO uint32_t ETHSBDCTRL;                        /**< Ethernet SBD flow control, offset: 0x454 */
X  volatile uint32_t ETHSBDCTRL;                         
N       uint8_t RESERVED_27[8];
N  __IO uint32_t SDIOCLKCTRL;                       /**< SDIO CCLKIN phase and delay control, offset: 0x460 */
X  volatile uint32_t SDIOCLKCTRL;                        
N       uint8_t RESERVED_28[156];
N  __IO uint32_t FROCTRL;                           /**< FRO oscillator control, offset: 0x500 */
X  volatile uint32_t FROCTRL;                            
N  __IO uint32_t SYSOSCCTRL;                        /**< System oscillator control, offset: 0x504 */
X  volatile uint32_t SYSOSCCTRL;                         
N  __IO uint32_t WDTOSCCTRL;                        /**< Watchdog oscillator control, offset: 0x508 */
X  volatile uint32_t WDTOSCCTRL;                         
N  __IO uint32_t RTCOSCCTRL;                        /**< RTC oscillator 32 kHz output control, offset: 0x50C */
X  volatile uint32_t RTCOSCCTRL;                         
N       uint8_t RESERVED_29[12];
N  __IO uint32_t USBPLLCTRL;                        /**< USB PLL control, offset: 0x51C */
X  volatile uint32_t USBPLLCTRL;                         
N  __IO uint32_t USBPLLSTAT;                        /**< USB PLL status, offset: 0x520 */
X  volatile uint32_t USBPLLSTAT;                         
N       uint8_t RESERVED_30[92];
N  __IO uint32_t SYSPLLCTRL;                        /**< System PLL control, offset: 0x580 */
X  volatile uint32_t SYSPLLCTRL;                         
N  __IO uint32_t SYSPLLSTAT;                        /**< PLL status, offset: 0x584 */
X  volatile uint32_t SYSPLLSTAT;                         
N  __IO uint32_t SYSPLLNDEC;                        /**< PLL N divider, offset: 0x588 */
X  volatile uint32_t SYSPLLNDEC;                         
N  __IO uint32_t SYSPLLPDEC;                        /**< PLL P divider, offset: 0x58C */
X  volatile uint32_t SYSPLLPDEC;                         
N  __IO uint32_t SYSPLLMDEC;                        /**< System PLL M divider, offset: 0x590 */
X  volatile uint32_t SYSPLLMDEC;                         
N       uint8_t RESERVED_31[12];
N  __IO uint32_t AUDPLLCTRL;                        /**< Audio PLL control, offset: 0x5A0 */
X  volatile uint32_t AUDPLLCTRL;                         
N  __IO uint32_t AUDPLLSTAT;                        /**< Audio PLL status, offset: 0x5A4 */
X  volatile uint32_t AUDPLLSTAT;                         
N  __IO uint32_t AUDPLLNDEC;                        /**< Audio PLL N divider, offset: 0x5A8 */
X  volatile uint32_t AUDPLLNDEC;                         
N  __IO uint32_t AUDPLLPDEC;                        /**< Audio PLL P divider, offset: 0x5AC */
X  volatile uint32_t AUDPLLPDEC;                         
N  __IO uint32_t AUDPLLMDEC;                        /**< Audio PLL M divider, offset: 0x5B0 */
X  volatile uint32_t AUDPLLMDEC;                         
N  __IO uint32_t AUDPLLFRAC;                        /**< Audio PLL fractional divider control, offset: 0x5B4 */
X  volatile uint32_t AUDPLLFRAC;                         
N       uint8_t RESERVED_32[72];
N  __IO uint32_t PDSLEEPCFG[2];                     /**< Power configuration register 0, array offset: 0x600, array step: 0x4 */
X  volatile uint32_t PDSLEEPCFG[2];                      
N       uint8_t RESERVED_33[8];
N  __IO uint32_t PDRUNCFG[2];                       /**< Power configuration register 0, array offset: 0x610, array step: 0x4 */
X  volatile uint32_t PDRUNCFG[2];                        
N       uint8_t RESERVED_34[8];
N  __IO uint32_t PDRUNCFGSET[2];                    /**< Set bits in PDRUNCFG0, array offset: 0x620, array step: 0x4 */
X  volatile uint32_t PDRUNCFGSET[2];                     
N       uint8_t RESERVED_35[8];
N  __IO uint32_t PDRUNCFGCLR[2];                    /**< Clear bits in PDRUNCFG0, array offset: 0x630, array step: 0x4 */
X  volatile uint32_t PDRUNCFGCLR[2];                     
N       uint8_t RESERVED_36[72];
N  __IO uint32_t STARTER[2];                        /**< Start logic 0 wake-up enable register, array offset: 0x680, array step: 0x4 */
X  volatile uint32_t STARTER[2];                         
N       uint8_t RESERVED_37[24];
N  __O  uint32_t STARTERSET[2];                     /**< Set bits in STARTER, array offset: 0x6A0, array step: 0x4 */
X  volatile  uint32_t STARTERSET[2];                      
N       uint8_t RESERVED_38[24];
N  __O  uint32_t STARTERCLR[2];                     /**< Clear bits in STARTER0, array offset: 0x6C0, array step: 0x4 */
X  volatile  uint32_t STARTERCLR[2];                      
N       uint8_t RESERVED_39[184];
N  __IO uint32_t HWWAKE;                            /**< Configures special cases of hardware wake-up, offset: 0x780 */
X  volatile uint32_t HWWAKE;                             
N       uint8_t RESERVED_40[1664];
N  __IO uint32_t AUTOCGOR;                          /**< Auto Clock-Gate Override Register, offset: 0xE04 */
X  volatile uint32_t AUTOCGOR;                           
N       uint8_t RESERVED_41[492];
N  __I  uint32_t JTAGIDCODE;                        /**< JTAG ID code register, offset: 0xFF4 */
X  volatile const  uint32_t JTAGIDCODE;                         
N  __I  uint32_t DEVICE_ID0;                        /**< Part ID register, offset: 0xFF8 */
X  volatile const  uint32_t DEVICE_ID0;                         
N  __I  uint32_t DEVICE_ID1;                        /**< Boot ROM and die revision register, offset: 0xFFC */
X  volatile const  uint32_t DEVICE_ID1;                         
N       uint8_t RESERVED_42[127044];
N  __IO uint32_t BODCTRL;                           /**< Brown-Out Detect control, offset: 0x20044 */
X  volatile uint32_t BODCTRL;                            
N} SYSCON_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SYSCON Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SYSCON_Register_Masks SYSCON Register Masks
N * @{
N */
N
N/*! @name AHBMATPRIO - AHB multilayer matrix priority control */
N#define SYSCON_AHBMATPRIO_PRI_ICODE_MASK         (0x3U)
N#define SYSCON_AHBMATPRIO_PRI_ICODE_SHIFT        (0U)
N#define SYSCON_AHBMATPRIO_PRI_ICODE(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_ICODE_SHIFT)) & SYSCON_AHBMATPRIO_PRI_ICODE_MASK)
N#define SYSCON_AHBMATPRIO_PRI_DCODE_MASK         (0xCU)
N#define SYSCON_AHBMATPRIO_PRI_DCODE_SHIFT        (2U)
N#define SYSCON_AHBMATPRIO_PRI_DCODE(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_DCODE_SHIFT)) & SYSCON_AHBMATPRIO_PRI_DCODE_MASK)
N#define SYSCON_AHBMATPRIO_PRI_SYS_MASK           (0x30U)
N#define SYSCON_AHBMATPRIO_PRI_SYS_SHIFT          (4U)
N#define SYSCON_AHBMATPRIO_PRI_SYS(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_SYS_SHIFT)) & SYSCON_AHBMATPRIO_PRI_SYS_MASK)
N#define SYSCON_AHBMATPRIO_PRI_DMA_MASK           (0x3C0U)
N#define SYSCON_AHBMATPRIO_PRI_DMA_SHIFT          (6U)
N#define SYSCON_AHBMATPRIO_PRI_DMA(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_DMA_SHIFT)) & SYSCON_AHBMATPRIO_PRI_DMA_MASK)
N#define SYSCON_AHBMATPRIO_PRI_ETH_MASK           (0xC00U)
N#define SYSCON_AHBMATPRIO_PRI_ETH_SHIFT          (10U)
N#define SYSCON_AHBMATPRIO_PRI_ETH(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_ETH_SHIFT)) & SYSCON_AHBMATPRIO_PRI_ETH_MASK)
N#define SYSCON_AHBMATPRIO_PRI_LCD_MASK           (0x3000U)
N#define SYSCON_AHBMATPRIO_PRI_LCD_SHIFT          (12U)
N#define SYSCON_AHBMATPRIO_PRI_LCD(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_LCD_SHIFT)) & SYSCON_AHBMATPRIO_PRI_LCD_MASK)
N#define SYSCON_AHBMATPRIO_PRI_USB0_MASK          (0xC000U)
N#define SYSCON_AHBMATPRIO_PRI_USB0_SHIFT         (14U)
N#define SYSCON_AHBMATPRIO_PRI_USB0(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_USB0_SHIFT)) & SYSCON_AHBMATPRIO_PRI_USB0_MASK)
N#define SYSCON_AHBMATPRIO_PRI_USB1_MASK          (0x30000U)
N#define SYSCON_AHBMATPRIO_PRI_USB1_SHIFT         (16U)
N#define SYSCON_AHBMATPRIO_PRI_USB1(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_USB1_SHIFT)) & SYSCON_AHBMATPRIO_PRI_USB1_MASK)
N#define SYSCON_AHBMATPRIO_PRI_SDIO_MASK          (0xC0000U)
N#define SYSCON_AHBMATPRIO_PRI_SDIO_SHIFT         (18U)
N#define SYSCON_AHBMATPRIO_PRI_SDIO(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_SDIO_SHIFT)) & SYSCON_AHBMATPRIO_PRI_SDIO_MASK)
N#define SYSCON_AHBMATPRIO_PRI_MCAN1_MASK         (0x300000U)
N#define SYSCON_AHBMATPRIO_PRI_MCAN1_SHIFT        (20U)
N#define SYSCON_AHBMATPRIO_PRI_MCAN1(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_MCAN1_SHIFT)) & SYSCON_AHBMATPRIO_PRI_MCAN1_MASK)
N#define SYSCON_AHBMATPRIO_PRI_MCAN2_MASK         (0xC00000U)
N#define SYSCON_AHBMATPRIO_PRI_MCAN2_SHIFT        (22U)
N#define SYSCON_AHBMATPRIO_PRI_MCAN2(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_MCAN2_SHIFT)) & SYSCON_AHBMATPRIO_PRI_MCAN2_MASK)
N#define SYSCON_AHBMATPRIO_PRI_SHA_MASK           (0x3000000U)
N#define SYSCON_AHBMATPRIO_PRI_SHA_SHIFT          (24U)
N#define SYSCON_AHBMATPRIO_PRI_SHA(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBMATPRIO_PRI_SHA_SHIFT)) & SYSCON_AHBMATPRIO_PRI_SHA_MASK)
N
N/*! @name SYSTCKCAL - System tick counter calibration */
N#define SYSCON_SYSTCKCAL_CAL_MASK                (0xFFFFFFU)
N#define SYSCON_SYSTCKCAL_CAL_SHIFT               (0U)
N#define SYSCON_SYSTCKCAL_CAL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTCKCAL_CAL_SHIFT)) & SYSCON_SYSTCKCAL_CAL_MASK)
N#define SYSCON_SYSTCKCAL_SKEW_MASK               (0x1000000U)
N#define SYSCON_SYSTCKCAL_SKEW_SHIFT              (24U)
N#define SYSCON_SYSTCKCAL_SKEW(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTCKCAL_SKEW_SHIFT)) & SYSCON_SYSTCKCAL_SKEW_MASK)
N#define SYSCON_SYSTCKCAL_NOREF_MASK              (0x2000000U)
N#define SYSCON_SYSTCKCAL_NOREF_SHIFT             (25U)
N#define SYSCON_SYSTCKCAL_NOREF(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTCKCAL_NOREF_SHIFT)) & SYSCON_SYSTCKCAL_NOREF_MASK)
N
N/*! @name NMISRC - NMI Source Select */
N#define SYSCON_NMISRC_IRQM4_MASK                 (0x3FU)
N#define SYSCON_NMISRC_IRQM4_SHIFT                (0U)
N#define SYSCON_NMISRC_IRQM4(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_NMISRC_IRQM4_SHIFT)) & SYSCON_NMISRC_IRQM4_MASK)
N#define SYSCON_NMISRC_NMIENM4_MASK               (0x80000000U)
N#define SYSCON_NMISRC_NMIENM4_SHIFT              (31U)
N#define SYSCON_NMISRC_NMIENM4(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_NMISRC_NMIENM4_SHIFT)) & SYSCON_NMISRC_NMIENM4_MASK)
N
N/*! @name ASYNCAPBCTRL - Asynchronous APB Control */
N#define SYSCON_ASYNCAPBCTRL_ENABLE_MASK          (0x1U)
N#define SYSCON_ASYNCAPBCTRL_ENABLE_SHIFT         (0U)
N#define SYSCON_ASYNCAPBCTRL_ENABLE(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_ASYNCAPBCTRL_ENABLE_SHIFT)) & SYSCON_ASYNCAPBCTRL_ENABLE_MASK)
N
N/*! @name PIOPORCAP - POR captured value of port n */
N#define SYSCON_PIOPORCAP_PIOPORCAP_MASK          (0xFFFFFFFFU)
N#define SYSCON_PIOPORCAP_PIOPORCAP_SHIFT         (0U)
N#define SYSCON_PIOPORCAP_PIOPORCAP(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PIOPORCAP_PIOPORCAP_SHIFT)) & SYSCON_PIOPORCAP_PIOPORCAP_MASK)
N
N/* The count of SYSCON_PIOPORCAP */
N#define SYSCON_PIOPORCAP_COUNT                   (2U)
N
N/*! @name PIORESCAP - Reset captured value of port n */
N#define SYSCON_PIORESCAP_PIORESCAP_MASK          (0xFFFFFFFFU)
N#define SYSCON_PIORESCAP_PIORESCAP_SHIFT         (0U)
N#define SYSCON_PIORESCAP_PIORESCAP(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PIORESCAP_PIORESCAP_SHIFT)) & SYSCON_PIORESCAP_PIORESCAP_MASK)
N
N/* The count of SYSCON_PIORESCAP */
N#define SYSCON_PIORESCAP_COUNT                   (2U)
N
N/*! @name PRESETCTRL - Peripheral reset control n */
N#define SYSCON_PRESETCTRL_MRT_RST_MASK           (0x1U)
N#define SYSCON_PRESETCTRL_MRT_RST_SHIFT          (0U)
N#define SYSCON_PRESETCTRL_MRT_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_MRT_RST_SHIFT)) & SYSCON_PRESETCTRL_MRT_RST_MASK)
N#define SYSCON_PRESETCTRL_SCT0_RST_MASK          (0x4U)
N#define SYSCON_PRESETCTRL_SCT0_RST_SHIFT         (2U)
N#define SYSCON_PRESETCTRL_SCT0_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SCT0_RST_SHIFT)) & SYSCON_PRESETCTRL_SCT0_RST_MASK)
N#define SYSCON_PRESETCTRL_LCD_RST_MASK           (0x4U)
N#define SYSCON_PRESETCTRL_LCD_RST_SHIFT          (2U)
N#define SYSCON_PRESETCTRL_LCD_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_LCD_RST_SHIFT)) & SYSCON_PRESETCTRL_LCD_RST_MASK)
N#define SYSCON_PRESETCTRL_SDIO_RST_MASK          (0x8U)
N#define SYSCON_PRESETCTRL_SDIO_RST_SHIFT         (3U)
N#define SYSCON_PRESETCTRL_SDIO_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SDIO_RST_SHIFT)) & SYSCON_PRESETCTRL_SDIO_RST_MASK)
N#define SYSCON_PRESETCTRL_USB1H_RST_MASK         (0x10U)
N#define SYSCON_PRESETCTRL_USB1H_RST_SHIFT        (4U)
N#define SYSCON_PRESETCTRL_USB1H_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_USB1H_RST_SHIFT)) & SYSCON_PRESETCTRL_USB1H_RST_MASK)
N#define SYSCON_PRESETCTRL_USB1D_RST_MASK         (0x20U)
N#define SYSCON_PRESETCTRL_USB1D_RST_SHIFT        (5U)
N#define SYSCON_PRESETCTRL_USB1D_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_USB1D_RST_SHIFT)) & SYSCON_PRESETCTRL_USB1D_RST_MASK)
N#define SYSCON_PRESETCTRL_USB1RAM_RST_MASK       (0x40U)
N#define SYSCON_PRESETCTRL_USB1RAM_RST_SHIFT      (6U)
N#define SYSCON_PRESETCTRL_USB1RAM_RST(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_USB1RAM_RST_SHIFT)) & SYSCON_PRESETCTRL_USB1RAM_RST_MASK)
N#define SYSCON_PRESETCTRL_EMC_RESET_MASK         (0x80U)
N#define SYSCON_PRESETCTRL_EMC_RESET_SHIFT        (7U)
N#define SYSCON_PRESETCTRL_EMC_RESET(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_EMC_RESET_SHIFT)) & SYSCON_PRESETCTRL_EMC_RESET_MASK)
N#define SYSCON_PRESETCTRL_FLASH_RST_MASK         (0x80U)
N#define SYSCON_PRESETCTRL_FLASH_RST_SHIFT        (7U)
N#define SYSCON_PRESETCTRL_FLASH_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FLASH_RST_SHIFT)) & SYSCON_PRESETCTRL_FLASH_RST_MASK)
N#define SYSCON_PRESETCTRL_MCAN0_RST_MASK         (0x80U)
N#define SYSCON_PRESETCTRL_MCAN0_RST_SHIFT        (7U)
N#define SYSCON_PRESETCTRL_MCAN0_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_MCAN0_RST_SHIFT)) & SYSCON_PRESETCTRL_MCAN0_RST_MASK)
N#define SYSCON_PRESETCTRL_FMC_RST_MASK           (0x100U)
N#define SYSCON_PRESETCTRL_FMC_RST_SHIFT          (8U)
N#define SYSCON_PRESETCTRL_FMC_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FMC_RST_SHIFT)) & SYSCON_PRESETCTRL_FMC_RST_MASK)
N#define SYSCON_PRESETCTRL_ETH_RST_MASK           (0x100U)
N#define SYSCON_PRESETCTRL_ETH_RST_SHIFT          (8U)
N#define SYSCON_PRESETCTRL_ETH_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_ETH_RST_SHIFT)) & SYSCON_PRESETCTRL_ETH_RST_MASK)
N#define SYSCON_PRESETCTRL_MCAN1_RST_MASK         (0x100U)
N#define SYSCON_PRESETCTRL_MCAN1_RST_SHIFT        (8U)
N#define SYSCON_PRESETCTRL_MCAN1_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_MCAN1_RST_SHIFT)) & SYSCON_PRESETCTRL_MCAN1_RST_MASK)
N#define SYSCON_PRESETCTRL_GPIO4_RST_MASK         (0x200U)
N#define SYSCON_PRESETCTRL_GPIO4_RST_SHIFT        (9U)
N#define SYSCON_PRESETCTRL_GPIO4_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO4_RST_SHIFT)) & SYSCON_PRESETCTRL_GPIO4_RST_MASK)
N#define SYSCON_PRESETCTRL_EEPROM_RST_MASK        (0x200U)
N#define SYSCON_PRESETCTRL_EEPROM_RST_SHIFT       (9U)
N#define SYSCON_PRESETCTRL_EEPROM_RST(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_EEPROM_RST_SHIFT)) & SYSCON_PRESETCTRL_EEPROM_RST_MASK)
N#define SYSCON_PRESETCTRL_GPIO5_RST_MASK         (0x400U)
N#define SYSCON_PRESETCTRL_GPIO5_RST_SHIFT        (10U)
N#define SYSCON_PRESETCTRL_GPIO5_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO5_RST_SHIFT)) & SYSCON_PRESETCTRL_GPIO5_RST_MASK)
N#define SYSCON_PRESETCTRL_UTICK_RST_MASK         (0x400U)
N#define SYSCON_PRESETCTRL_UTICK_RST_SHIFT        (10U)
N#define SYSCON_PRESETCTRL_UTICK_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_UTICK_RST_SHIFT)) & SYSCON_PRESETCTRL_UTICK_RST_MASK)
N#define SYSCON_PRESETCTRL_SPIFI_RST_MASK         (0x400U)
N#define SYSCON_PRESETCTRL_SPIFI_RST_SHIFT        (10U)
N#define SYSCON_PRESETCTRL_SPIFI_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SPIFI_RST_SHIFT)) & SYSCON_PRESETCTRL_SPIFI_RST_MASK)
N#define SYSCON_PRESETCTRL_AES_RST_MASK           (0x800U)
N#define SYSCON_PRESETCTRL_AES_RST_SHIFT          (11U)
N#define SYSCON_PRESETCTRL_AES_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_AES_RST_SHIFT)) & SYSCON_PRESETCTRL_AES_RST_MASK)
N#define SYSCON_PRESETCTRL_MUX_RST_MASK           (0x800U)
N#define SYSCON_PRESETCTRL_MUX_RST_SHIFT          (11U)
N#define SYSCON_PRESETCTRL_MUX_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_MUX_RST_SHIFT)) & SYSCON_PRESETCTRL_MUX_RST_MASK)
N#define SYSCON_PRESETCTRL_FC0_RST_MASK           (0x800U)
N#define SYSCON_PRESETCTRL_FC0_RST_SHIFT          (11U)
N#define SYSCON_PRESETCTRL_FC0_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC0_RST_SHIFT)) & SYSCON_PRESETCTRL_FC0_RST_MASK)
N#define SYSCON_PRESETCTRL_OTP_RST_MASK           (0x1000U)
N#define SYSCON_PRESETCTRL_OTP_RST_SHIFT          (12U)
N#define SYSCON_PRESETCTRL_OTP_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_OTP_RST_SHIFT)) & SYSCON_PRESETCTRL_OTP_RST_MASK)
N#define SYSCON_PRESETCTRL_FC1_RST_MASK           (0x1000U)
N#define SYSCON_PRESETCTRL_FC1_RST_SHIFT          (12U)
N#define SYSCON_PRESETCTRL_FC1_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC1_RST_SHIFT)) & SYSCON_PRESETCTRL_FC1_RST_MASK)
N#define SYSCON_PRESETCTRL_IOCON_RST_MASK         (0x2000U)
N#define SYSCON_PRESETCTRL_IOCON_RST_SHIFT        (13U)
N#define SYSCON_PRESETCTRL_IOCON_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_IOCON_RST_SHIFT)) & SYSCON_PRESETCTRL_IOCON_RST_MASK)
N#define SYSCON_PRESETCTRL_RNG_RST_MASK           (0x2000U)
N#define SYSCON_PRESETCTRL_RNG_RST_SHIFT          (13U)
N#define SYSCON_PRESETCTRL_RNG_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_RNG_RST_SHIFT)) & SYSCON_PRESETCTRL_RNG_RST_MASK)
N#define SYSCON_PRESETCTRL_FC2_RST_MASK           (0x2000U)
N#define SYSCON_PRESETCTRL_FC2_RST_SHIFT          (13U)
N#define SYSCON_PRESETCTRL_FC2_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC2_RST_SHIFT)) & SYSCON_PRESETCTRL_FC2_RST_MASK)
N#define SYSCON_PRESETCTRL_FC8_RST_MASK           (0x4000U)
N#define SYSCON_PRESETCTRL_FC8_RST_SHIFT          (14U)
N#define SYSCON_PRESETCTRL_FC8_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC8_RST_SHIFT)) & SYSCON_PRESETCTRL_FC8_RST_MASK)
N#define SYSCON_PRESETCTRL_FC3_RST_MASK           (0x4000U)
N#define SYSCON_PRESETCTRL_FC3_RST_SHIFT          (14U)
N#define SYSCON_PRESETCTRL_FC3_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC3_RST_SHIFT)) & SYSCON_PRESETCTRL_FC3_RST_MASK)
N#define SYSCON_PRESETCTRL_GPIO0_RST_MASK         (0x4000U)
N#define SYSCON_PRESETCTRL_GPIO0_RST_SHIFT        (14U)
N#define SYSCON_PRESETCTRL_GPIO0_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO0_RST_SHIFT)) & SYSCON_PRESETCTRL_GPIO0_RST_MASK)
N#define SYSCON_PRESETCTRL_GPIO1_RST_MASK         (0x8000U)
N#define SYSCON_PRESETCTRL_GPIO1_RST_SHIFT        (15U)
N#define SYSCON_PRESETCTRL_GPIO1_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO1_RST_SHIFT)) & SYSCON_PRESETCTRL_GPIO1_RST_MASK)
N#define SYSCON_PRESETCTRL_FC9_RST_MASK           (0x8000U)
N#define SYSCON_PRESETCTRL_FC9_RST_SHIFT          (15U)
N#define SYSCON_PRESETCTRL_FC9_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC9_RST_SHIFT)) & SYSCON_PRESETCTRL_FC9_RST_MASK)
N#define SYSCON_PRESETCTRL_FC4_RST_MASK           (0x8000U)
N#define SYSCON_PRESETCTRL_FC4_RST_SHIFT          (15U)
N#define SYSCON_PRESETCTRL_FC4_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC4_RST_SHIFT)) & SYSCON_PRESETCTRL_FC4_RST_MASK)
N#define SYSCON_PRESETCTRL_USB0HMR_RST_MASK       (0x10000U)
N#define SYSCON_PRESETCTRL_USB0HMR_RST_SHIFT      (16U)
N#define SYSCON_PRESETCTRL_USB0HMR_RST(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_USB0HMR_RST_SHIFT)) & SYSCON_PRESETCTRL_USB0HMR_RST_MASK)
N#define SYSCON_PRESETCTRL_GPIO2_RST_MASK         (0x10000U)
N#define SYSCON_PRESETCTRL_GPIO2_RST_SHIFT        (16U)
N#define SYSCON_PRESETCTRL_GPIO2_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO2_RST_SHIFT)) & SYSCON_PRESETCTRL_GPIO2_RST_MASK)
N#define SYSCON_PRESETCTRL_FC5_RST_MASK           (0x10000U)
N#define SYSCON_PRESETCTRL_FC5_RST_SHIFT          (16U)
N#define SYSCON_PRESETCTRL_FC5_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC5_RST_SHIFT)) & SYSCON_PRESETCTRL_FC5_RST_MASK)
N#define SYSCON_PRESETCTRL_GPIO3_RST_MASK         (0x20000U)
N#define SYSCON_PRESETCTRL_GPIO3_RST_SHIFT        (17U)
N#define SYSCON_PRESETCTRL_GPIO3_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO3_RST_SHIFT)) & SYSCON_PRESETCTRL_GPIO3_RST_MASK)
N#define SYSCON_PRESETCTRL_FC6_RST_MASK           (0x20000U)
N#define SYSCON_PRESETCTRL_FC6_RST_SHIFT          (17U)
N#define SYSCON_PRESETCTRL_FC6_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC6_RST_SHIFT)) & SYSCON_PRESETCTRL_FC6_RST_MASK)
N#define SYSCON_PRESETCTRL_USB0HSL_RST_MASK       (0x20000U)
N#define SYSCON_PRESETCTRL_USB0HSL_RST_SHIFT      (17U)
N#define SYSCON_PRESETCTRL_USB0HSL_RST(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_USB0HSL_RST_SHIFT)) & SYSCON_PRESETCTRL_USB0HSL_RST_MASK)
N#define SYSCON_PRESETCTRL_FC7_RST_MASK           (0x40000U)
N#define SYSCON_PRESETCTRL_FC7_RST_SHIFT          (18U)
N#define SYSCON_PRESETCTRL_FC7_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FC7_RST_SHIFT)) & SYSCON_PRESETCTRL_FC7_RST_MASK)
N#define SYSCON_PRESETCTRL_SHA_RST_MASK           (0x40000U)
N#define SYSCON_PRESETCTRL_SHA_RST_SHIFT          (18U)
N#define SYSCON_PRESETCTRL_SHA_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SHA_RST_SHIFT)) & SYSCON_PRESETCTRL_SHA_RST_MASK)
N#define SYSCON_PRESETCTRL_PINT_RST_MASK          (0x40000U)
N#define SYSCON_PRESETCTRL_PINT_RST_SHIFT         (18U)
N#define SYSCON_PRESETCTRL_PINT_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_PINT_RST_SHIFT)) & SYSCON_PRESETCTRL_PINT_RST_MASK)
N#define SYSCON_PRESETCTRL_DMIC_RST_MASK          (0x80000U)
N#define SYSCON_PRESETCTRL_DMIC_RST_SHIFT         (19U)
N#define SYSCON_PRESETCTRL_DMIC_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_DMIC_RST_SHIFT)) & SYSCON_PRESETCTRL_DMIC_RST_MASK)
N#define SYSCON_PRESETCTRL_SC0_RST_MASK           (0x80000U)
N#define SYSCON_PRESETCTRL_SC0_RST_SHIFT          (19U)
N#define SYSCON_PRESETCTRL_SC0_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SC0_RST_SHIFT)) & SYSCON_PRESETCTRL_SC0_RST_MASK)
N#define SYSCON_PRESETCTRL_GINT_RST_MASK          (0x80000U)
N#define SYSCON_PRESETCTRL_GINT_RST_SHIFT         (19U)
N#define SYSCON_PRESETCTRL_GINT_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GINT_RST_SHIFT)) & SYSCON_PRESETCTRL_GINT_RST_MASK)
N#define SYSCON_PRESETCTRL_SC1_RST_MASK           (0x100000U)
N#define SYSCON_PRESETCTRL_SC1_RST_SHIFT          (20U)
N#define SYSCON_PRESETCTRL_SC1_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SC1_RST_SHIFT)) & SYSCON_PRESETCTRL_SC1_RST_MASK)
N#define SYSCON_PRESETCTRL_DMA0_RST_MASK          (0x100000U)
N#define SYSCON_PRESETCTRL_DMA0_RST_SHIFT         (20U)
N#define SYSCON_PRESETCTRL_DMA0_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_DMA0_RST_SHIFT)) & SYSCON_PRESETCTRL_DMA0_RST_MASK)
N#define SYSCON_PRESETCTRL_CRC_RST_MASK           (0x200000U)
N#define SYSCON_PRESETCTRL_CRC_RST_SHIFT          (21U)
N#define SYSCON_PRESETCTRL_CRC_RST(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_CRC_RST_SHIFT)) & SYSCON_PRESETCTRL_CRC_RST_MASK)
N#define SYSCON_PRESETCTRL_CTIMER2_RST_MASK       (0x400000U)
N#define SYSCON_PRESETCTRL_CTIMER2_RST_SHIFT      (22U)
N#define SYSCON_PRESETCTRL_CTIMER2_RST(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_CTIMER2_RST_SHIFT)) & SYSCON_PRESETCTRL_CTIMER2_RST_MASK)
N#define SYSCON_PRESETCTRL_WWDT_RST_MASK          (0x400000U)
N#define SYSCON_PRESETCTRL_WWDT_RST_SHIFT         (22U)
N#define SYSCON_PRESETCTRL_WWDT_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_WWDT_RST_SHIFT)) & SYSCON_PRESETCTRL_WWDT_RST_MASK)
N#define SYSCON_PRESETCTRL_USB0D_RST_MASK         (0x2000000U)
N#define SYSCON_PRESETCTRL_USB0D_RST_SHIFT        (25U)
N#define SYSCON_PRESETCTRL_USB0D_RST(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_USB0D_RST_SHIFT)) & SYSCON_PRESETCTRL_USB0D_RST_MASK)
N#define SYSCON_PRESETCTRL_CTIMER0_RST_MASK       (0x4000000U)
N#define SYSCON_PRESETCTRL_CTIMER0_RST_SHIFT      (26U)
N#define SYSCON_PRESETCTRL_CTIMER0_RST(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_CTIMER0_RST_SHIFT)) & SYSCON_PRESETCTRL_CTIMER0_RST_MASK)
N#define SYSCON_PRESETCTRL_ADC0_RST_MASK          (0x8000000U)
N#define SYSCON_PRESETCTRL_ADC0_RST_SHIFT         (27U)
N#define SYSCON_PRESETCTRL_ADC0_RST(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_ADC0_RST_SHIFT)) & SYSCON_PRESETCTRL_ADC0_RST_MASK)
N#define SYSCON_PRESETCTRL_CTIMER1_RST_MASK       (0x8000000U)
N#define SYSCON_PRESETCTRL_CTIMER1_RST_SHIFT      (27U)
N#define SYSCON_PRESETCTRL_CTIMER1_RST(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_CTIMER1_RST_SHIFT)) & SYSCON_PRESETCTRL_CTIMER1_RST_MASK)
N
N/* The count of SYSCON_PRESETCTRL */
N#define SYSCON_PRESETCTRL_COUNT                  (3U)
N
N/*! @name PRESETCTRLSET - Set bits in PRESETCTRLn */
N#define SYSCON_PRESETCTRLSET_RST_SET_MASK        (0xFFFFFFFFU)
N#define SYSCON_PRESETCTRLSET_RST_SET_SHIFT       (0U)
N#define SYSCON_PRESETCTRLSET_RST_SET(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRLSET_RST_SET_SHIFT)) & SYSCON_PRESETCTRLSET_RST_SET_MASK)
N
N/* The count of SYSCON_PRESETCTRLSET */
N#define SYSCON_PRESETCTRLSET_COUNT               (3U)
N
N/*! @name PRESETCTRLCLR - Clear bits in PRESETCTRLn */
N#define SYSCON_PRESETCTRLCLR_RST_CLR_MASK        (0xFFFFFFFFU)
N#define SYSCON_PRESETCTRLCLR_RST_CLR_SHIFT       (0U)
N#define SYSCON_PRESETCTRLCLR_RST_CLR(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRLCLR_RST_CLR_SHIFT)) & SYSCON_PRESETCTRLCLR_RST_CLR_MASK)
N
N/* The count of SYSCON_PRESETCTRLCLR */
N#define SYSCON_PRESETCTRLCLR_COUNT               (3U)
N
N/*! @name SYSRSTSTAT - System reset status register */
N#define SYSCON_SYSRSTSTAT_POR_MASK               (0x1U)
N#define SYSCON_SYSRSTSTAT_POR_SHIFT              (0U)
N#define SYSCON_SYSRSTSTAT_POR(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_POR_SHIFT)) & SYSCON_SYSRSTSTAT_POR_MASK)
N#define SYSCON_SYSRSTSTAT_EXTRST_MASK            (0x2U)
N#define SYSCON_SYSRSTSTAT_EXTRST_SHIFT           (1U)
N#define SYSCON_SYSRSTSTAT_EXTRST(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_EXTRST_SHIFT)) & SYSCON_SYSRSTSTAT_EXTRST_MASK)
N#define SYSCON_SYSRSTSTAT_WDT_MASK               (0x4U)
N#define SYSCON_SYSRSTSTAT_WDT_SHIFT              (2U)
N#define SYSCON_SYSRSTSTAT_WDT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_WDT_SHIFT)) & SYSCON_SYSRSTSTAT_WDT_MASK)
N#define SYSCON_SYSRSTSTAT_BOD_MASK               (0x8U)
N#define SYSCON_SYSRSTSTAT_BOD_SHIFT              (3U)
N#define SYSCON_SYSRSTSTAT_BOD(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_BOD_SHIFT)) & SYSCON_SYSRSTSTAT_BOD_MASK)
N#define SYSCON_SYSRSTSTAT_SYSRST_MASK            (0x10U)
N#define SYSCON_SYSRSTSTAT_SYSRST_SHIFT           (4U)
N#define SYSCON_SYSRSTSTAT_SYSRST(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_SYSRST_SHIFT)) & SYSCON_SYSRSTSTAT_SYSRST_MASK)
N
N/*! @name AHBCLKCTRL - AHB Clock control n */
N#define SYSCON_AHBCLKCTRL_MRT_MASK               (0x1U)
N#define SYSCON_AHBCLKCTRL_MRT_SHIFT              (0U)
N#define SYSCON_AHBCLKCTRL_MRT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_MRT_SHIFT)) & SYSCON_AHBCLKCTRL_MRT_MASK)
N#define SYSCON_AHBCLKCTRL_RIT_MASK               (0x2U)
N#define SYSCON_AHBCLKCTRL_RIT_SHIFT              (1U)
N#define SYSCON_AHBCLKCTRL_RIT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_RIT_SHIFT)) & SYSCON_AHBCLKCTRL_RIT_MASK)
N#define SYSCON_AHBCLKCTRL_ROM_MASK               (0x2U)
N#define SYSCON_AHBCLKCTRL_ROM_SHIFT              (1U)
N#define SYSCON_AHBCLKCTRL_ROM(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_ROM_SHIFT)) & SYSCON_AHBCLKCTRL_ROM_MASK)
N#define SYSCON_AHBCLKCTRL_SCT0_MASK              (0x4U)
N#define SYSCON_AHBCLKCTRL_SCT0_SHIFT             (2U)
N#define SYSCON_AHBCLKCTRL_SCT0(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SCT0_SHIFT)) & SYSCON_AHBCLKCTRL_SCT0_MASK)
N#define SYSCON_AHBCLKCTRL_LCD_MASK               (0x4U)
N#define SYSCON_AHBCLKCTRL_LCD_SHIFT              (2U)
N#define SYSCON_AHBCLKCTRL_LCD(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_LCD_SHIFT)) & SYSCON_AHBCLKCTRL_LCD_MASK)
N#define SYSCON_AHBCLKCTRL_SRAM1_MASK             (0x8U)
N#define SYSCON_AHBCLKCTRL_SRAM1_SHIFT            (3U)
N#define SYSCON_AHBCLKCTRL_SRAM1(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SRAM1_SHIFT)) & SYSCON_AHBCLKCTRL_SRAM1_MASK)
N#define SYSCON_AHBCLKCTRL_SDIO_MASK              (0x8U)
N#define SYSCON_AHBCLKCTRL_SDIO_SHIFT             (3U)
N#define SYSCON_AHBCLKCTRL_SDIO(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SDIO_SHIFT)) & SYSCON_AHBCLKCTRL_SDIO_MASK)
N#define SYSCON_AHBCLKCTRL_SRAM2_MASK             (0x10U)
N#define SYSCON_AHBCLKCTRL_SRAM2_SHIFT            (4U)
N#define SYSCON_AHBCLKCTRL_SRAM2(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SRAM2_SHIFT)) & SYSCON_AHBCLKCTRL_SRAM2_MASK)
N#define SYSCON_AHBCLKCTRL_USB1H_MASK             (0x10U)
N#define SYSCON_AHBCLKCTRL_USB1H_SHIFT            (4U)
N#define SYSCON_AHBCLKCTRL_USB1H(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_USB1H_SHIFT)) & SYSCON_AHBCLKCTRL_USB1H_MASK)
N#define SYSCON_AHBCLKCTRL_SRAM3_MASK             (0x20U)
N#define SYSCON_AHBCLKCTRL_SRAM3_SHIFT            (5U)
N#define SYSCON_AHBCLKCTRL_SRAM3(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SRAM3_SHIFT)) & SYSCON_AHBCLKCTRL_SRAM3_MASK)
N#define SYSCON_AHBCLKCTRL_USB1D_MASK             (0x20U)
N#define SYSCON_AHBCLKCTRL_USB1D_SHIFT            (5U)
N#define SYSCON_AHBCLKCTRL_USB1D(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_USB1D_SHIFT)) & SYSCON_AHBCLKCTRL_USB1D_MASK)
N#define SYSCON_AHBCLKCTRL_USB1RAM_MASK           (0x40U)
N#define SYSCON_AHBCLKCTRL_USB1RAM_SHIFT          (6U)
N#define SYSCON_AHBCLKCTRL_USB1RAM(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_USB1RAM_SHIFT)) & SYSCON_AHBCLKCTRL_USB1RAM_MASK)
N#define SYSCON_AHBCLKCTRL_FLASH_MASK             (0x80U)
N#define SYSCON_AHBCLKCTRL_FLASH_SHIFT            (7U)
N#define SYSCON_AHBCLKCTRL_FLASH(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLASH_SHIFT)) & SYSCON_AHBCLKCTRL_FLASH_MASK)
N#define SYSCON_AHBCLKCTRL_EMC_MASK               (0x80U)
N#define SYSCON_AHBCLKCTRL_EMC_SHIFT              (7U)
N#define SYSCON_AHBCLKCTRL_EMC(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_EMC_SHIFT)) & SYSCON_AHBCLKCTRL_EMC_MASK)
N#define SYSCON_AHBCLKCTRL_MCAN0_MASK             (0x80U)
N#define SYSCON_AHBCLKCTRL_MCAN0_SHIFT            (7U)
N#define SYSCON_AHBCLKCTRL_MCAN0(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_MCAN0_SHIFT)) & SYSCON_AHBCLKCTRL_MCAN0_MASK)
N#define SYSCON_AHBCLKCTRL_FMC_MASK               (0x100U)
N#define SYSCON_AHBCLKCTRL_FMC_SHIFT              (8U)
N#define SYSCON_AHBCLKCTRL_FMC(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FMC_SHIFT)) & SYSCON_AHBCLKCTRL_FMC_MASK)
N#define SYSCON_AHBCLKCTRL_ETH_MASK               (0x100U)
N#define SYSCON_AHBCLKCTRL_ETH_SHIFT              (8U)
N#define SYSCON_AHBCLKCTRL_ETH(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_ETH_SHIFT)) & SYSCON_AHBCLKCTRL_ETH_MASK)
N#define SYSCON_AHBCLKCTRL_MCAN1_MASK             (0x100U)
N#define SYSCON_AHBCLKCTRL_MCAN1_SHIFT            (8U)
N#define SYSCON_AHBCLKCTRL_MCAN1(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_MCAN1_SHIFT)) & SYSCON_AHBCLKCTRL_MCAN1_MASK)
N#define SYSCON_AHBCLKCTRL_EEPROM_MASK            (0x200U)
N#define SYSCON_AHBCLKCTRL_EEPROM_SHIFT           (9U)
N#define SYSCON_AHBCLKCTRL_EEPROM(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_EEPROM_SHIFT)) & SYSCON_AHBCLKCTRL_EEPROM_MASK)
N#define SYSCON_AHBCLKCTRL_GPIO4_MASK             (0x200U)
N#define SYSCON_AHBCLKCTRL_GPIO4_SHIFT            (9U)
N#define SYSCON_AHBCLKCTRL_GPIO4(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GPIO4_SHIFT)) & SYSCON_AHBCLKCTRL_GPIO4_MASK)
N#define SYSCON_AHBCLKCTRL_GPIO5_MASK             (0x400U)
N#define SYSCON_AHBCLKCTRL_GPIO5_SHIFT            (10U)
N#define SYSCON_AHBCLKCTRL_GPIO5(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GPIO5_SHIFT)) & SYSCON_AHBCLKCTRL_GPIO5_MASK)
N#define SYSCON_AHBCLKCTRL_UTICK_MASK             (0x400U)
N#define SYSCON_AHBCLKCTRL_UTICK_SHIFT            (10U)
N#define SYSCON_AHBCLKCTRL_UTICK(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_UTICK_SHIFT)) & SYSCON_AHBCLKCTRL_UTICK_MASK)
N#define SYSCON_AHBCLKCTRL_SPIFI_MASK             (0x400U)
N#define SYSCON_AHBCLKCTRL_SPIFI_SHIFT            (10U)
N#define SYSCON_AHBCLKCTRL_SPIFI(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SPIFI_SHIFT)) & SYSCON_AHBCLKCTRL_SPIFI_MASK)
N#define SYSCON_AHBCLKCTRL_INPUTMUX_MASK          (0x800U)
N#define SYSCON_AHBCLKCTRL_INPUTMUX_SHIFT         (11U)
N#define SYSCON_AHBCLKCTRL_INPUTMUX(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_INPUTMUX_SHIFT)) & SYSCON_AHBCLKCTRL_INPUTMUX_MASK)
N#define SYSCON_AHBCLKCTRL_AES_MASK               (0x800U)
N#define SYSCON_AHBCLKCTRL_AES_SHIFT              (11U)
N#define SYSCON_AHBCLKCTRL_AES(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_AES_SHIFT)) & SYSCON_AHBCLKCTRL_AES_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM0_MASK         (0x800U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM0_SHIFT        (11U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM0(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM0_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM0_MASK)
N#define SYSCON_AHBCLKCTRL_OTP_MASK               (0x1000U)
N#define SYSCON_AHBCLKCTRL_OTP_SHIFT              (12U)
N#define SYSCON_AHBCLKCTRL_OTP(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_OTP_SHIFT)) & SYSCON_AHBCLKCTRL_OTP_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM1_MASK         (0x1000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM1_SHIFT        (12U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM1(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM1_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM1_MASK)
N#define SYSCON_AHBCLKCTRL_RNG_MASK               (0x2000U)
N#define SYSCON_AHBCLKCTRL_RNG_SHIFT              (13U)
N#define SYSCON_AHBCLKCTRL_RNG(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_RNG_SHIFT)) & SYSCON_AHBCLKCTRL_RNG_MASK)
N#define SYSCON_AHBCLKCTRL_IOCON_MASK             (0x2000U)
N#define SYSCON_AHBCLKCTRL_IOCON_SHIFT            (13U)
N#define SYSCON_AHBCLKCTRL_IOCON(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_IOCON_SHIFT)) & SYSCON_AHBCLKCTRL_IOCON_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM2_MASK         (0x2000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM2_SHIFT        (13U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM2(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM2_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM2_MASK)
N#define SYSCON_AHBCLKCTRL_GPIO0_MASK             (0x4000U)
N#define SYSCON_AHBCLKCTRL_GPIO0_SHIFT            (14U)
N#define SYSCON_AHBCLKCTRL_GPIO0(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GPIO0_SHIFT)) & SYSCON_AHBCLKCTRL_GPIO0_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM3_MASK         (0x4000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM3_SHIFT        (14U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM3(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM3_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM3_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM8_MASK         (0x4000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM8_SHIFT        (14U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM8(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM8_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM8_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM9_MASK         (0x8000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM9_SHIFT        (15U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM9(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM9_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM9_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM4_MASK         (0x8000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM4_SHIFT        (15U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM4(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM4_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM4_MASK)
N#define SYSCON_AHBCLKCTRL_GPIO1_MASK             (0x8000U)
N#define SYSCON_AHBCLKCTRL_GPIO1_SHIFT            (15U)
N#define SYSCON_AHBCLKCTRL_GPIO1(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GPIO1_SHIFT)) & SYSCON_AHBCLKCTRL_GPIO1_MASK)
N#define SYSCON_AHBCLKCTRL_GPIO2_MASK             (0x10000U)
N#define SYSCON_AHBCLKCTRL_GPIO2_SHIFT            (16U)
N#define SYSCON_AHBCLKCTRL_GPIO2(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GPIO2_SHIFT)) & SYSCON_AHBCLKCTRL_GPIO2_MASK)
N#define SYSCON_AHBCLKCTRL_USB0HMR_MASK           (0x10000U)
N#define SYSCON_AHBCLKCTRL_USB0HMR_SHIFT          (16U)
N#define SYSCON_AHBCLKCTRL_USB0HMR(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_USB0HMR_SHIFT)) & SYSCON_AHBCLKCTRL_USB0HMR_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM5_MASK         (0x10000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM5_SHIFT        (16U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM5(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM5_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM5_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM6_MASK         (0x20000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM6_SHIFT        (17U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM6(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM6_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM6_MASK)
N#define SYSCON_AHBCLKCTRL_GPIO3_MASK             (0x20000U)
N#define SYSCON_AHBCLKCTRL_GPIO3_SHIFT            (17U)
N#define SYSCON_AHBCLKCTRL_GPIO3(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GPIO3_SHIFT)) & SYSCON_AHBCLKCTRL_GPIO3_MASK)
N#define SYSCON_AHBCLKCTRL_USB0HSL_MASK           (0x20000U)
N#define SYSCON_AHBCLKCTRL_USB0HSL_SHIFT          (17U)
N#define SYSCON_AHBCLKCTRL_USB0HSL(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_USB0HSL_SHIFT)) & SYSCON_AHBCLKCTRL_USB0HSL_MASK)
N#define SYSCON_AHBCLKCTRL_PINT_MASK              (0x40000U)
N#define SYSCON_AHBCLKCTRL_PINT_SHIFT             (18U)
N#define SYSCON_AHBCLKCTRL_PINT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_PINT_SHIFT)) & SYSCON_AHBCLKCTRL_PINT_MASK)
N#define SYSCON_AHBCLKCTRL_SHA0_MASK              (0x40000U)
N#define SYSCON_AHBCLKCTRL_SHA0_SHIFT             (18U)
N#define SYSCON_AHBCLKCTRL_SHA0(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SHA0_SHIFT)) & SYSCON_AHBCLKCTRL_SHA0_MASK)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM7_MASK         (0x40000U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM7_SHIFT        (18U)
N#define SYSCON_AHBCLKCTRL_FLEXCOMM7(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_FLEXCOMM7_SHIFT)) & SYSCON_AHBCLKCTRL_FLEXCOMM7_MASK)
N#define SYSCON_AHBCLKCTRL_DMIC_MASK              (0x80000U)
N#define SYSCON_AHBCLKCTRL_DMIC_SHIFT             (19U)
N#define SYSCON_AHBCLKCTRL_DMIC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_DMIC_SHIFT)) & SYSCON_AHBCLKCTRL_DMIC_MASK)
N#define SYSCON_AHBCLKCTRL_GINT_MASK              (0x80000U)
N#define SYSCON_AHBCLKCTRL_GINT_SHIFT             (19U)
N#define SYSCON_AHBCLKCTRL_GINT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_GINT_SHIFT)) & SYSCON_AHBCLKCTRL_GINT_MASK)
N#define SYSCON_AHBCLKCTRL_SC0_MASK               (0x80000U)
N#define SYSCON_AHBCLKCTRL_SC0_SHIFT              (19U)
N#define SYSCON_AHBCLKCTRL_SC0(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SC0_SHIFT)) & SYSCON_AHBCLKCTRL_SC0_MASK)
N#define SYSCON_AHBCLKCTRL_SC1_MASK               (0x100000U)
N#define SYSCON_AHBCLKCTRL_SC1_SHIFT              (20U)
N#define SYSCON_AHBCLKCTRL_SC1(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_SC1_SHIFT)) & SYSCON_AHBCLKCTRL_SC1_MASK)
N#define SYSCON_AHBCLKCTRL_DMA_MASK               (0x100000U)
N#define SYSCON_AHBCLKCTRL_DMA_SHIFT              (20U)
N#define SYSCON_AHBCLKCTRL_DMA(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_DMA_SHIFT)) & SYSCON_AHBCLKCTRL_DMA_MASK)
N#define SYSCON_AHBCLKCTRL_CRC_MASK               (0x200000U)
N#define SYSCON_AHBCLKCTRL_CRC_SHIFT              (21U)
N#define SYSCON_AHBCLKCTRL_CRC(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_CRC_SHIFT)) & SYSCON_AHBCLKCTRL_CRC_MASK)
N#define SYSCON_AHBCLKCTRL_WWDT_MASK              (0x400000U)
N#define SYSCON_AHBCLKCTRL_WWDT_SHIFT             (22U)
N#define SYSCON_AHBCLKCTRL_WWDT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_WWDT_SHIFT)) & SYSCON_AHBCLKCTRL_WWDT_MASK)
N#define SYSCON_AHBCLKCTRL_CTIMER2_MASK           (0x400000U)
N#define SYSCON_AHBCLKCTRL_CTIMER2_SHIFT          (22U)
N#define SYSCON_AHBCLKCTRL_CTIMER2(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_CTIMER2_SHIFT)) & SYSCON_AHBCLKCTRL_CTIMER2_MASK)
N#define SYSCON_AHBCLKCTRL_RTC_MASK               (0x800000U)
N#define SYSCON_AHBCLKCTRL_RTC_SHIFT              (23U)
N#define SYSCON_AHBCLKCTRL_RTC(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_RTC_SHIFT)) & SYSCON_AHBCLKCTRL_RTC_MASK)
N#define SYSCON_AHBCLKCTRL_USB0D_MASK             (0x2000000U)
N#define SYSCON_AHBCLKCTRL_USB0D_SHIFT            (25U)
N#define SYSCON_AHBCLKCTRL_USB0D(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_USB0D_SHIFT)) & SYSCON_AHBCLKCTRL_USB0D_MASK)
N#define SYSCON_AHBCLKCTRL_CTIMER0_MASK           (0x4000000U)
N#define SYSCON_AHBCLKCTRL_CTIMER0_SHIFT          (26U)
N#define SYSCON_AHBCLKCTRL_CTIMER0(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_CTIMER0_SHIFT)) & SYSCON_AHBCLKCTRL_CTIMER0_MASK)
N#define SYSCON_AHBCLKCTRL_CTIMER1_MASK           (0x8000000U)
N#define SYSCON_AHBCLKCTRL_CTIMER1_SHIFT          (27U)
N#define SYSCON_AHBCLKCTRL_CTIMER1(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_CTIMER1_SHIFT)) & SYSCON_AHBCLKCTRL_CTIMER1_MASK)
N#define SYSCON_AHBCLKCTRL_ADC0_MASK              (0x8000000U)
N#define SYSCON_AHBCLKCTRL_ADC0_SHIFT             (27U)
N#define SYSCON_AHBCLKCTRL_ADC0(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRL_ADC0_SHIFT)) & SYSCON_AHBCLKCTRL_ADC0_MASK)
N
N/* The count of SYSCON_AHBCLKCTRL */
N#define SYSCON_AHBCLKCTRL_COUNT                  (3U)
N
N/*! @name AHBCLKCTRLSET - Set bits in AHBCLKCTRLn */
N#define SYSCON_AHBCLKCTRLSET_CLK_SET_MASK        (0xFFFFFFFFU)
N#define SYSCON_AHBCLKCTRLSET_CLK_SET_SHIFT       (0U)
N#define SYSCON_AHBCLKCTRLSET_CLK_SET(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRLSET_CLK_SET_SHIFT)) & SYSCON_AHBCLKCTRLSET_CLK_SET_MASK)
N
N/* The count of SYSCON_AHBCLKCTRLSET */
N#define SYSCON_AHBCLKCTRLSET_COUNT               (3U)
N
N/*! @name AHBCLKCTRLCLR - Clear bits in AHBCLKCTRLn */
N#define SYSCON_AHBCLKCTRLCLR_CLK_CLR_MASK        (0xFFFFFFFFU)
N#define SYSCON_AHBCLKCTRLCLR_CLK_CLR_SHIFT       (0U)
N#define SYSCON_AHBCLKCTRLCLR_CLK_CLR(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKCTRLCLR_CLK_CLR_SHIFT)) & SYSCON_AHBCLKCTRLCLR_CLK_CLR_MASK)
N
N/* The count of SYSCON_AHBCLKCTRLCLR */
N#define SYSCON_AHBCLKCTRLCLR_COUNT               (3U)
N
N/*! @name MAINCLKSELA - Main clock source select A */
N#define SYSCON_MAINCLKSELA_SEL_MASK              (0x3U)
N#define SYSCON_MAINCLKSELA_SEL_SHIFT             (0U)
N#define SYSCON_MAINCLKSELA_SEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_MAINCLKSELA_SEL_SHIFT)) & SYSCON_MAINCLKSELA_SEL_MASK)
N
N/*! @name MAINCLKSELB - Main clock source select B */
N#define SYSCON_MAINCLKSELB_SEL_MASK              (0x3U)
N#define SYSCON_MAINCLKSELB_SEL_SHIFT             (0U)
N#define SYSCON_MAINCLKSELB_SEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_MAINCLKSELB_SEL_SHIFT)) & SYSCON_MAINCLKSELB_SEL_MASK)
N
N/*! @name CLKOUTSELA - CLKOUT clock source select A */
N#define SYSCON_CLKOUTSELA_SEL_MASK               (0x7U)
N#define SYSCON_CLKOUTSELA_SEL_SHIFT              (0U)
N#define SYSCON_CLKOUTSELA_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTSELA_SEL_SHIFT)) & SYSCON_CLKOUTSELA_SEL_MASK)
N
N/*! @name SYSPLLCLKSEL - PLL clock source select */
N#define SYSCON_SYSPLLCLKSEL_SEL_MASK             (0x7U)
N#define SYSCON_SYSPLLCLKSEL_SEL_SHIFT            (0U)
N#define SYSCON_SYSPLLCLKSEL_SEL(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCLKSEL_SEL_SHIFT)) & SYSCON_SYSPLLCLKSEL_SEL_MASK)
N
N/*! @name AUDPLLCLKSEL - Audio PLL clock source select */
N#define SYSCON_AUDPLLCLKSEL_SEL_MASK             (0x7U)
N#define SYSCON_AUDPLLCLKSEL_SEL_SHIFT            (0U)
N#define SYSCON_AUDPLLCLKSEL_SEL(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCLKSEL_SEL_SHIFT)) & SYSCON_AUDPLLCLKSEL_SEL_MASK)
N
N/*! @name SPIFICLKSEL - SPIFI clock source select */
N#define SYSCON_SPIFICLKSEL_SEL_MASK              (0x7U)
N#define SYSCON_SPIFICLKSEL_SEL_SHIFT             (0U)
N#define SYSCON_SPIFICLKSEL_SEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SPIFICLKSEL_SEL_SHIFT)) & SYSCON_SPIFICLKSEL_SEL_MASK)
N
N/*! @name ADCCLKSEL - ADC clock source select */
N#define SYSCON_ADCCLKSEL_SEL_MASK                (0x7U)
N#define SYSCON_ADCCLKSEL_SEL_SHIFT               (0U)
N#define SYSCON_ADCCLKSEL_SEL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_ADCCLKSEL_SEL_SHIFT)) & SYSCON_ADCCLKSEL_SEL_MASK)
N
N/*! @name USB0CLKSEL - USB0 clock source select */
N#define SYSCON_USB0CLKSEL_SEL_MASK               (0x7U)
N#define SYSCON_USB0CLKSEL_SEL_SHIFT              (0U)
N#define SYSCON_USB0CLKSEL_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKSEL_SEL_SHIFT)) & SYSCON_USB0CLKSEL_SEL_MASK)
N
N/*! @name USB1CLKSEL - USB1 clock source select */
N#define SYSCON_USB1CLKSEL_SEL_MASK               (0x7U)
N#define SYSCON_USB1CLKSEL_SEL_SHIFT              (0U)
N#define SYSCON_USB1CLKSEL_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKSEL_SEL_SHIFT)) & SYSCON_USB1CLKSEL_SEL_MASK)
N
N/*! @name FCLKSEL - Flexcomm 0 clock source select */
N#define SYSCON_FCLKSEL_SEL_MASK                  (0x7U)
N#define SYSCON_FCLKSEL_SEL_SHIFT                 (0U)
N#define SYSCON_FCLKSEL_SEL(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_FCLKSEL_SEL_SHIFT)) & SYSCON_FCLKSEL_SEL_MASK)
N
N/* The count of SYSCON_FCLKSEL */
N#define SYSCON_FCLKSEL_COUNT                     (10U)
N
N/*! @name MCLKCLKSEL - MCLK clock source select */
N#define SYSCON_MCLKCLKSEL_SEL_MASK               (0x7U)
N#define SYSCON_MCLKCLKSEL_SEL_SHIFT              (0U)
N#define SYSCON_MCLKCLKSEL_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_MCLKCLKSEL_SEL_SHIFT)) & SYSCON_MCLKCLKSEL_SEL_MASK)
N
N/*! @name FRGCLKSEL - Fractional Rate Generator clock source select */
N#define SYSCON_FRGCLKSEL_SEL_MASK                (0x7U)
N#define SYSCON_FRGCLKSEL_SEL_SHIFT               (0U)
N#define SYSCON_FRGCLKSEL_SEL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_FRGCLKSEL_SEL_SHIFT)) & SYSCON_FRGCLKSEL_SEL_MASK)
N
N/*! @name DMICCLKSEL - Digital microphone (DMIC) subsystem clock select */
N#define SYSCON_DMICCLKSEL_SEL_MASK               (0x7U)
N#define SYSCON_DMICCLKSEL_SEL_SHIFT              (0U)
N#define SYSCON_DMICCLKSEL_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_DMICCLKSEL_SEL_SHIFT)) & SYSCON_DMICCLKSEL_SEL_MASK)
N
N/*! @name SCTCLKSEL - SCTimer/PWM clock source select */
N#define SYSCON_SCTCLKSEL_SEL_MASK                (0x7U)
N#define SYSCON_SCTCLKSEL_SEL_SHIFT               (0U)
N#define SYSCON_SCTCLKSEL_SEL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_SCTCLKSEL_SEL_SHIFT)) & SYSCON_SCTCLKSEL_SEL_MASK)
N
N/*! @name LCDCLKSEL - LCD clock source select */
N#define SYSCON_LCDCLKSEL_SEL_MASK                (0x3U)
N#define SYSCON_LCDCLKSEL_SEL_SHIFT               (0U)
N#define SYSCON_LCDCLKSEL_SEL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_LCDCLKSEL_SEL_SHIFT)) & SYSCON_LCDCLKSEL_SEL_MASK)
N
N/*! @name SDIOCLKSEL - SDIO clock source select */
N#define SYSCON_SDIOCLKSEL_SEL_MASK               (0x7U)
N#define SYSCON_SDIOCLKSEL_SEL_SHIFT              (0U)
N#define SYSCON_SDIOCLKSEL_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKSEL_SEL_SHIFT)) & SYSCON_SDIOCLKSEL_SEL_MASK)
N
N/*! @name SYSTICKCLKDIV - SYSTICK clock divider */
N#define SYSCON_SYSTICKCLKDIV_DIV_MASK            (0xFFU)
N#define SYSCON_SYSTICKCLKDIV_DIV_SHIFT           (0U)
N#define SYSCON_SYSTICKCLKDIV_DIV(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTICKCLKDIV_DIV_SHIFT)) & SYSCON_SYSTICKCLKDIV_DIV_MASK)
N#define SYSCON_SYSTICKCLKDIV_RESET_MASK          (0x20000000U)
N#define SYSCON_SYSTICKCLKDIV_RESET_SHIFT         (29U)
N#define SYSCON_SYSTICKCLKDIV_RESET(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTICKCLKDIV_RESET_SHIFT)) & SYSCON_SYSTICKCLKDIV_RESET_MASK)
N#define SYSCON_SYSTICKCLKDIV_HALT_MASK           (0x40000000U)
N#define SYSCON_SYSTICKCLKDIV_HALT_SHIFT          (30U)
N#define SYSCON_SYSTICKCLKDIV_HALT(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTICKCLKDIV_HALT_SHIFT)) & SYSCON_SYSTICKCLKDIV_HALT_MASK)
N#define SYSCON_SYSTICKCLKDIV_REQFLAG_MASK        (0x80000000U)
N#define SYSCON_SYSTICKCLKDIV_REQFLAG_SHIFT       (31U)
N#define SYSCON_SYSTICKCLKDIV_REQFLAG(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTICKCLKDIV_REQFLAG_SHIFT)) & SYSCON_SYSTICKCLKDIV_REQFLAG_MASK)
N
N/*! @name ARMTRCLKDIV - ARM Trace clock divider */
N#define SYSCON_ARMTRCLKDIV_DIV_MASK              (0xFFU)
N#define SYSCON_ARMTRCLKDIV_DIV_SHIFT             (0U)
N#define SYSCON_ARMTRCLKDIV_DIV(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_ARMTRCLKDIV_DIV_SHIFT)) & SYSCON_ARMTRCLKDIV_DIV_MASK)
N#define SYSCON_ARMTRCLKDIV_RESET_MASK            (0x20000000U)
N#define SYSCON_ARMTRCLKDIV_RESET_SHIFT           (29U)
N#define SYSCON_ARMTRCLKDIV_RESET(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_ARMTRCLKDIV_RESET_SHIFT)) & SYSCON_ARMTRCLKDIV_RESET_MASK)
N#define SYSCON_ARMTRCLKDIV_HALT_MASK             (0x40000000U)
N#define SYSCON_ARMTRCLKDIV_HALT_SHIFT            (30U)
N#define SYSCON_ARMTRCLKDIV_HALT(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_ARMTRCLKDIV_HALT_SHIFT)) & SYSCON_ARMTRCLKDIV_HALT_MASK)
N#define SYSCON_ARMTRCLKDIV_REQFLAG_MASK          (0x80000000U)
N#define SYSCON_ARMTRCLKDIV_REQFLAG_SHIFT         (31U)
N#define SYSCON_ARMTRCLKDIV_REQFLAG(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_ARMTRCLKDIV_REQFLAG_SHIFT)) & SYSCON_ARMTRCLKDIV_REQFLAG_MASK)
N
N/*! @name CAN0CLKDIV - MCAN0 clock divider */
N#define SYSCON_CAN0CLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_CAN0CLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_CAN0CLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN0CLKDIV_DIV_SHIFT)) & SYSCON_CAN0CLKDIV_DIV_MASK)
N#define SYSCON_CAN0CLKDIV_RESET_MASK             (0x20000000U)
N#define SYSCON_CAN0CLKDIV_RESET_SHIFT            (29U)
N#define SYSCON_CAN0CLKDIV_RESET(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN0CLKDIV_RESET_SHIFT)) & SYSCON_CAN0CLKDIV_RESET_MASK)
N#define SYSCON_CAN0CLKDIV_HALT_MASK              (0x40000000U)
N#define SYSCON_CAN0CLKDIV_HALT_SHIFT             (30U)
N#define SYSCON_CAN0CLKDIV_HALT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN0CLKDIV_HALT_SHIFT)) & SYSCON_CAN0CLKDIV_HALT_MASK)
N#define SYSCON_CAN0CLKDIV_REQFLAG_MASK           (0x80000000U)
N#define SYSCON_CAN0CLKDIV_REQFLAG_SHIFT          (31U)
N#define SYSCON_CAN0CLKDIV_REQFLAG(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN0CLKDIV_REQFLAG_SHIFT)) & SYSCON_CAN0CLKDIV_REQFLAG_MASK)
N
N/*! @name CAN1CLKDIV - MCAN1 clock divider */
N#define SYSCON_CAN1CLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_CAN1CLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_CAN1CLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN1CLKDIV_DIV_SHIFT)) & SYSCON_CAN1CLKDIV_DIV_MASK)
N#define SYSCON_CAN1CLKDIV_RESET_MASK             (0x20000000U)
N#define SYSCON_CAN1CLKDIV_RESET_SHIFT            (29U)
N#define SYSCON_CAN1CLKDIV_RESET(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN1CLKDIV_RESET_SHIFT)) & SYSCON_CAN1CLKDIV_RESET_MASK)
N#define SYSCON_CAN1CLKDIV_HALT_MASK              (0x40000000U)
N#define SYSCON_CAN1CLKDIV_HALT_SHIFT             (30U)
N#define SYSCON_CAN1CLKDIV_HALT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN1CLKDIV_HALT_SHIFT)) & SYSCON_CAN1CLKDIV_HALT_MASK)
N#define SYSCON_CAN1CLKDIV_REQFLAG_MASK           (0x80000000U)
N#define SYSCON_CAN1CLKDIV_REQFLAG_SHIFT          (31U)
N#define SYSCON_CAN1CLKDIV_REQFLAG(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_CAN1CLKDIV_REQFLAG_SHIFT)) & SYSCON_CAN1CLKDIV_REQFLAG_MASK)
N
N/*! @name SC0CLKDIV - Smartcard0 clock divider */
N#define SYSCON_SC0CLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_SC0CLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_SC0CLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_SC0CLKDIV_DIV_SHIFT)) & SYSCON_SC0CLKDIV_DIV_MASK)
N#define SYSCON_SC0CLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_SC0CLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_SC0CLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SC0CLKDIV_RESET_SHIFT)) & SYSCON_SC0CLKDIV_RESET_MASK)
N#define SYSCON_SC0CLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_SC0CLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_SC0CLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SC0CLKDIV_HALT_SHIFT)) & SYSCON_SC0CLKDIV_HALT_MASK)
N#define SYSCON_SC0CLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_SC0CLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_SC0CLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SC0CLKDIV_REQFLAG_SHIFT)) & SYSCON_SC0CLKDIV_REQFLAG_MASK)
N
N/*! @name SC1CLKDIV - Smartcard1 clock divider */
N#define SYSCON_SC1CLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_SC1CLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_SC1CLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_SC1CLKDIV_DIV_SHIFT)) & SYSCON_SC1CLKDIV_DIV_MASK)
N#define SYSCON_SC1CLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_SC1CLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_SC1CLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SC1CLKDIV_RESET_SHIFT)) & SYSCON_SC1CLKDIV_RESET_MASK)
N#define SYSCON_SC1CLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_SC1CLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_SC1CLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SC1CLKDIV_HALT_SHIFT)) & SYSCON_SC1CLKDIV_HALT_MASK)
N#define SYSCON_SC1CLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_SC1CLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_SC1CLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SC1CLKDIV_REQFLAG_SHIFT)) & SYSCON_SC1CLKDIV_REQFLAG_MASK)
N
N/*! @name AHBCLKDIV - AHB clock divider */
N#define SYSCON_AHBCLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_AHBCLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_AHBCLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKDIV_DIV_SHIFT)) & SYSCON_AHBCLKDIV_DIV_MASK)
N#define SYSCON_AHBCLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_AHBCLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_AHBCLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKDIV_RESET_SHIFT)) & SYSCON_AHBCLKDIV_RESET_MASK)
N#define SYSCON_AHBCLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_AHBCLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_AHBCLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKDIV_HALT_SHIFT)) & SYSCON_AHBCLKDIV_HALT_MASK)
N#define SYSCON_AHBCLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_AHBCLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_AHBCLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_AHBCLKDIV_REQFLAG_SHIFT)) & SYSCON_AHBCLKDIV_REQFLAG_MASK)
N
N/*! @name CLKOUTDIV - CLKOUT clock divider */
N#define SYSCON_CLKOUTDIV_DIV_MASK                (0xFFU)
N#define SYSCON_CLKOUTDIV_DIV_SHIFT               (0U)
N#define SYSCON_CLKOUTDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTDIV_DIV_SHIFT)) & SYSCON_CLKOUTDIV_DIV_MASK)
N#define SYSCON_CLKOUTDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_CLKOUTDIV_RESET_SHIFT             (29U)
N#define SYSCON_CLKOUTDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTDIV_RESET_SHIFT)) & SYSCON_CLKOUTDIV_RESET_MASK)
N#define SYSCON_CLKOUTDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_CLKOUTDIV_HALT_SHIFT              (30U)
N#define SYSCON_CLKOUTDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTDIV_HALT_SHIFT)) & SYSCON_CLKOUTDIV_HALT_MASK)
N#define SYSCON_CLKOUTDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_CLKOUTDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_CLKOUTDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTDIV_REQFLAG_SHIFT)) & SYSCON_CLKOUTDIV_REQFLAG_MASK)
N
N/*! @name FROHFCLKDIV - FROHF clock divider */
N#define SYSCON_FROHFCLKDIV_DIV_MASK              (0xFFU)
N#define SYSCON_FROHFCLKDIV_DIV_SHIFT             (0U)
N#define SYSCON_FROHFCLKDIV_DIV(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_FROHFCLKDIV_DIV_SHIFT)) & SYSCON_FROHFCLKDIV_DIV_MASK)
N#define SYSCON_FROHFCLKDIV_RESET_MASK            (0x20000000U)
N#define SYSCON_FROHFCLKDIV_RESET_SHIFT           (29U)
N#define SYSCON_FROHFCLKDIV_RESET(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_FROHFCLKDIV_RESET_SHIFT)) & SYSCON_FROHFCLKDIV_RESET_MASK)
N#define SYSCON_FROHFCLKDIV_HALT_MASK             (0x40000000U)
N#define SYSCON_FROHFCLKDIV_HALT_SHIFT            (30U)
N#define SYSCON_FROHFCLKDIV_HALT(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_FROHFCLKDIV_HALT_SHIFT)) & SYSCON_FROHFCLKDIV_HALT_MASK)
N#define SYSCON_FROHFCLKDIV_REQFLAG_MASK          (0x80000000U)
N#define SYSCON_FROHFCLKDIV_REQFLAG_SHIFT         (31U)
N#define SYSCON_FROHFCLKDIV_REQFLAG(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_FROHFCLKDIV_REQFLAG_SHIFT)) & SYSCON_FROHFCLKDIV_REQFLAG_MASK)
N
N/*! @name SPIFICLKDIV - SPIFI clock divider */
N#define SYSCON_SPIFICLKDIV_DIV_MASK              (0xFFU)
N#define SYSCON_SPIFICLKDIV_DIV_SHIFT             (0U)
N#define SYSCON_SPIFICLKDIV_DIV(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SPIFICLKDIV_DIV_SHIFT)) & SYSCON_SPIFICLKDIV_DIV_MASK)
N#define SYSCON_SPIFICLKDIV_RESET_MASK            (0x20000000U)
N#define SYSCON_SPIFICLKDIV_RESET_SHIFT           (29U)
N#define SYSCON_SPIFICLKDIV_RESET(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SPIFICLKDIV_RESET_SHIFT)) & SYSCON_SPIFICLKDIV_RESET_MASK)
N#define SYSCON_SPIFICLKDIV_HALT_MASK             (0x40000000U)
N#define SYSCON_SPIFICLKDIV_HALT_SHIFT            (30U)
N#define SYSCON_SPIFICLKDIV_HALT(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_SPIFICLKDIV_HALT_SHIFT)) & SYSCON_SPIFICLKDIV_HALT_MASK)
N#define SYSCON_SPIFICLKDIV_REQFLAG_MASK          (0x80000000U)
N#define SYSCON_SPIFICLKDIV_REQFLAG_SHIFT         (31U)
N#define SYSCON_SPIFICLKDIV_REQFLAG(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SPIFICLKDIV_REQFLAG_SHIFT)) & SYSCON_SPIFICLKDIV_REQFLAG_MASK)
N
N/*! @name ADCCLKDIV - ADC clock divider */
N#define SYSCON_ADCCLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_ADCCLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_ADCCLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_ADCCLKDIV_DIV_SHIFT)) & SYSCON_ADCCLKDIV_DIV_MASK)
N#define SYSCON_ADCCLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_ADCCLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_ADCCLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_ADCCLKDIV_RESET_SHIFT)) & SYSCON_ADCCLKDIV_RESET_MASK)
N#define SYSCON_ADCCLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_ADCCLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_ADCCLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_ADCCLKDIV_HALT_SHIFT)) & SYSCON_ADCCLKDIV_HALT_MASK)
N#define SYSCON_ADCCLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_ADCCLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_ADCCLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_ADCCLKDIV_REQFLAG_SHIFT)) & SYSCON_ADCCLKDIV_REQFLAG_MASK)
N
N/*! @name USB0CLKDIV - USB0 clock divider */
N#define SYSCON_USB0CLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_USB0CLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_USB0CLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKDIV_DIV_SHIFT)) & SYSCON_USB0CLKDIV_DIV_MASK)
N#define SYSCON_USB0CLKDIV_RESET_MASK             (0x20000000U)
N#define SYSCON_USB0CLKDIV_RESET_SHIFT            (29U)
N#define SYSCON_USB0CLKDIV_RESET(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKDIV_RESET_SHIFT)) & SYSCON_USB0CLKDIV_RESET_MASK)
N#define SYSCON_USB0CLKDIV_HALT_MASK              (0x40000000U)
N#define SYSCON_USB0CLKDIV_HALT_SHIFT             (30U)
N#define SYSCON_USB0CLKDIV_HALT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKDIV_HALT_SHIFT)) & SYSCON_USB0CLKDIV_HALT_MASK)
N#define SYSCON_USB0CLKDIV_REQFLAG_MASK           (0x80000000U)
N#define SYSCON_USB0CLKDIV_REQFLAG_SHIFT          (31U)
N#define SYSCON_USB0CLKDIV_REQFLAG(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKDIV_REQFLAG_SHIFT)) & SYSCON_USB0CLKDIV_REQFLAG_MASK)
N
N/*! @name USB1CLKDIV - USB1 clock divider */
N#define SYSCON_USB1CLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_USB1CLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_USB1CLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKDIV_DIV_SHIFT)) & SYSCON_USB1CLKDIV_DIV_MASK)
N#define SYSCON_USB1CLKDIV_RESET_MASK             (0x20000000U)
N#define SYSCON_USB1CLKDIV_RESET_SHIFT            (29U)
N#define SYSCON_USB1CLKDIV_RESET(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKDIV_RESET_SHIFT)) & SYSCON_USB1CLKDIV_RESET_MASK)
N#define SYSCON_USB1CLKDIV_HALT_MASK              (0x40000000U)
N#define SYSCON_USB1CLKDIV_HALT_SHIFT             (30U)
N#define SYSCON_USB1CLKDIV_HALT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKDIV_HALT_SHIFT)) & SYSCON_USB1CLKDIV_HALT_MASK)
N#define SYSCON_USB1CLKDIV_REQFLAG_MASK           (0x80000000U)
N#define SYSCON_USB1CLKDIV_REQFLAG_SHIFT          (31U)
N#define SYSCON_USB1CLKDIV_REQFLAG(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKDIV_REQFLAG_SHIFT)) & SYSCON_USB1CLKDIV_REQFLAG_MASK)
N
N/*! @name FRGCTRL - Fractional rate divider */
N#define SYSCON_FRGCTRL_DIV_MASK                  (0xFFU)
N#define SYSCON_FRGCTRL_DIV_SHIFT                 (0U)
N#define SYSCON_FRGCTRL_DIV(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_FRGCTRL_DIV_SHIFT)) & SYSCON_FRGCTRL_DIV_MASK)
N#define SYSCON_FRGCTRL_MULT_MASK                 (0xFF00U)
N#define SYSCON_FRGCTRL_MULT_SHIFT                (8U)
N#define SYSCON_FRGCTRL_MULT(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_FRGCTRL_MULT_SHIFT)) & SYSCON_FRGCTRL_MULT_MASK)
N
N/*! @name DMICCLKDIV - DMIC clock divider */
N#define SYSCON_DMICCLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_DMICCLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_DMICCLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_DMICCLKDIV_DIV_SHIFT)) & SYSCON_DMICCLKDIV_DIV_MASK)
N#define SYSCON_DMICCLKDIV_RESET_MASK             (0x20000000U)
N#define SYSCON_DMICCLKDIV_RESET_SHIFT            (29U)
N#define SYSCON_DMICCLKDIV_RESET(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_DMICCLKDIV_RESET_SHIFT)) & SYSCON_DMICCLKDIV_RESET_MASK)
N#define SYSCON_DMICCLKDIV_HALT_MASK              (0x40000000U)
N#define SYSCON_DMICCLKDIV_HALT_SHIFT             (30U)
N#define SYSCON_DMICCLKDIV_HALT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_DMICCLKDIV_HALT_SHIFT)) & SYSCON_DMICCLKDIV_HALT_MASK)
N#define SYSCON_DMICCLKDIV_REQFLAG_MASK           (0x80000000U)
N#define SYSCON_DMICCLKDIV_REQFLAG_SHIFT          (31U)
N#define SYSCON_DMICCLKDIV_REQFLAG(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_DMICCLKDIV_REQFLAG_SHIFT)) & SYSCON_DMICCLKDIV_REQFLAG_MASK)
N
N/*! @name MCLKDIV - I2S MCLK clock divider */
N#define SYSCON_MCLKDIV_DIV_MASK                  (0xFFU)
N#define SYSCON_MCLKDIV_DIV_SHIFT                 (0U)
N#define SYSCON_MCLKDIV_DIV(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_MCLKDIV_DIV_SHIFT)) & SYSCON_MCLKDIV_DIV_MASK)
N#define SYSCON_MCLKDIV_RESET_MASK                (0x20000000U)
N#define SYSCON_MCLKDIV_RESET_SHIFT               (29U)
N#define SYSCON_MCLKDIV_RESET(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_MCLKDIV_RESET_SHIFT)) & SYSCON_MCLKDIV_RESET_MASK)
N#define SYSCON_MCLKDIV_HALT_MASK                 (0x40000000U)
N#define SYSCON_MCLKDIV_HALT_SHIFT                (30U)
N#define SYSCON_MCLKDIV_HALT(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_MCLKDIV_HALT_SHIFT)) & SYSCON_MCLKDIV_HALT_MASK)
N#define SYSCON_MCLKDIV_REQFLAG_MASK              (0x80000000U)
N#define SYSCON_MCLKDIV_REQFLAG_SHIFT             (31U)
N#define SYSCON_MCLKDIV_REQFLAG(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_MCLKDIV_REQFLAG_SHIFT)) & SYSCON_MCLKDIV_REQFLAG_MASK)
N
N/*! @name LCDCLKDIV - LCD clock divider */
N#define SYSCON_LCDCLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_LCDCLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_LCDCLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_LCDCLKDIV_DIV_SHIFT)) & SYSCON_LCDCLKDIV_DIV_MASK)
N#define SYSCON_LCDCLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_LCDCLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_LCDCLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_LCDCLKDIV_RESET_SHIFT)) & SYSCON_LCDCLKDIV_RESET_MASK)
N#define SYSCON_LCDCLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_LCDCLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_LCDCLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_LCDCLKDIV_HALT_SHIFT)) & SYSCON_LCDCLKDIV_HALT_MASK)
N#define SYSCON_LCDCLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_LCDCLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_LCDCLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_LCDCLKDIV_REQFLAG_SHIFT)) & SYSCON_LCDCLKDIV_REQFLAG_MASK)
N
N/*! @name SCTCLKDIV - SCT/PWM clock divider */
N#define SYSCON_SCTCLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_SCTCLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_SCTCLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_SCTCLKDIV_DIV_SHIFT)) & SYSCON_SCTCLKDIV_DIV_MASK)
N#define SYSCON_SCTCLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_SCTCLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_SCTCLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SCTCLKDIV_RESET_SHIFT)) & SYSCON_SCTCLKDIV_RESET_MASK)
N#define SYSCON_SCTCLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_SCTCLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_SCTCLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SCTCLKDIV_HALT_SHIFT)) & SYSCON_SCTCLKDIV_HALT_MASK)
N#define SYSCON_SCTCLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_SCTCLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_SCTCLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SCTCLKDIV_REQFLAG_SHIFT)) & SYSCON_SCTCLKDIV_REQFLAG_MASK)
N
N/*! @name EMCCLKDIV - EMC clock divider */
N#define SYSCON_EMCCLKDIV_DIV_MASK                (0xFFU)
N#define SYSCON_EMCCLKDIV_DIV_SHIFT               (0U)
N#define SYSCON_EMCCLKDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCCLKDIV_DIV_SHIFT)) & SYSCON_EMCCLKDIV_DIV_MASK)
N#define SYSCON_EMCCLKDIV_RESET_MASK              (0x20000000U)
N#define SYSCON_EMCCLKDIV_RESET_SHIFT             (29U)
N#define SYSCON_EMCCLKDIV_RESET(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCCLKDIV_RESET_SHIFT)) & SYSCON_EMCCLKDIV_RESET_MASK)
N#define SYSCON_EMCCLKDIV_HALT_MASK               (0x40000000U)
N#define SYSCON_EMCCLKDIV_HALT_SHIFT              (30U)
N#define SYSCON_EMCCLKDIV_HALT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCCLKDIV_HALT_SHIFT)) & SYSCON_EMCCLKDIV_HALT_MASK)
N#define SYSCON_EMCCLKDIV_REQFLAG_MASK            (0x80000000U)
N#define SYSCON_EMCCLKDIV_REQFLAG_SHIFT           (31U)
N#define SYSCON_EMCCLKDIV_REQFLAG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCCLKDIV_REQFLAG_SHIFT)) & SYSCON_EMCCLKDIV_REQFLAG_MASK)
N
N/*! @name SDIOCLKDIV - SDIO clock divider */
N#define SYSCON_SDIOCLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_SDIOCLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_SDIOCLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKDIV_DIV_SHIFT)) & SYSCON_SDIOCLKDIV_DIV_MASK)
N#define SYSCON_SDIOCLKDIV_RESET_MASK             (0x20000000U)
N#define SYSCON_SDIOCLKDIV_RESET_SHIFT            (29U)
N#define SYSCON_SDIOCLKDIV_RESET(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKDIV_RESET_SHIFT)) & SYSCON_SDIOCLKDIV_RESET_MASK)
N#define SYSCON_SDIOCLKDIV_HALT_MASK              (0x40000000U)
N#define SYSCON_SDIOCLKDIV_HALT_SHIFT             (30U)
N#define SYSCON_SDIOCLKDIV_HALT(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKDIV_HALT_SHIFT)) & SYSCON_SDIOCLKDIV_HALT_MASK)
N#define SYSCON_SDIOCLKDIV_REQFLAG_MASK           (0x80000000U)
N#define SYSCON_SDIOCLKDIV_REQFLAG_SHIFT          (31U)
N#define SYSCON_SDIOCLKDIV_REQFLAG(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKDIV_REQFLAG_SHIFT)) & SYSCON_SDIOCLKDIV_REQFLAG_MASK)
N
N/*! @name FLASHCFG - Flash wait states configuration */
N#define SYSCON_FLASHCFG_FETCHCFG_MASK            (0x3U)
N#define SYSCON_FLASHCFG_FETCHCFG_SHIFT           (0U)
N#define SYSCON_FLASHCFG_FETCHCFG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_FLASHCFG_FETCHCFG_SHIFT)) & SYSCON_FLASHCFG_FETCHCFG_MASK)
N#define SYSCON_FLASHCFG_DATACFG_MASK             (0xCU)
N#define SYSCON_FLASHCFG_DATACFG_SHIFT            (2U)
N#define SYSCON_FLASHCFG_DATACFG(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_FLASHCFG_DATACFG_SHIFT)) & SYSCON_FLASHCFG_DATACFG_MASK)
N#define SYSCON_FLASHCFG_ACCEL_MASK               (0x10U)
N#define SYSCON_FLASHCFG_ACCEL_SHIFT              (4U)
N#define SYSCON_FLASHCFG_ACCEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_FLASHCFG_ACCEL_SHIFT)) & SYSCON_FLASHCFG_ACCEL_MASK)
N#define SYSCON_FLASHCFG_PREFEN_MASK              (0x20U)
N#define SYSCON_FLASHCFG_PREFEN_SHIFT             (5U)
N#define SYSCON_FLASHCFG_PREFEN(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_FLASHCFG_PREFEN_SHIFT)) & SYSCON_FLASHCFG_PREFEN_MASK)
N#define SYSCON_FLASHCFG_PREFOVR_MASK             (0x40U)
N#define SYSCON_FLASHCFG_PREFOVR_SHIFT            (6U)
N#define SYSCON_FLASHCFG_PREFOVR(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_FLASHCFG_PREFOVR_SHIFT)) & SYSCON_FLASHCFG_PREFOVR_MASK)
N#define SYSCON_FLASHCFG_FLASHTIM_MASK            (0xF000U)
N#define SYSCON_FLASHCFG_FLASHTIM_SHIFT           (12U)
N#define SYSCON_FLASHCFG_FLASHTIM(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_FLASHCFG_FLASHTIM_SHIFT)) & SYSCON_FLASHCFG_FLASHTIM_MASK)
N
N/*! @name USB0CLKCTRL - USB0 clock control */
N#define SYSCON_USB0CLKCTRL_AP_FS_DEV_CLK_MASK    (0x1U)
N#define SYSCON_USB0CLKCTRL_AP_FS_DEV_CLK_SHIFT   (0U)
N#define SYSCON_USB0CLKCTRL_AP_FS_DEV_CLK(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKCTRL_AP_FS_DEV_CLK_SHIFT)) & SYSCON_USB0CLKCTRL_AP_FS_DEV_CLK_MASK)
N#define SYSCON_USB0CLKCTRL_POL_FS_DEV_CLK_MASK   (0x2U)
N#define SYSCON_USB0CLKCTRL_POL_FS_DEV_CLK_SHIFT  (1U)
N#define SYSCON_USB0CLKCTRL_POL_FS_DEV_CLK(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKCTRL_POL_FS_DEV_CLK_SHIFT)) & SYSCON_USB0CLKCTRL_POL_FS_DEV_CLK_MASK)
N#define SYSCON_USB0CLKCTRL_AP_FS_HOST_CLK_MASK   (0x4U)
N#define SYSCON_USB0CLKCTRL_AP_FS_HOST_CLK_SHIFT  (2U)
N#define SYSCON_USB0CLKCTRL_AP_FS_HOST_CLK(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKCTRL_AP_FS_HOST_CLK_SHIFT)) & SYSCON_USB0CLKCTRL_AP_FS_HOST_CLK_MASK)
N#define SYSCON_USB0CLKCTRL_POL_FS_HOST_CLK_MASK  (0x8U)
N#define SYSCON_USB0CLKCTRL_POL_FS_HOST_CLK_SHIFT (3U)
N#define SYSCON_USB0CLKCTRL_POL_FS_HOST_CLK(x)    (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKCTRL_POL_FS_HOST_CLK_SHIFT)) & SYSCON_USB0CLKCTRL_POL_FS_HOST_CLK_MASK)
N#define SYSCON_USB0CLKCTRL_PU_DISABLE_MASK       (0x10U)
N#define SYSCON_USB0CLKCTRL_PU_DISABLE_SHIFT      (4U)
N#define SYSCON_USB0CLKCTRL_PU_DISABLE(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKCTRL_PU_DISABLE_SHIFT)) & SYSCON_USB0CLKCTRL_PU_DISABLE_MASK)
N
N/*! @name USB0CLKSTAT - USB0 clock status */
N#define SYSCON_USB0CLKSTAT_DEV_NEED_CLKST_MASK   (0x1U)
N#define SYSCON_USB0CLKSTAT_DEV_NEED_CLKST_SHIFT  (0U)
N#define SYSCON_USB0CLKSTAT_DEV_NEED_CLKST(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKSTAT_DEV_NEED_CLKST_SHIFT)) & SYSCON_USB0CLKSTAT_DEV_NEED_CLKST_MASK)
N#define SYSCON_USB0CLKSTAT_HOST_NEED_CLKST_MASK  (0x2U)
N#define SYSCON_USB0CLKSTAT_HOST_NEED_CLKST_SHIFT (1U)
N#define SYSCON_USB0CLKSTAT_HOST_NEED_CLKST(x)    (((uint32_t)(((uint32_t)(x)) << SYSCON_USB0CLKSTAT_HOST_NEED_CLKST_SHIFT)) & SYSCON_USB0CLKSTAT_HOST_NEED_CLKST_MASK)
N
N/*! @name FREQMECTRL - Frequency measure register */
N#define SYSCON_FREQMECTRL_CAPVAL_MASK            (0x3FFFU)
N#define SYSCON_FREQMECTRL_CAPVAL_SHIFT           (0U)
N#define SYSCON_FREQMECTRL_CAPVAL(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_FREQMECTRL_CAPVAL_SHIFT)) & SYSCON_FREQMECTRL_CAPVAL_MASK)
N#define SYSCON_FREQMECTRL_PROG_MASK              (0x80000000U)
N#define SYSCON_FREQMECTRL_PROG_SHIFT             (31U)
N#define SYSCON_FREQMECTRL_PROG(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_FREQMECTRL_PROG_SHIFT)) & SYSCON_FREQMECTRL_PROG_MASK)
N
N/*! @name MCLKIO - MCLK input/output control */
N#define SYSCON_MCLKIO_DIR_MASK                   (0x1U)
N#define SYSCON_MCLKIO_DIR_SHIFT                  (0U)
N#define SYSCON_MCLKIO_DIR(x)                     (((uint32_t)(((uint32_t)(x)) << SYSCON_MCLKIO_DIR_SHIFT)) & SYSCON_MCLKIO_DIR_MASK)
N
N/*! @name USB1CLKCTRL - USB1 clock control */
N#define SYSCON_USB1CLKCTRL_AP_FS_DEV_CLK_MASK    (0x1U)
N#define SYSCON_USB1CLKCTRL_AP_FS_DEV_CLK_SHIFT   (0U)
N#define SYSCON_USB1CLKCTRL_AP_FS_DEV_CLK(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKCTRL_AP_FS_DEV_CLK_SHIFT)) & SYSCON_USB1CLKCTRL_AP_FS_DEV_CLK_MASK)
N#define SYSCON_USB1CLKCTRL_POL_FS_DEV_CLK_MASK   (0x2U)
N#define SYSCON_USB1CLKCTRL_POL_FS_DEV_CLK_SHIFT  (1U)
N#define SYSCON_USB1CLKCTRL_POL_FS_DEV_CLK(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKCTRL_POL_FS_DEV_CLK_SHIFT)) & SYSCON_USB1CLKCTRL_POL_FS_DEV_CLK_MASK)
N#define SYSCON_USB1CLKCTRL_AP_FS_HOST_CLK_MASK   (0x4U)
N#define SYSCON_USB1CLKCTRL_AP_FS_HOST_CLK_SHIFT  (2U)
N#define SYSCON_USB1CLKCTRL_AP_FS_HOST_CLK(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKCTRL_AP_FS_HOST_CLK_SHIFT)) & SYSCON_USB1CLKCTRL_AP_FS_HOST_CLK_MASK)
N#define SYSCON_USB1CLKCTRL_POL_FS_HOST_CLK_MASK  (0x8U)
N#define SYSCON_USB1CLKCTRL_POL_FS_HOST_CLK_SHIFT (3U)
N#define SYSCON_USB1CLKCTRL_POL_FS_HOST_CLK(x)    (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKCTRL_POL_FS_HOST_CLK_SHIFT)) & SYSCON_USB1CLKCTRL_POL_FS_HOST_CLK_MASK)
N#define SYSCON_USB1CLKCTRL_HS_DEV_WAKEUP_N_MASK  (0x10U)
N#define SYSCON_USB1CLKCTRL_HS_DEV_WAKEUP_N_SHIFT (4U)
N#define SYSCON_USB1CLKCTRL_HS_DEV_WAKEUP_N(x)    (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKCTRL_HS_DEV_WAKEUP_N_SHIFT)) & SYSCON_USB1CLKCTRL_HS_DEV_WAKEUP_N_MASK)
N
N/*! @name USB1CLKSTAT - USB1 clock status */
N#define SYSCON_USB1CLKSTAT_DEV_NEED_CLKST_MASK   (0x1U)
N#define SYSCON_USB1CLKSTAT_DEV_NEED_CLKST_SHIFT  (0U)
N#define SYSCON_USB1CLKSTAT_DEV_NEED_CLKST(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKSTAT_DEV_NEED_CLKST_SHIFT)) & SYSCON_USB1CLKSTAT_DEV_NEED_CLKST_MASK)
N#define SYSCON_USB1CLKSTAT_HOST_NEED_CLKST_MASK  (0x2U)
N#define SYSCON_USB1CLKSTAT_HOST_NEED_CLKST_SHIFT (1U)
N#define SYSCON_USB1CLKSTAT_HOST_NEED_CLKST(x)    (((uint32_t)(((uint32_t)(x)) << SYSCON_USB1CLKSTAT_HOST_NEED_CLKST_SHIFT)) & SYSCON_USB1CLKSTAT_HOST_NEED_CLKST_MASK)
N
N/*! @name EMCSYSCTRL - EMC system control */
N#define SYSCON_EMCSYSCTRL_EMCSC_MASK             (0x1U)
N#define SYSCON_EMCSYSCTRL_EMCSC_SHIFT            (0U)
N#define SYSCON_EMCSYSCTRL_EMCSC(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCSYSCTRL_EMCSC_SHIFT)) & SYSCON_EMCSYSCTRL_EMCSC_MASK)
N#define SYSCON_EMCSYSCTRL_EMCRD_MASK             (0x2U)
N#define SYSCON_EMCSYSCTRL_EMCRD_SHIFT            (1U)
N#define SYSCON_EMCSYSCTRL_EMCRD(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCSYSCTRL_EMCRD_SHIFT)) & SYSCON_EMCSYSCTRL_EMCRD_MASK)
N#define SYSCON_EMCSYSCTRL_EMCBC_MASK             (0x4U)
N#define SYSCON_EMCSYSCTRL_EMCBC_SHIFT            (2U)
N#define SYSCON_EMCSYSCTRL_EMCBC(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCSYSCTRL_EMCBC_SHIFT)) & SYSCON_EMCSYSCTRL_EMCBC_MASK)
N#define SYSCON_EMCSYSCTRL_EMCFBCLKINSEL_MASK     (0x8U)
N#define SYSCON_EMCSYSCTRL_EMCFBCLKINSEL_SHIFT    (3U)
N#define SYSCON_EMCSYSCTRL_EMCFBCLKINSEL(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCSYSCTRL_EMCFBCLKINSEL_SHIFT)) & SYSCON_EMCSYSCTRL_EMCFBCLKINSEL_MASK)
N
N/*! @name EMCDLYCTRL - EMC clock delay control */
N#define SYSCON_EMCDLYCTRL_CMD_DELAY_MASK         (0x1FU)
N#define SYSCON_EMCDLYCTRL_CMD_DELAY_SHIFT        (0U)
N#define SYSCON_EMCDLYCTRL_CMD_DELAY(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCDLYCTRL_CMD_DELAY_SHIFT)) & SYSCON_EMCDLYCTRL_CMD_DELAY_MASK)
N#define SYSCON_EMCDLYCTRL_FBCLK_DELAY_MASK       (0x1F00U)
N#define SYSCON_EMCDLYCTRL_FBCLK_DELAY_SHIFT      (8U)
N#define SYSCON_EMCDLYCTRL_FBCLK_DELAY(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCDLYCTRL_FBCLK_DELAY_SHIFT)) & SYSCON_EMCDLYCTRL_FBCLK_DELAY_MASK)
N
N/*! @name EMCDLYCAL - EMC delay chain calibration control */
N#define SYSCON_EMCDLYCAL_CALVALUE_MASK           (0xFFU)
N#define SYSCON_EMCDLYCAL_CALVALUE_SHIFT          (0U)
N#define SYSCON_EMCDLYCAL_CALVALUE(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCDLYCAL_CALVALUE_SHIFT)) & SYSCON_EMCDLYCAL_CALVALUE_MASK)
N#define SYSCON_EMCDLYCAL_START_MASK              (0x4000U)
N#define SYSCON_EMCDLYCAL_START_SHIFT             (14U)
N#define SYSCON_EMCDLYCAL_START(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCDLYCAL_START_SHIFT)) & SYSCON_EMCDLYCAL_START_MASK)
N#define SYSCON_EMCDLYCAL_DONE_MASK               (0x8000U)
N#define SYSCON_EMCDLYCAL_DONE_SHIFT              (15U)
N#define SYSCON_EMCDLYCAL_DONE(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_EMCDLYCAL_DONE_SHIFT)) & SYSCON_EMCDLYCAL_DONE_MASK)
N
N/*! @name ETHPHYSEL - Ethernet PHY Selection */
N#define SYSCON_ETHPHYSEL_PHY_SEL_MASK            (0x4U)
N#define SYSCON_ETHPHYSEL_PHY_SEL_SHIFT           (2U)
N#define SYSCON_ETHPHYSEL_PHY_SEL(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_ETHPHYSEL_PHY_SEL_SHIFT)) & SYSCON_ETHPHYSEL_PHY_SEL_MASK)
N
N/*! @name ETHSBDCTRL - Ethernet SBD flow control */
N#define SYSCON_ETHSBDCTRL_SBD_CTRL_MASK          (0x3U)
N#define SYSCON_ETHSBDCTRL_SBD_CTRL_SHIFT         (0U)
N#define SYSCON_ETHSBDCTRL_SBD_CTRL(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_ETHSBDCTRL_SBD_CTRL_SHIFT)) & SYSCON_ETHSBDCTRL_SBD_CTRL_MASK)
N
N/*! @name SDIOCLKCTRL - SDIO CCLKIN phase and delay control */
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE_MASK   (0x3U)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE_SHIFT  (0U)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE_SHIFT)) & SYSCON_SDIOCLKCTRL_CCLK_DRV_PHASE_MASK)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE_MASK (0xCU)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE_SHIFT (2U)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE(x)  (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE_SHIFT)) & SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_PHASE_MASK)
N#define SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_MASK     (0x80U)
N#define SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_SHIFT    (7U)
N#define SYSCON_SDIOCLKCTRL_PHASE_ACTIVE(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_SHIFT)) & SYSCON_SDIOCLKCTRL_PHASE_ACTIVE_MASK)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_MASK   (0x1F0000U)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_SHIFT  (16U)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_SHIFT)) & SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_MASK)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_MASK (0x800000U)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_SHIFT (23U)
N#define SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE(x) (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_SHIFT)) & SYSCON_SDIOCLKCTRL_CCLK_DRV_DELAY_ACTIVE_MASK)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_MASK (0x1F000000U)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_SHIFT (24U)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY(x)  (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_SHIFT)) & SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_MASK)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_MASK (0x80000000U)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_SHIFT (31U)
N#define SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE(x) (((uint32_t)(((uint32_t)(x)) << SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_SHIFT)) & SYSCON_SDIOCLKCTRL_CCLK_SAMPLE_DELAY_ACTIVE_MASK)
N
N/*! @name FROCTRL - FRO oscillator control */
N#define SYSCON_FROCTRL_TRIM_MASK                 (0x3FFFU)
N#define SYSCON_FROCTRL_TRIM_SHIFT                (0U)
N#define SYSCON_FROCTRL_TRIM(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_TRIM_SHIFT)) & SYSCON_FROCTRL_TRIM_MASK)
N#define SYSCON_FROCTRL_SEL_MASK                  (0x4000U)
N#define SYSCON_FROCTRL_SEL_SHIFT                 (14U)
N#define SYSCON_FROCTRL_SEL(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_SEL_SHIFT)) & SYSCON_FROCTRL_SEL_MASK)
N#define SYSCON_FROCTRL_FREQTRIM_MASK             (0xFF0000U)
N#define SYSCON_FROCTRL_FREQTRIM_SHIFT            (16U)
N#define SYSCON_FROCTRL_FREQTRIM(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_FREQTRIM_SHIFT)) & SYSCON_FROCTRL_FREQTRIM_MASK)
N#define SYSCON_FROCTRL_USBCLKADJ_MASK            (0x1000000U)
N#define SYSCON_FROCTRL_USBCLKADJ_SHIFT           (24U)
N#define SYSCON_FROCTRL_USBCLKADJ(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_USBCLKADJ_SHIFT)) & SYSCON_FROCTRL_USBCLKADJ_MASK)
N#define SYSCON_FROCTRL_USBMODCHG_MASK            (0x2000000U)
N#define SYSCON_FROCTRL_USBMODCHG_SHIFT           (25U)
N#define SYSCON_FROCTRL_USBMODCHG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_USBMODCHG_SHIFT)) & SYSCON_FROCTRL_USBMODCHG_MASK)
N#define SYSCON_FROCTRL_HSPDCLK_MASK              (0x40000000U)
N#define SYSCON_FROCTRL_HSPDCLK_SHIFT             (30U)
N#define SYSCON_FROCTRL_HSPDCLK(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_HSPDCLK_SHIFT)) & SYSCON_FROCTRL_HSPDCLK_MASK)
N#define SYSCON_FROCTRL_WRTRIM_MASK               (0x80000000U)
N#define SYSCON_FROCTRL_WRTRIM_SHIFT              (31U)
N#define SYSCON_FROCTRL_WRTRIM(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_FROCTRL_WRTRIM_SHIFT)) & SYSCON_FROCTRL_WRTRIM_MASK)
N
N/*! @name SYSOSCCTRL - System oscillator control */
N#define SYSCON_SYSOSCCTRL_BYPASS_MASK            (0x1U)
N#define SYSCON_SYSOSCCTRL_BYPASS_SHIFT           (0U)
N#define SYSCON_SYSOSCCTRL_BYPASS(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSOSCCTRL_BYPASS_SHIFT)) & SYSCON_SYSOSCCTRL_BYPASS_MASK)
N#define SYSCON_SYSOSCCTRL_FREQRANGE_MASK         (0x2U)
N#define SYSCON_SYSOSCCTRL_FREQRANGE_SHIFT        (1U)
N#define SYSCON_SYSOSCCTRL_FREQRANGE(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSOSCCTRL_FREQRANGE_SHIFT)) & SYSCON_SYSOSCCTRL_FREQRANGE_MASK)
N
N/*! @name WDTOSCCTRL - Watchdog oscillator control */
N#define SYSCON_WDTOSCCTRL_DIVSEL_MASK            (0x1FU)
N#define SYSCON_WDTOSCCTRL_DIVSEL_SHIFT           (0U)
N#define SYSCON_WDTOSCCTRL_DIVSEL(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_WDTOSCCTRL_DIVSEL_SHIFT)) & SYSCON_WDTOSCCTRL_DIVSEL_MASK)
N#define SYSCON_WDTOSCCTRL_FREQSEL_MASK           (0x3E0U)
N#define SYSCON_WDTOSCCTRL_FREQSEL_SHIFT          (5U)
N#define SYSCON_WDTOSCCTRL_FREQSEL(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_WDTOSCCTRL_FREQSEL_SHIFT)) & SYSCON_WDTOSCCTRL_FREQSEL_MASK)
N
N/*! @name RTCOSCCTRL - RTC oscillator 32 kHz output control */
N#define SYSCON_RTCOSCCTRL_EN_MASK                (0x1U)
N#define SYSCON_RTCOSCCTRL_EN_SHIFT               (0U)
N#define SYSCON_RTCOSCCTRL_EN(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_RTCOSCCTRL_EN_SHIFT)) & SYSCON_RTCOSCCTRL_EN_MASK)
N
N/*! @name USBPLLCTRL - USB PLL control */
N#define SYSCON_USBPLLCTRL_MSEL_MASK              (0xFFU)
N#define SYSCON_USBPLLCTRL_MSEL_SHIFT             (0U)
N#define SYSCON_USBPLLCTRL_MSEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLCTRL_MSEL_SHIFT)) & SYSCON_USBPLLCTRL_MSEL_MASK)
N#define SYSCON_USBPLLCTRL_PSEL_MASK              (0x300U)
N#define SYSCON_USBPLLCTRL_PSEL_SHIFT             (8U)
N#define SYSCON_USBPLLCTRL_PSEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLCTRL_PSEL_SHIFT)) & SYSCON_USBPLLCTRL_PSEL_MASK)
N#define SYSCON_USBPLLCTRL_NSEL_MASK              (0xC00U)
N#define SYSCON_USBPLLCTRL_NSEL_SHIFT             (10U)
N#define SYSCON_USBPLLCTRL_NSEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLCTRL_NSEL_SHIFT)) & SYSCON_USBPLLCTRL_NSEL_MASK)
N#define SYSCON_USBPLLCTRL_DIRECT_MASK            (0x1000U)
N#define SYSCON_USBPLLCTRL_DIRECT_SHIFT           (12U)
N#define SYSCON_USBPLLCTRL_DIRECT(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLCTRL_DIRECT_SHIFT)) & SYSCON_USBPLLCTRL_DIRECT_MASK)
N#define SYSCON_USBPLLCTRL_BYPASS_MASK            (0x2000U)
N#define SYSCON_USBPLLCTRL_BYPASS_SHIFT           (13U)
N#define SYSCON_USBPLLCTRL_BYPASS(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLCTRL_BYPASS_SHIFT)) & SYSCON_USBPLLCTRL_BYPASS_MASK)
N#define SYSCON_USBPLLCTRL_BYPASSCCODIV2_MASK     (0x4000U)
N#define SYSCON_USBPLLCTRL_BYPASSCCODIV2_SHIFT    (14U)
N#define SYSCON_USBPLLCTRL_BYPASSCCODIV2(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLCTRL_BYPASSCCODIV2_SHIFT)) & SYSCON_USBPLLCTRL_BYPASSCCODIV2_MASK)
N
N/*! @name USBPLLSTAT - USB PLL status */
N#define SYSCON_USBPLLSTAT_LOCK_MASK              (0x1U)
N#define SYSCON_USBPLLSTAT_LOCK_SHIFT             (0U)
N#define SYSCON_USBPLLSTAT_LOCK(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_USBPLLSTAT_LOCK_SHIFT)) & SYSCON_USBPLLSTAT_LOCK_MASK)
N
N/*! @name SYSPLLCTRL - System PLL control */
N#define SYSCON_SYSPLLCTRL_SELR_MASK              (0xFU)
N#define SYSCON_SYSPLLCTRL_SELR_SHIFT             (0U)
N#define SYSCON_SYSPLLCTRL_SELR(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_SELR_SHIFT)) & SYSCON_SYSPLLCTRL_SELR_MASK)
N#define SYSCON_SYSPLLCTRL_SELI_MASK              (0x3F0U)
N#define SYSCON_SYSPLLCTRL_SELI_SHIFT             (4U)
N#define SYSCON_SYSPLLCTRL_SELI(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_SELI_SHIFT)) & SYSCON_SYSPLLCTRL_SELI_MASK)
N#define SYSCON_SYSPLLCTRL_SELP_MASK              (0x7C00U)
N#define SYSCON_SYSPLLCTRL_SELP_SHIFT             (10U)
N#define SYSCON_SYSPLLCTRL_SELP(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_SELP_SHIFT)) & SYSCON_SYSPLLCTRL_SELP_MASK)
N#define SYSCON_SYSPLLCTRL_BYPASS_MASK            (0x8000U)
N#define SYSCON_SYSPLLCTRL_BYPASS_SHIFT           (15U)
N#define SYSCON_SYSPLLCTRL_BYPASS(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_BYPASS_SHIFT)) & SYSCON_SYSPLLCTRL_BYPASS_MASK)
N#define SYSCON_SYSPLLCTRL_UPLIMOFF_MASK          (0x20000U)
N#define SYSCON_SYSPLLCTRL_UPLIMOFF_SHIFT         (17U)
N#define SYSCON_SYSPLLCTRL_UPLIMOFF(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_UPLIMOFF_SHIFT)) & SYSCON_SYSPLLCTRL_UPLIMOFF_MASK)
N#define SYSCON_SYSPLLCTRL_DIRECTI_MASK           (0x80000U)
N#define SYSCON_SYSPLLCTRL_DIRECTI_SHIFT          (19U)
N#define SYSCON_SYSPLLCTRL_DIRECTI(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_DIRECTI_SHIFT)) & SYSCON_SYSPLLCTRL_DIRECTI_MASK)
N#define SYSCON_SYSPLLCTRL_DIRECTO_MASK           (0x100000U)
N#define SYSCON_SYSPLLCTRL_DIRECTO_SHIFT          (20U)
N#define SYSCON_SYSPLLCTRL_DIRECTO(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_DIRECTO_SHIFT)) & SYSCON_SYSPLLCTRL_DIRECTO_MASK)
N
N/*! @name SYSPLLSTAT - PLL status */
N#define SYSCON_SYSPLLSTAT_LOCK_MASK              (0x1U)
N#define SYSCON_SYSPLLSTAT_LOCK_SHIFT             (0U)
N#define SYSCON_SYSPLLSTAT_LOCK(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLSTAT_LOCK_SHIFT)) & SYSCON_SYSPLLSTAT_LOCK_MASK)
N
N/*! @name SYSPLLNDEC - PLL N divider */
N#define SYSCON_SYSPLLNDEC_NDEC_MASK              (0x3FFU)
N#define SYSCON_SYSPLLNDEC_NDEC_SHIFT             (0U)
N#define SYSCON_SYSPLLNDEC_NDEC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLNDEC_NDEC_SHIFT)) & SYSCON_SYSPLLNDEC_NDEC_MASK)
N#define SYSCON_SYSPLLNDEC_NREQ_MASK              (0x400U)
N#define SYSCON_SYSPLLNDEC_NREQ_SHIFT             (10U)
N#define SYSCON_SYSPLLNDEC_NREQ(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLNDEC_NREQ_SHIFT)) & SYSCON_SYSPLLNDEC_NREQ_MASK)
N
N/*! @name SYSPLLPDEC - PLL P divider */
N#define SYSCON_SYSPLLPDEC_PDEC_MASK              (0x7FU)
N#define SYSCON_SYSPLLPDEC_PDEC_SHIFT             (0U)
N#define SYSCON_SYSPLLPDEC_PDEC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLPDEC_PDEC_SHIFT)) & SYSCON_SYSPLLPDEC_PDEC_MASK)
N#define SYSCON_SYSPLLPDEC_PREQ_MASK              (0x80U)
N#define SYSCON_SYSPLLPDEC_PREQ_SHIFT             (7U)
N#define SYSCON_SYSPLLPDEC_PREQ(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLPDEC_PREQ_SHIFT)) & SYSCON_SYSPLLPDEC_PREQ_MASK)
N
N/*! @name SYSPLLMDEC - System PLL M divider */
N#define SYSCON_SYSPLLMDEC_MDEC_MASK              (0x1FFFFU)
N#define SYSCON_SYSPLLMDEC_MDEC_SHIFT             (0U)
N#define SYSCON_SYSPLLMDEC_MDEC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLMDEC_MDEC_SHIFT)) & SYSCON_SYSPLLMDEC_MDEC_MASK)
N#define SYSCON_SYSPLLMDEC_MREQ_MASK              (0x20000U)
N#define SYSCON_SYSPLLMDEC_MREQ_SHIFT             (17U)
N#define SYSCON_SYSPLLMDEC_MREQ(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLMDEC_MREQ_SHIFT)) & SYSCON_SYSPLLMDEC_MREQ_MASK)
N
N/*! @name AUDPLLCTRL - Audio PLL control */
N#define SYSCON_AUDPLLCTRL_SELR_MASK              (0xFU)
N#define SYSCON_AUDPLLCTRL_SELR_SHIFT             (0U)
N#define SYSCON_AUDPLLCTRL_SELR(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_SELR_SHIFT)) & SYSCON_AUDPLLCTRL_SELR_MASK)
N#define SYSCON_AUDPLLCTRL_SELI_MASK              (0x3F0U)
N#define SYSCON_AUDPLLCTRL_SELI_SHIFT             (4U)
N#define SYSCON_AUDPLLCTRL_SELI(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_SELI_SHIFT)) & SYSCON_AUDPLLCTRL_SELI_MASK)
N#define SYSCON_AUDPLLCTRL_SELP_MASK              (0x7C00U)
N#define SYSCON_AUDPLLCTRL_SELP_SHIFT             (10U)
N#define SYSCON_AUDPLLCTRL_SELP(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_SELP_SHIFT)) & SYSCON_AUDPLLCTRL_SELP_MASK)
N#define SYSCON_AUDPLLCTRL_BYPASS_MASK            (0x8000U)
N#define SYSCON_AUDPLLCTRL_BYPASS_SHIFT           (15U)
N#define SYSCON_AUDPLLCTRL_BYPASS(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_BYPASS_SHIFT)) & SYSCON_AUDPLLCTRL_BYPASS_MASK)
N#define SYSCON_AUDPLLCTRL_UPLIMOFF_MASK          (0x20000U)
N#define SYSCON_AUDPLLCTRL_UPLIMOFF_SHIFT         (17U)
N#define SYSCON_AUDPLLCTRL_UPLIMOFF(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_UPLIMOFF_SHIFT)) & SYSCON_AUDPLLCTRL_UPLIMOFF_MASK)
N#define SYSCON_AUDPLLCTRL_DIRECTI_MASK           (0x80000U)
N#define SYSCON_AUDPLLCTRL_DIRECTI_SHIFT          (19U)
N#define SYSCON_AUDPLLCTRL_DIRECTI(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_DIRECTI_SHIFT)) & SYSCON_AUDPLLCTRL_DIRECTI_MASK)
N#define SYSCON_AUDPLLCTRL_DIRECTO_MASK           (0x100000U)
N#define SYSCON_AUDPLLCTRL_DIRECTO_SHIFT          (20U)
N#define SYSCON_AUDPLLCTRL_DIRECTO(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLCTRL_DIRECTO_SHIFT)) & SYSCON_AUDPLLCTRL_DIRECTO_MASK)
N
N/*! @name AUDPLLSTAT - Audio PLL status */
N#define SYSCON_AUDPLLSTAT_LOCK_MASK              (0x1U)
N#define SYSCON_AUDPLLSTAT_LOCK_SHIFT             (0U)
N#define SYSCON_AUDPLLSTAT_LOCK(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLSTAT_LOCK_SHIFT)) & SYSCON_AUDPLLSTAT_LOCK_MASK)
N
N/*! @name AUDPLLNDEC - Audio PLL N divider */
N#define SYSCON_AUDPLLNDEC_NDEC_MASK              (0x3FFU)
N#define SYSCON_AUDPLLNDEC_NDEC_SHIFT             (0U)
N#define SYSCON_AUDPLLNDEC_NDEC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLNDEC_NDEC_SHIFT)) & SYSCON_AUDPLLNDEC_NDEC_MASK)
N#define SYSCON_AUDPLLNDEC_NREQ_MASK              (0x400U)
N#define SYSCON_AUDPLLNDEC_NREQ_SHIFT             (10U)
N#define SYSCON_AUDPLLNDEC_NREQ(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLNDEC_NREQ_SHIFT)) & SYSCON_AUDPLLNDEC_NREQ_MASK)
N
N/*! @name AUDPLLPDEC - Audio PLL P divider */
N#define SYSCON_AUDPLLPDEC_PDEC_MASK              (0x7FU)
N#define SYSCON_AUDPLLPDEC_PDEC_SHIFT             (0U)
N#define SYSCON_AUDPLLPDEC_PDEC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLPDEC_PDEC_SHIFT)) & SYSCON_AUDPLLPDEC_PDEC_MASK)
N#define SYSCON_AUDPLLPDEC_PREQ_MASK              (0x80U)
N#define SYSCON_AUDPLLPDEC_PREQ_SHIFT             (7U)
N#define SYSCON_AUDPLLPDEC_PREQ(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLPDEC_PREQ_SHIFT)) & SYSCON_AUDPLLPDEC_PREQ_MASK)
N
N/*! @name AUDPLLMDEC - Audio PLL M divider */
N#define SYSCON_AUDPLLMDEC_MDEC_MASK              (0x1FFFFU)
N#define SYSCON_AUDPLLMDEC_MDEC_SHIFT             (0U)
N#define SYSCON_AUDPLLMDEC_MDEC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLMDEC_MDEC_SHIFT)) & SYSCON_AUDPLLMDEC_MDEC_MASK)
N#define SYSCON_AUDPLLMDEC_MREQ_MASK              (0x20000U)
N#define SYSCON_AUDPLLMDEC_MREQ_SHIFT             (17U)
N#define SYSCON_AUDPLLMDEC_MREQ(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLMDEC_MREQ_SHIFT)) & SYSCON_AUDPLLMDEC_MREQ_MASK)
N
N/*! @name AUDPLLFRAC - Audio PLL fractional divider control */
N#define SYSCON_AUDPLLFRAC_CTRL_MASK              (0x3FFFFFU)
N#define SYSCON_AUDPLLFRAC_CTRL_SHIFT             (0U)
N#define SYSCON_AUDPLLFRAC_CTRL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLFRAC_CTRL_SHIFT)) & SYSCON_AUDPLLFRAC_CTRL_MASK)
N#define SYSCON_AUDPLLFRAC_REQ_MASK               (0x400000U)
N#define SYSCON_AUDPLLFRAC_REQ_SHIFT              (22U)
N#define SYSCON_AUDPLLFRAC_REQ(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLFRAC_REQ_SHIFT)) & SYSCON_AUDPLLFRAC_REQ_MASK)
N#define SYSCON_AUDPLLFRAC_SEL_EXT_MASK           (0x800000U)
N#define SYSCON_AUDPLLFRAC_SEL_EXT_SHIFT          (23U)
N#define SYSCON_AUDPLLFRAC_SEL_EXT(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_AUDPLLFRAC_SEL_EXT_SHIFT)) & SYSCON_AUDPLLFRAC_SEL_EXT_MASK)
N
N/*! @name PDSLEEPCFG - Power configuration register 0 */
N#define SYSCON_PDSLEEPCFG_PDEN_USB1_PHY_MASK     (0x1U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB1_PHY_SHIFT    (0U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB1_PHY(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_USB1_PHY_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_USB1_PHY_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_USB1_PLL_MASK     (0x2U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB1_PLL_SHIFT    (1U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB1_PLL(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_USB1_PLL_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_USB1_PLL_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_AUD_PLL_MASK      (0x4U)
N#define SYSCON_PDSLEEPCFG_PDEN_AUD_PLL_SHIFT     (2U)
N#define SYSCON_PDSLEEPCFG_PDEN_AUD_PLL(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_AUD_PLL_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_AUD_PLL_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_SYSOSC_MASK       (0x8U)
N#define SYSCON_PDSLEEPCFG_PDEN_SYSOSC_SHIFT      (3U)
N#define SYSCON_PDSLEEPCFG_PDEN_SYSOSC(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_SYSOSC_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_SYSOSC_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_FRO_MASK          (0x10U)
N#define SYSCON_PDSLEEPCFG_PDEN_FRO_SHIFT         (4U)
N#define SYSCON_PDSLEEPCFG_PDEN_FRO(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_FRO_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_FRO_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_EEPROM_MASK       (0x20U)
N#define SYSCON_PDSLEEPCFG_PDEN_EEPROM_SHIFT      (5U)
N#define SYSCON_PDSLEEPCFG_PDEN_EEPROM(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_EEPROM_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_EEPROM_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_FLASH_MASK        (0x20U)
N#define SYSCON_PDSLEEPCFG_PDEN_FLASH_SHIFT       (5U)
N#define SYSCON_PDSLEEPCFG_PDEN_FLASH(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_FLASH_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_FLASH_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_TS_MASK           (0x40U)
N#define SYSCON_PDSLEEPCFG_PDEN_TS_SHIFT          (6U)
N#define SYSCON_PDSLEEPCFG_PDEN_TS(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_TS_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_TS_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_BOD_RST_MASK      (0x80U)
N#define SYSCON_PDSLEEPCFG_PDEN_BOD_RST_SHIFT     (7U)
N#define SYSCON_PDSLEEPCFG_PDEN_BOD_RST(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_BOD_RST_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_BOD_RST_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_RNG_MASK          (0x80U)
N#define SYSCON_PDSLEEPCFG_PDEN_RNG_SHIFT         (7U)
N#define SYSCON_PDSLEEPCFG_PDEN_RNG(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_RNG_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_RNG_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_BOD_INTR_MASK     (0x100U)
N#define SYSCON_PDSLEEPCFG_PDEN_BOD_INTR_SHIFT    (8U)
N#define SYSCON_PDSLEEPCFG_PDEN_BOD_INTR(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_BOD_INTR_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_BOD_INTR_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VD2_ANA_MASK      (0x200U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD2_ANA_SHIFT     (9U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD2_ANA(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VD2_ANA_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VD2_ANA_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_ADC0_MASK         (0x400U)
N#define SYSCON_PDSLEEPCFG_PDEN_ADC0_SHIFT        (10U)
N#define SYSCON_PDSLEEPCFG_PDEN_ADC0(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_ADC0_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_ADC0_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAMX_MASK        (0x2000U)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAMX_SHIFT       (13U)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAMX(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_SRAMX_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_SRAMX_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAM0_MASK        (0x4000U)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAM0_SHIFT       (14U)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAM0(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_SRAM0_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_SRAM0_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAM1_2_3_MASK    (0x8000U)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAM1_2_3_SHIFT   (15U)
N#define SYSCON_PDSLEEPCFG_PDEN_SRAM1_2_3(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_SRAM1_2_3_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_SRAM1_2_3_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_USB_RAM_MASK      (0x10000U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB_RAM_SHIFT     (16U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB_RAM(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_USB_RAM_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_USB_RAM_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_ROM_MASK          (0x20000U)
N#define SYSCON_PDSLEEPCFG_PDEN_ROM_SHIFT         (17U)
N#define SYSCON_PDSLEEPCFG_PDEN_ROM(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_ROM_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_ROM_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VDDA_MASK         (0x80000U)
N#define SYSCON_PDSLEEPCFG_PDEN_VDDA_SHIFT        (19U)
N#define SYSCON_PDSLEEPCFG_PDEN_VDDA(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VDDA_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VDDA_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_WDT_OSC_MASK      (0x100000U)
N#define SYSCON_PDSLEEPCFG_PDEN_WDT_OSC_SHIFT     (20U)
N#define SYSCON_PDSLEEPCFG_PDEN_WDT_OSC(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_WDT_OSC_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_WDT_OSC_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_USB0_PHY_MASK     (0x200000U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB0_PHY_SHIFT    (21U)
N#define SYSCON_PDSLEEPCFG_PDEN_USB0_PHY(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_USB0_PHY_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_USB0_PHY_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_SYS_PLL_MASK      (0x400000U)
N#define SYSCON_PDSLEEPCFG_PDEN_SYS_PLL_SHIFT     (22U)
N#define SYSCON_PDSLEEPCFG_PDEN_SYS_PLL(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_SYS_PLL_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_SYS_PLL_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VREFP_MASK        (0x800000U)
N#define SYSCON_PDSLEEPCFG_PDEN_VREFP_SHIFT       (23U)
N#define SYSCON_PDSLEEPCFG_PDEN_VREFP(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VREFP_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VREFP_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VD3_MASK          (0x4000000U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD3_SHIFT         (26U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD3(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VD3_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VD3_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VD4_MASK          (0x8000000U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD4_SHIFT         (27U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD4(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VD4_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VD4_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VD5_MASK          (0x10000000U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD5_SHIFT         (28U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD5(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VD5_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VD5_MASK)
N#define SYSCON_PDSLEEPCFG_PDEN_VD6_MASK          (0x20000000U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD6_SHIFT         (29U)
N#define SYSCON_PDSLEEPCFG_PDEN_VD6(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_PDEN_VD6_SHIFT)) & SYSCON_PDSLEEPCFG_PDEN_VD6_MASK)
N
N/* The count of SYSCON_PDSLEEPCFG */
N#define SYSCON_PDSLEEPCFG_COUNT                  (2U)
N
N/*! @name PDRUNCFG - Power configuration register 0 */
N#define SYSCON_PDRUNCFG_PDEN_USB1_PHY_MASK       (0x1U)
N#define SYSCON_PDRUNCFG_PDEN_USB1_PHY_SHIFT      (0U)
N#define SYSCON_PDRUNCFG_PDEN_USB1_PHY(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_USB1_PHY_SHIFT)) & SYSCON_PDRUNCFG_PDEN_USB1_PHY_MASK)
N#define SYSCON_PDRUNCFG_PDEN_USB1_PLL_MASK       (0x2U)
N#define SYSCON_PDRUNCFG_PDEN_USB1_PLL_SHIFT      (1U)
N#define SYSCON_PDRUNCFG_PDEN_USB1_PLL(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_USB1_PLL_SHIFT)) & SYSCON_PDRUNCFG_PDEN_USB1_PLL_MASK)
N#define SYSCON_PDRUNCFG_PDEN_AUD_PLL_MASK        (0x4U)
N#define SYSCON_PDRUNCFG_PDEN_AUD_PLL_SHIFT       (2U)
N#define SYSCON_PDRUNCFG_PDEN_AUD_PLL(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_AUD_PLL_SHIFT)) & SYSCON_PDRUNCFG_PDEN_AUD_PLL_MASK)
N#define SYSCON_PDRUNCFG_PDEN_SYSOSC_MASK         (0x8U)
N#define SYSCON_PDRUNCFG_PDEN_SYSOSC_SHIFT        (3U)
N#define SYSCON_PDRUNCFG_PDEN_SYSOSC(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_SYSOSC_SHIFT)) & SYSCON_PDRUNCFG_PDEN_SYSOSC_MASK)
N#define SYSCON_PDRUNCFG_PDEN_FRO_MASK            (0x10U)
N#define SYSCON_PDRUNCFG_PDEN_FRO_SHIFT           (4U)
N#define SYSCON_PDRUNCFG_PDEN_FRO(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_FRO_SHIFT)) & SYSCON_PDRUNCFG_PDEN_FRO_MASK)
N#define SYSCON_PDRUNCFG_PDEN_EEPROM_MASK         (0x20U)
N#define SYSCON_PDRUNCFG_PDEN_EEPROM_SHIFT        (5U)
N#define SYSCON_PDRUNCFG_PDEN_EEPROM(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_EEPROM_SHIFT)) & SYSCON_PDRUNCFG_PDEN_EEPROM_MASK)
N#define SYSCON_PDRUNCFG_PDEN_FLASH_MASK          (0x20U)
N#define SYSCON_PDRUNCFG_PDEN_FLASH_SHIFT         (5U)
N#define SYSCON_PDRUNCFG_PDEN_FLASH(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_FLASH_SHIFT)) & SYSCON_PDRUNCFG_PDEN_FLASH_MASK)
N#define SYSCON_PDRUNCFG_PDEN_TS_MASK             (0x40U)
N#define SYSCON_PDRUNCFG_PDEN_TS_SHIFT            (6U)
N#define SYSCON_PDRUNCFG_PDEN_TS(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_TS_SHIFT)) & SYSCON_PDRUNCFG_PDEN_TS_MASK)
N#define SYSCON_PDRUNCFG_PDEN_BOD_RST_MASK        (0x80U)
N#define SYSCON_PDRUNCFG_PDEN_BOD_RST_SHIFT       (7U)
N#define SYSCON_PDRUNCFG_PDEN_BOD_RST(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_BOD_RST_SHIFT)) & SYSCON_PDRUNCFG_PDEN_BOD_RST_MASK)
N#define SYSCON_PDRUNCFG_PDEN_RNG_MASK            (0x80U)
N#define SYSCON_PDRUNCFG_PDEN_RNG_SHIFT           (7U)
N#define SYSCON_PDRUNCFG_PDEN_RNG(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_RNG_SHIFT)) & SYSCON_PDRUNCFG_PDEN_RNG_MASK)
N#define SYSCON_PDRUNCFG_PDEN_BOD_INTR_MASK       (0x100U)
N#define SYSCON_PDRUNCFG_PDEN_BOD_INTR_SHIFT      (8U)
N#define SYSCON_PDRUNCFG_PDEN_BOD_INTR(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_BOD_INTR_SHIFT)) & SYSCON_PDRUNCFG_PDEN_BOD_INTR_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VD2_ANA_MASK        (0x200U)
N#define SYSCON_PDRUNCFG_PDEN_VD2_ANA_SHIFT       (9U)
N#define SYSCON_PDRUNCFG_PDEN_VD2_ANA(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VD2_ANA_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VD2_ANA_MASK)
N#define SYSCON_PDRUNCFG_PDEN_ADC0_MASK           (0x400U)
N#define SYSCON_PDRUNCFG_PDEN_ADC0_SHIFT          (10U)
N#define SYSCON_PDRUNCFG_PDEN_ADC0(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_ADC0_SHIFT)) & SYSCON_PDRUNCFG_PDEN_ADC0_MASK)
N#define SYSCON_PDRUNCFG_PDEN_SRAMX_MASK          (0x2000U)
N#define SYSCON_PDRUNCFG_PDEN_SRAMX_SHIFT         (13U)
N#define SYSCON_PDRUNCFG_PDEN_SRAMX(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_SRAMX_SHIFT)) & SYSCON_PDRUNCFG_PDEN_SRAMX_MASK)
N#define SYSCON_PDRUNCFG_PDEN_SRAM0_MASK          (0x4000U)
N#define SYSCON_PDRUNCFG_PDEN_SRAM0_SHIFT         (14U)
N#define SYSCON_PDRUNCFG_PDEN_SRAM0(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_SRAM0_SHIFT)) & SYSCON_PDRUNCFG_PDEN_SRAM0_MASK)
N#define SYSCON_PDRUNCFG_PDEN_SRAM1_2_3_MASK      (0x8000U)
N#define SYSCON_PDRUNCFG_PDEN_SRAM1_2_3_SHIFT     (15U)
N#define SYSCON_PDRUNCFG_PDEN_SRAM1_2_3(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_SRAM1_2_3_SHIFT)) & SYSCON_PDRUNCFG_PDEN_SRAM1_2_3_MASK)
N#define SYSCON_PDRUNCFG_PDEN_USB_RAM_MASK        (0x10000U)
N#define SYSCON_PDRUNCFG_PDEN_USB_RAM_SHIFT       (16U)
N#define SYSCON_PDRUNCFG_PDEN_USB_RAM(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_USB_RAM_SHIFT)) & SYSCON_PDRUNCFG_PDEN_USB_RAM_MASK)
N#define SYSCON_PDRUNCFG_PDEN_ROM_MASK            (0x20000U)
N#define SYSCON_PDRUNCFG_PDEN_ROM_SHIFT           (17U)
N#define SYSCON_PDRUNCFG_PDEN_ROM(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_ROM_SHIFT)) & SYSCON_PDRUNCFG_PDEN_ROM_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VDDA_MASK           (0x80000U)
N#define SYSCON_PDRUNCFG_PDEN_VDDA_SHIFT          (19U)
N#define SYSCON_PDRUNCFG_PDEN_VDDA(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VDDA_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VDDA_MASK)
N#define SYSCON_PDRUNCFG_PDEN_WDT_OSC_MASK        (0x100000U)
N#define SYSCON_PDRUNCFG_PDEN_WDT_OSC_SHIFT       (20U)
N#define SYSCON_PDRUNCFG_PDEN_WDT_OSC(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_WDT_OSC_SHIFT)) & SYSCON_PDRUNCFG_PDEN_WDT_OSC_MASK)
N#define SYSCON_PDRUNCFG_PDEN_USB0_PHY_MASK       (0x200000U)
N#define SYSCON_PDRUNCFG_PDEN_USB0_PHY_SHIFT      (21U)
N#define SYSCON_PDRUNCFG_PDEN_USB0_PHY(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_USB0_PHY_SHIFT)) & SYSCON_PDRUNCFG_PDEN_USB0_PHY_MASK)
N#define SYSCON_PDRUNCFG_PDEN_SYS_PLL_MASK        (0x400000U)
N#define SYSCON_PDRUNCFG_PDEN_SYS_PLL_SHIFT       (22U)
N#define SYSCON_PDRUNCFG_PDEN_SYS_PLL(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_SYS_PLL_SHIFT)) & SYSCON_PDRUNCFG_PDEN_SYS_PLL_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VREFP_MASK          (0x800000U)
N#define SYSCON_PDRUNCFG_PDEN_VREFP_SHIFT         (23U)
N#define SYSCON_PDRUNCFG_PDEN_VREFP(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VREFP_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VREFP_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VD3_MASK            (0x4000000U)
N#define SYSCON_PDRUNCFG_PDEN_VD3_SHIFT           (26U)
N#define SYSCON_PDRUNCFG_PDEN_VD3(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VD3_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VD3_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VD4_MASK            (0x8000000U)
N#define SYSCON_PDRUNCFG_PDEN_VD4_SHIFT           (27U)
N#define SYSCON_PDRUNCFG_PDEN_VD4(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VD4_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VD4_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VD5_MASK            (0x10000000U)
N#define SYSCON_PDRUNCFG_PDEN_VD5_SHIFT           (28U)
N#define SYSCON_PDRUNCFG_PDEN_VD5(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VD5_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VD5_MASK)
N#define SYSCON_PDRUNCFG_PDEN_VD6_MASK            (0x20000000U)
N#define SYSCON_PDRUNCFG_PDEN_VD6_SHIFT           (29U)
N#define SYSCON_PDRUNCFG_PDEN_VD6(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_PDEN_VD6_SHIFT)) & SYSCON_PDRUNCFG_PDEN_VD6_MASK)
N
N/* The count of SYSCON_PDRUNCFG */
N#define SYSCON_PDRUNCFG_COUNT                    (2U)
N
N/*! @name PDRUNCFGSET - Set bits in PDRUNCFG0 */
N#define SYSCON_PDRUNCFGSET_PDEN_USB1_PHY_MASK    (0x1U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB1_PHY_SHIFT   (0U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB1_PHY(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_USB1_PHY_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_USB1_PHY_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_USB1_PLL_MASK    (0x2U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB1_PLL_SHIFT   (1U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB1_PLL(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_USB1_PLL_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_USB1_PLL_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_AUD_PLL_MASK     (0x4U)
N#define SYSCON_PDRUNCFGSET_PDEN_AUD_PLL_SHIFT    (2U)
N#define SYSCON_PDRUNCFGSET_PDEN_AUD_PLL(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_AUD_PLL_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_AUD_PLL_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_SYSOSC_MASK      (0x8U)
N#define SYSCON_PDRUNCFGSET_PDEN_SYSOSC_SHIFT     (3U)
N#define SYSCON_PDRUNCFGSET_PDEN_SYSOSC(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_SYSOSC_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_SYSOSC_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_FRO_MASK         (0x10U)
N#define SYSCON_PDRUNCFGSET_PDEN_FRO_SHIFT        (4U)
N#define SYSCON_PDRUNCFGSET_PDEN_FRO(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_FRO_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_FRO_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_EEPROM_MASK      (0x20U)
N#define SYSCON_PDRUNCFGSET_PDEN_EEPROM_SHIFT     (5U)
N#define SYSCON_PDRUNCFGSET_PDEN_EEPROM(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_EEPROM_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_EEPROM_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_FLASH_MASK       (0x20U)
N#define SYSCON_PDRUNCFGSET_PDEN_FLASH_SHIFT      (5U)
N#define SYSCON_PDRUNCFGSET_PDEN_FLASH(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_FLASH_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_FLASH_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_TS_MASK          (0x40U)
N#define SYSCON_PDRUNCFGSET_PDEN_TS_SHIFT         (6U)
N#define SYSCON_PDRUNCFGSET_PDEN_TS(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_TS_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_TS_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_BOD_RST_MASK     (0x80U)
N#define SYSCON_PDRUNCFGSET_PDEN_BOD_RST_SHIFT    (7U)
N#define SYSCON_PDRUNCFGSET_PDEN_BOD_RST(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_BOD_RST_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_BOD_RST_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_RNG_MASK         (0x80U)
N#define SYSCON_PDRUNCFGSET_PDEN_RNG_SHIFT        (7U)
N#define SYSCON_PDRUNCFGSET_PDEN_RNG(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_RNG_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_RNG_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_BOD_INTR_MASK    (0x100U)
N#define SYSCON_PDRUNCFGSET_PDEN_BOD_INTR_SHIFT   (8U)
N#define SYSCON_PDRUNCFGSET_PDEN_BOD_INTR(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_BOD_INTR_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_BOD_INTR_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VD2_ANA_MASK     (0x200U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD2_ANA_SHIFT    (9U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD2_ANA(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VD2_ANA_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VD2_ANA_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_ADC0_MASK        (0x400U)
N#define SYSCON_PDRUNCFGSET_PDEN_ADC0_SHIFT       (10U)
N#define SYSCON_PDRUNCFGSET_PDEN_ADC0(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_ADC0_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_ADC0_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAMX_MASK       (0x2000U)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAMX_SHIFT      (13U)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAMX(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_SRAMX_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_SRAMX_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAM0_MASK       (0x4000U)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAM0_SHIFT      (14U)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAM0(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_SRAM0_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_SRAM0_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAM1_2_3_MASK   (0x8000U)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAM1_2_3_SHIFT  (15U)
N#define SYSCON_PDRUNCFGSET_PDEN_SRAM1_2_3(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_SRAM1_2_3_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_SRAM1_2_3_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_USB_RAM_MASK     (0x10000U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB_RAM_SHIFT    (16U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB_RAM(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_USB_RAM_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_USB_RAM_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_ROM_MASK         (0x20000U)
N#define SYSCON_PDRUNCFGSET_PDEN_ROM_SHIFT        (17U)
N#define SYSCON_PDRUNCFGSET_PDEN_ROM(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_ROM_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_ROM_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VDDA_MASK        (0x80000U)
N#define SYSCON_PDRUNCFGSET_PDEN_VDDA_SHIFT       (19U)
N#define SYSCON_PDRUNCFGSET_PDEN_VDDA(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VDDA_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VDDA_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_WDT_OSC_MASK     (0x100000U)
N#define SYSCON_PDRUNCFGSET_PDEN_WDT_OSC_SHIFT    (20U)
N#define SYSCON_PDRUNCFGSET_PDEN_WDT_OSC(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_WDT_OSC_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_WDT_OSC_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_USB0_PHY_MASK    (0x200000U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB0_PHY_SHIFT   (21U)
N#define SYSCON_PDRUNCFGSET_PDEN_USB0_PHY(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_USB0_PHY_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_USB0_PHY_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_SYS_PLL_MASK     (0x400000U)
N#define SYSCON_PDRUNCFGSET_PDEN_SYS_PLL_SHIFT    (22U)
N#define SYSCON_PDRUNCFGSET_PDEN_SYS_PLL(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_SYS_PLL_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_SYS_PLL_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VREFP_MASK       (0x800000U)
N#define SYSCON_PDRUNCFGSET_PDEN_VREFP_SHIFT      (23U)
N#define SYSCON_PDRUNCFGSET_PDEN_VREFP(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VREFP_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VREFP_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VD3_MASK         (0x4000000U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD3_SHIFT        (26U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD3(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VD3_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VD3_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VD4_MASK         (0x8000000U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD4_SHIFT        (27U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD4(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VD4_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VD4_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VD5_MASK         (0x10000000U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD5_SHIFT        (28U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD5(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VD5_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VD5_MASK)
N#define SYSCON_PDRUNCFGSET_PDEN_VD6_MASK         (0x20000000U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD6_SHIFT        (29U)
N#define SYSCON_PDRUNCFGSET_PDEN_VD6(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGSET_PDEN_VD6_SHIFT)) & SYSCON_PDRUNCFGSET_PDEN_VD6_MASK)
N
N/* The count of SYSCON_PDRUNCFGSET */
N#define SYSCON_PDRUNCFGSET_COUNT                 (2U)
N
N/*! @name PDRUNCFGCLR - Clear bits in PDRUNCFG0 */
N#define SYSCON_PDRUNCFGCLR_PDEN_USB1_PHY_MASK    (0x1U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB1_PHY_SHIFT   (0U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB1_PHY(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_USB1_PHY_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_USB1_PHY_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB1_PLL_MASK    (0x2U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB1_PLL_SHIFT   (1U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB1_PLL(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_USB1_PLL_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_USB1_PLL_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_AUD_PLL_MASK     (0x4U)
N#define SYSCON_PDRUNCFGCLR_PDEN_AUD_PLL_SHIFT    (2U)
N#define SYSCON_PDRUNCFGCLR_PDEN_AUD_PLL(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_AUD_PLL_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_AUD_PLL_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_SYSOSC_MASK      (0x8U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SYSOSC_SHIFT     (3U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SYSOSC(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_SYSOSC_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_SYSOSC_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_FRO_MASK         (0x10U)
N#define SYSCON_PDRUNCFGCLR_PDEN_FRO_SHIFT        (4U)
N#define SYSCON_PDRUNCFGCLR_PDEN_FRO(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_FRO_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_FRO_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_EEPROM_MASK      (0x20U)
N#define SYSCON_PDRUNCFGCLR_PDEN_EEPROM_SHIFT     (5U)
N#define SYSCON_PDRUNCFGCLR_PDEN_EEPROM(x)        (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_EEPROM_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_EEPROM_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_FLASH_MASK       (0x20U)
N#define SYSCON_PDRUNCFGCLR_PDEN_FLASH_SHIFT      (5U)
N#define SYSCON_PDRUNCFGCLR_PDEN_FLASH(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_FLASH_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_FLASH_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_TS_MASK          (0x40U)
N#define SYSCON_PDRUNCFGCLR_PDEN_TS_SHIFT         (6U)
N#define SYSCON_PDRUNCFGCLR_PDEN_TS(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_TS_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_TS_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_BOD_RST_MASK     (0x80U)
N#define SYSCON_PDRUNCFGCLR_PDEN_BOD_RST_SHIFT    (7U)
N#define SYSCON_PDRUNCFGCLR_PDEN_BOD_RST(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_BOD_RST_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_BOD_RST_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_RNG_MASK         (0x80U)
N#define SYSCON_PDRUNCFGCLR_PDEN_RNG_SHIFT        (7U)
N#define SYSCON_PDRUNCFGCLR_PDEN_RNG(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_RNG_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_RNG_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_BOD_INTR_MASK    (0x100U)
N#define SYSCON_PDRUNCFGCLR_PDEN_BOD_INTR_SHIFT   (8U)
N#define SYSCON_PDRUNCFGCLR_PDEN_BOD_INTR(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_BOD_INTR_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_BOD_INTR_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD2_ANA_MASK     (0x200U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD2_ANA_SHIFT    (9U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD2_ANA(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VD2_ANA_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VD2_ANA_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_ADC0_MASK        (0x400U)
N#define SYSCON_PDRUNCFGCLR_PDEN_ADC0_SHIFT       (10U)
N#define SYSCON_PDRUNCFGCLR_PDEN_ADC0(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_ADC0_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_ADC0_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAMX_MASK       (0x2000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAMX_SHIFT      (13U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAMX(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_SRAMX_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_SRAMX_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAM0_MASK       (0x4000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAM0_SHIFT      (14U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAM0(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_SRAM0_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_SRAM0_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAM1_2_3_MASK   (0x8000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAM1_2_3_SHIFT  (15U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SRAM1_2_3(x)     (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_SRAM1_2_3_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_SRAM1_2_3_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB_RAM_MASK     (0x10000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB_RAM_SHIFT    (16U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB_RAM(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_USB_RAM_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_USB_RAM_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_ROM_MASK         (0x20000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_ROM_SHIFT        (17U)
N#define SYSCON_PDRUNCFGCLR_PDEN_ROM(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_ROM_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_ROM_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VDDA_MASK        (0x80000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VDDA_SHIFT       (19U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VDDA(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VDDA_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VDDA_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_WDT_OSC_MASK     (0x100000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_WDT_OSC_SHIFT    (20U)
N#define SYSCON_PDRUNCFGCLR_PDEN_WDT_OSC(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_WDT_OSC_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_WDT_OSC_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB0_PHY_MASK    (0x200000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB0_PHY_SHIFT   (21U)
N#define SYSCON_PDRUNCFGCLR_PDEN_USB0_PHY(x)      (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_USB0_PHY_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_USB0_PHY_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_SYS_PLL_MASK     (0x400000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SYS_PLL_SHIFT    (22U)
N#define SYSCON_PDRUNCFGCLR_PDEN_SYS_PLL(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_SYS_PLL_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_SYS_PLL_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VREFP_MASK       (0x800000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VREFP_SHIFT      (23U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VREFP(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VREFP_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VREFP_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD3_MASK         (0x4000000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD3_SHIFT        (26U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD3(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VD3_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VD3_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD4_MASK         (0x8000000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD4_SHIFT        (27U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD4(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VD4_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VD4_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD5_MASK         (0x10000000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD5_SHIFT        (28U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD5(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VD5_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VD5_MASK)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD6_MASK         (0x20000000U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD6_SHIFT        (29U)
N#define SYSCON_PDRUNCFGCLR_PDEN_VD6(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFGCLR_PDEN_VD6_SHIFT)) & SYSCON_PDRUNCFGCLR_PDEN_VD6_MASK)
N
N/* The count of SYSCON_PDRUNCFGCLR */
N#define SYSCON_PDRUNCFGCLR_COUNT                 (2U)
N
N/*! @name STARTER - Start logic 0 wake-up enable register */
N#define SYSCON_STARTER_WDT_BOD_MASK              (0x1U)
N#define SYSCON_STARTER_WDT_BOD_SHIFT             (0U)
N#define SYSCON_STARTER_WDT_BOD(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_WDT_BOD_SHIFT)) & SYSCON_STARTER_WDT_BOD_MASK)
N#define SYSCON_STARTER_PINT4_MASK                (0x1U)
N#define SYSCON_STARTER_PINT4_SHIFT               (0U)
N#define SYSCON_STARTER_PINT4(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PINT4_SHIFT)) & SYSCON_STARTER_PINT4_MASK)
N#define SYSCON_STARTER_PINT5_MASK                (0x2U)
N#define SYSCON_STARTER_PINT5_SHIFT               (1U)
N#define SYSCON_STARTER_PINT5(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PINT5_SHIFT)) & SYSCON_STARTER_PINT5_MASK)
N#define SYSCON_STARTER_DMA_MASK                  (0x2U)
N#define SYSCON_STARTER_DMA_SHIFT                 (1U)
N#define SYSCON_STARTER_DMA(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_DMA_SHIFT)) & SYSCON_STARTER_DMA_MASK)
N#define SYSCON_STARTER_GINT0_MASK                (0x4U)
N#define SYSCON_STARTER_GINT0_SHIFT               (2U)
N#define SYSCON_STARTER_GINT0(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_GINT0_SHIFT)) & SYSCON_STARTER_GINT0_MASK)
N#define SYSCON_STARTER_PINT6_MASK                (0x4U)
N#define SYSCON_STARTER_PINT6_SHIFT               (2U)
N#define SYSCON_STARTER_PINT6(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PINT6_SHIFT)) & SYSCON_STARTER_PINT6_MASK)
N#define SYSCON_STARTER_GINT1_MASK                (0x8U)
N#define SYSCON_STARTER_GINT1_SHIFT               (3U)
N#define SYSCON_STARTER_GINT1(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_GINT1_SHIFT)) & SYSCON_STARTER_GINT1_MASK)
N#define SYSCON_STARTER_PINT7_MASK                (0x8U)
N#define SYSCON_STARTER_PINT7_SHIFT               (3U)
N#define SYSCON_STARTER_PINT7(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PINT7_SHIFT)) & SYSCON_STARTER_PINT7_MASK)
N#define SYSCON_STARTER_CTIMER2_MASK              (0x10U)
N#define SYSCON_STARTER_CTIMER2_SHIFT             (4U)
N#define SYSCON_STARTER_CTIMER2(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_CTIMER2_SHIFT)) & SYSCON_STARTER_CTIMER2_MASK)
N#define SYSCON_STARTER_PIN_INT0_MASK             (0x10U)
N#define SYSCON_STARTER_PIN_INT0_SHIFT            (4U)
N#define SYSCON_STARTER_PIN_INT0(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PIN_INT0_SHIFT)) & SYSCON_STARTER_PIN_INT0_MASK)
N#define SYSCON_STARTER_CTIMER4_MASK              (0x20U)
N#define SYSCON_STARTER_CTIMER4_SHIFT             (5U)
N#define SYSCON_STARTER_CTIMER4(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_CTIMER4_SHIFT)) & SYSCON_STARTER_CTIMER4_MASK)
N#define SYSCON_STARTER_PIN_INT1_MASK             (0x20U)
N#define SYSCON_STARTER_PIN_INT1_SHIFT            (5U)
N#define SYSCON_STARTER_PIN_INT1(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PIN_INT1_SHIFT)) & SYSCON_STARTER_PIN_INT1_MASK)
N#define SYSCON_STARTER_PIN_INT2_MASK             (0x40U)
N#define SYSCON_STARTER_PIN_INT2_SHIFT            (6U)
N#define SYSCON_STARTER_PIN_INT2(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PIN_INT2_SHIFT)) & SYSCON_STARTER_PIN_INT2_MASK)
N#define SYSCON_STARTER_PIN_INT3_MASK             (0x80U)
N#define SYSCON_STARTER_PIN_INT3_SHIFT            (7U)
N#define SYSCON_STARTER_PIN_INT3(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_PIN_INT3_SHIFT)) & SYSCON_STARTER_PIN_INT3_MASK)
N#define SYSCON_STARTER_SPIFI_MASK                (0x80U)
N#define SYSCON_STARTER_SPIFI_SHIFT               (7U)
N#define SYSCON_STARTER_SPIFI(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_SPIFI_SHIFT)) & SYSCON_STARTER_SPIFI_MASK)
N#define SYSCON_STARTER_FLEXCOMM8_MASK            (0x100U)
N#define SYSCON_STARTER_FLEXCOMM8_SHIFT           (8U)
N#define SYSCON_STARTER_FLEXCOMM8(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM8_SHIFT)) & SYSCON_STARTER_FLEXCOMM8_MASK)
N#define SYSCON_STARTER_UTICK_MASK                (0x100U)
N#define SYSCON_STARTER_UTICK_SHIFT               (8U)
N#define SYSCON_STARTER_UTICK(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_UTICK_SHIFT)) & SYSCON_STARTER_UTICK_MASK)
N#define SYSCON_STARTER_MRT_MASK                  (0x200U)
N#define SYSCON_STARTER_MRT_SHIFT                 (9U)
N#define SYSCON_STARTER_MRT(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_MRT_SHIFT)) & SYSCON_STARTER_MRT_MASK)
N#define SYSCON_STARTER_FLEXCOMM9_MASK            (0x200U)
N#define SYSCON_STARTER_FLEXCOMM9_SHIFT           (9U)
N#define SYSCON_STARTER_FLEXCOMM9(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM9_SHIFT)) & SYSCON_STARTER_FLEXCOMM9_MASK)
N#define SYSCON_STARTER_CTIMER0_MASK              (0x400U)
N#define SYSCON_STARTER_CTIMER0_SHIFT             (10U)
N#define SYSCON_STARTER_CTIMER0(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_CTIMER0_SHIFT)) & SYSCON_STARTER_CTIMER0_MASK)
N#define SYSCON_STARTER_CTIMER1_MASK              (0x800U)
N#define SYSCON_STARTER_CTIMER1_SHIFT             (11U)
N#define SYSCON_STARTER_CTIMER1(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_CTIMER1_SHIFT)) & SYSCON_STARTER_CTIMER1_MASK)
N#define SYSCON_STARTER_SCT0_MASK                 (0x1000U)
N#define SYSCON_STARTER_SCT0_SHIFT                (12U)
N#define SYSCON_STARTER_SCT0(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_SCT0_SHIFT)) & SYSCON_STARTER_SCT0_MASK)
N#define SYSCON_STARTER_CTIMER3_MASK              (0x2000U)
N#define SYSCON_STARTER_CTIMER3_SHIFT             (13U)
N#define SYSCON_STARTER_CTIMER3(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_CTIMER3_SHIFT)) & SYSCON_STARTER_CTIMER3_MASK)
N#define SYSCON_STARTER_FLEXCOMM0_MASK            (0x4000U)
N#define SYSCON_STARTER_FLEXCOMM0_SHIFT           (14U)
N#define SYSCON_STARTER_FLEXCOMM0(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM0_SHIFT)) & SYSCON_STARTER_FLEXCOMM0_MASK)
N#define SYSCON_STARTER_FLEXCOMM1_MASK            (0x8000U)
N#define SYSCON_STARTER_FLEXCOMM1_SHIFT           (15U)
N#define SYSCON_STARTER_FLEXCOMM1(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM1_SHIFT)) & SYSCON_STARTER_FLEXCOMM1_MASK)
N#define SYSCON_STARTER_USB1_MASK                 (0x8000U)
N#define SYSCON_STARTER_USB1_SHIFT                (15U)
N#define SYSCON_STARTER_USB1(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_USB1_SHIFT)) & SYSCON_STARTER_USB1_MASK)
N#define SYSCON_STARTER_FLEXCOMM2_MASK            (0x10000U)
N#define SYSCON_STARTER_FLEXCOMM2_SHIFT           (16U)
N#define SYSCON_STARTER_FLEXCOMM2(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM2_SHIFT)) & SYSCON_STARTER_FLEXCOMM2_MASK)
N#define SYSCON_STARTER_USB1_ACT_MASK             (0x10000U)
N#define SYSCON_STARTER_USB1_ACT_SHIFT            (16U)
N#define SYSCON_STARTER_USB1_ACT(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_USB1_ACT_SHIFT)) & SYSCON_STARTER_USB1_ACT_MASK)
N#define SYSCON_STARTER_ENET_INT1_MASK            (0x20000U)
N#define SYSCON_STARTER_ENET_INT1_SHIFT           (17U)
N#define SYSCON_STARTER_ENET_INT1(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_ENET_INT1_SHIFT)) & SYSCON_STARTER_ENET_INT1_MASK)
N#define SYSCON_STARTER_FLEXCOMM3_MASK            (0x20000U)
N#define SYSCON_STARTER_FLEXCOMM3_SHIFT           (17U)
N#define SYSCON_STARTER_FLEXCOMM3(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM3_SHIFT)) & SYSCON_STARTER_FLEXCOMM3_MASK)
N#define SYSCON_STARTER_ENET_INT2_MASK            (0x40000U)
N#define SYSCON_STARTER_ENET_INT2_SHIFT           (18U)
N#define SYSCON_STARTER_ENET_INT2(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_ENET_INT2_SHIFT)) & SYSCON_STARTER_ENET_INT2_MASK)
N#define SYSCON_STARTER_FLEXCOMM4_MASK            (0x40000U)
N#define SYSCON_STARTER_FLEXCOMM4_SHIFT           (18U)
N#define SYSCON_STARTER_FLEXCOMM4(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM4_SHIFT)) & SYSCON_STARTER_FLEXCOMM4_MASK)
N#define SYSCON_STARTER_ENET_INT0_MASK            (0x80000U)
N#define SYSCON_STARTER_ENET_INT0_SHIFT           (19U)
N#define SYSCON_STARTER_ENET_INT0(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_ENET_INT0_SHIFT)) & SYSCON_STARTER_ENET_INT0_MASK)
N#define SYSCON_STARTER_FLEXCOMM5_MASK            (0x80000U)
N#define SYSCON_STARTER_FLEXCOMM5_SHIFT           (19U)
N#define SYSCON_STARTER_FLEXCOMM5(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM5_SHIFT)) & SYSCON_STARTER_FLEXCOMM5_MASK)
N#define SYSCON_STARTER_FLEXCOMM6_MASK            (0x100000U)
N#define SYSCON_STARTER_FLEXCOMM6_SHIFT           (20U)
N#define SYSCON_STARTER_FLEXCOMM6(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM6_SHIFT)) & SYSCON_STARTER_FLEXCOMM6_MASK)
N#define SYSCON_STARTER_FLEXCOMM7_MASK            (0x200000U)
N#define SYSCON_STARTER_FLEXCOMM7_SHIFT           (21U)
N#define SYSCON_STARTER_FLEXCOMM7(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_FLEXCOMM7_SHIFT)) & SYSCON_STARTER_FLEXCOMM7_MASK)
N#define SYSCON_STARTER_ADC0_SEQA_MASK            (0x400000U)
N#define SYSCON_STARTER_ADC0_SEQA_SHIFT           (22U)
N#define SYSCON_STARTER_ADC0_SEQA(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_ADC0_SEQA_SHIFT)) & SYSCON_STARTER_ADC0_SEQA_MASK)
N#define SYSCON_STARTER_SMARTCARD0_MASK           (0x800000U)
N#define SYSCON_STARTER_SMARTCARD0_SHIFT          (23U)
N#define SYSCON_STARTER_SMARTCARD0(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_SMARTCARD0_SHIFT)) & SYSCON_STARTER_SMARTCARD0_MASK)
N#define SYSCON_STARTER_ADC0_SEQB_MASK            (0x800000U)
N#define SYSCON_STARTER_ADC0_SEQB_SHIFT           (23U)
N#define SYSCON_STARTER_ADC0_SEQB(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_ADC0_SEQB_SHIFT)) & SYSCON_STARTER_ADC0_SEQB_MASK)
N#define SYSCON_STARTER_ADC0_THCMP_MASK           (0x1000000U)
N#define SYSCON_STARTER_ADC0_THCMP_SHIFT          (24U)
N#define SYSCON_STARTER_ADC0_THCMP(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_ADC0_THCMP_SHIFT)) & SYSCON_STARTER_ADC0_THCMP_MASK)
N#define SYSCON_STARTER_SMARTCARD1_MASK           (0x1000000U)
N#define SYSCON_STARTER_SMARTCARD1_SHIFT          (24U)
N#define SYSCON_STARTER_SMARTCARD1(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_SMARTCARD1_SHIFT)) & SYSCON_STARTER_SMARTCARD1_MASK)
N#define SYSCON_STARTER_DMIC_MASK                 (0x2000000U)
N#define SYSCON_STARTER_DMIC_SHIFT                (25U)
N#define SYSCON_STARTER_DMIC(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_DMIC_SHIFT)) & SYSCON_STARTER_DMIC_MASK)
N#define SYSCON_STARTER_HWVAD_MASK                (0x4000000U)
N#define SYSCON_STARTER_HWVAD_SHIFT               (26U)
N#define SYSCON_STARTER_HWVAD(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_HWVAD_SHIFT)) & SYSCON_STARTER_HWVAD_MASK)
N#define SYSCON_STARTER_USB0_NEEDCLK_MASK         (0x8000000U)
N#define SYSCON_STARTER_USB0_NEEDCLK_SHIFT        (27U)
N#define SYSCON_STARTER_USB0_NEEDCLK(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_USB0_NEEDCLK_SHIFT)) & SYSCON_STARTER_USB0_NEEDCLK_MASK)
N#define SYSCON_STARTER_USB0_MASK                 (0x10000000U)
N#define SYSCON_STARTER_USB0_SHIFT                (28U)
N#define SYSCON_STARTER_USB0(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_USB0_SHIFT)) & SYSCON_STARTER_USB0_MASK)
N#define SYSCON_STARTER_RTC_MASK                  (0x20000000U)
N#define SYSCON_STARTER_RTC_SHIFT                 (29U)
N#define SYSCON_STARTER_RTC(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTER_RTC_SHIFT)) & SYSCON_STARTER_RTC_MASK)
N
N/* The count of SYSCON_STARTER */
N#define SYSCON_STARTER_COUNT                     (2U)
N
N/*! @name STARTERSET - Set bits in STARTER */
N#define SYSCON_STARTERSET_START_SET_MASK         (0xFFFFFFFFU)
N#define SYSCON_STARTERSET_START_SET_SHIFT        (0U)
N#define SYSCON_STARTERSET_START_SET(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERSET_START_SET_SHIFT)) & SYSCON_STARTERSET_START_SET_MASK)
N
N/* The count of SYSCON_STARTERSET */
N#define SYSCON_STARTERSET_COUNT                  (2U)
N
N/*! @name STARTERCLR - Clear bits in STARTER0 */
N#define SYSCON_STARTERCLR_START_CLR_MASK         (0xFFFFFFFFU)
N#define SYSCON_STARTERCLR_START_CLR_SHIFT        (0U)
N#define SYSCON_STARTERCLR_START_CLR(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERCLR_START_CLR_SHIFT)) & SYSCON_STARTERCLR_START_CLR_MASK)
N
N/* The count of SYSCON_STARTERCLR */
N#define SYSCON_STARTERCLR_COUNT                  (2U)
N
N/*! @name HWWAKE - Configures special cases of hardware wake-up */
N#define SYSCON_HWWAKE_FORCEWAKE_MASK             (0x1U)
N#define SYSCON_HWWAKE_FORCEWAKE_SHIFT            (0U)
N#define SYSCON_HWWAKE_FORCEWAKE(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_HWWAKE_FORCEWAKE_SHIFT)) & SYSCON_HWWAKE_FORCEWAKE_MASK)
N#define SYSCON_HWWAKE_FCWAKE_MASK                (0x2U)
N#define SYSCON_HWWAKE_FCWAKE_SHIFT               (1U)
N#define SYSCON_HWWAKE_FCWAKE(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_HWWAKE_FCWAKE_SHIFT)) & SYSCON_HWWAKE_FCWAKE_MASK)
N#define SYSCON_HWWAKE_WAKEDMIC_MASK              (0x4U)
N#define SYSCON_HWWAKE_WAKEDMIC_SHIFT             (2U)
N#define SYSCON_HWWAKE_WAKEDMIC(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_HWWAKE_WAKEDMIC_SHIFT)) & SYSCON_HWWAKE_WAKEDMIC_MASK)
N#define SYSCON_HWWAKE_WAKEDMA_MASK               (0x8U)
N#define SYSCON_HWWAKE_WAKEDMA_SHIFT              (3U)
N#define SYSCON_HWWAKE_WAKEDMA(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_HWWAKE_WAKEDMA_SHIFT)) & SYSCON_HWWAKE_WAKEDMA_MASK)
N
N/*! @name AUTOCGOR - Auto Clock-Gate Override Register */
N#define SYSCON_AUTOCGOR_RAM0X_MASK               (0x2U)
N#define SYSCON_AUTOCGOR_RAM0X_SHIFT              (1U)
N#define SYSCON_AUTOCGOR_RAM0X(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_AUTOCGOR_RAM0X_SHIFT)) & SYSCON_AUTOCGOR_RAM0X_MASK)
N#define SYSCON_AUTOCGOR_RAM1_MASK                (0x4U)
N#define SYSCON_AUTOCGOR_RAM1_SHIFT               (2U)
N#define SYSCON_AUTOCGOR_RAM1(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_AUTOCGOR_RAM1_SHIFT)) & SYSCON_AUTOCGOR_RAM1_MASK)
N#define SYSCON_AUTOCGOR_RAM2_MASK                (0x8U)
N#define SYSCON_AUTOCGOR_RAM2_SHIFT               (3U)
N#define SYSCON_AUTOCGOR_RAM2(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_AUTOCGOR_RAM2_SHIFT)) & SYSCON_AUTOCGOR_RAM2_MASK)
N#define SYSCON_AUTOCGOR_RAM3_MASK                (0x10U)
N#define SYSCON_AUTOCGOR_RAM3_SHIFT               (4U)
N#define SYSCON_AUTOCGOR_RAM3(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_AUTOCGOR_RAM3_SHIFT)) & SYSCON_AUTOCGOR_RAM3_MASK)
N
N/*! @name JTAGIDCODE - JTAG ID code register */
N#define SYSCON_JTAGIDCODE_JTAGID_MASK            (0xFFFFFFFFU)
N#define SYSCON_JTAGIDCODE_JTAGID_SHIFT           (0U)
N#define SYSCON_JTAGIDCODE_JTAGID(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_JTAGIDCODE_JTAGID_SHIFT)) & SYSCON_JTAGIDCODE_JTAGID_MASK)
N
N/*! @name DEVICE_ID0 - Part ID register */
N#define SYSCON_DEVICE_ID0_PARTID_MASK            (0xFFFFFFFFU)
N#define SYSCON_DEVICE_ID0_PARTID_SHIFT           (0U)
N#define SYSCON_DEVICE_ID0_PARTID(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_DEVICE_ID0_PARTID_SHIFT)) & SYSCON_DEVICE_ID0_PARTID_MASK)
N
N/*! @name DEVICE_ID1 - Boot ROM and die revision register */
N#define SYSCON_DEVICE_ID1_REVID_MASK             (0xFFFFFFFFU)
N#define SYSCON_DEVICE_ID1_REVID_SHIFT            (0U)
N#define SYSCON_DEVICE_ID1_REVID(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_DEVICE_ID1_REVID_SHIFT)) & SYSCON_DEVICE_ID1_REVID_MASK)
N
N/*! @name BODCTRL - Brown-Out Detect control */
N#define SYSCON_BODCTRL_BODRSTLEV_MASK            (0x3U)
N#define SYSCON_BODCTRL_BODRSTLEV_SHIFT           (0U)
N#define SYSCON_BODCTRL_BODRSTLEV(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODRSTLEV_SHIFT)) & SYSCON_BODCTRL_BODRSTLEV_MASK)
N#define SYSCON_BODCTRL_BODRSTENA_MASK            (0x4U)
N#define SYSCON_BODCTRL_BODRSTENA_SHIFT           (2U)
N#define SYSCON_BODCTRL_BODRSTENA(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODRSTENA_SHIFT)) & SYSCON_BODCTRL_BODRSTENA_MASK)
N#define SYSCON_BODCTRL_BODINTLEV_MASK            (0x18U)
N#define SYSCON_BODCTRL_BODINTLEV_SHIFT           (3U)
N#define SYSCON_BODCTRL_BODINTLEV(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODINTLEV_SHIFT)) & SYSCON_BODCTRL_BODINTLEV_MASK)
N#define SYSCON_BODCTRL_BODINTENA_MASK            (0x20U)
N#define SYSCON_BODCTRL_BODINTENA_SHIFT           (5U)
N#define SYSCON_BODCTRL_BODINTENA(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODINTENA_SHIFT)) & SYSCON_BODCTRL_BODINTENA_MASK)
N#define SYSCON_BODCTRL_BODRSTSTAT_MASK           (0x40U)
N#define SYSCON_BODCTRL_BODRSTSTAT_SHIFT          (6U)
N#define SYSCON_BODCTRL_BODRSTSTAT(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODRSTSTAT_SHIFT)) & SYSCON_BODCTRL_BODRSTSTAT_MASK)
N#define SYSCON_BODCTRL_BODINTSTAT_MASK           (0x80U)
N#define SYSCON_BODCTRL_BODINTSTAT_SHIFT          (7U)
N#define SYSCON_BODCTRL_BODINTSTAT(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODINTSTAT_SHIFT)) & SYSCON_BODCTRL_BODINTSTAT_MASK)
N
N
N/*!
N * @}
N */ /* end of group SYSCON_Register_Masks */
N
N
N/* SYSCON - Peripheral instance base addresses */
N/** Peripheral SYSCON base address */
N#define SYSCON_BASE                              (0x40000000u)
N/** Peripheral SYSCON base pointer */
N#define SYSCON                                   ((SYSCON_Type *)SYSCON_BASE)
N/** Array initializer of SYSCON peripheral base addresses */
N#define SYSCON_BASE_ADDRS                        { SYSCON_BASE }
N/** Array initializer of SYSCON peripheral base pointers */
N#define SYSCON_BASE_PTRS                         { SYSCON }
N
N/*!
N * @}
N */ /* end of group SYSCON_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USART Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USART_Peripheral_Access_Layer USART Peripheral Access Layer
N * @{
N */
N
N/** USART - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CFG;                               /**< USART Configuration register. Basic USART configuration settings that typically are not changed during operation., offset: 0x0 */
X  volatile uint32_t CFG;                                
N  __IO uint32_t CTL;                               /**< USART Control register. USART control settings that are more likely to change during operation., offset: 0x4 */
X  volatile uint32_t CTL;                                
N  __IO uint32_t STAT;                              /**< USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them., offset: 0x8 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t INTENSET;                          /**< Interrupt Enable read and Set register for USART (not FIFO) status. Contains individual interrupt enable bits for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set., offset: 0xC */
X  volatile uint32_t INTENSET;                           
N  __O  uint32_t INTENCLR;                          /**< Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared., offset: 0x10 */
X  volatile  uint32_t INTENCLR;                           
N       uint8_t RESERVED_0[12];
N  __IO uint32_t BRG;                               /**< Baud Rate Generator register. 16-bit integer baud rate divisor value., offset: 0x20 */
X  volatile uint32_t BRG;                                
N  __I  uint32_t INTSTAT;                           /**< Interrupt status register. Reflects interrupts that are currently enabled., offset: 0x24 */
X  volatile const  uint32_t INTSTAT;                            
N  __IO uint32_t OSR;                               /**< Oversample selection register for asynchronous communication., offset: 0x28 */
X  volatile uint32_t OSR;                                
N  __IO uint32_t ADDR;                              /**< Address register for automatic address matching., offset: 0x2C */
X  volatile uint32_t ADDR;                               
N       uint8_t RESERVED_1[3536];
N  __IO uint32_t FIFOCFG;                           /**< FIFO configuration and enable register., offset: 0xE00 */
X  volatile uint32_t FIFOCFG;                            
N  __IO uint32_t FIFOSTAT;                          /**< FIFO status register., offset: 0xE04 */
X  volatile uint32_t FIFOSTAT;                           
N  __IO uint32_t FIFOTRIG;                          /**< FIFO trigger settings for interrupt and DMA request., offset: 0xE08 */
X  volatile uint32_t FIFOTRIG;                           
N       uint8_t RESERVED_2[4];
N  __IO uint32_t FIFOINTENSET;                      /**< FIFO interrupt enable set (enable) and read register., offset: 0xE10 */
X  volatile uint32_t FIFOINTENSET;                       
N  __IO uint32_t FIFOINTENCLR;                      /**< FIFO interrupt enable clear (disable) and read register., offset: 0xE14 */
X  volatile uint32_t FIFOINTENCLR;                       
N  __I  uint32_t FIFOINTSTAT;                       /**< FIFO interrupt status register., offset: 0xE18 */
X  volatile const  uint32_t FIFOINTSTAT;                        
N       uint8_t RESERVED_3[4];
N  __IO uint32_t FIFOWR;                            /**< FIFO write data., offset: 0xE20 */
X  volatile uint32_t FIFOWR;                             
N       uint8_t RESERVED_4[12];
N  __I  uint32_t FIFORD;                            /**< FIFO read data., offset: 0xE30 */
X  volatile const  uint32_t FIFORD;                             
N       uint8_t RESERVED_5[12];
N  __I  uint32_t FIFORDNOPOP;                       /**< FIFO data read with no FIFO pop., offset: 0xE40 */
X  volatile const  uint32_t FIFORDNOPOP;                        
N       uint8_t RESERVED_6[440];
N  __I  uint32_t ID;                                /**< Peripheral identification register., offset: 0xFFC */
X  volatile const  uint32_t ID;                                 
N} USART_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USART Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USART_Register_Masks USART Register Masks
N * @{
N */
N
N/*! @name CFG - USART Configuration register. Basic USART configuration settings that typically are not changed during operation. */
N#define USART_CFG_ENABLE_MASK                    (0x1U)
N#define USART_CFG_ENABLE_SHIFT                   (0U)
N#define USART_CFG_ENABLE(x)                      (((uint32_t)(((uint32_t)(x)) << USART_CFG_ENABLE_SHIFT)) & USART_CFG_ENABLE_MASK)
N#define USART_CFG_DATALEN_MASK                   (0xCU)
N#define USART_CFG_DATALEN_SHIFT                  (2U)
N#define USART_CFG_DATALEN(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_DATALEN_SHIFT)) & USART_CFG_DATALEN_MASK)
N#define USART_CFG_PARITYSEL_MASK                 (0x30U)
N#define USART_CFG_PARITYSEL_SHIFT                (4U)
N#define USART_CFG_PARITYSEL(x)                   (((uint32_t)(((uint32_t)(x)) << USART_CFG_PARITYSEL_SHIFT)) & USART_CFG_PARITYSEL_MASK)
N#define USART_CFG_STOPLEN_MASK                   (0x40U)
N#define USART_CFG_STOPLEN_SHIFT                  (6U)
N#define USART_CFG_STOPLEN(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_STOPLEN_SHIFT)) & USART_CFG_STOPLEN_MASK)
N#define USART_CFG_MODE32K_MASK                   (0x80U)
N#define USART_CFG_MODE32K_SHIFT                  (7U)
N#define USART_CFG_MODE32K(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_MODE32K_SHIFT)) & USART_CFG_MODE32K_MASK)
N#define USART_CFG_LINMODE_MASK                   (0x100U)
N#define USART_CFG_LINMODE_SHIFT                  (8U)
N#define USART_CFG_LINMODE(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_LINMODE_SHIFT)) & USART_CFG_LINMODE_MASK)
N#define USART_CFG_CTSEN_MASK                     (0x200U)
N#define USART_CFG_CTSEN_SHIFT                    (9U)
N#define USART_CFG_CTSEN(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_CTSEN_SHIFT)) & USART_CFG_CTSEN_MASK)
N#define USART_CFG_SYNCEN_MASK                    (0x800U)
N#define USART_CFG_SYNCEN_SHIFT                   (11U)
N#define USART_CFG_SYNCEN(x)                      (((uint32_t)(((uint32_t)(x)) << USART_CFG_SYNCEN_SHIFT)) & USART_CFG_SYNCEN_MASK)
N#define USART_CFG_CLKPOL_MASK                    (0x1000U)
N#define USART_CFG_CLKPOL_SHIFT                   (12U)
N#define USART_CFG_CLKPOL(x)                      (((uint32_t)(((uint32_t)(x)) << USART_CFG_CLKPOL_SHIFT)) & USART_CFG_CLKPOL_MASK)
N#define USART_CFG_SYNCMST_MASK                   (0x4000U)
N#define USART_CFG_SYNCMST_SHIFT                  (14U)
N#define USART_CFG_SYNCMST(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_SYNCMST_SHIFT)) & USART_CFG_SYNCMST_MASK)
N#define USART_CFG_LOOP_MASK                      (0x8000U)
N#define USART_CFG_LOOP_SHIFT                     (15U)
N#define USART_CFG_LOOP(x)                        (((uint32_t)(((uint32_t)(x)) << USART_CFG_LOOP_SHIFT)) & USART_CFG_LOOP_MASK)
N#define USART_CFG_OETA_MASK                      (0x40000U)
N#define USART_CFG_OETA_SHIFT                     (18U)
N#define USART_CFG_OETA(x)                        (((uint32_t)(((uint32_t)(x)) << USART_CFG_OETA_SHIFT)) & USART_CFG_OETA_MASK)
N#define USART_CFG_AUTOADDR_MASK                  (0x80000U)
N#define USART_CFG_AUTOADDR_SHIFT                 (19U)
N#define USART_CFG_AUTOADDR(x)                    (((uint32_t)(((uint32_t)(x)) << USART_CFG_AUTOADDR_SHIFT)) & USART_CFG_AUTOADDR_MASK)
N#define USART_CFG_OESEL_MASK                     (0x100000U)
N#define USART_CFG_OESEL_SHIFT                    (20U)
N#define USART_CFG_OESEL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_OESEL_SHIFT)) & USART_CFG_OESEL_MASK)
N#define USART_CFG_OEPOL_MASK                     (0x200000U)
N#define USART_CFG_OEPOL_SHIFT                    (21U)
N#define USART_CFG_OEPOL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_OEPOL_SHIFT)) & USART_CFG_OEPOL_MASK)
N#define USART_CFG_RXPOL_MASK                     (0x400000U)
N#define USART_CFG_RXPOL_SHIFT                    (22U)
N#define USART_CFG_RXPOL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_RXPOL_SHIFT)) & USART_CFG_RXPOL_MASK)
N#define USART_CFG_TXPOL_MASK                     (0x800000U)
N#define USART_CFG_TXPOL_SHIFT                    (23U)
N#define USART_CFG_TXPOL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_TXPOL_SHIFT)) & USART_CFG_TXPOL_MASK)
N
N/*! @name CTL - USART Control register. USART control settings that are more likely to change during operation. */
N#define USART_CTL_TXBRKEN_MASK                   (0x2U)
N#define USART_CTL_TXBRKEN_SHIFT                  (1U)
N#define USART_CTL_TXBRKEN(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CTL_TXBRKEN_SHIFT)) & USART_CTL_TXBRKEN_MASK)
N#define USART_CTL_ADDRDET_MASK                   (0x4U)
N#define USART_CTL_ADDRDET_SHIFT                  (2U)
N#define USART_CTL_ADDRDET(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CTL_ADDRDET_SHIFT)) & USART_CTL_ADDRDET_MASK)
N#define USART_CTL_TXDIS_MASK                     (0x40U)
N#define USART_CTL_TXDIS_SHIFT                    (6U)
N#define USART_CTL_TXDIS(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CTL_TXDIS_SHIFT)) & USART_CTL_TXDIS_MASK)
N#define USART_CTL_CC_MASK                        (0x100U)
N#define USART_CTL_CC_SHIFT                       (8U)
N#define USART_CTL_CC(x)                          (((uint32_t)(((uint32_t)(x)) << USART_CTL_CC_SHIFT)) & USART_CTL_CC_MASK)
N#define USART_CTL_CLRCCONRX_MASK                 (0x200U)
N#define USART_CTL_CLRCCONRX_SHIFT                (9U)
N#define USART_CTL_CLRCCONRX(x)                   (((uint32_t)(((uint32_t)(x)) << USART_CTL_CLRCCONRX_SHIFT)) & USART_CTL_CLRCCONRX_MASK)
N#define USART_CTL_AUTOBAUD_MASK                  (0x10000U)
N#define USART_CTL_AUTOBAUD_SHIFT                 (16U)
N#define USART_CTL_AUTOBAUD(x)                    (((uint32_t)(((uint32_t)(x)) << USART_CTL_AUTOBAUD_SHIFT)) & USART_CTL_AUTOBAUD_MASK)
N
N/*! @name STAT - USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them. */
N#define USART_STAT_RXIDLE_MASK                   (0x2U)
N#define USART_STAT_RXIDLE_SHIFT                  (1U)
N#define USART_STAT_RXIDLE(x)                     (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXIDLE_SHIFT)) & USART_STAT_RXIDLE_MASK)
N#define USART_STAT_TXIDLE_MASK                   (0x8U)
N#define USART_STAT_TXIDLE_SHIFT                  (3U)
N#define USART_STAT_TXIDLE(x)                     (((uint32_t)(((uint32_t)(x)) << USART_STAT_TXIDLE_SHIFT)) & USART_STAT_TXIDLE_MASK)
N#define USART_STAT_CTS_MASK                      (0x10U)
N#define USART_STAT_CTS_SHIFT                     (4U)
N#define USART_STAT_CTS(x)                        (((uint32_t)(((uint32_t)(x)) << USART_STAT_CTS_SHIFT)) & USART_STAT_CTS_MASK)
N#define USART_STAT_DELTACTS_MASK                 (0x20U)
N#define USART_STAT_DELTACTS_SHIFT                (5U)
N#define USART_STAT_DELTACTS(x)                   (((uint32_t)(((uint32_t)(x)) << USART_STAT_DELTACTS_SHIFT)) & USART_STAT_DELTACTS_MASK)
N#define USART_STAT_TXDISSTAT_MASK                (0x40U)
N#define USART_STAT_TXDISSTAT_SHIFT               (6U)
N#define USART_STAT_TXDISSTAT(x)                  (((uint32_t)(((uint32_t)(x)) << USART_STAT_TXDISSTAT_SHIFT)) & USART_STAT_TXDISSTAT_MASK)
N#define USART_STAT_RXBRK_MASK                    (0x400U)
N#define USART_STAT_RXBRK_SHIFT                   (10U)
N#define USART_STAT_RXBRK(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXBRK_SHIFT)) & USART_STAT_RXBRK_MASK)
N#define USART_STAT_DELTARXBRK_MASK               (0x800U)
N#define USART_STAT_DELTARXBRK_SHIFT              (11U)
N#define USART_STAT_DELTARXBRK(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_DELTARXBRK_SHIFT)) & USART_STAT_DELTARXBRK_MASK)
N#define USART_STAT_START_MASK                    (0x1000U)
N#define USART_STAT_START_SHIFT                   (12U)
N#define USART_STAT_START(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_START_SHIFT)) & USART_STAT_START_MASK)
N#define USART_STAT_FRAMERRINT_MASK               (0x2000U)
N#define USART_STAT_FRAMERRINT_SHIFT              (13U)
N#define USART_STAT_FRAMERRINT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_FRAMERRINT_SHIFT)) & USART_STAT_FRAMERRINT_MASK)
N#define USART_STAT_PARITYERRINT_MASK             (0x4000U)
N#define USART_STAT_PARITYERRINT_SHIFT            (14U)
N#define USART_STAT_PARITYERRINT(x)               (((uint32_t)(((uint32_t)(x)) << USART_STAT_PARITYERRINT_SHIFT)) & USART_STAT_PARITYERRINT_MASK)
N#define USART_STAT_RXNOISEINT_MASK               (0x8000U)
N#define USART_STAT_RXNOISEINT_SHIFT              (15U)
N#define USART_STAT_RXNOISEINT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXNOISEINT_SHIFT)) & USART_STAT_RXNOISEINT_MASK)
N#define USART_STAT_ABERR_MASK                    (0x10000U)
N#define USART_STAT_ABERR_SHIFT                   (16U)
N#define USART_STAT_ABERR(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_ABERR_SHIFT)) & USART_STAT_ABERR_MASK)
N
N/*! @name INTENSET - Interrupt Enable read and Set register for USART (not FIFO) status. Contains individual interrupt enable bits for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set. */
N#define USART_INTENSET_TXIDLEEN_MASK             (0x8U)
N#define USART_INTENSET_TXIDLEEN_SHIFT            (3U)
N#define USART_INTENSET_TXIDLEEN(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_TXIDLEEN_SHIFT)) & USART_INTENSET_TXIDLEEN_MASK)
N#define USART_INTENSET_DELTACTSEN_MASK           (0x20U)
N#define USART_INTENSET_DELTACTSEN_SHIFT          (5U)
N#define USART_INTENSET_DELTACTSEN(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_DELTACTSEN_SHIFT)) & USART_INTENSET_DELTACTSEN_MASK)
N#define USART_INTENSET_TXDISEN_MASK              (0x40U)
N#define USART_INTENSET_TXDISEN_SHIFT             (6U)
N#define USART_INTENSET_TXDISEN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_TXDISEN_SHIFT)) & USART_INTENSET_TXDISEN_MASK)
N#define USART_INTENSET_DELTARXBRKEN_MASK         (0x800U)
N#define USART_INTENSET_DELTARXBRKEN_SHIFT        (11U)
N#define USART_INTENSET_DELTARXBRKEN(x)           (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_DELTARXBRKEN_SHIFT)) & USART_INTENSET_DELTARXBRKEN_MASK)
N#define USART_INTENSET_STARTEN_MASK              (0x1000U)
N#define USART_INTENSET_STARTEN_SHIFT             (12U)
N#define USART_INTENSET_STARTEN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_STARTEN_SHIFT)) & USART_INTENSET_STARTEN_MASK)
N#define USART_INTENSET_FRAMERREN_MASK            (0x2000U)
N#define USART_INTENSET_FRAMERREN_SHIFT           (13U)
N#define USART_INTENSET_FRAMERREN(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_FRAMERREN_SHIFT)) & USART_INTENSET_FRAMERREN_MASK)
N#define USART_INTENSET_PARITYERREN_MASK          (0x4000U)
N#define USART_INTENSET_PARITYERREN_SHIFT         (14U)
N#define USART_INTENSET_PARITYERREN(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_PARITYERREN_SHIFT)) & USART_INTENSET_PARITYERREN_MASK)
N#define USART_INTENSET_RXNOISEEN_MASK            (0x8000U)
N#define USART_INTENSET_RXNOISEEN_SHIFT           (15U)
N#define USART_INTENSET_RXNOISEEN(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_RXNOISEEN_SHIFT)) & USART_INTENSET_RXNOISEEN_MASK)
N#define USART_INTENSET_ABERREN_MASK              (0x10000U)
N#define USART_INTENSET_ABERREN_SHIFT             (16U)
N#define USART_INTENSET_ABERREN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_ABERREN_SHIFT)) & USART_INTENSET_ABERREN_MASK)
N
N/*! @name INTENCLR - Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared. */
N#define USART_INTENCLR_TXIDLECLR_MASK            (0x8U)
N#define USART_INTENCLR_TXIDLECLR_SHIFT           (3U)
N#define USART_INTENCLR_TXIDLECLR(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_TXIDLECLR_SHIFT)) & USART_INTENCLR_TXIDLECLR_MASK)
N#define USART_INTENCLR_DELTACTSCLR_MASK          (0x20U)
N#define USART_INTENCLR_DELTACTSCLR_SHIFT         (5U)
N#define USART_INTENCLR_DELTACTSCLR(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_DELTACTSCLR_SHIFT)) & USART_INTENCLR_DELTACTSCLR_MASK)
N#define USART_INTENCLR_TXDISCLR_MASK             (0x40U)
N#define USART_INTENCLR_TXDISCLR_SHIFT            (6U)
N#define USART_INTENCLR_TXDISCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_TXDISCLR_SHIFT)) & USART_INTENCLR_TXDISCLR_MASK)
N#define USART_INTENCLR_DELTARXBRKCLR_MASK        (0x800U)
N#define USART_INTENCLR_DELTARXBRKCLR_SHIFT       (11U)
N#define USART_INTENCLR_DELTARXBRKCLR(x)          (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_DELTARXBRKCLR_SHIFT)) & USART_INTENCLR_DELTARXBRKCLR_MASK)
N#define USART_INTENCLR_STARTCLR_MASK             (0x1000U)
N#define USART_INTENCLR_STARTCLR_SHIFT            (12U)
N#define USART_INTENCLR_STARTCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_STARTCLR_SHIFT)) & USART_INTENCLR_STARTCLR_MASK)
N#define USART_INTENCLR_FRAMERRCLR_MASK           (0x2000U)
N#define USART_INTENCLR_FRAMERRCLR_SHIFT          (13U)
N#define USART_INTENCLR_FRAMERRCLR(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_FRAMERRCLR_SHIFT)) & USART_INTENCLR_FRAMERRCLR_MASK)
N#define USART_INTENCLR_PARITYERRCLR_MASK         (0x4000U)
N#define USART_INTENCLR_PARITYERRCLR_SHIFT        (14U)
N#define USART_INTENCLR_PARITYERRCLR(x)           (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_PARITYERRCLR_SHIFT)) & USART_INTENCLR_PARITYERRCLR_MASK)
N#define USART_INTENCLR_RXNOISECLR_MASK           (0x8000U)
N#define USART_INTENCLR_RXNOISECLR_SHIFT          (15U)
N#define USART_INTENCLR_RXNOISECLR(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_RXNOISECLR_SHIFT)) & USART_INTENCLR_RXNOISECLR_MASK)
N#define USART_INTENCLR_ABERRCLR_MASK             (0x10000U)
N#define USART_INTENCLR_ABERRCLR_SHIFT            (16U)
N#define USART_INTENCLR_ABERRCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_ABERRCLR_SHIFT)) & USART_INTENCLR_ABERRCLR_MASK)
N
N/*! @name BRG - Baud Rate Generator register. 16-bit integer baud rate divisor value. */
N#define USART_BRG_BRGVAL_MASK                    (0xFFFFU)
N#define USART_BRG_BRGVAL_SHIFT                   (0U)
N#define USART_BRG_BRGVAL(x)                      (((uint32_t)(((uint32_t)(x)) << USART_BRG_BRGVAL_SHIFT)) & USART_BRG_BRGVAL_MASK)
N
N/*! @name INTSTAT - Interrupt status register. Reflects interrupts that are currently enabled. */
N#define USART_INTSTAT_TXIDLE_MASK                (0x8U)
N#define USART_INTSTAT_TXIDLE_SHIFT               (3U)
N#define USART_INTSTAT_TXIDLE(x)                  (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_TXIDLE_SHIFT)) & USART_INTSTAT_TXIDLE_MASK)
N#define USART_INTSTAT_DELTACTS_MASK              (0x20U)
N#define USART_INTSTAT_DELTACTS_SHIFT             (5U)
N#define USART_INTSTAT_DELTACTS(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_DELTACTS_SHIFT)) & USART_INTSTAT_DELTACTS_MASK)
N#define USART_INTSTAT_TXDISINT_MASK              (0x40U)
N#define USART_INTSTAT_TXDISINT_SHIFT             (6U)
N#define USART_INTSTAT_TXDISINT(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_TXDISINT_SHIFT)) & USART_INTSTAT_TXDISINT_MASK)
N#define USART_INTSTAT_DELTARXBRK_MASK            (0x800U)
N#define USART_INTSTAT_DELTARXBRK_SHIFT           (11U)
N#define USART_INTSTAT_DELTARXBRK(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_DELTARXBRK_SHIFT)) & USART_INTSTAT_DELTARXBRK_MASK)
N#define USART_INTSTAT_START_MASK                 (0x1000U)
N#define USART_INTSTAT_START_SHIFT                (12U)
N#define USART_INTSTAT_START(x)                   (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_START_SHIFT)) & USART_INTSTAT_START_MASK)
N#define USART_INTSTAT_FRAMERRINT_MASK            (0x2000U)
N#define USART_INTSTAT_FRAMERRINT_SHIFT           (13U)
N#define USART_INTSTAT_FRAMERRINT(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_FRAMERRINT_SHIFT)) & USART_INTSTAT_FRAMERRINT_MASK)
N#define USART_INTSTAT_PARITYERRINT_MASK          (0x4000U)
N#define USART_INTSTAT_PARITYERRINT_SHIFT         (14U)
N#define USART_INTSTAT_PARITYERRINT(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_PARITYERRINT_SHIFT)) & USART_INTSTAT_PARITYERRINT_MASK)
N#define USART_INTSTAT_RXNOISEINT_MASK            (0x8000U)
N#define USART_INTSTAT_RXNOISEINT_SHIFT           (15U)
N#define USART_INTSTAT_RXNOISEINT(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_RXNOISEINT_SHIFT)) & USART_INTSTAT_RXNOISEINT_MASK)
N#define USART_INTSTAT_ABERRINT_MASK              (0x10000U)
N#define USART_INTSTAT_ABERRINT_SHIFT             (16U)
N#define USART_INTSTAT_ABERRINT(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_ABERRINT_SHIFT)) & USART_INTSTAT_ABERRINT_MASK)
N
N/*! @name OSR - Oversample selection register for asynchronous communication. */
N#define USART_OSR_OSRVAL_MASK                    (0xFU)
N#define USART_OSR_OSRVAL_SHIFT                   (0U)
N#define USART_OSR_OSRVAL(x)                      (((uint32_t)(((uint32_t)(x)) << USART_OSR_OSRVAL_SHIFT)) & USART_OSR_OSRVAL_MASK)
N
N/*! @name ADDR - Address register for automatic address matching. */
N#define USART_ADDR_ADDRESS_MASK                  (0xFFU)
N#define USART_ADDR_ADDRESS_SHIFT                 (0U)
N#define USART_ADDR_ADDRESS(x)                    (((uint32_t)(((uint32_t)(x)) << USART_ADDR_ADDRESS_SHIFT)) & USART_ADDR_ADDRESS_MASK)
N
N/*! @name FIFOCFG - FIFO configuration and enable register. */
N#define USART_FIFOCFG_ENABLETX_MASK              (0x1U)
N#define USART_FIFOCFG_ENABLETX_SHIFT             (0U)
N#define USART_FIFOCFG_ENABLETX(x)                (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_ENABLETX_SHIFT)) & USART_FIFOCFG_ENABLETX_MASK)
N#define USART_FIFOCFG_ENABLERX_MASK              (0x2U)
N#define USART_FIFOCFG_ENABLERX_SHIFT             (1U)
N#define USART_FIFOCFG_ENABLERX(x)                (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_ENABLERX_SHIFT)) & USART_FIFOCFG_ENABLERX_MASK)
N#define USART_FIFOCFG_SIZE_MASK                  (0x30U)
N#define USART_FIFOCFG_SIZE_SHIFT                 (4U)
N#define USART_FIFOCFG_SIZE(x)                    (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_SIZE_SHIFT)) & USART_FIFOCFG_SIZE_MASK)
N#define USART_FIFOCFG_DMATX_MASK                 (0x1000U)
N#define USART_FIFOCFG_DMATX_SHIFT                (12U)
N#define USART_FIFOCFG_DMATX(x)                   (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_DMATX_SHIFT)) & USART_FIFOCFG_DMATX_MASK)
N#define USART_FIFOCFG_DMARX_MASK                 (0x2000U)
N#define USART_FIFOCFG_DMARX_SHIFT                (13U)
N#define USART_FIFOCFG_DMARX(x)                   (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_DMARX_SHIFT)) & USART_FIFOCFG_DMARX_MASK)
N#define USART_FIFOCFG_WAKETX_MASK                (0x4000U)
N#define USART_FIFOCFG_WAKETX_SHIFT               (14U)
N#define USART_FIFOCFG_WAKETX(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_WAKETX_SHIFT)) & USART_FIFOCFG_WAKETX_MASK)
N#define USART_FIFOCFG_WAKERX_MASK                (0x8000U)
N#define USART_FIFOCFG_WAKERX_SHIFT               (15U)
N#define USART_FIFOCFG_WAKERX(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_WAKERX_SHIFT)) & USART_FIFOCFG_WAKERX_MASK)
N#define USART_FIFOCFG_EMPTYTX_MASK               (0x10000U)
N#define USART_FIFOCFG_EMPTYTX_SHIFT              (16U)
N#define USART_FIFOCFG_EMPTYTX(x)                 (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_EMPTYTX_SHIFT)) & USART_FIFOCFG_EMPTYTX_MASK)
N#define USART_FIFOCFG_EMPTYRX_MASK               (0x20000U)
N#define USART_FIFOCFG_EMPTYRX_SHIFT              (17U)
N#define USART_FIFOCFG_EMPTYRX(x)                 (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_EMPTYRX_SHIFT)) & USART_FIFOCFG_EMPTYRX_MASK)
N#define USART_FIFOCFG_POPDBG_MASK                (0x40000U)
N#define USART_FIFOCFG_POPDBG_SHIFT               (18U)
N#define USART_FIFOCFG_POPDBG(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOCFG_POPDBG_SHIFT)) & USART_FIFOCFG_POPDBG_MASK)
N
N/*! @name FIFOSTAT - FIFO status register. */
N#define USART_FIFOSTAT_TXERR_MASK                (0x1U)
N#define USART_FIFOSTAT_TXERR_SHIFT               (0U)
N#define USART_FIFOSTAT_TXERR(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_TXERR_SHIFT)) & USART_FIFOSTAT_TXERR_MASK)
N#define USART_FIFOSTAT_RXERR_MASK                (0x2U)
N#define USART_FIFOSTAT_RXERR_SHIFT               (1U)
N#define USART_FIFOSTAT_RXERR(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_RXERR_SHIFT)) & USART_FIFOSTAT_RXERR_MASK)
N#define USART_FIFOSTAT_PERINT_MASK               (0x8U)
N#define USART_FIFOSTAT_PERINT_SHIFT              (3U)
N#define USART_FIFOSTAT_PERINT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_PERINT_SHIFT)) & USART_FIFOSTAT_PERINT_MASK)
N#define USART_FIFOSTAT_TXEMPTY_MASK              (0x10U)
N#define USART_FIFOSTAT_TXEMPTY_SHIFT             (4U)
N#define USART_FIFOSTAT_TXEMPTY(x)                (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_TXEMPTY_SHIFT)) & USART_FIFOSTAT_TXEMPTY_MASK)
N#define USART_FIFOSTAT_TXNOTFULL_MASK            (0x20U)
N#define USART_FIFOSTAT_TXNOTFULL_SHIFT           (5U)
N#define USART_FIFOSTAT_TXNOTFULL(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_TXNOTFULL_SHIFT)) & USART_FIFOSTAT_TXNOTFULL_MASK)
N#define USART_FIFOSTAT_RXNOTEMPTY_MASK           (0x40U)
N#define USART_FIFOSTAT_RXNOTEMPTY_SHIFT          (6U)
N#define USART_FIFOSTAT_RXNOTEMPTY(x)             (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_RXNOTEMPTY_SHIFT)) & USART_FIFOSTAT_RXNOTEMPTY_MASK)
N#define USART_FIFOSTAT_RXFULL_MASK               (0x80U)
N#define USART_FIFOSTAT_RXFULL_SHIFT              (7U)
N#define USART_FIFOSTAT_RXFULL(x)                 (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_RXFULL_SHIFT)) & USART_FIFOSTAT_RXFULL_MASK)
N#define USART_FIFOSTAT_TXLVL_MASK                (0x1F00U)
N#define USART_FIFOSTAT_TXLVL_SHIFT               (8U)
N#define USART_FIFOSTAT_TXLVL(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_TXLVL_SHIFT)) & USART_FIFOSTAT_TXLVL_MASK)
N#define USART_FIFOSTAT_RXLVL_MASK                (0x1F0000U)
N#define USART_FIFOSTAT_RXLVL_SHIFT               (16U)
N#define USART_FIFOSTAT_RXLVL(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOSTAT_RXLVL_SHIFT)) & USART_FIFOSTAT_RXLVL_MASK)
N
N/*! @name FIFOTRIG - FIFO trigger settings for interrupt and DMA request. */
N#define USART_FIFOTRIG_TXLVLENA_MASK             (0x1U)
N#define USART_FIFOTRIG_TXLVLENA_SHIFT            (0U)
N#define USART_FIFOTRIG_TXLVLENA(x)               (((uint32_t)(((uint32_t)(x)) << USART_FIFOTRIG_TXLVLENA_SHIFT)) & USART_FIFOTRIG_TXLVLENA_MASK)
N#define USART_FIFOTRIG_RXLVLENA_MASK             (0x2U)
N#define USART_FIFOTRIG_RXLVLENA_SHIFT            (1U)
N#define USART_FIFOTRIG_RXLVLENA(x)               (((uint32_t)(((uint32_t)(x)) << USART_FIFOTRIG_RXLVLENA_SHIFT)) & USART_FIFOTRIG_RXLVLENA_MASK)
N#define USART_FIFOTRIG_TXLVL_MASK                (0xF00U)
N#define USART_FIFOTRIG_TXLVL_SHIFT               (8U)
N#define USART_FIFOTRIG_TXLVL(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOTRIG_TXLVL_SHIFT)) & USART_FIFOTRIG_TXLVL_MASK)
N#define USART_FIFOTRIG_RXLVL_MASK                (0xF0000U)
N#define USART_FIFOTRIG_RXLVL_SHIFT               (16U)
N#define USART_FIFOTRIG_RXLVL(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFOTRIG_RXLVL_SHIFT)) & USART_FIFOTRIG_RXLVL_MASK)
N
N/*! @name FIFOINTENSET - FIFO interrupt enable set (enable) and read register. */
N#define USART_FIFOINTENSET_TXERR_MASK            (0x1U)
N#define USART_FIFOINTENSET_TXERR_SHIFT           (0U)
N#define USART_FIFOINTENSET_TXERR(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENSET_TXERR_SHIFT)) & USART_FIFOINTENSET_TXERR_MASK)
N#define USART_FIFOINTENSET_RXERR_MASK            (0x2U)
N#define USART_FIFOINTENSET_RXERR_SHIFT           (1U)
N#define USART_FIFOINTENSET_RXERR(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENSET_RXERR_SHIFT)) & USART_FIFOINTENSET_RXERR_MASK)
N#define USART_FIFOINTENSET_TXLVL_MASK            (0x4U)
N#define USART_FIFOINTENSET_TXLVL_SHIFT           (2U)
N#define USART_FIFOINTENSET_TXLVL(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENSET_TXLVL_SHIFT)) & USART_FIFOINTENSET_TXLVL_MASK)
N#define USART_FIFOINTENSET_RXLVL_MASK            (0x8U)
N#define USART_FIFOINTENSET_RXLVL_SHIFT           (3U)
N#define USART_FIFOINTENSET_RXLVL(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENSET_RXLVL_SHIFT)) & USART_FIFOINTENSET_RXLVL_MASK)
N
N/*! @name FIFOINTENCLR - FIFO interrupt enable clear (disable) and read register. */
N#define USART_FIFOINTENCLR_TXERR_MASK            (0x1U)
N#define USART_FIFOINTENCLR_TXERR_SHIFT           (0U)
N#define USART_FIFOINTENCLR_TXERR(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENCLR_TXERR_SHIFT)) & USART_FIFOINTENCLR_TXERR_MASK)
N#define USART_FIFOINTENCLR_RXERR_MASK            (0x2U)
N#define USART_FIFOINTENCLR_RXERR_SHIFT           (1U)
N#define USART_FIFOINTENCLR_RXERR(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENCLR_RXERR_SHIFT)) & USART_FIFOINTENCLR_RXERR_MASK)
N#define USART_FIFOINTENCLR_TXLVL_MASK            (0x4U)
N#define USART_FIFOINTENCLR_TXLVL_SHIFT           (2U)
N#define USART_FIFOINTENCLR_TXLVL(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENCLR_TXLVL_SHIFT)) & USART_FIFOINTENCLR_TXLVL_MASK)
N#define USART_FIFOINTENCLR_RXLVL_MASK            (0x8U)
N#define USART_FIFOINTENCLR_RXLVL_SHIFT           (3U)
N#define USART_FIFOINTENCLR_RXLVL(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTENCLR_RXLVL_SHIFT)) & USART_FIFOINTENCLR_RXLVL_MASK)
N
N/*! @name FIFOINTSTAT - FIFO interrupt status register. */
N#define USART_FIFOINTSTAT_TXERR_MASK             (0x1U)
N#define USART_FIFOINTSTAT_TXERR_SHIFT            (0U)
N#define USART_FIFOINTSTAT_TXERR(x)               (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTSTAT_TXERR_SHIFT)) & USART_FIFOINTSTAT_TXERR_MASK)
N#define USART_FIFOINTSTAT_RXERR_MASK             (0x2U)
N#define USART_FIFOINTSTAT_RXERR_SHIFT            (1U)
N#define USART_FIFOINTSTAT_RXERR(x)               (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTSTAT_RXERR_SHIFT)) & USART_FIFOINTSTAT_RXERR_MASK)
N#define USART_FIFOINTSTAT_TXLVL_MASK             (0x4U)
N#define USART_FIFOINTSTAT_TXLVL_SHIFT            (2U)
N#define USART_FIFOINTSTAT_TXLVL(x)               (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTSTAT_TXLVL_SHIFT)) & USART_FIFOINTSTAT_TXLVL_MASK)
N#define USART_FIFOINTSTAT_RXLVL_MASK             (0x8U)
N#define USART_FIFOINTSTAT_RXLVL_SHIFT            (3U)
N#define USART_FIFOINTSTAT_RXLVL(x)               (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTSTAT_RXLVL_SHIFT)) & USART_FIFOINTSTAT_RXLVL_MASK)
N#define USART_FIFOINTSTAT_PERINT_MASK            (0x10U)
N#define USART_FIFOINTSTAT_PERINT_SHIFT           (4U)
N#define USART_FIFOINTSTAT_PERINT(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFOINTSTAT_PERINT_SHIFT)) & USART_FIFOINTSTAT_PERINT_MASK)
N
N/*! @name FIFOWR - FIFO write data. */
N#define USART_FIFOWR_TXDATA_MASK                 (0x1FFU)
N#define USART_FIFOWR_TXDATA_SHIFT                (0U)
N#define USART_FIFOWR_TXDATA(x)                   (((uint32_t)(((uint32_t)(x)) << USART_FIFOWR_TXDATA_SHIFT)) & USART_FIFOWR_TXDATA_MASK)
N
N/*! @name FIFORD - FIFO read data. */
N#define USART_FIFORD_RXDATA_MASK                 (0x1FFU)
N#define USART_FIFORD_RXDATA_SHIFT                (0U)
N#define USART_FIFORD_RXDATA(x)                   (((uint32_t)(((uint32_t)(x)) << USART_FIFORD_RXDATA_SHIFT)) & USART_FIFORD_RXDATA_MASK)
N#define USART_FIFORD_FRAMERR_MASK                (0x2000U)
N#define USART_FIFORD_FRAMERR_SHIFT               (13U)
N#define USART_FIFORD_FRAMERR(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFORD_FRAMERR_SHIFT)) & USART_FIFORD_FRAMERR_MASK)
N#define USART_FIFORD_PARITYERR_MASK              (0x4000U)
N#define USART_FIFORD_PARITYERR_SHIFT             (14U)
N#define USART_FIFORD_PARITYERR(x)                (((uint32_t)(((uint32_t)(x)) << USART_FIFORD_PARITYERR_SHIFT)) & USART_FIFORD_PARITYERR_MASK)
N#define USART_FIFORD_RXNOISE_MASK                (0x8000U)
N#define USART_FIFORD_RXNOISE_SHIFT               (15U)
N#define USART_FIFORD_RXNOISE(x)                  (((uint32_t)(((uint32_t)(x)) << USART_FIFORD_RXNOISE_SHIFT)) & USART_FIFORD_RXNOISE_MASK)
N
N/*! @name FIFORDNOPOP - FIFO data read with no FIFO pop. */
N#define USART_FIFORDNOPOP_RXDATA_MASK            (0x1FFU)
N#define USART_FIFORDNOPOP_RXDATA_SHIFT           (0U)
N#define USART_FIFORDNOPOP_RXDATA(x)              (((uint32_t)(((uint32_t)(x)) << USART_FIFORDNOPOP_RXDATA_SHIFT)) & USART_FIFORDNOPOP_RXDATA_MASK)
N#define USART_FIFORDNOPOP_FRAMERR_MASK           (0x2000U)
N#define USART_FIFORDNOPOP_FRAMERR_SHIFT          (13U)
N#define USART_FIFORDNOPOP_FRAMERR(x)             (((uint32_t)(((uint32_t)(x)) << USART_FIFORDNOPOP_FRAMERR_SHIFT)) & USART_FIFORDNOPOP_FRAMERR_MASK)
N#define USART_FIFORDNOPOP_PARITYERR_MASK         (0x4000U)
N#define USART_FIFORDNOPOP_PARITYERR_SHIFT        (14U)
N#define USART_FIFORDNOPOP_PARITYERR(x)           (((uint32_t)(((uint32_t)(x)) << USART_FIFORDNOPOP_PARITYERR_SHIFT)) & USART_FIFORDNOPOP_PARITYERR_MASK)
N#define USART_FIFORDNOPOP_RXNOISE_MASK           (0x8000U)
N#define USART_FIFORDNOPOP_RXNOISE_SHIFT          (15U)
N#define USART_FIFORDNOPOP_RXNOISE(x)             (((uint32_t)(((uint32_t)(x)) << USART_FIFORDNOPOP_RXNOISE_SHIFT)) & USART_FIFORDNOPOP_RXNOISE_MASK)
N
N/*! @name ID - Peripheral identification register. */
N#define USART_ID_APERTURE_MASK                   (0xFFU)
N#define USART_ID_APERTURE_SHIFT                  (0U)
N#define USART_ID_APERTURE(x)                     (((uint32_t)(((uint32_t)(x)) << USART_ID_APERTURE_SHIFT)) & USART_ID_APERTURE_MASK)
N#define USART_ID_MINOR_REV_MASK                  (0xF00U)
N#define USART_ID_MINOR_REV_SHIFT                 (8U)
N#define USART_ID_MINOR_REV(x)                    (((uint32_t)(((uint32_t)(x)) << USART_ID_MINOR_REV_SHIFT)) & USART_ID_MINOR_REV_MASK)
N#define USART_ID_MAJOR_REV_MASK                  (0xF000U)
N#define USART_ID_MAJOR_REV_SHIFT                 (12U)
N#define USART_ID_MAJOR_REV(x)                    (((uint32_t)(((uint32_t)(x)) << USART_ID_MAJOR_REV_SHIFT)) & USART_ID_MAJOR_REV_MASK)
N#define USART_ID_ID_MASK                         (0xFFFF0000U)
N#define USART_ID_ID_SHIFT                        (16U)
N#define USART_ID_ID(x)                           (((uint32_t)(((uint32_t)(x)) << USART_ID_ID_SHIFT)) & USART_ID_ID_MASK)
N
N
N/*!
N * @}
N */ /* end of group USART_Register_Masks */
N
N
N/* USART - Peripheral instance base addresses */
N/** Peripheral USART0 base address */
N#define USART0_BASE                              (0x40086000u)
N/** Peripheral USART0 base pointer */
N#define USART0                                   ((USART_Type *)USART0_BASE)
N/** Peripheral USART1 base address */
N#define USART1_BASE                              (0x40087000u)
N/** Peripheral USART1 base pointer */
N#define USART1                                   ((USART_Type *)USART1_BASE)
N/** Peripheral USART2 base address */
N#define USART2_BASE                              (0x40088000u)
N/** Peripheral USART2 base pointer */
N#define USART2                                   ((USART_Type *)USART2_BASE)
N/** Peripheral USART3 base address */
N#define USART3_BASE                              (0x40089000u)
N/** Peripheral USART3 base pointer */
N#define USART3                                   ((USART_Type *)USART3_BASE)
N/** Peripheral USART4 base address */
N#define USART4_BASE                              (0x4008A000u)
N/** Peripheral USART4 base pointer */
N#define USART4                                   ((USART_Type *)USART4_BASE)
N/** Peripheral USART5 base address */
N#define USART5_BASE                              (0x40096000u)
N/** Peripheral USART5 base pointer */
N#define USART5                                   ((USART_Type *)USART5_BASE)
N/** Peripheral USART6 base address */
N#define USART6_BASE                              (0x40097000u)
N/** Peripheral USART6 base pointer */
N#define USART6                                   ((USART_Type *)USART6_BASE)
N/** Peripheral USART7 base address */
N#define USART7_BASE                              (0x40098000u)
N/** Peripheral USART7 base pointer */
N#define USART7                                   ((USART_Type *)USART7_BASE)
N/** Peripheral USART8 base address */
N#define USART8_BASE                              (0x40099000u)
N/** Peripheral USART8 base pointer */
N#define USART8                                   ((USART_Type *)USART8_BASE)
N/** Peripheral USART9 base address */
N#define USART9_BASE                              (0x4009A000u)
N/** Peripheral USART9 base pointer */
N#define USART9                                   ((USART_Type *)USART9_BASE)
N/** Array initializer of USART peripheral base addresses */
N#define USART_BASE_ADDRS                         { USART0_BASE, USART1_BASE, USART2_BASE, USART3_BASE, USART4_BASE, USART5_BASE, USART6_BASE, USART7_BASE, USART8_BASE, USART9_BASE }
N/** Array initializer of USART peripheral base pointers */
N#define USART_BASE_PTRS                          { USART0, USART1, USART2, USART3, USART4, USART5, USART6, USART7, USART8, USART9 }
N/** Interrupt vectors for the USART peripheral type */
N#define USART_IRQS                               { FLEXCOMM0_IRQn, FLEXCOMM1_IRQn, FLEXCOMM2_IRQn, FLEXCOMM3_IRQn, FLEXCOMM4_IRQn, FLEXCOMM5_IRQn, FLEXCOMM6_IRQn, FLEXCOMM7_IRQn, FLEXCOMM8_IRQn, FLEXCOMM9_IRQn }
N
N/*!
N * @}
N */ /* end of group USART_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USB Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USB_Peripheral_Access_Layer USB Peripheral Access Layer
N * @{
N */
N
N/** USB - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t DEVCMDSTAT;                        /**< USB Device Command/Status register, offset: 0x0 */
X  volatile uint32_t DEVCMDSTAT;                         
N  __IO uint32_t INFO;                              /**< USB Info register, offset: 0x4 */
X  volatile uint32_t INFO;                               
N  __IO uint32_t EPLISTSTART;                       /**< USB EP Command/Status List start address, offset: 0x8 */
X  volatile uint32_t EPLISTSTART;                        
N  __IO uint32_t DATABUFSTART;                      /**< USB Data buffer start address, offset: 0xC */
X  volatile uint32_t DATABUFSTART;                       
N  __IO uint32_t LPM;                               /**< USB Link Power Management register, offset: 0x10 */
X  volatile uint32_t LPM;                                
N  __IO uint32_t EPSKIP;                            /**< USB Endpoint skip, offset: 0x14 */
X  volatile uint32_t EPSKIP;                             
N  __IO uint32_t EPINUSE;                           /**< USB Endpoint Buffer in use, offset: 0x18 */
X  volatile uint32_t EPINUSE;                            
N  __IO uint32_t EPBUFCFG;                          /**< USB Endpoint Buffer Configuration register, offset: 0x1C */
X  volatile uint32_t EPBUFCFG;                           
N  __IO uint32_t INTSTAT;                           /**< USB interrupt status register, offset: 0x20 */
X  volatile uint32_t INTSTAT;                            
N  __IO uint32_t INTEN;                             /**< USB interrupt enable register, offset: 0x24 */
X  volatile uint32_t INTEN;                              
N  __IO uint32_t INTSETSTAT;                        /**< USB set interrupt status register, offset: 0x28 */
X  volatile uint32_t INTSETSTAT;                         
N       uint8_t RESERVED_0[8];
N  __IO uint32_t EPTOGGLE;                          /**< USB Endpoint toggle register, offset: 0x34 */
X  volatile uint32_t EPTOGGLE;                           
N} USB_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USB Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USB_Register_Masks USB Register Masks
N * @{
N */
N
N/*! @name DEVCMDSTAT - USB Device Command/Status register */
N#define USB_DEVCMDSTAT_DEV_ADDR_MASK             (0x7FU)
N#define USB_DEVCMDSTAT_DEV_ADDR_SHIFT            (0U)
N#define USB_DEVCMDSTAT_DEV_ADDR(x)               (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DEV_ADDR_SHIFT)) & USB_DEVCMDSTAT_DEV_ADDR_MASK)
N#define USB_DEVCMDSTAT_DEV_EN_MASK               (0x80U)
N#define USB_DEVCMDSTAT_DEV_EN_SHIFT              (7U)
N#define USB_DEVCMDSTAT_DEV_EN(x)                 (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DEV_EN_SHIFT)) & USB_DEVCMDSTAT_DEV_EN_MASK)
N#define USB_DEVCMDSTAT_SETUP_MASK                (0x100U)
N#define USB_DEVCMDSTAT_SETUP_SHIFT               (8U)
N#define USB_DEVCMDSTAT_SETUP(x)                  (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_SETUP_SHIFT)) & USB_DEVCMDSTAT_SETUP_MASK)
N#define USB_DEVCMDSTAT_FORCE_NEEDCLK_MASK        (0x200U)
N#define USB_DEVCMDSTAT_FORCE_NEEDCLK_SHIFT       (9U)
N#define USB_DEVCMDSTAT_FORCE_NEEDCLK(x)          (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_FORCE_NEEDCLK_SHIFT)) & USB_DEVCMDSTAT_FORCE_NEEDCLK_MASK)
N#define USB_DEVCMDSTAT_LPM_SUP_MASK              (0x800U)
N#define USB_DEVCMDSTAT_LPM_SUP_SHIFT             (11U)
N#define USB_DEVCMDSTAT_LPM_SUP(x)                (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_LPM_SUP_SHIFT)) & USB_DEVCMDSTAT_LPM_SUP_MASK)
N#define USB_DEVCMDSTAT_INTONNAK_AO_MASK          (0x1000U)
N#define USB_DEVCMDSTAT_INTONNAK_AO_SHIFT         (12U)
N#define USB_DEVCMDSTAT_INTONNAK_AO(x)            (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_INTONNAK_AO_SHIFT)) & USB_DEVCMDSTAT_INTONNAK_AO_MASK)
N#define USB_DEVCMDSTAT_INTONNAK_AI_MASK          (0x2000U)
N#define USB_DEVCMDSTAT_INTONNAK_AI_SHIFT         (13U)
N#define USB_DEVCMDSTAT_INTONNAK_AI(x)            (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_INTONNAK_AI_SHIFT)) & USB_DEVCMDSTAT_INTONNAK_AI_MASK)
N#define USB_DEVCMDSTAT_INTONNAK_CO_MASK          (0x4000U)
N#define USB_DEVCMDSTAT_INTONNAK_CO_SHIFT         (14U)
N#define USB_DEVCMDSTAT_INTONNAK_CO(x)            (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_INTONNAK_CO_SHIFT)) & USB_DEVCMDSTAT_INTONNAK_CO_MASK)
N#define USB_DEVCMDSTAT_INTONNAK_CI_MASK          (0x8000U)
N#define USB_DEVCMDSTAT_INTONNAK_CI_SHIFT         (15U)
N#define USB_DEVCMDSTAT_INTONNAK_CI(x)            (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_INTONNAK_CI_SHIFT)) & USB_DEVCMDSTAT_INTONNAK_CI_MASK)
N#define USB_DEVCMDSTAT_DCON_MASK                 (0x10000U)
N#define USB_DEVCMDSTAT_DCON_SHIFT                (16U)
N#define USB_DEVCMDSTAT_DCON(x)                   (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DCON_SHIFT)) & USB_DEVCMDSTAT_DCON_MASK)
N#define USB_DEVCMDSTAT_DSUS_MASK                 (0x20000U)
N#define USB_DEVCMDSTAT_DSUS_SHIFT                (17U)
N#define USB_DEVCMDSTAT_DSUS(x)                   (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DSUS_SHIFT)) & USB_DEVCMDSTAT_DSUS_MASK)
N#define USB_DEVCMDSTAT_LPM_SUS_MASK              (0x80000U)
N#define USB_DEVCMDSTAT_LPM_SUS_SHIFT             (19U)
N#define USB_DEVCMDSTAT_LPM_SUS(x)                (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_LPM_SUS_SHIFT)) & USB_DEVCMDSTAT_LPM_SUS_MASK)
N#define USB_DEVCMDSTAT_LPM_REWP_MASK             (0x100000U)
N#define USB_DEVCMDSTAT_LPM_REWP_SHIFT            (20U)
N#define USB_DEVCMDSTAT_LPM_REWP(x)               (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_LPM_REWP_SHIFT)) & USB_DEVCMDSTAT_LPM_REWP_MASK)
N#define USB_DEVCMDSTAT_DCON_C_MASK               (0x1000000U)
N#define USB_DEVCMDSTAT_DCON_C_SHIFT              (24U)
N#define USB_DEVCMDSTAT_DCON_C(x)                 (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DCON_C_SHIFT)) & USB_DEVCMDSTAT_DCON_C_MASK)
N#define USB_DEVCMDSTAT_DSUS_C_MASK               (0x2000000U)
N#define USB_DEVCMDSTAT_DSUS_C_SHIFT              (25U)
N#define USB_DEVCMDSTAT_DSUS_C(x)                 (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DSUS_C_SHIFT)) & USB_DEVCMDSTAT_DSUS_C_MASK)
N#define USB_DEVCMDSTAT_DRES_C_MASK               (0x4000000U)
N#define USB_DEVCMDSTAT_DRES_C_SHIFT              (26U)
N#define USB_DEVCMDSTAT_DRES_C(x)                 (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_DRES_C_SHIFT)) & USB_DEVCMDSTAT_DRES_C_MASK)
N#define USB_DEVCMDSTAT_VBUSDEBOUNCED_MASK        (0x10000000U)
N#define USB_DEVCMDSTAT_VBUSDEBOUNCED_SHIFT       (28U)
N#define USB_DEVCMDSTAT_VBUSDEBOUNCED(x)          (((uint32_t)(((uint32_t)(x)) << USB_DEVCMDSTAT_VBUSDEBOUNCED_SHIFT)) & USB_DEVCMDSTAT_VBUSDEBOUNCED_MASK)
N
N/*! @name INFO - USB Info register */
N#define USB_INFO_FRAME_NR_MASK                   (0x7FFU)
N#define USB_INFO_FRAME_NR_SHIFT                  (0U)
N#define USB_INFO_FRAME_NR(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INFO_FRAME_NR_SHIFT)) & USB_INFO_FRAME_NR_MASK)
N#define USB_INFO_ERR_CODE_MASK                   (0x7800U)
N#define USB_INFO_ERR_CODE_SHIFT                  (11U)
N#define USB_INFO_ERR_CODE(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INFO_ERR_CODE_SHIFT)) & USB_INFO_ERR_CODE_MASK)
N#define USB_INFO_MINREV_MASK                     (0xFF0000U)
N#define USB_INFO_MINREV_SHIFT                    (16U)
N#define USB_INFO_MINREV(x)                       (((uint32_t)(((uint32_t)(x)) << USB_INFO_MINREV_SHIFT)) & USB_INFO_MINREV_MASK)
N#define USB_INFO_MAJREV_MASK                     (0xFF000000U)
N#define USB_INFO_MAJREV_SHIFT                    (24U)
N#define USB_INFO_MAJREV(x)                       (((uint32_t)(((uint32_t)(x)) << USB_INFO_MAJREV_SHIFT)) & USB_INFO_MAJREV_MASK)
N
N/*! @name EPLISTSTART - USB EP Command/Status List start address */
N#define USB_EPLISTSTART_EP_LIST_MASK             (0xFFFFFF00U)
N#define USB_EPLISTSTART_EP_LIST_SHIFT            (8U)
N#define USB_EPLISTSTART_EP_LIST(x)               (((uint32_t)(((uint32_t)(x)) << USB_EPLISTSTART_EP_LIST_SHIFT)) & USB_EPLISTSTART_EP_LIST_MASK)
N
N/*! @name DATABUFSTART - USB Data buffer start address */
N#define USB_DATABUFSTART_DA_BUF_MASK             (0xFFC00000U)
N#define USB_DATABUFSTART_DA_BUF_SHIFT            (22U)
N#define USB_DATABUFSTART_DA_BUF(x)               (((uint32_t)(((uint32_t)(x)) << USB_DATABUFSTART_DA_BUF_SHIFT)) & USB_DATABUFSTART_DA_BUF_MASK)
N
N/*! @name LPM - USB Link Power Management register */
N#define USB_LPM_HIRD_HW_MASK                     (0xFU)
N#define USB_LPM_HIRD_HW_SHIFT                    (0U)
N#define USB_LPM_HIRD_HW(x)                       (((uint32_t)(((uint32_t)(x)) << USB_LPM_HIRD_HW_SHIFT)) & USB_LPM_HIRD_HW_MASK)
N#define USB_LPM_HIRD_SW_MASK                     (0xF0U)
N#define USB_LPM_HIRD_SW_SHIFT                    (4U)
N#define USB_LPM_HIRD_SW(x)                       (((uint32_t)(((uint32_t)(x)) << USB_LPM_HIRD_SW_SHIFT)) & USB_LPM_HIRD_SW_MASK)
N#define USB_LPM_DATA_PENDING_MASK                (0x100U)
N#define USB_LPM_DATA_PENDING_SHIFT               (8U)
N#define USB_LPM_DATA_PENDING(x)                  (((uint32_t)(((uint32_t)(x)) << USB_LPM_DATA_PENDING_SHIFT)) & USB_LPM_DATA_PENDING_MASK)
N
N/*! @name EPSKIP - USB Endpoint skip */
N#define USB_EPSKIP_SKIP_MASK                     (0x3FFU)
N#define USB_EPSKIP_SKIP_SHIFT                    (0U)
N#define USB_EPSKIP_SKIP(x)                       (((uint32_t)(((uint32_t)(x)) << USB_EPSKIP_SKIP_SHIFT)) & USB_EPSKIP_SKIP_MASK)
N
N/*! @name EPINUSE - USB Endpoint Buffer in use */
N#define USB_EPINUSE_BUF_MASK                     (0x3FCU)
N#define USB_EPINUSE_BUF_SHIFT                    (2U)
N#define USB_EPINUSE_BUF(x)                       (((uint32_t)(((uint32_t)(x)) << USB_EPINUSE_BUF_SHIFT)) & USB_EPINUSE_BUF_MASK)
N
N/*! @name EPBUFCFG - USB Endpoint Buffer Configuration register */
N#define USB_EPBUFCFG_BUF_SB_MASK                 (0x3FCU)
N#define USB_EPBUFCFG_BUF_SB_SHIFT                (2U)
N#define USB_EPBUFCFG_BUF_SB(x)                   (((uint32_t)(((uint32_t)(x)) << USB_EPBUFCFG_BUF_SB_SHIFT)) & USB_EPBUFCFG_BUF_SB_MASK)
N
N/*! @name INTSTAT - USB interrupt status register */
N#define USB_INTSTAT_EP0OUT_MASK                  (0x1U)
N#define USB_INTSTAT_EP0OUT_SHIFT                 (0U)
N#define USB_INTSTAT_EP0OUT(x)                    (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP0OUT_SHIFT)) & USB_INTSTAT_EP0OUT_MASK)
N#define USB_INTSTAT_EP0IN_MASK                   (0x2U)
N#define USB_INTSTAT_EP0IN_SHIFT                  (1U)
N#define USB_INTSTAT_EP0IN(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP0IN_SHIFT)) & USB_INTSTAT_EP0IN_MASK)
N#define USB_INTSTAT_EP1OUT_MASK                  (0x4U)
N#define USB_INTSTAT_EP1OUT_SHIFT                 (2U)
N#define USB_INTSTAT_EP1OUT(x)                    (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP1OUT_SHIFT)) & USB_INTSTAT_EP1OUT_MASK)
N#define USB_INTSTAT_EP1IN_MASK                   (0x8U)
N#define USB_INTSTAT_EP1IN_SHIFT                  (3U)
N#define USB_INTSTAT_EP1IN(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP1IN_SHIFT)) & USB_INTSTAT_EP1IN_MASK)
N#define USB_INTSTAT_EP2OUT_MASK                  (0x10U)
N#define USB_INTSTAT_EP2OUT_SHIFT                 (4U)
N#define USB_INTSTAT_EP2OUT(x)                    (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP2OUT_SHIFT)) & USB_INTSTAT_EP2OUT_MASK)
N#define USB_INTSTAT_EP2IN_MASK                   (0x20U)
N#define USB_INTSTAT_EP2IN_SHIFT                  (5U)
N#define USB_INTSTAT_EP2IN(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP2IN_SHIFT)) & USB_INTSTAT_EP2IN_MASK)
N#define USB_INTSTAT_EP3OUT_MASK                  (0x40U)
N#define USB_INTSTAT_EP3OUT_SHIFT                 (6U)
N#define USB_INTSTAT_EP3OUT(x)                    (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP3OUT_SHIFT)) & USB_INTSTAT_EP3OUT_MASK)
N#define USB_INTSTAT_EP3IN_MASK                   (0x80U)
N#define USB_INTSTAT_EP3IN_SHIFT                  (7U)
N#define USB_INTSTAT_EP3IN(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP3IN_SHIFT)) & USB_INTSTAT_EP3IN_MASK)
N#define USB_INTSTAT_EP4OUT_MASK                  (0x100U)
N#define USB_INTSTAT_EP4OUT_SHIFT                 (8U)
N#define USB_INTSTAT_EP4OUT(x)                    (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP4OUT_SHIFT)) & USB_INTSTAT_EP4OUT_MASK)
N#define USB_INTSTAT_EP4IN_MASK                   (0x200U)
N#define USB_INTSTAT_EP4IN_SHIFT                  (9U)
N#define USB_INTSTAT_EP4IN(x)                     (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_EP4IN_SHIFT)) & USB_INTSTAT_EP4IN_MASK)
N#define USB_INTSTAT_FRAME_INT_MASK               (0x40000000U)
N#define USB_INTSTAT_FRAME_INT_SHIFT              (30U)
N#define USB_INTSTAT_FRAME_INT(x)                 (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_FRAME_INT_SHIFT)) & USB_INTSTAT_FRAME_INT_MASK)
N#define USB_INTSTAT_DEV_INT_MASK                 (0x80000000U)
N#define USB_INTSTAT_DEV_INT_SHIFT                (31U)
N#define USB_INTSTAT_DEV_INT(x)                   (((uint32_t)(((uint32_t)(x)) << USB_INTSTAT_DEV_INT_SHIFT)) & USB_INTSTAT_DEV_INT_MASK)
N
N/*! @name INTEN - USB interrupt enable register */
N#define USB_INTEN_EP_INT_EN_MASK                 (0x3FFU)
N#define USB_INTEN_EP_INT_EN_SHIFT                (0U)
N#define USB_INTEN_EP_INT_EN(x)                   (((uint32_t)(((uint32_t)(x)) << USB_INTEN_EP_INT_EN_SHIFT)) & USB_INTEN_EP_INT_EN_MASK)
N#define USB_INTEN_FRAME_INT_EN_MASK              (0x40000000U)
N#define USB_INTEN_FRAME_INT_EN_SHIFT             (30U)
N#define USB_INTEN_FRAME_INT_EN(x)                (((uint32_t)(((uint32_t)(x)) << USB_INTEN_FRAME_INT_EN_SHIFT)) & USB_INTEN_FRAME_INT_EN_MASK)
N#define USB_INTEN_DEV_INT_EN_MASK                (0x80000000U)
N#define USB_INTEN_DEV_INT_EN_SHIFT               (31U)
N#define USB_INTEN_DEV_INT_EN(x)                  (((uint32_t)(((uint32_t)(x)) << USB_INTEN_DEV_INT_EN_SHIFT)) & USB_INTEN_DEV_INT_EN_MASK)
N
N/*! @name INTSETSTAT - USB set interrupt status register */
N#define USB_INTSETSTAT_EP_SET_INT_MASK           (0x3FFU)
N#define USB_INTSETSTAT_EP_SET_INT_SHIFT          (0U)
N#define USB_INTSETSTAT_EP_SET_INT(x)             (((uint32_t)(((uint32_t)(x)) << USB_INTSETSTAT_EP_SET_INT_SHIFT)) & USB_INTSETSTAT_EP_SET_INT_MASK)
N#define USB_INTSETSTAT_FRAME_SET_INT_MASK        (0x40000000U)
N#define USB_INTSETSTAT_FRAME_SET_INT_SHIFT       (30U)
N#define USB_INTSETSTAT_FRAME_SET_INT(x)          (((uint32_t)(((uint32_t)(x)) << USB_INTSETSTAT_FRAME_SET_INT_SHIFT)) & USB_INTSETSTAT_FRAME_SET_INT_MASK)
N#define USB_INTSETSTAT_DEV_SET_INT_MASK          (0x80000000U)
N#define USB_INTSETSTAT_DEV_SET_INT_SHIFT         (31U)
N#define USB_INTSETSTAT_DEV_SET_INT(x)            (((uint32_t)(((uint32_t)(x)) << USB_INTSETSTAT_DEV_SET_INT_SHIFT)) & USB_INTSETSTAT_DEV_SET_INT_MASK)
N
N/*! @name EPTOGGLE - USB Endpoint toggle register */
N#define USB_EPTOGGLE_TOGGLE_MASK                 (0x3FFU)
N#define USB_EPTOGGLE_TOGGLE_SHIFT                (0U)
N#define USB_EPTOGGLE_TOGGLE(x)                   (((uint32_t)(((uint32_t)(x)) << USB_EPTOGGLE_TOGGLE_SHIFT)) & USB_EPTOGGLE_TOGGLE_MASK)
N
N
N/*!
N * @}
N */ /* end of group USB_Register_Masks */
N
N
N/* USB - Peripheral instance base addresses */
N/** Peripheral USB0 base address */
N#define USB0_BASE                                (0x40084000u)
N/** Peripheral USB0 base pointer */
N#define USB0                                     ((USB_Type *)USB0_BASE)
N/** Array initializer of USB peripheral base addresses */
N#define USB_BASE_ADDRS                           { USB0_BASE }
N/** Array initializer of USB peripheral base pointers */
N#define USB_BASE_PTRS                            { USB0 }
N/** Interrupt vectors for the USB peripheral type */
N#define USB_IRQS                                 { USB0_IRQn }
N#define USB_NEEDCLK_IRQS                         { USB0_NEEDCLK_IRQn }
N
N/*!
N * @}
N */ /* end of group USB_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USBFSH Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USBFSH_Peripheral_Access_Layer USBFSH Peripheral Access Layer
N * @{
N */
N
N/** USBFSH - Register Layout Typedef */
Ntypedef struct {
N  __I  uint32_t HCREVISION;                        /**< BCD representation of the version of the HCI specification that is implemented by the Host Controller (HC), offset: 0x0 */
X  volatile const  uint32_t HCREVISION;                         
N  __IO uint32_t HCCONTROL;                         /**< Defines the operating modes of the HC, offset: 0x4 */
X  volatile uint32_t HCCONTROL;                          
N  __IO uint32_t HCCOMMANDSTATUS;                   /**< This register is used to receive the commands from the Host Controller Driver (HCD), offset: 0x8 */
X  volatile uint32_t HCCOMMANDSTATUS;                    
N  __IO uint32_t HCINTERRUPTSTATUS;                 /**< Indicates the status on various events that cause hardware interrupts by setting the appropriate bits, offset: 0xC */
X  volatile uint32_t HCINTERRUPTSTATUS;                  
N  __IO uint32_t HCINTERRUPTENABLE;                 /**< Controls the bits in the HcInterruptStatus register and indicates which events will generate a hardware interrupt, offset: 0x10 */
X  volatile uint32_t HCINTERRUPTENABLE;                  
N  __IO uint32_t HCINTERRUPTDISABLE;                /**< The bits in this register are used to disable corresponding bits in the HCInterruptStatus register and in turn disable that event leading to hardware interrupt, offset: 0x14 */
X  volatile uint32_t HCINTERRUPTDISABLE;                 
N  __IO uint32_t HCHCCA;                            /**< Contains the physical address of the host controller communication area, offset: 0x18 */
X  volatile uint32_t HCHCCA;                             
N  __IO uint32_t HCPERIODCURRENTED;                 /**< Contains the physical address of the current isochronous or interrupt endpoint descriptor, offset: 0x1C */
X  volatile uint32_t HCPERIODCURRENTED;                  
N  __IO uint32_t HCCONTROLHEADED;                   /**< Contains the physical address of the first endpoint descriptor of the control list, offset: 0x20 */
X  volatile uint32_t HCCONTROLHEADED;                    
N  __IO uint32_t HCCONTROLCURRENTED;                /**< Contains the physical address of the current endpoint descriptor of the control list, offset: 0x24 */
X  volatile uint32_t HCCONTROLCURRENTED;                 
N  __IO uint32_t HCBULKHEADED;                      /**< Contains the physical address of the first endpoint descriptor of the bulk list, offset: 0x28 */
X  volatile uint32_t HCBULKHEADED;                       
N  __IO uint32_t HCBULKCURRENTED;                   /**< Contains the physical address of the current endpoint descriptor of the bulk list, offset: 0x2C */
X  volatile uint32_t HCBULKCURRENTED;                    
N  __IO uint32_t HCDONEHEAD;                        /**< Contains the physical address of the last transfer descriptor added to the 'Done' queue, offset: 0x30 */
X  volatile uint32_t HCDONEHEAD;                         
N  __IO uint32_t HCFMINTERVAL;                      /**< Defines the bit time interval in a frame and the full speed maximum packet size which would not cause an overrun, offset: 0x34 */
X  volatile uint32_t HCFMINTERVAL;                       
N  __IO uint32_t HCFMREMAINING;                     /**< A 14-bit counter showing the bit time remaining in the current frame, offset: 0x38 */
X  volatile uint32_t HCFMREMAINING;                      
N  __IO uint32_t HCFMNUMBER;                        /**< Contains a 16-bit counter and provides the timing reference among events happening in the HC and the HCD, offset: 0x3C */
X  volatile uint32_t HCFMNUMBER;                         
N  __IO uint32_t HCPERIODICSTART;                   /**< Contains a programmable 14-bit value which determines the earliest time HC should start processing a periodic list, offset: 0x40 */
X  volatile uint32_t HCPERIODICSTART;                    
N  __IO uint32_t HCLSTHRESHOLD;                     /**< Contains 11-bit value which is used by the HC to determine whether to commit to transfer a maximum of 8-byte LS packet before EOF, offset: 0x44 */
X  volatile uint32_t HCLSTHRESHOLD;                      
N  __IO uint32_t HCRHDESCRIPTORA;                   /**< First of the two registers which describes the characteristics of the root hub, offset: 0x48 */
X  volatile uint32_t HCRHDESCRIPTORA;                    
N  __IO uint32_t HCRHDESCRIPTORB;                   /**< Second of the two registers which describes the characteristics of the Root Hub, offset: 0x4C */
X  volatile uint32_t HCRHDESCRIPTORB;                    
N  __IO uint32_t HCRHSTATUS;                        /**< This register is divided into two parts, offset: 0x50 */
X  volatile uint32_t HCRHSTATUS;                         
N  __IO uint32_t HCRHPORTSTATUS;                    /**< Controls and reports the port events on a per-port basis, offset: 0x54 */
X  volatile uint32_t HCRHPORTSTATUS;                     
N       uint8_t RESERVED_0[4];
N  __IO uint32_t PORTMODE;                          /**< Controls the port if it is attached to the host block or the device block, offset: 0x5C */
X  volatile uint32_t PORTMODE;                           
N} USBFSH_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USBFSH Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USBFSH_Register_Masks USBFSH Register Masks
N * @{
N */
N
N/*! @name HCREVISION - BCD representation of the version of the HCI specification that is implemented by the Host Controller (HC) */
N#define USBFSH_HCREVISION_REV_MASK               (0xFFU)
N#define USBFSH_HCREVISION_REV_SHIFT              (0U)
N#define USBFSH_HCREVISION_REV(x)                 (((uint32_t)(((uint32_t)(x)) << USBFSH_HCREVISION_REV_SHIFT)) & USBFSH_HCREVISION_REV_MASK)
N
N/*! @name HCCONTROL - Defines the operating modes of the HC */
N#define USBFSH_HCCONTROL_CBSR_MASK               (0x3U)
N#define USBFSH_HCCONTROL_CBSR_SHIFT              (0U)
N#define USBFSH_HCCONTROL_CBSR(x)                 (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_CBSR_SHIFT)) & USBFSH_HCCONTROL_CBSR_MASK)
N#define USBFSH_HCCONTROL_PLE_MASK                (0x4U)
N#define USBFSH_HCCONTROL_PLE_SHIFT               (2U)
N#define USBFSH_HCCONTROL_PLE(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_PLE_SHIFT)) & USBFSH_HCCONTROL_PLE_MASK)
N#define USBFSH_HCCONTROL_IE_MASK                 (0x8U)
N#define USBFSH_HCCONTROL_IE_SHIFT                (3U)
N#define USBFSH_HCCONTROL_IE(x)                   (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_IE_SHIFT)) & USBFSH_HCCONTROL_IE_MASK)
N#define USBFSH_HCCONTROL_CLE_MASK                (0x10U)
N#define USBFSH_HCCONTROL_CLE_SHIFT               (4U)
N#define USBFSH_HCCONTROL_CLE(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_CLE_SHIFT)) & USBFSH_HCCONTROL_CLE_MASK)
N#define USBFSH_HCCONTROL_BLE_MASK                (0x20U)
N#define USBFSH_HCCONTROL_BLE_SHIFT               (5U)
N#define USBFSH_HCCONTROL_BLE(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_BLE_SHIFT)) & USBFSH_HCCONTROL_BLE_MASK)
N#define USBFSH_HCCONTROL_HCFS_MASK               (0xC0U)
N#define USBFSH_HCCONTROL_HCFS_SHIFT              (6U)
N#define USBFSH_HCCONTROL_HCFS(x)                 (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_HCFS_SHIFT)) & USBFSH_HCCONTROL_HCFS_MASK)
N#define USBFSH_HCCONTROL_IR_MASK                 (0x100U)
N#define USBFSH_HCCONTROL_IR_SHIFT                (8U)
N#define USBFSH_HCCONTROL_IR(x)                   (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_IR_SHIFT)) & USBFSH_HCCONTROL_IR_MASK)
N#define USBFSH_HCCONTROL_RWC_MASK                (0x200U)
N#define USBFSH_HCCONTROL_RWC_SHIFT               (9U)
N#define USBFSH_HCCONTROL_RWC(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_RWC_SHIFT)) & USBFSH_HCCONTROL_RWC_MASK)
N#define USBFSH_HCCONTROL_RWE_MASK                (0x400U)
N#define USBFSH_HCCONTROL_RWE_SHIFT               (10U)
N#define USBFSH_HCCONTROL_RWE(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROL_RWE_SHIFT)) & USBFSH_HCCONTROL_RWE_MASK)
N
N/*! @name HCCOMMANDSTATUS - This register is used to receive the commands from the Host Controller Driver (HCD) */
N#define USBFSH_HCCOMMANDSTATUS_HCR_MASK          (0x1U)
N#define USBFSH_HCCOMMANDSTATUS_HCR_SHIFT         (0U)
N#define USBFSH_HCCOMMANDSTATUS_HCR(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCOMMANDSTATUS_HCR_SHIFT)) & USBFSH_HCCOMMANDSTATUS_HCR_MASK)
N#define USBFSH_HCCOMMANDSTATUS_CLF_MASK          (0x2U)
N#define USBFSH_HCCOMMANDSTATUS_CLF_SHIFT         (1U)
N#define USBFSH_HCCOMMANDSTATUS_CLF(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCOMMANDSTATUS_CLF_SHIFT)) & USBFSH_HCCOMMANDSTATUS_CLF_MASK)
N#define USBFSH_HCCOMMANDSTATUS_BLF_MASK          (0x4U)
N#define USBFSH_HCCOMMANDSTATUS_BLF_SHIFT         (2U)
N#define USBFSH_HCCOMMANDSTATUS_BLF(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCOMMANDSTATUS_BLF_SHIFT)) & USBFSH_HCCOMMANDSTATUS_BLF_MASK)
N#define USBFSH_HCCOMMANDSTATUS_OCR_MASK          (0x8U)
N#define USBFSH_HCCOMMANDSTATUS_OCR_SHIFT         (3U)
N#define USBFSH_HCCOMMANDSTATUS_OCR(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCOMMANDSTATUS_OCR_SHIFT)) & USBFSH_HCCOMMANDSTATUS_OCR_MASK)
N#define USBFSH_HCCOMMANDSTATUS_SOC_MASK          (0xC0U)
N#define USBFSH_HCCOMMANDSTATUS_SOC_SHIFT         (6U)
N#define USBFSH_HCCOMMANDSTATUS_SOC(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCOMMANDSTATUS_SOC_SHIFT)) & USBFSH_HCCOMMANDSTATUS_SOC_MASK)
N
N/*! @name HCINTERRUPTSTATUS - Indicates the status on various events that cause hardware interrupts by setting the appropriate bits */
N#define USBFSH_HCINTERRUPTSTATUS_SO_MASK         (0x1U)
N#define USBFSH_HCINTERRUPTSTATUS_SO_SHIFT        (0U)
N#define USBFSH_HCINTERRUPTSTATUS_SO(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_SO_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_SO_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_WDH_MASK        (0x2U)
N#define USBFSH_HCINTERRUPTSTATUS_WDH_SHIFT       (1U)
N#define USBFSH_HCINTERRUPTSTATUS_WDH(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_WDH_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_WDH_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_SF_MASK         (0x4U)
N#define USBFSH_HCINTERRUPTSTATUS_SF_SHIFT        (2U)
N#define USBFSH_HCINTERRUPTSTATUS_SF(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_SF_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_SF_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_RD_MASK         (0x8U)
N#define USBFSH_HCINTERRUPTSTATUS_RD_SHIFT        (3U)
N#define USBFSH_HCINTERRUPTSTATUS_RD(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_RD_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_RD_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_UE_MASK         (0x10U)
N#define USBFSH_HCINTERRUPTSTATUS_UE_SHIFT        (4U)
N#define USBFSH_HCINTERRUPTSTATUS_UE(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_UE_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_UE_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_FNO_MASK        (0x20U)
N#define USBFSH_HCINTERRUPTSTATUS_FNO_SHIFT       (5U)
N#define USBFSH_HCINTERRUPTSTATUS_FNO(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_FNO_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_FNO_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_RHSC_MASK       (0x40U)
N#define USBFSH_HCINTERRUPTSTATUS_RHSC_SHIFT      (6U)
N#define USBFSH_HCINTERRUPTSTATUS_RHSC(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_RHSC_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_RHSC_MASK)
N#define USBFSH_HCINTERRUPTSTATUS_OC_MASK         (0xFFFFFC00U)
N#define USBFSH_HCINTERRUPTSTATUS_OC_SHIFT        (10U)
N#define USBFSH_HCINTERRUPTSTATUS_OC(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTSTATUS_OC_SHIFT)) & USBFSH_HCINTERRUPTSTATUS_OC_MASK)
N
N/*! @name HCINTERRUPTENABLE - Controls the bits in the HcInterruptStatus register and indicates which events will generate a hardware interrupt */
N#define USBFSH_HCINTERRUPTENABLE_SO_MASK         (0x1U)
N#define USBFSH_HCINTERRUPTENABLE_SO_SHIFT        (0U)
N#define USBFSH_HCINTERRUPTENABLE_SO(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_SO_SHIFT)) & USBFSH_HCINTERRUPTENABLE_SO_MASK)
N#define USBFSH_HCINTERRUPTENABLE_WDH_MASK        (0x2U)
N#define USBFSH_HCINTERRUPTENABLE_WDH_SHIFT       (1U)
N#define USBFSH_HCINTERRUPTENABLE_WDH(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_WDH_SHIFT)) & USBFSH_HCINTERRUPTENABLE_WDH_MASK)
N#define USBFSH_HCINTERRUPTENABLE_SF_MASK         (0x4U)
N#define USBFSH_HCINTERRUPTENABLE_SF_SHIFT        (2U)
N#define USBFSH_HCINTERRUPTENABLE_SF(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_SF_SHIFT)) & USBFSH_HCINTERRUPTENABLE_SF_MASK)
N#define USBFSH_HCINTERRUPTENABLE_RD_MASK         (0x8U)
N#define USBFSH_HCINTERRUPTENABLE_RD_SHIFT        (3U)
N#define USBFSH_HCINTERRUPTENABLE_RD(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_RD_SHIFT)) & USBFSH_HCINTERRUPTENABLE_RD_MASK)
N#define USBFSH_HCINTERRUPTENABLE_UE_MASK         (0x10U)
N#define USBFSH_HCINTERRUPTENABLE_UE_SHIFT        (4U)
N#define USBFSH_HCINTERRUPTENABLE_UE(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_UE_SHIFT)) & USBFSH_HCINTERRUPTENABLE_UE_MASK)
N#define USBFSH_HCINTERRUPTENABLE_FNO_MASK        (0x20U)
N#define USBFSH_HCINTERRUPTENABLE_FNO_SHIFT       (5U)
N#define USBFSH_HCINTERRUPTENABLE_FNO(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_FNO_SHIFT)) & USBFSH_HCINTERRUPTENABLE_FNO_MASK)
N#define USBFSH_HCINTERRUPTENABLE_RHSC_MASK       (0x40U)
N#define USBFSH_HCINTERRUPTENABLE_RHSC_SHIFT      (6U)
N#define USBFSH_HCINTERRUPTENABLE_RHSC(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_RHSC_SHIFT)) & USBFSH_HCINTERRUPTENABLE_RHSC_MASK)
N#define USBFSH_HCINTERRUPTENABLE_OC_MASK         (0x40000000U)
N#define USBFSH_HCINTERRUPTENABLE_OC_SHIFT        (30U)
N#define USBFSH_HCINTERRUPTENABLE_OC(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_OC_SHIFT)) & USBFSH_HCINTERRUPTENABLE_OC_MASK)
N#define USBFSH_HCINTERRUPTENABLE_MIE_MASK        (0x80000000U)
N#define USBFSH_HCINTERRUPTENABLE_MIE_SHIFT       (31U)
N#define USBFSH_HCINTERRUPTENABLE_MIE(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTENABLE_MIE_SHIFT)) & USBFSH_HCINTERRUPTENABLE_MIE_MASK)
N
N/*! @name HCINTERRUPTDISABLE - The bits in this register are used to disable corresponding bits in the HCInterruptStatus register and in turn disable that event leading to hardware interrupt */
N#define USBFSH_HCINTERRUPTDISABLE_SO_MASK        (0x1U)
N#define USBFSH_HCINTERRUPTDISABLE_SO_SHIFT       (0U)
N#define USBFSH_HCINTERRUPTDISABLE_SO(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_SO_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_SO_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_WDH_MASK       (0x2U)
N#define USBFSH_HCINTERRUPTDISABLE_WDH_SHIFT      (1U)
N#define USBFSH_HCINTERRUPTDISABLE_WDH(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_WDH_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_WDH_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_SF_MASK        (0x4U)
N#define USBFSH_HCINTERRUPTDISABLE_SF_SHIFT       (2U)
N#define USBFSH_HCINTERRUPTDISABLE_SF(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_SF_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_SF_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_RD_MASK        (0x8U)
N#define USBFSH_HCINTERRUPTDISABLE_RD_SHIFT       (3U)
N#define USBFSH_HCINTERRUPTDISABLE_RD(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_RD_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_RD_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_UE_MASK        (0x10U)
N#define USBFSH_HCINTERRUPTDISABLE_UE_SHIFT       (4U)
N#define USBFSH_HCINTERRUPTDISABLE_UE(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_UE_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_UE_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_FNO_MASK       (0x20U)
N#define USBFSH_HCINTERRUPTDISABLE_FNO_SHIFT      (5U)
N#define USBFSH_HCINTERRUPTDISABLE_FNO(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_FNO_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_FNO_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_RHSC_MASK      (0x40U)
N#define USBFSH_HCINTERRUPTDISABLE_RHSC_SHIFT     (6U)
N#define USBFSH_HCINTERRUPTDISABLE_RHSC(x)        (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_RHSC_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_RHSC_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_OC_MASK        (0x40000000U)
N#define USBFSH_HCINTERRUPTDISABLE_OC_SHIFT       (30U)
N#define USBFSH_HCINTERRUPTDISABLE_OC(x)          (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_OC_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_OC_MASK)
N#define USBFSH_HCINTERRUPTDISABLE_MIE_MASK       (0x80000000U)
N#define USBFSH_HCINTERRUPTDISABLE_MIE_SHIFT      (31U)
N#define USBFSH_HCINTERRUPTDISABLE_MIE(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCINTERRUPTDISABLE_MIE_SHIFT)) & USBFSH_HCINTERRUPTDISABLE_MIE_MASK)
N
N/*! @name HCHCCA - Contains the physical address of the host controller communication area */
N#define USBFSH_HCHCCA_HCCA_MASK                  (0xFFFFFF00U)
N#define USBFSH_HCHCCA_HCCA_SHIFT                 (8U)
N#define USBFSH_HCHCCA_HCCA(x)                    (((uint32_t)(((uint32_t)(x)) << USBFSH_HCHCCA_HCCA_SHIFT)) & USBFSH_HCHCCA_HCCA_MASK)
N
N/*! @name HCPERIODCURRENTED - Contains the physical address of the current isochronous or interrupt endpoint descriptor */
N#define USBFSH_HCPERIODCURRENTED_PCED_MASK       (0xFFFFFFF0U)
N#define USBFSH_HCPERIODCURRENTED_PCED_SHIFT      (4U)
N#define USBFSH_HCPERIODCURRENTED_PCED(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCPERIODCURRENTED_PCED_SHIFT)) & USBFSH_HCPERIODCURRENTED_PCED_MASK)
N
N/*! @name HCCONTROLHEADED - Contains the physical address of the first endpoint descriptor of the control list */
N#define USBFSH_HCCONTROLHEADED_CHED_MASK         (0xFFFFFFF0U)
N#define USBFSH_HCCONTROLHEADED_CHED_SHIFT        (4U)
N#define USBFSH_HCCONTROLHEADED_CHED(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROLHEADED_CHED_SHIFT)) & USBFSH_HCCONTROLHEADED_CHED_MASK)
N
N/*! @name HCCONTROLCURRENTED - Contains the physical address of the current endpoint descriptor of the control list */
N#define USBFSH_HCCONTROLCURRENTED_CCED_MASK      (0xFFFFFFF0U)
N#define USBFSH_HCCONTROLCURRENTED_CCED_SHIFT     (4U)
N#define USBFSH_HCCONTROLCURRENTED_CCED(x)        (((uint32_t)(((uint32_t)(x)) << USBFSH_HCCONTROLCURRENTED_CCED_SHIFT)) & USBFSH_HCCONTROLCURRENTED_CCED_MASK)
N
N/*! @name HCBULKHEADED - Contains the physical address of the first endpoint descriptor of the bulk list */
N#define USBFSH_HCBULKHEADED_BHED_MASK            (0xFFFFFFF0U)
N#define USBFSH_HCBULKHEADED_BHED_SHIFT           (4U)
N#define USBFSH_HCBULKHEADED_BHED(x)              (((uint32_t)(((uint32_t)(x)) << USBFSH_HCBULKHEADED_BHED_SHIFT)) & USBFSH_HCBULKHEADED_BHED_MASK)
N
N/*! @name HCBULKCURRENTED - Contains the physical address of the current endpoint descriptor of the bulk list */
N#define USBFSH_HCBULKCURRENTED_BCED_MASK         (0xFFFFFFF0U)
N#define USBFSH_HCBULKCURRENTED_BCED_SHIFT        (4U)
N#define USBFSH_HCBULKCURRENTED_BCED(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCBULKCURRENTED_BCED_SHIFT)) & USBFSH_HCBULKCURRENTED_BCED_MASK)
N
N/*! @name HCDONEHEAD - Contains the physical address of the last transfer descriptor added to the 'Done' queue */
N#define USBFSH_HCDONEHEAD_DH_MASK                (0xFFFFFFF0U)
N#define USBFSH_HCDONEHEAD_DH_SHIFT               (4U)
N#define USBFSH_HCDONEHEAD_DH(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCDONEHEAD_DH_SHIFT)) & USBFSH_HCDONEHEAD_DH_MASK)
N
N/*! @name HCFMINTERVAL - Defines the bit time interval in a frame and the full speed maximum packet size which would not cause an overrun */
N#define USBFSH_HCFMINTERVAL_FI_MASK              (0x3FFFU)
N#define USBFSH_HCFMINTERVAL_FI_SHIFT             (0U)
N#define USBFSH_HCFMINTERVAL_FI(x)                (((uint32_t)(((uint32_t)(x)) << USBFSH_HCFMINTERVAL_FI_SHIFT)) & USBFSH_HCFMINTERVAL_FI_MASK)
N#define USBFSH_HCFMINTERVAL_FSMPS_MASK           (0x7FFF0000U)
N#define USBFSH_HCFMINTERVAL_FSMPS_SHIFT          (16U)
N#define USBFSH_HCFMINTERVAL_FSMPS(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCFMINTERVAL_FSMPS_SHIFT)) & USBFSH_HCFMINTERVAL_FSMPS_MASK)
N#define USBFSH_HCFMINTERVAL_FIT_MASK             (0x80000000U)
N#define USBFSH_HCFMINTERVAL_FIT_SHIFT            (31U)
N#define USBFSH_HCFMINTERVAL_FIT(x)               (((uint32_t)(((uint32_t)(x)) << USBFSH_HCFMINTERVAL_FIT_SHIFT)) & USBFSH_HCFMINTERVAL_FIT_MASK)
N
N/*! @name HCFMREMAINING - A 14-bit counter showing the bit time remaining in the current frame */
N#define USBFSH_HCFMREMAINING_FR_MASK             (0x3FFFU)
N#define USBFSH_HCFMREMAINING_FR_SHIFT            (0U)
N#define USBFSH_HCFMREMAINING_FR(x)               (((uint32_t)(((uint32_t)(x)) << USBFSH_HCFMREMAINING_FR_SHIFT)) & USBFSH_HCFMREMAINING_FR_MASK)
N#define USBFSH_HCFMREMAINING_FRT_MASK            (0x80000000U)
N#define USBFSH_HCFMREMAINING_FRT_SHIFT           (31U)
N#define USBFSH_HCFMREMAINING_FRT(x)              (((uint32_t)(((uint32_t)(x)) << USBFSH_HCFMREMAINING_FRT_SHIFT)) & USBFSH_HCFMREMAINING_FRT_MASK)
N
N/*! @name HCFMNUMBER - Contains a 16-bit counter and provides the timing reference among events happening in the HC and the HCD */
N#define USBFSH_HCFMNUMBER_FN_MASK                (0xFFFFU)
N#define USBFSH_HCFMNUMBER_FN_SHIFT               (0U)
N#define USBFSH_HCFMNUMBER_FN(x)                  (((uint32_t)(((uint32_t)(x)) << USBFSH_HCFMNUMBER_FN_SHIFT)) & USBFSH_HCFMNUMBER_FN_MASK)
N
N/*! @name HCPERIODICSTART - Contains a programmable 14-bit value which determines the earliest time HC should start processing a periodic list */
N#define USBFSH_HCPERIODICSTART_PS_MASK           (0x3FFFU)
N#define USBFSH_HCPERIODICSTART_PS_SHIFT          (0U)
N#define USBFSH_HCPERIODICSTART_PS(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCPERIODICSTART_PS_SHIFT)) & USBFSH_HCPERIODICSTART_PS_MASK)
N
N/*! @name HCLSTHRESHOLD - Contains 11-bit value which is used by the HC to determine whether to commit to transfer a maximum of 8-byte LS packet before EOF */
N#define USBFSH_HCLSTHRESHOLD_LST_MASK            (0xFFFU)
N#define USBFSH_HCLSTHRESHOLD_LST_SHIFT           (0U)
N#define USBFSH_HCLSTHRESHOLD_LST(x)              (((uint32_t)(((uint32_t)(x)) << USBFSH_HCLSTHRESHOLD_LST_SHIFT)) & USBFSH_HCLSTHRESHOLD_LST_MASK)
N
N/*! @name HCRHDESCRIPTORA - First of the two registers which describes the characteristics of the root hub */
N#define USBFSH_HCRHDESCRIPTORA_NDP_MASK          (0xFFU)
N#define USBFSH_HCRHDESCRIPTORA_NDP_SHIFT         (0U)
N#define USBFSH_HCRHDESCRIPTORA_NDP(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_NDP_SHIFT)) & USBFSH_HCRHDESCRIPTORA_NDP_MASK)
N#define USBFSH_HCRHDESCRIPTORA_PSM_MASK          (0x100U)
N#define USBFSH_HCRHDESCRIPTORA_PSM_SHIFT         (8U)
N#define USBFSH_HCRHDESCRIPTORA_PSM(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_PSM_SHIFT)) & USBFSH_HCRHDESCRIPTORA_PSM_MASK)
N#define USBFSH_HCRHDESCRIPTORA_NPS_MASK          (0x200U)
N#define USBFSH_HCRHDESCRIPTORA_NPS_SHIFT         (9U)
N#define USBFSH_HCRHDESCRIPTORA_NPS(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_NPS_SHIFT)) & USBFSH_HCRHDESCRIPTORA_NPS_MASK)
N#define USBFSH_HCRHDESCRIPTORA_DT_MASK           (0x400U)
N#define USBFSH_HCRHDESCRIPTORA_DT_SHIFT          (10U)
N#define USBFSH_HCRHDESCRIPTORA_DT(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_DT_SHIFT)) & USBFSH_HCRHDESCRIPTORA_DT_MASK)
N#define USBFSH_HCRHDESCRIPTORA_OCPM_MASK         (0x800U)
N#define USBFSH_HCRHDESCRIPTORA_OCPM_SHIFT        (11U)
N#define USBFSH_HCRHDESCRIPTORA_OCPM(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_OCPM_SHIFT)) & USBFSH_HCRHDESCRIPTORA_OCPM_MASK)
N#define USBFSH_HCRHDESCRIPTORA_NOCP_MASK         (0x1000U)
N#define USBFSH_HCRHDESCRIPTORA_NOCP_SHIFT        (12U)
N#define USBFSH_HCRHDESCRIPTORA_NOCP(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_NOCP_SHIFT)) & USBFSH_HCRHDESCRIPTORA_NOCP_MASK)
N#define USBFSH_HCRHDESCRIPTORA_POTPGT_MASK       (0xFF000000U)
N#define USBFSH_HCRHDESCRIPTORA_POTPGT_SHIFT      (24U)
N#define USBFSH_HCRHDESCRIPTORA_POTPGT(x)         (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORA_POTPGT_SHIFT)) & USBFSH_HCRHDESCRIPTORA_POTPGT_MASK)
N
N/*! @name HCRHDESCRIPTORB - Second of the two registers which describes the characteristics of the Root Hub */
N#define USBFSH_HCRHDESCRIPTORB_DR_MASK           (0xFFFFU)
N#define USBFSH_HCRHDESCRIPTORB_DR_SHIFT          (0U)
N#define USBFSH_HCRHDESCRIPTORB_DR(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORB_DR_SHIFT)) & USBFSH_HCRHDESCRIPTORB_DR_MASK)
N#define USBFSH_HCRHDESCRIPTORB_PPCM_MASK         (0xFFFF0000U)
N#define USBFSH_HCRHDESCRIPTORB_PPCM_SHIFT        (16U)
N#define USBFSH_HCRHDESCRIPTORB_PPCM(x)           (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHDESCRIPTORB_PPCM_SHIFT)) & USBFSH_HCRHDESCRIPTORB_PPCM_MASK)
N
N/*! @name HCRHSTATUS - This register is divided into two parts */
N#define USBFSH_HCRHSTATUS_LPS_MASK               (0x1U)
N#define USBFSH_HCRHSTATUS_LPS_SHIFT              (0U)
N#define USBFSH_HCRHSTATUS_LPS(x)                 (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHSTATUS_LPS_SHIFT)) & USBFSH_HCRHSTATUS_LPS_MASK)
N#define USBFSH_HCRHSTATUS_OCI_MASK               (0x2U)
N#define USBFSH_HCRHSTATUS_OCI_SHIFT              (1U)
N#define USBFSH_HCRHSTATUS_OCI(x)                 (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHSTATUS_OCI_SHIFT)) & USBFSH_HCRHSTATUS_OCI_MASK)
N#define USBFSH_HCRHSTATUS_DRWE_MASK              (0x8000U)
N#define USBFSH_HCRHSTATUS_DRWE_SHIFT             (15U)
N#define USBFSH_HCRHSTATUS_DRWE(x)                (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHSTATUS_DRWE_SHIFT)) & USBFSH_HCRHSTATUS_DRWE_MASK)
N#define USBFSH_HCRHSTATUS_LPSC_MASK              (0x10000U)
N#define USBFSH_HCRHSTATUS_LPSC_SHIFT             (16U)
N#define USBFSH_HCRHSTATUS_LPSC(x)                (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHSTATUS_LPSC_SHIFT)) & USBFSH_HCRHSTATUS_LPSC_MASK)
N#define USBFSH_HCRHSTATUS_OCIC_MASK              (0x20000U)
N#define USBFSH_HCRHSTATUS_OCIC_SHIFT             (17U)
N#define USBFSH_HCRHSTATUS_OCIC(x)                (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHSTATUS_OCIC_SHIFT)) & USBFSH_HCRHSTATUS_OCIC_MASK)
N#define USBFSH_HCRHSTATUS_CRWE_MASK              (0x80000000U)
N#define USBFSH_HCRHSTATUS_CRWE_SHIFT             (31U)
N#define USBFSH_HCRHSTATUS_CRWE(x)                (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHSTATUS_CRWE_SHIFT)) & USBFSH_HCRHSTATUS_CRWE_MASK)
N
N/*! @name HCRHPORTSTATUS - Controls and reports the port events on a per-port basis */
N#define USBFSH_HCRHPORTSTATUS_CCS_MASK           (0x1U)
N#define USBFSH_HCRHPORTSTATUS_CCS_SHIFT          (0U)
N#define USBFSH_HCRHPORTSTATUS_CCS(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_CCS_SHIFT)) & USBFSH_HCRHPORTSTATUS_CCS_MASK)
N#define USBFSH_HCRHPORTSTATUS_PES_MASK           (0x2U)
N#define USBFSH_HCRHPORTSTATUS_PES_SHIFT          (1U)
N#define USBFSH_HCRHPORTSTATUS_PES(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PES_SHIFT)) & USBFSH_HCRHPORTSTATUS_PES_MASK)
N#define USBFSH_HCRHPORTSTATUS_PSS_MASK           (0x4U)
N#define USBFSH_HCRHPORTSTATUS_PSS_SHIFT          (2U)
N#define USBFSH_HCRHPORTSTATUS_PSS(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PSS_SHIFT)) & USBFSH_HCRHPORTSTATUS_PSS_MASK)
N#define USBFSH_HCRHPORTSTATUS_POCI_MASK          (0x8U)
N#define USBFSH_HCRHPORTSTATUS_POCI_SHIFT         (3U)
N#define USBFSH_HCRHPORTSTATUS_POCI(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_POCI_SHIFT)) & USBFSH_HCRHPORTSTATUS_POCI_MASK)
N#define USBFSH_HCRHPORTSTATUS_PRS_MASK           (0x10U)
N#define USBFSH_HCRHPORTSTATUS_PRS_SHIFT          (4U)
N#define USBFSH_HCRHPORTSTATUS_PRS(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PRS_SHIFT)) & USBFSH_HCRHPORTSTATUS_PRS_MASK)
N#define USBFSH_HCRHPORTSTATUS_PPS_MASK           (0x100U)
N#define USBFSH_HCRHPORTSTATUS_PPS_SHIFT          (8U)
N#define USBFSH_HCRHPORTSTATUS_PPS(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PPS_SHIFT)) & USBFSH_HCRHPORTSTATUS_PPS_MASK)
N#define USBFSH_HCRHPORTSTATUS_LSDA_MASK          (0x200U)
N#define USBFSH_HCRHPORTSTATUS_LSDA_SHIFT         (9U)
N#define USBFSH_HCRHPORTSTATUS_LSDA(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_LSDA_SHIFT)) & USBFSH_HCRHPORTSTATUS_LSDA_MASK)
N#define USBFSH_HCRHPORTSTATUS_CSC_MASK           (0x10000U)
N#define USBFSH_HCRHPORTSTATUS_CSC_SHIFT          (16U)
N#define USBFSH_HCRHPORTSTATUS_CSC(x)             (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_CSC_SHIFT)) & USBFSH_HCRHPORTSTATUS_CSC_MASK)
N#define USBFSH_HCRHPORTSTATUS_PESC_MASK          (0x20000U)
N#define USBFSH_HCRHPORTSTATUS_PESC_SHIFT         (17U)
N#define USBFSH_HCRHPORTSTATUS_PESC(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PESC_SHIFT)) & USBFSH_HCRHPORTSTATUS_PESC_MASK)
N#define USBFSH_HCRHPORTSTATUS_PSSC_MASK          (0x40000U)
N#define USBFSH_HCRHPORTSTATUS_PSSC_SHIFT         (18U)
N#define USBFSH_HCRHPORTSTATUS_PSSC(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PSSC_SHIFT)) & USBFSH_HCRHPORTSTATUS_PSSC_MASK)
N#define USBFSH_HCRHPORTSTATUS_OCIC_MASK          (0x80000U)
N#define USBFSH_HCRHPORTSTATUS_OCIC_SHIFT         (19U)
N#define USBFSH_HCRHPORTSTATUS_OCIC(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_OCIC_SHIFT)) & USBFSH_HCRHPORTSTATUS_OCIC_MASK)
N#define USBFSH_HCRHPORTSTATUS_PRSC_MASK          (0x100000U)
N#define USBFSH_HCRHPORTSTATUS_PRSC_SHIFT         (20U)
N#define USBFSH_HCRHPORTSTATUS_PRSC(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_HCRHPORTSTATUS_PRSC_SHIFT)) & USBFSH_HCRHPORTSTATUS_PRSC_MASK)
N
N/*! @name PORTMODE - Controls the port if it is attached to the host block or the device block */
N#define USBFSH_PORTMODE_ID_MASK                  (0x1U)
N#define USBFSH_PORTMODE_ID_SHIFT                 (0U)
N#define USBFSH_PORTMODE_ID(x)                    (((uint32_t)(((uint32_t)(x)) << USBFSH_PORTMODE_ID_SHIFT)) & USBFSH_PORTMODE_ID_MASK)
N#define USBFSH_PORTMODE_ID_EN_MASK               (0x100U)
N#define USBFSH_PORTMODE_ID_EN_SHIFT              (8U)
N#define USBFSH_PORTMODE_ID_EN(x)                 (((uint32_t)(((uint32_t)(x)) << USBFSH_PORTMODE_ID_EN_SHIFT)) & USBFSH_PORTMODE_ID_EN_MASK)
N#define USBFSH_PORTMODE_DEV_ENABLE_MASK          (0x10000U)
N#define USBFSH_PORTMODE_DEV_ENABLE_SHIFT         (16U)
N#define USBFSH_PORTMODE_DEV_ENABLE(x)            (((uint32_t)(((uint32_t)(x)) << USBFSH_PORTMODE_DEV_ENABLE_SHIFT)) & USBFSH_PORTMODE_DEV_ENABLE_MASK)
N
N
N/*!
N * @}
N */ /* end of group USBFSH_Register_Masks */
N
N
N/* USBFSH - Peripheral instance base addresses */
N/** Peripheral USBFSH base address */
N#define USBFSH_BASE                              (0x400A2000u)
N/** Peripheral USBFSH base pointer */
N#define USBFSH                                   ((USBFSH_Type *)USBFSH_BASE)
N/** Array initializer of USBFSH peripheral base addresses */
N#define USBFSH_BASE_ADDRS                        { USBFSH_BASE }
N/** Array initializer of USBFSH peripheral base pointers */
N#define USBFSH_BASE_PTRS                         { USBFSH }
N/** Interrupt vectors for the USBFSH peripheral type */
N#define USBFSH_IRQS                              { USB0_IRQn }
N#define USBFSH_NEEDCLK_IRQS                      { USB0_NEEDCLK_IRQn }
N
N/*!
N * @}
N */ /* end of group USBFSH_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USBHSD Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USBHSD_Peripheral_Access_Layer USBHSD Peripheral Access Layer
N * @{
N */
N
N/** USBHSD - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t DEVCMDSTAT;                        /**< USB Device Command/Status register, offset: 0x0 */
X  volatile uint32_t DEVCMDSTAT;                         
N  __I  uint32_t INFO;                              /**< USB Info register, offset: 0x4 */
X  volatile const  uint32_t INFO;                               
N  __IO uint32_t EPLISTSTART;                       /**< USB EP Command/Status List start address, offset: 0x8 */
X  volatile uint32_t EPLISTSTART;                        
N  __I  uint32_t DATABUFSTART;                      /**< USB Data buffer start address, offset: 0xC */
X  volatile const  uint32_t DATABUFSTART;                       
N  __IO uint32_t LPM;                               /**< USB Link Power Management register, offset: 0x10 */
X  volatile uint32_t LPM;                                
N  __IO uint32_t EPSKIP;                            /**< USB Endpoint skip, offset: 0x14 */
X  volatile uint32_t EPSKIP;                             
N  __IO uint32_t EPINUSE;                           /**< USB Endpoint Buffer in use, offset: 0x18 */
X  volatile uint32_t EPINUSE;                            
N  __IO uint32_t EPBUFCFG;                          /**< USB Endpoint Buffer Configuration register, offset: 0x1C */
X  volatile uint32_t EPBUFCFG;                           
N  __IO uint32_t INTSTAT;                           /**< USB interrupt status register, offset: 0x20 */
X  volatile uint32_t INTSTAT;                            
N  __IO uint32_t INTEN;                             /**< USB interrupt enable register, offset: 0x24 */
X  volatile uint32_t INTEN;                              
N  __IO uint32_t INTSETSTAT;                        /**< USB set interrupt status register, offset: 0x28 */
X  volatile uint32_t INTSETSTAT;                         
N       uint8_t RESERVED_0[8];
N  __I  uint32_t EPTOGGLE;                          /**< USB Endpoint toggle register, offset: 0x34 */
X  volatile const  uint32_t EPTOGGLE;                           
N       uint8_t RESERVED_1[4];
N  __IO uint32_t ULPIDEBUG;                         /**< UTMI/ULPI debug register, offset: 0x3C */
X  volatile uint32_t ULPIDEBUG;                          
N} USBHSD_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USBHSD Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USBHSD_Register_Masks USBHSD Register Masks
N * @{
N */
N
N/*! @name DEVCMDSTAT - USB Device Command/Status register */
N#define USBHSD_DEVCMDSTAT_DEV_ADDR_MASK          (0x7FU)
N#define USBHSD_DEVCMDSTAT_DEV_ADDR_SHIFT         (0U)
N#define USBHSD_DEVCMDSTAT_DEV_ADDR(x)            (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DEV_ADDR_SHIFT)) & USBHSD_DEVCMDSTAT_DEV_ADDR_MASK)
N#define USBHSD_DEVCMDSTAT_DEV_EN_MASK            (0x80U)
N#define USBHSD_DEVCMDSTAT_DEV_EN_SHIFT           (7U)
N#define USBHSD_DEVCMDSTAT_DEV_EN(x)              (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DEV_EN_SHIFT)) & USBHSD_DEVCMDSTAT_DEV_EN_MASK)
N#define USBHSD_DEVCMDSTAT_SETUP_MASK             (0x100U)
N#define USBHSD_DEVCMDSTAT_SETUP_SHIFT            (8U)
N#define USBHSD_DEVCMDSTAT_SETUP(x)               (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_SETUP_SHIFT)) & USBHSD_DEVCMDSTAT_SETUP_MASK)
N#define USBHSD_DEVCMDSTAT_FORCE_NEEDCLK_MASK     (0x200U)
N#define USBHSD_DEVCMDSTAT_FORCE_NEEDCLK_SHIFT    (9U)
N#define USBHSD_DEVCMDSTAT_FORCE_NEEDCLK(x)       (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_FORCE_NEEDCLK_SHIFT)) & USBHSD_DEVCMDSTAT_FORCE_NEEDCLK_MASK)
N#define USBHSD_DEVCMDSTAT_FORCE_VBUS_MASK        (0x400U)
N#define USBHSD_DEVCMDSTAT_FORCE_VBUS_SHIFT       (10U)
N#define USBHSD_DEVCMDSTAT_FORCE_VBUS(x)          (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_FORCE_VBUS_SHIFT)) & USBHSD_DEVCMDSTAT_FORCE_VBUS_MASK)
N#define USBHSD_DEVCMDSTAT_LPM_SUP_MASK           (0x800U)
N#define USBHSD_DEVCMDSTAT_LPM_SUP_SHIFT          (11U)
N#define USBHSD_DEVCMDSTAT_LPM_SUP(x)             (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_LPM_SUP_SHIFT)) & USBHSD_DEVCMDSTAT_LPM_SUP_MASK)
N#define USBHSD_DEVCMDSTAT_INTONNAK_AO_MASK       (0x1000U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_AO_SHIFT      (12U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_AO(x)         (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_INTONNAK_AO_SHIFT)) & USBHSD_DEVCMDSTAT_INTONNAK_AO_MASK)
N#define USBHSD_DEVCMDSTAT_INTONNAK_AI_MASK       (0x2000U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_AI_SHIFT      (13U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_AI(x)         (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_INTONNAK_AI_SHIFT)) & USBHSD_DEVCMDSTAT_INTONNAK_AI_MASK)
N#define USBHSD_DEVCMDSTAT_INTONNAK_CO_MASK       (0x4000U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_CO_SHIFT      (14U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_CO(x)         (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_INTONNAK_CO_SHIFT)) & USBHSD_DEVCMDSTAT_INTONNAK_CO_MASK)
N#define USBHSD_DEVCMDSTAT_INTONNAK_CI_MASK       (0x8000U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_CI_SHIFT      (15U)
N#define USBHSD_DEVCMDSTAT_INTONNAK_CI(x)         (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_INTONNAK_CI_SHIFT)) & USBHSD_DEVCMDSTAT_INTONNAK_CI_MASK)
N#define USBHSD_DEVCMDSTAT_DCON_MASK              (0x10000U)
N#define USBHSD_DEVCMDSTAT_DCON_SHIFT             (16U)
N#define USBHSD_DEVCMDSTAT_DCON(x)                (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DCON_SHIFT)) & USBHSD_DEVCMDSTAT_DCON_MASK)
N#define USBHSD_DEVCMDSTAT_DSUS_MASK              (0x20000U)
N#define USBHSD_DEVCMDSTAT_DSUS_SHIFT             (17U)
N#define USBHSD_DEVCMDSTAT_DSUS(x)                (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DSUS_SHIFT)) & USBHSD_DEVCMDSTAT_DSUS_MASK)
N#define USBHSD_DEVCMDSTAT_LPM_SUS_MASK           (0x80000U)
N#define USBHSD_DEVCMDSTAT_LPM_SUS_SHIFT          (19U)
N#define USBHSD_DEVCMDSTAT_LPM_SUS(x)             (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_LPM_SUS_SHIFT)) & USBHSD_DEVCMDSTAT_LPM_SUS_MASK)
N#define USBHSD_DEVCMDSTAT_LPM_REWP_MASK          (0x100000U)
N#define USBHSD_DEVCMDSTAT_LPM_REWP_SHIFT         (20U)
N#define USBHSD_DEVCMDSTAT_LPM_REWP(x)            (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_LPM_REWP_SHIFT)) & USBHSD_DEVCMDSTAT_LPM_REWP_MASK)
N#define USBHSD_DEVCMDSTAT_Speed_MASK             (0xC00000U)
N#define USBHSD_DEVCMDSTAT_Speed_SHIFT            (22U)
N#define USBHSD_DEVCMDSTAT_Speed(x)               (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_Speed_SHIFT)) & USBHSD_DEVCMDSTAT_Speed_MASK)
N#define USBHSD_DEVCMDSTAT_DCON_C_MASK            (0x1000000U)
N#define USBHSD_DEVCMDSTAT_DCON_C_SHIFT           (24U)
N#define USBHSD_DEVCMDSTAT_DCON_C(x)              (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DCON_C_SHIFT)) & USBHSD_DEVCMDSTAT_DCON_C_MASK)
N#define USBHSD_DEVCMDSTAT_DSUS_C_MASK            (0x2000000U)
N#define USBHSD_DEVCMDSTAT_DSUS_C_SHIFT           (25U)
N#define USBHSD_DEVCMDSTAT_DSUS_C(x)              (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DSUS_C_SHIFT)) & USBHSD_DEVCMDSTAT_DSUS_C_MASK)
N#define USBHSD_DEVCMDSTAT_DRES_C_MASK            (0x4000000U)
N#define USBHSD_DEVCMDSTAT_DRES_C_SHIFT           (26U)
N#define USBHSD_DEVCMDSTAT_DRES_C(x)              (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_DRES_C_SHIFT)) & USBHSD_DEVCMDSTAT_DRES_C_MASK)
N#define USBHSD_DEVCMDSTAT_VBUS_DEBOUNCED_MASK    (0x10000000U)
N#define USBHSD_DEVCMDSTAT_VBUS_DEBOUNCED_SHIFT   (28U)
N#define USBHSD_DEVCMDSTAT_VBUS_DEBOUNCED(x)      (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_VBUS_DEBOUNCED_SHIFT)) & USBHSD_DEVCMDSTAT_VBUS_DEBOUNCED_MASK)
N#define USBHSD_DEVCMDSTAT_PHY_TEST_MODE_MASK     (0xE0000000U)
N#define USBHSD_DEVCMDSTAT_PHY_TEST_MODE_SHIFT    (29U)
N#define USBHSD_DEVCMDSTAT_PHY_TEST_MODE(x)       (((uint32_t)(((uint32_t)(x)) << USBHSD_DEVCMDSTAT_PHY_TEST_MODE_SHIFT)) & USBHSD_DEVCMDSTAT_PHY_TEST_MODE_MASK)
N
N/*! @name INFO - USB Info register */
N#define USBHSD_INFO_FRAME_NR_MASK                (0x7FFU)
N#define USBHSD_INFO_FRAME_NR_SHIFT               (0U)
N#define USBHSD_INFO_FRAME_NR(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INFO_FRAME_NR_SHIFT)) & USBHSD_INFO_FRAME_NR_MASK)
N#define USBHSD_INFO_ERR_CODE_MASK                (0x7800U)
N#define USBHSD_INFO_ERR_CODE_SHIFT               (11U)
N#define USBHSD_INFO_ERR_CODE(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INFO_ERR_CODE_SHIFT)) & USBHSD_INFO_ERR_CODE_MASK)
N#define USBHSD_INFO_Minrev_MASK                  (0xFF0000U)
N#define USBHSD_INFO_Minrev_SHIFT                 (16U)
N#define USBHSD_INFO_Minrev(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSD_INFO_Minrev_SHIFT)) & USBHSD_INFO_Minrev_MASK)
N#define USBHSD_INFO_Majrev_MASK                  (0xFF000000U)
N#define USBHSD_INFO_Majrev_SHIFT                 (24U)
N#define USBHSD_INFO_Majrev(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSD_INFO_Majrev_SHIFT)) & USBHSD_INFO_Majrev_MASK)
N
N/*! @name EPLISTSTART - USB EP Command/Status List start address */
N#define USBHSD_EPLISTSTART_EP_LIST_PRG_MASK      (0xFFF00U)
N#define USBHSD_EPLISTSTART_EP_LIST_PRG_SHIFT     (8U)
N#define USBHSD_EPLISTSTART_EP_LIST_PRG(x)        (((uint32_t)(((uint32_t)(x)) << USBHSD_EPLISTSTART_EP_LIST_PRG_SHIFT)) & USBHSD_EPLISTSTART_EP_LIST_PRG_MASK)
N#define USBHSD_EPLISTSTART_EP_LIST_FIXED_MASK    (0xFFF00000U)
N#define USBHSD_EPLISTSTART_EP_LIST_FIXED_SHIFT   (20U)
N#define USBHSD_EPLISTSTART_EP_LIST_FIXED(x)      (((uint32_t)(((uint32_t)(x)) << USBHSD_EPLISTSTART_EP_LIST_FIXED_SHIFT)) & USBHSD_EPLISTSTART_EP_LIST_FIXED_MASK)
N
N/*! @name DATABUFSTART - USB Data buffer start address */
N#define USBHSD_DATABUFSTART_DA_BUF_MASK          (0xFFFFFFFFU)
N#define USBHSD_DATABUFSTART_DA_BUF_SHIFT         (0U)
N#define USBHSD_DATABUFSTART_DA_BUF(x)            (((uint32_t)(((uint32_t)(x)) << USBHSD_DATABUFSTART_DA_BUF_SHIFT)) & USBHSD_DATABUFSTART_DA_BUF_MASK)
N
N/*! @name LPM - USB Link Power Management register */
N#define USBHSD_LPM_HIRD_HW_MASK                  (0xFU)
N#define USBHSD_LPM_HIRD_HW_SHIFT                 (0U)
N#define USBHSD_LPM_HIRD_HW(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSD_LPM_HIRD_HW_SHIFT)) & USBHSD_LPM_HIRD_HW_MASK)
N#define USBHSD_LPM_HIRD_SW_MASK                  (0xF0U)
N#define USBHSD_LPM_HIRD_SW_SHIFT                 (4U)
N#define USBHSD_LPM_HIRD_SW(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSD_LPM_HIRD_SW_SHIFT)) & USBHSD_LPM_HIRD_SW_MASK)
N#define USBHSD_LPM_DATA_PENDING_MASK             (0x100U)
N#define USBHSD_LPM_DATA_PENDING_SHIFT            (8U)
N#define USBHSD_LPM_DATA_PENDING(x)               (((uint32_t)(((uint32_t)(x)) << USBHSD_LPM_DATA_PENDING_SHIFT)) & USBHSD_LPM_DATA_PENDING_MASK)
N
N/*! @name EPSKIP - USB Endpoint skip */
N#define USBHSD_EPSKIP_SKIP_MASK                  (0xFFFU)
N#define USBHSD_EPSKIP_SKIP_SHIFT                 (0U)
N#define USBHSD_EPSKIP_SKIP(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSD_EPSKIP_SKIP_SHIFT)) & USBHSD_EPSKIP_SKIP_MASK)
N
N/*! @name EPINUSE - USB Endpoint Buffer in use */
N#define USBHSD_EPINUSE_BUF_MASK                  (0xFFCU)
N#define USBHSD_EPINUSE_BUF_SHIFT                 (2U)
N#define USBHSD_EPINUSE_BUF(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSD_EPINUSE_BUF_SHIFT)) & USBHSD_EPINUSE_BUF_MASK)
N
N/*! @name EPBUFCFG - USB Endpoint Buffer Configuration register */
N#define USBHSD_EPBUFCFG_BUF_SB_MASK              (0xFFCU)
N#define USBHSD_EPBUFCFG_BUF_SB_SHIFT             (2U)
N#define USBHSD_EPBUFCFG_BUF_SB(x)                (((uint32_t)(((uint32_t)(x)) << USBHSD_EPBUFCFG_BUF_SB_SHIFT)) & USBHSD_EPBUFCFG_BUF_SB_MASK)
N
N/*! @name INTSTAT - USB interrupt status register */
N#define USBHSD_INTSTAT_EP0OUT_MASK               (0x1U)
N#define USBHSD_INTSTAT_EP0OUT_SHIFT              (0U)
N#define USBHSD_INTSTAT_EP0OUT(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP0OUT_SHIFT)) & USBHSD_INTSTAT_EP0OUT_MASK)
N#define USBHSD_INTSTAT_EP0IN_MASK                (0x2U)
N#define USBHSD_INTSTAT_EP0IN_SHIFT               (1U)
N#define USBHSD_INTSTAT_EP0IN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP0IN_SHIFT)) & USBHSD_INTSTAT_EP0IN_MASK)
N#define USBHSD_INTSTAT_EP1OUT_MASK               (0x4U)
N#define USBHSD_INTSTAT_EP1OUT_SHIFT              (2U)
N#define USBHSD_INTSTAT_EP1OUT(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP1OUT_SHIFT)) & USBHSD_INTSTAT_EP1OUT_MASK)
N#define USBHSD_INTSTAT_EP1IN_MASK                (0x8U)
N#define USBHSD_INTSTAT_EP1IN_SHIFT               (3U)
N#define USBHSD_INTSTAT_EP1IN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP1IN_SHIFT)) & USBHSD_INTSTAT_EP1IN_MASK)
N#define USBHSD_INTSTAT_EP2OUT_MASK               (0x10U)
N#define USBHSD_INTSTAT_EP2OUT_SHIFT              (4U)
N#define USBHSD_INTSTAT_EP2OUT(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP2OUT_SHIFT)) & USBHSD_INTSTAT_EP2OUT_MASK)
N#define USBHSD_INTSTAT_EP2IN_MASK                (0x20U)
N#define USBHSD_INTSTAT_EP2IN_SHIFT               (5U)
N#define USBHSD_INTSTAT_EP2IN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP2IN_SHIFT)) & USBHSD_INTSTAT_EP2IN_MASK)
N#define USBHSD_INTSTAT_EP3OUT_MASK               (0x40U)
N#define USBHSD_INTSTAT_EP3OUT_SHIFT              (6U)
N#define USBHSD_INTSTAT_EP3OUT(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP3OUT_SHIFT)) & USBHSD_INTSTAT_EP3OUT_MASK)
N#define USBHSD_INTSTAT_EP3IN_MASK                (0x80U)
N#define USBHSD_INTSTAT_EP3IN_SHIFT               (7U)
N#define USBHSD_INTSTAT_EP3IN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP3IN_SHIFT)) & USBHSD_INTSTAT_EP3IN_MASK)
N#define USBHSD_INTSTAT_EP4OUT_MASK               (0x100U)
N#define USBHSD_INTSTAT_EP4OUT_SHIFT              (8U)
N#define USBHSD_INTSTAT_EP4OUT(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP4OUT_SHIFT)) & USBHSD_INTSTAT_EP4OUT_MASK)
N#define USBHSD_INTSTAT_EP4IN_MASK                (0x200U)
N#define USBHSD_INTSTAT_EP4IN_SHIFT               (9U)
N#define USBHSD_INTSTAT_EP4IN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP4IN_SHIFT)) & USBHSD_INTSTAT_EP4IN_MASK)
N#define USBHSD_INTSTAT_EP5OUT_MASK               (0x400U)
N#define USBHSD_INTSTAT_EP5OUT_SHIFT              (10U)
N#define USBHSD_INTSTAT_EP5OUT(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP5OUT_SHIFT)) & USBHSD_INTSTAT_EP5OUT_MASK)
N#define USBHSD_INTSTAT_EP5IN_MASK                (0x800U)
N#define USBHSD_INTSTAT_EP5IN_SHIFT               (11U)
N#define USBHSD_INTSTAT_EP5IN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_EP5IN_SHIFT)) & USBHSD_INTSTAT_EP5IN_MASK)
N#define USBHSD_INTSTAT_FRAME_INT_MASK            (0x40000000U)
N#define USBHSD_INTSTAT_FRAME_INT_SHIFT           (30U)
N#define USBHSD_INTSTAT_FRAME_INT(x)              (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_FRAME_INT_SHIFT)) & USBHSD_INTSTAT_FRAME_INT_MASK)
N#define USBHSD_INTSTAT_DEV_INT_MASK              (0x80000000U)
N#define USBHSD_INTSTAT_DEV_INT_SHIFT             (31U)
N#define USBHSD_INTSTAT_DEV_INT(x)                (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSTAT_DEV_INT_SHIFT)) & USBHSD_INTSTAT_DEV_INT_MASK)
N
N/*! @name INTEN - USB interrupt enable register */
N#define USBHSD_INTEN_EP_INT_EN_MASK              (0xFFFU)
N#define USBHSD_INTEN_EP_INT_EN_SHIFT             (0U)
N#define USBHSD_INTEN_EP_INT_EN(x)                (((uint32_t)(((uint32_t)(x)) << USBHSD_INTEN_EP_INT_EN_SHIFT)) & USBHSD_INTEN_EP_INT_EN_MASK)
N#define USBHSD_INTEN_FRAME_INT_EN_MASK           (0x40000000U)
N#define USBHSD_INTEN_FRAME_INT_EN_SHIFT          (30U)
N#define USBHSD_INTEN_FRAME_INT_EN(x)             (((uint32_t)(((uint32_t)(x)) << USBHSD_INTEN_FRAME_INT_EN_SHIFT)) & USBHSD_INTEN_FRAME_INT_EN_MASK)
N#define USBHSD_INTEN_DEV_INT_EN_MASK             (0x80000000U)
N#define USBHSD_INTEN_DEV_INT_EN_SHIFT            (31U)
N#define USBHSD_INTEN_DEV_INT_EN(x)               (((uint32_t)(((uint32_t)(x)) << USBHSD_INTEN_DEV_INT_EN_SHIFT)) & USBHSD_INTEN_DEV_INT_EN_MASK)
N
N/*! @name INTSETSTAT - USB set interrupt status register */
N#define USBHSD_INTSETSTAT_EP_SET_INT_MASK        (0xFFFU)
N#define USBHSD_INTSETSTAT_EP_SET_INT_SHIFT       (0U)
N#define USBHSD_INTSETSTAT_EP_SET_INT(x)          (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSETSTAT_EP_SET_INT_SHIFT)) & USBHSD_INTSETSTAT_EP_SET_INT_MASK)
N#define USBHSD_INTSETSTAT_FRAME_SET_INT_MASK     (0x40000000U)
N#define USBHSD_INTSETSTAT_FRAME_SET_INT_SHIFT    (30U)
N#define USBHSD_INTSETSTAT_FRAME_SET_INT(x)       (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSETSTAT_FRAME_SET_INT_SHIFT)) & USBHSD_INTSETSTAT_FRAME_SET_INT_MASK)
N#define USBHSD_INTSETSTAT_DEV_SET_INT_MASK       (0x80000000U)
N#define USBHSD_INTSETSTAT_DEV_SET_INT_SHIFT      (31U)
N#define USBHSD_INTSETSTAT_DEV_SET_INT(x)         (((uint32_t)(((uint32_t)(x)) << USBHSD_INTSETSTAT_DEV_SET_INT_SHIFT)) & USBHSD_INTSETSTAT_DEV_SET_INT_MASK)
N
N/*! @name EPTOGGLE - USB Endpoint toggle register */
N#define USBHSD_EPTOGGLE_TOGGLE_MASK              (0x3FFFFFFFU)
N#define USBHSD_EPTOGGLE_TOGGLE_SHIFT             (0U)
N#define USBHSD_EPTOGGLE_TOGGLE(x)                (((uint32_t)(((uint32_t)(x)) << USBHSD_EPTOGGLE_TOGGLE_SHIFT)) & USBHSD_EPTOGGLE_TOGGLE_MASK)
N
N/*! @name ULPIDEBUG - UTMI/ULPI debug register */
N#define USBHSD_ULPIDEBUG_PHY_ADDR_MASK           (0xFFU)
N#define USBHSD_ULPIDEBUG_PHY_ADDR_SHIFT          (0U)
N#define USBHSD_ULPIDEBUG_PHY_ADDR(x)             (((uint32_t)(((uint32_t)(x)) << USBHSD_ULPIDEBUG_PHY_ADDR_SHIFT)) & USBHSD_ULPIDEBUG_PHY_ADDR_MASK)
N#define USBHSD_ULPIDEBUG_PHY_WDATA_MASK          (0xFF00U)
N#define USBHSD_ULPIDEBUG_PHY_WDATA_SHIFT         (8U)
N#define USBHSD_ULPIDEBUG_PHY_WDATA(x)            (((uint32_t)(((uint32_t)(x)) << USBHSD_ULPIDEBUG_PHY_WDATA_SHIFT)) & USBHSD_ULPIDEBUG_PHY_WDATA_MASK)
N#define USBHSD_ULPIDEBUG_PHY_RDATA_MASK          (0xFF0000U)
N#define USBHSD_ULPIDEBUG_PHY_RDATA_SHIFT         (16U)
N#define USBHSD_ULPIDEBUG_PHY_RDATA(x)            (((uint32_t)(((uint32_t)(x)) << USBHSD_ULPIDEBUG_PHY_RDATA_SHIFT)) & USBHSD_ULPIDEBUG_PHY_RDATA_MASK)
N#define USBHSD_ULPIDEBUG_PHY_RW_MASK             (0x1000000U)
N#define USBHSD_ULPIDEBUG_PHY_RW_SHIFT            (24U)
N#define USBHSD_ULPIDEBUG_PHY_RW(x)               (((uint32_t)(((uint32_t)(x)) << USBHSD_ULPIDEBUG_PHY_RW_SHIFT)) & USBHSD_ULPIDEBUG_PHY_RW_MASK)
N#define USBHSD_ULPIDEBUG_PHY_ACCESS_MASK         (0x2000000U)
N#define USBHSD_ULPIDEBUG_PHY_ACCESS_SHIFT        (25U)
N#define USBHSD_ULPIDEBUG_PHY_ACCESS(x)           (((uint32_t)(((uint32_t)(x)) << USBHSD_ULPIDEBUG_PHY_ACCESS_SHIFT)) & USBHSD_ULPIDEBUG_PHY_ACCESS_MASK)
N#define USBHSD_ULPIDEBUG_PHY_MODE_MASK           (0x80000000U)
N#define USBHSD_ULPIDEBUG_PHY_MODE_SHIFT          (31U)
N#define USBHSD_ULPIDEBUG_PHY_MODE(x)             (((uint32_t)(((uint32_t)(x)) << USBHSD_ULPIDEBUG_PHY_MODE_SHIFT)) & USBHSD_ULPIDEBUG_PHY_MODE_MASK)
N
N
N/*!
N * @}
N */ /* end of group USBHSD_Register_Masks */
N
N
N/* USBHSD - Peripheral instance base addresses */
N/** Peripheral USBHSD base address */
N#define USBHSD_BASE                              (0x40094000u)
N/** Peripheral USBHSD base pointer */
N#define USBHSD                                   ((USBHSD_Type *)USBHSD_BASE)
N/** Array initializer of USBHSD peripheral base addresses */
N#define USBHSD_BASE_ADDRS                        { USBHSD_BASE }
N/** Array initializer of USBHSD peripheral base pointers */
N#define USBHSD_BASE_PTRS                         { USBHSD }
N/** Interrupt vectors for the USBHSD peripheral type */
N#define USBHSD_IRQS                              { USB1_IRQn }
N#define USBHSD_NEEDCLK_IRQS                      { USB1_NEEDCLK_IRQn }
N
N/*!
N * @}
N */ /* end of group USBHSD_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USBHSH Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USBHSH_Peripheral_Access_Layer USBHSH Peripheral Access Layer
N * @{
N */
N
N/** USBHSH - Register Layout Typedef */
Ntypedef struct {
N  __I  uint32_t CAPLENGTH_CHIPID;                  /**< This register contains the offset value towards the start of the operational register space and the version number of the IP block, offset: 0x0 */
X  volatile const  uint32_t CAPLENGTH_CHIPID;                   
N  __I  uint32_t HCSPARAMS;                         /**< Host Controller Structural Parameters, offset: 0x4 */
X  volatile const  uint32_t HCSPARAMS;                          
N  __I  uint32_t HCCPARAMS;                         /**< Host Controller Capability Parameters, offset: 0x8 */
X  volatile const  uint32_t HCCPARAMS;                          
N  __IO uint32_t FLADJ_FRINDEX;                     /**< Frame Length Adjustment, offset: 0xC */
X  volatile uint32_t FLADJ_FRINDEX;                      
N  __IO uint32_t ATL_PTD_BASE_ADDR;                 /**< Memory base address where ATL PTD0 is stored, offset: 0x10 */
X  volatile uint32_t ATL_PTD_BASE_ADDR;                  
N  __IO uint32_t ISO_PTD_BASE_ADDR;                 /**< Memory base address where ISO PTD0 is stored, offset: 0x14 */
X  volatile uint32_t ISO_PTD_BASE_ADDR;                  
N  __IO uint32_t INT_PTD_BASE_ADDR;                 /**< Memory base address where INT PTD0 is stored, offset: 0x18 */
X  volatile uint32_t INT_PTD_BASE_ADDR;                  
N  __IO uint32_t DATA_PAYLOAD_BASE_ADDR;            /**< Memory base address that indicates the start of the data payload buffers, offset: 0x1C */
X  volatile uint32_t DATA_PAYLOAD_BASE_ADDR;             
N  __IO uint32_t USBCMD;                            /**< USB Command register, offset: 0x20 */
X  volatile uint32_t USBCMD;                             
N  __IO uint32_t USBSTS;                            /**< USB Interrupt Status register, offset: 0x24 */
X  volatile uint32_t USBSTS;                             
N  __IO uint32_t USBINTR;                           /**< USB Interrupt Enable register, offset: 0x28 */
X  volatile uint32_t USBINTR;                            
N  __IO uint32_t PORTSC1;                           /**< Port Status and Control register, offset: 0x2C */
X  volatile uint32_t PORTSC1;                            
N  __IO uint32_t ATL_PTD_DONE_MAP;                  /**< Done map for each ATL PTD, offset: 0x30 */
X  volatile uint32_t ATL_PTD_DONE_MAP;                   
N  __IO uint32_t ATL_PTD_SKIP_MAP;                  /**< Skip map for each ATL PTD, offset: 0x34 */
X  volatile uint32_t ATL_PTD_SKIP_MAP;                   
N  __IO uint32_t ISO_PTD_DONE_MAP;                  /**< Done map for each ISO PTD, offset: 0x38 */
X  volatile uint32_t ISO_PTD_DONE_MAP;                   
N  __IO uint32_t ISO_PTD_SKIP_MAP;                  /**< Skip map for each ISO PTD, offset: 0x3C */
X  volatile uint32_t ISO_PTD_SKIP_MAP;                   
N  __IO uint32_t INT_PTD_DONE_MAP;                  /**< Done map for each INT PTD, offset: 0x40 */
X  volatile uint32_t INT_PTD_DONE_MAP;                   
N  __IO uint32_t INT_PTD_SKIP_MAP;                  /**< Skip map for each INT PTD, offset: 0x44 */
X  volatile uint32_t INT_PTD_SKIP_MAP;                   
N  __IO uint32_t LAST_PTD_INUSE;                    /**< Marks the last PTD in the list for ISO, INT and ATL, offset: 0x48 */
X  volatile uint32_t LAST_PTD_INUSE;                     
N  __IO uint32_t UTMIPLUS_ULPI_DEBUG;               /**< Register to read/write registers in the attached USB PHY, offset: 0x4C */
X  volatile uint32_t UTMIPLUS_ULPI_DEBUG;                
N  __IO uint32_t PORTMODE;                          /**< Controls the port if it is attached to the host block or the device block, offset: 0x50 */
X  volatile uint32_t PORTMODE;                           
N} USBHSH_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USBHSH Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USBHSH_Register_Masks USBHSH Register Masks
N * @{
N */
N
N/*! @name CAPLENGTH_CHIPID - This register contains the offset value towards the start of the operational register space and the version number of the IP block */
N#define USBHSH_CAPLENGTH_CHIPID_CAPLENGTH_MASK   (0xFFU)
N#define USBHSH_CAPLENGTH_CHIPID_CAPLENGTH_SHIFT  (0U)
N#define USBHSH_CAPLENGTH_CHIPID_CAPLENGTH(x)     (((uint32_t)(((uint32_t)(x)) << USBHSH_CAPLENGTH_CHIPID_CAPLENGTH_SHIFT)) & USBHSH_CAPLENGTH_CHIPID_CAPLENGTH_MASK)
N#define USBHSH_CAPLENGTH_CHIPID_CHIPID_MASK      (0xFFFF0000U)
N#define USBHSH_CAPLENGTH_CHIPID_CHIPID_SHIFT     (16U)
N#define USBHSH_CAPLENGTH_CHIPID_CHIPID(x)        (((uint32_t)(((uint32_t)(x)) << USBHSH_CAPLENGTH_CHIPID_CHIPID_SHIFT)) & USBHSH_CAPLENGTH_CHIPID_CHIPID_MASK)
N
N/*! @name HCSPARAMS - Host Controller Structural Parameters */
N#define USBHSH_HCSPARAMS_N_PORTS_MASK            (0xFU)
N#define USBHSH_HCSPARAMS_N_PORTS_SHIFT           (0U)
N#define USBHSH_HCSPARAMS_N_PORTS(x)              (((uint32_t)(((uint32_t)(x)) << USBHSH_HCSPARAMS_N_PORTS_SHIFT)) & USBHSH_HCSPARAMS_N_PORTS_MASK)
N#define USBHSH_HCSPARAMS_PPC_MASK                (0x10U)
N#define USBHSH_HCSPARAMS_PPC_SHIFT               (4U)
N#define USBHSH_HCSPARAMS_PPC(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSH_HCSPARAMS_PPC_SHIFT)) & USBHSH_HCSPARAMS_PPC_MASK)
N#define USBHSH_HCSPARAMS_P_INDICATOR_MASK        (0x10000U)
N#define USBHSH_HCSPARAMS_P_INDICATOR_SHIFT       (16U)
N#define USBHSH_HCSPARAMS_P_INDICATOR(x)          (((uint32_t)(((uint32_t)(x)) << USBHSH_HCSPARAMS_P_INDICATOR_SHIFT)) & USBHSH_HCSPARAMS_P_INDICATOR_MASK)
N
N/*! @name HCCPARAMS - Host Controller Capability Parameters */
N#define USBHSH_HCCPARAMS_LPMC_MASK               (0x20000U)
N#define USBHSH_HCCPARAMS_LPMC_SHIFT              (17U)
N#define USBHSH_HCCPARAMS_LPMC(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_HCCPARAMS_LPMC_SHIFT)) & USBHSH_HCCPARAMS_LPMC_MASK)
N
N/*! @name FLADJ_FRINDEX - Frame Length Adjustment */
N#define USBHSH_FLADJ_FRINDEX_FLADJ_MASK          (0x3FU)
N#define USBHSH_FLADJ_FRINDEX_FLADJ_SHIFT         (0U)
N#define USBHSH_FLADJ_FRINDEX_FLADJ(x)            (((uint32_t)(((uint32_t)(x)) << USBHSH_FLADJ_FRINDEX_FLADJ_SHIFT)) & USBHSH_FLADJ_FRINDEX_FLADJ_MASK)
N#define USBHSH_FLADJ_FRINDEX_FRINDEX_MASK        (0x3FFF0000U)
N#define USBHSH_FLADJ_FRINDEX_FRINDEX_SHIFT       (16U)
N#define USBHSH_FLADJ_FRINDEX_FRINDEX(x)          (((uint32_t)(((uint32_t)(x)) << USBHSH_FLADJ_FRINDEX_FRINDEX_SHIFT)) & USBHSH_FLADJ_FRINDEX_FRINDEX_MASK)
N
N/*! @name ATL_PTD_BASE_ADDR - Memory base address where ATL PTD0 is stored */
N#define USBHSH_ATL_PTD_BASE_ADDR_ATL_CUR_MASK    (0x1F0U)
N#define USBHSH_ATL_PTD_BASE_ADDR_ATL_CUR_SHIFT   (4U)
N#define USBHSH_ATL_PTD_BASE_ADDR_ATL_CUR(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_ATL_PTD_BASE_ADDR_ATL_CUR_SHIFT)) & USBHSH_ATL_PTD_BASE_ADDR_ATL_CUR_MASK)
N#define USBHSH_ATL_PTD_BASE_ADDR_ATL_BASE_MASK   (0xFFFFFE00U)
N#define USBHSH_ATL_PTD_BASE_ADDR_ATL_BASE_SHIFT  (9U)
N#define USBHSH_ATL_PTD_BASE_ADDR_ATL_BASE(x)     (((uint32_t)(((uint32_t)(x)) << USBHSH_ATL_PTD_BASE_ADDR_ATL_BASE_SHIFT)) & USBHSH_ATL_PTD_BASE_ADDR_ATL_BASE_MASK)
N
N/*! @name ISO_PTD_BASE_ADDR - Memory base address where ISO PTD0 is stored */
N#define USBHSH_ISO_PTD_BASE_ADDR_ISO_FIRST_MASK  (0x3E0U)
N#define USBHSH_ISO_PTD_BASE_ADDR_ISO_FIRST_SHIFT (5U)
N#define USBHSH_ISO_PTD_BASE_ADDR_ISO_FIRST(x)    (((uint32_t)(((uint32_t)(x)) << USBHSH_ISO_PTD_BASE_ADDR_ISO_FIRST_SHIFT)) & USBHSH_ISO_PTD_BASE_ADDR_ISO_FIRST_MASK)
N#define USBHSH_ISO_PTD_BASE_ADDR_ISO_BASE_MASK   (0xFFFFFC00U)
N#define USBHSH_ISO_PTD_BASE_ADDR_ISO_BASE_SHIFT  (10U)
N#define USBHSH_ISO_PTD_BASE_ADDR_ISO_BASE(x)     (((uint32_t)(((uint32_t)(x)) << USBHSH_ISO_PTD_BASE_ADDR_ISO_BASE_SHIFT)) & USBHSH_ISO_PTD_BASE_ADDR_ISO_BASE_MASK)
N
N/*! @name INT_PTD_BASE_ADDR - Memory base address where INT PTD0 is stored */
N#define USBHSH_INT_PTD_BASE_ADDR_INT_FIRST_MASK  (0x3E0U)
N#define USBHSH_INT_PTD_BASE_ADDR_INT_FIRST_SHIFT (5U)
N#define USBHSH_INT_PTD_BASE_ADDR_INT_FIRST(x)    (((uint32_t)(((uint32_t)(x)) << USBHSH_INT_PTD_BASE_ADDR_INT_FIRST_SHIFT)) & USBHSH_INT_PTD_BASE_ADDR_INT_FIRST_MASK)
N#define USBHSH_INT_PTD_BASE_ADDR_INT_BASE_MASK   (0xFFFFFC00U)
N#define USBHSH_INT_PTD_BASE_ADDR_INT_BASE_SHIFT  (10U)
N#define USBHSH_INT_PTD_BASE_ADDR_INT_BASE(x)     (((uint32_t)(((uint32_t)(x)) << USBHSH_INT_PTD_BASE_ADDR_INT_BASE_SHIFT)) & USBHSH_INT_PTD_BASE_ADDR_INT_BASE_MASK)
N
N/*! @name DATA_PAYLOAD_BASE_ADDR - Memory base address that indicates the start of the data payload buffers */
N#define USBHSH_DATA_PAYLOAD_BASE_ADDR_DAT_BASE_MASK (0xFFFF0000U)
N#define USBHSH_DATA_PAYLOAD_BASE_ADDR_DAT_BASE_SHIFT (16U)
N#define USBHSH_DATA_PAYLOAD_BASE_ADDR_DAT_BASE(x) (((uint32_t)(((uint32_t)(x)) << USBHSH_DATA_PAYLOAD_BASE_ADDR_DAT_BASE_SHIFT)) & USBHSH_DATA_PAYLOAD_BASE_ADDR_DAT_BASE_MASK)
N
N/*! @name USBCMD - USB Command register */
N#define USBHSH_USBCMD_RS_MASK                    (0x1U)
N#define USBHSH_USBCMD_RS_SHIFT                   (0U)
N#define USBHSH_USBCMD_RS(x)                      (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_RS_SHIFT)) & USBHSH_USBCMD_RS_MASK)
N#define USBHSH_USBCMD_HCRESET_MASK               (0x2U)
N#define USBHSH_USBCMD_HCRESET_SHIFT              (1U)
N#define USBHSH_USBCMD_HCRESET(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_HCRESET_SHIFT)) & USBHSH_USBCMD_HCRESET_MASK)
N#define USBHSH_USBCMD_FLS_MASK                   (0xCU)
N#define USBHSH_USBCMD_FLS_SHIFT                  (2U)
N#define USBHSH_USBCMD_FLS(x)                     (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_FLS_SHIFT)) & USBHSH_USBCMD_FLS_MASK)
N#define USBHSH_USBCMD_LHCR_MASK                  (0x80U)
N#define USBHSH_USBCMD_LHCR_SHIFT                 (7U)
N#define USBHSH_USBCMD_LHCR(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_LHCR_SHIFT)) & USBHSH_USBCMD_LHCR_MASK)
N#define USBHSH_USBCMD_ATL_EN_MASK                (0x100U)
N#define USBHSH_USBCMD_ATL_EN_SHIFT               (8U)
N#define USBHSH_USBCMD_ATL_EN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_ATL_EN_SHIFT)) & USBHSH_USBCMD_ATL_EN_MASK)
N#define USBHSH_USBCMD_ISO_EN_MASK                (0x200U)
N#define USBHSH_USBCMD_ISO_EN_SHIFT               (9U)
N#define USBHSH_USBCMD_ISO_EN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_ISO_EN_SHIFT)) & USBHSH_USBCMD_ISO_EN_MASK)
N#define USBHSH_USBCMD_INT_EN_MASK                (0x400U)
N#define USBHSH_USBCMD_INT_EN_SHIFT               (10U)
N#define USBHSH_USBCMD_INT_EN(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_INT_EN_SHIFT)) & USBHSH_USBCMD_INT_EN_MASK)
N#define USBHSH_USBCMD_HIRD_MASK                  (0xF000000U)
N#define USBHSH_USBCMD_HIRD_SHIFT                 (24U)
N#define USBHSH_USBCMD_HIRD(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_HIRD_SHIFT)) & USBHSH_USBCMD_HIRD_MASK)
N#define USBHSH_USBCMD_LPM_RWU_MASK               (0x10000000U)
N#define USBHSH_USBCMD_LPM_RWU_SHIFT              (28U)
N#define USBHSH_USBCMD_LPM_RWU(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_USBCMD_LPM_RWU_SHIFT)) & USBHSH_USBCMD_LPM_RWU_MASK)
N
N/*! @name USBSTS - USB Interrupt Status register */
N#define USBHSH_USBSTS_PCD_MASK                   (0x4U)
N#define USBHSH_USBSTS_PCD_SHIFT                  (2U)
N#define USBHSH_USBSTS_PCD(x)                     (((uint32_t)(((uint32_t)(x)) << USBHSH_USBSTS_PCD_SHIFT)) & USBHSH_USBSTS_PCD_MASK)
N#define USBHSH_USBSTS_FLR_MASK                   (0x8U)
N#define USBHSH_USBSTS_FLR_SHIFT                  (3U)
N#define USBHSH_USBSTS_FLR(x)                     (((uint32_t)(((uint32_t)(x)) << USBHSH_USBSTS_FLR_SHIFT)) & USBHSH_USBSTS_FLR_MASK)
N#define USBHSH_USBSTS_ATL_IRQ_MASK               (0x10000U)
N#define USBHSH_USBSTS_ATL_IRQ_SHIFT              (16U)
N#define USBHSH_USBSTS_ATL_IRQ(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_USBSTS_ATL_IRQ_SHIFT)) & USBHSH_USBSTS_ATL_IRQ_MASK)
N#define USBHSH_USBSTS_ISO_IRQ_MASK               (0x20000U)
N#define USBHSH_USBSTS_ISO_IRQ_SHIFT              (17U)
N#define USBHSH_USBSTS_ISO_IRQ(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_USBSTS_ISO_IRQ_SHIFT)) & USBHSH_USBSTS_ISO_IRQ_MASK)
N#define USBHSH_USBSTS_INT_IRQ_MASK               (0x40000U)
N#define USBHSH_USBSTS_INT_IRQ_SHIFT              (18U)
N#define USBHSH_USBSTS_INT_IRQ(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_USBSTS_INT_IRQ_SHIFT)) & USBHSH_USBSTS_INT_IRQ_MASK)
N#define USBHSH_USBSTS_SOF_IRQ_MASK               (0x80000U)
N#define USBHSH_USBSTS_SOF_IRQ_SHIFT              (19U)
N#define USBHSH_USBSTS_SOF_IRQ(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_USBSTS_SOF_IRQ_SHIFT)) & USBHSH_USBSTS_SOF_IRQ_MASK)
N
N/*! @name USBINTR - USB Interrupt Enable register */
N#define USBHSH_USBINTR_PCDE_MASK                 (0x4U)
N#define USBHSH_USBINTR_PCDE_SHIFT                (2U)
N#define USBHSH_USBINTR_PCDE(x)                   (((uint32_t)(((uint32_t)(x)) << USBHSH_USBINTR_PCDE_SHIFT)) & USBHSH_USBINTR_PCDE_MASK)
N#define USBHSH_USBINTR_FLRE_MASK                 (0x8U)
N#define USBHSH_USBINTR_FLRE_SHIFT                (3U)
N#define USBHSH_USBINTR_FLRE(x)                   (((uint32_t)(((uint32_t)(x)) << USBHSH_USBINTR_FLRE_SHIFT)) & USBHSH_USBINTR_FLRE_MASK)
N#define USBHSH_USBINTR_ATL_IRQ_E_MASK            (0x10000U)
N#define USBHSH_USBINTR_ATL_IRQ_E_SHIFT           (16U)
N#define USBHSH_USBINTR_ATL_IRQ_E(x)              (((uint32_t)(((uint32_t)(x)) << USBHSH_USBINTR_ATL_IRQ_E_SHIFT)) & USBHSH_USBINTR_ATL_IRQ_E_MASK)
N#define USBHSH_USBINTR_ISO_IRQ_E_MASK            (0x20000U)
N#define USBHSH_USBINTR_ISO_IRQ_E_SHIFT           (17U)
N#define USBHSH_USBINTR_ISO_IRQ_E(x)              (((uint32_t)(((uint32_t)(x)) << USBHSH_USBINTR_ISO_IRQ_E_SHIFT)) & USBHSH_USBINTR_ISO_IRQ_E_MASK)
N#define USBHSH_USBINTR_INT_IRQ_E_MASK            (0x40000U)
N#define USBHSH_USBINTR_INT_IRQ_E_SHIFT           (18U)
N#define USBHSH_USBINTR_INT_IRQ_E(x)              (((uint32_t)(((uint32_t)(x)) << USBHSH_USBINTR_INT_IRQ_E_SHIFT)) & USBHSH_USBINTR_INT_IRQ_E_MASK)
N#define USBHSH_USBINTR_SOF_E_MASK                (0x80000U)
N#define USBHSH_USBINTR_SOF_E_SHIFT               (19U)
N#define USBHSH_USBINTR_SOF_E(x)                  (((uint32_t)(((uint32_t)(x)) << USBHSH_USBINTR_SOF_E_SHIFT)) & USBHSH_USBINTR_SOF_E_MASK)
N
N/*! @name PORTSC1 - Port Status and Control register */
N#define USBHSH_PORTSC1_CCS_MASK                  (0x1U)
N#define USBHSH_PORTSC1_CCS_SHIFT                 (0U)
N#define USBHSH_PORTSC1_CCS(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_CCS_SHIFT)) & USBHSH_PORTSC1_CCS_MASK)
N#define USBHSH_PORTSC1_CSC_MASK                  (0x2U)
N#define USBHSH_PORTSC1_CSC_SHIFT                 (1U)
N#define USBHSH_PORTSC1_CSC(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_CSC_SHIFT)) & USBHSH_PORTSC1_CSC_MASK)
N#define USBHSH_PORTSC1_PED_MASK                  (0x4U)
N#define USBHSH_PORTSC1_PED_SHIFT                 (2U)
N#define USBHSH_PORTSC1_PED(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PED_SHIFT)) & USBHSH_PORTSC1_PED_MASK)
N#define USBHSH_PORTSC1_PEDC_MASK                 (0x8U)
N#define USBHSH_PORTSC1_PEDC_SHIFT                (3U)
N#define USBHSH_PORTSC1_PEDC(x)                   (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PEDC_SHIFT)) & USBHSH_PORTSC1_PEDC_MASK)
N#define USBHSH_PORTSC1_OCA_MASK                  (0x10U)
N#define USBHSH_PORTSC1_OCA_SHIFT                 (4U)
N#define USBHSH_PORTSC1_OCA(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_OCA_SHIFT)) & USBHSH_PORTSC1_OCA_MASK)
N#define USBHSH_PORTSC1_OCC_MASK                  (0x20U)
N#define USBHSH_PORTSC1_OCC_SHIFT                 (5U)
N#define USBHSH_PORTSC1_OCC(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_OCC_SHIFT)) & USBHSH_PORTSC1_OCC_MASK)
N#define USBHSH_PORTSC1_FPR_MASK                  (0x40U)
N#define USBHSH_PORTSC1_FPR_SHIFT                 (6U)
N#define USBHSH_PORTSC1_FPR(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_FPR_SHIFT)) & USBHSH_PORTSC1_FPR_MASK)
N#define USBHSH_PORTSC1_SUSP_MASK                 (0x80U)
N#define USBHSH_PORTSC1_SUSP_SHIFT                (7U)
N#define USBHSH_PORTSC1_SUSP(x)                   (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_SUSP_SHIFT)) & USBHSH_PORTSC1_SUSP_MASK)
N#define USBHSH_PORTSC1_PR_MASK                   (0x100U)
N#define USBHSH_PORTSC1_PR_SHIFT                  (8U)
N#define USBHSH_PORTSC1_PR(x)                     (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PR_SHIFT)) & USBHSH_PORTSC1_PR_MASK)
N#define USBHSH_PORTSC1_SUS_L1_MASK               (0x200U)
N#define USBHSH_PORTSC1_SUS_L1_SHIFT              (9U)
N#define USBHSH_PORTSC1_SUS_L1(x)                 (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_SUS_L1_SHIFT)) & USBHSH_PORTSC1_SUS_L1_MASK)
N#define USBHSH_PORTSC1_LS_MASK                   (0xC00U)
N#define USBHSH_PORTSC1_LS_SHIFT                  (10U)
N#define USBHSH_PORTSC1_LS(x)                     (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_LS_SHIFT)) & USBHSH_PORTSC1_LS_MASK)
N#define USBHSH_PORTSC1_PP_MASK                   (0x1000U)
N#define USBHSH_PORTSC1_PP_SHIFT                  (12U)
N#define USBHSH_PORTSC1_PP(x)                     (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PP_SHIFT)) & USBHSH_PORTSC1_PP_MASK)
N#define USBHSH_PORTSC1_PIC_MASK                  (0xC000U)
N#define USBHSH_PORTSC1_PIC_SHIFT                 (14U)
N#define USBHSH_PORTSC1_PIC(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PIC_SHIFT)) & USBHSH_PORTSC1_PIC_MASK)
N#define USBHSH_PORTSC1_PTC_MASK                  (0xF0000U)
N#define USBHSH_PORTSC1_PTC_SHIFT                 (16U)
N#define USBHSH_PORTSC1_PTC(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PTC_SHIFT)) & USBHSH_PORTSC1_PTC_MASK)
N#define USBHSH_PORTSC1_PSPD_MASK                 (0x300000U)
N#define USBHSH_PORTSC1_PSPD_SHIFT                (20U)
N#define USBHSH_PORTSC1_PSPD(x)                   (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_PSPD_SHIFT)) & USBHSH_PORTSC1_PSPD_MASK)
N#define USBHSH_PORTSC1_WOO_MASK                  (0x400000U)
N#define USBHSH_PORTSC1_WOO_SHIFT                 (22U)
N#define USBHSH_PORTSC1_WOO(x)                    (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_WOO_SHIFT)) & USBHSH_PORTSC1_WOO_MASK)
N#define USBHSH_PORTSC1_SUS_STAT_MASK             (0x1800000U)
N#define USBHSH_PORTSC1_SUS_STAT_SHIFT            (23U)
N#define USBHSH_PORTSC1_SUS_STAT(x)               (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_SUS_STAT_SHIFT)) & USBHSH_PORTSC1_SUS_STAT_MASK)
N#define USBHSH_PORTSC1_DEV_ADD_MASK              (0xFE000000U)
N#define USBHSH_PORTSC1_DEV_ADD_SHIFT             (25U)
N#define USBHSH_PORTSC1_DEV_ADD(x)                (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTSC1_DEV_ADD_SHIFT)) & USBHSH_PORTSC1_DEV_ADD_MASK)
N
N/*! @name ATL_PTD_DONE_MAP - Done map for each ATL PTD */
N#define USBHSH_ATL_PTD_DONE_MAP_ATL_DONE_MASK    (0xFFFFFFFFU)
N#define USBHSH_ATL_PTD_DONE_MAP_ATL_DONE_SHIFT   (0U)
N#define USBHSH_ATL_PTD_DONE_MAP_ATL_DONE(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_ATL_PTD_DONE_MAP_ATL_DONE_SHIFT)) & USBHSH_ATL_PTD_DONE_MAP_ATL_DONE_MASK)
N
N/*! @name ATL_PTD_SKIP_MAP - Skip map for each ATL PTD */
N#define USBHSH_ATL_PTD_SKIP_MAP_ATL_SKIP_MASK    (0xFFFFFFFFU)
N#define USBHSH_ATL_PTD_SKIP_MAP_ATL_SKIP_SHIFT   (0U)
N#define USBHSH_ATL_PTD_SKIP_MAP_ATL_SKIP(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_ATL_PTD_SKIP_MAP_ATL_SKIP_SHIFT)) & USBHSH_ATL_PTD_SKIP_MAP_ATL_SKIP_MASK)
N
N/*! @name ISO_PTD_DONE_MAP - Done map for each ISO PTD */
N#define USBHSH_ISO_PTD_DONE_MAP_ISO_DONE_MASK    (0xFFFFFFFFU)
N#define USBHSH_ISO_PTD_DONE_MAP_ISO_DONE_SHIFT   (0U)
N#define USBHSH_ISO_PTD_DONE_MAP_ISO_DONE(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_ISO_PTD_DONE_MAP_ISO_DONE_SHIFT)) & USBHSH_ISO_PTD_DONE_MAP_ISO_DONE_MASK)
N
N/*! @name ISO_PTD_SKIP_MAP - Skip map for each ISO PTD */
N#define USBHSH_ISO_PTD_SKIP_MAP_ISO_SKIP_MASK    (0xFFFFFFFFU)
N#define USBHSH_ISO_PTD_SKIP_MAP_ISO_SKIP_SHIFT   (0U)
N#define USBHSH_ISO_PTD_SKIP_MAP_ISO_SKIP(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_ISO_PTD_SKIP_MAP_ISO_SKIP_SHIFT)) & USBHSH_ISO_PTD_SKIP_MAP_ISO_SKIP_MASK)
N
N/*! @name INT_PTD_DONE_MAP - Done map for each INT PTD */
N#define USBHSH_INT_PTD_DONE_MAP_INT_DONE_MASK    (0xFFFFFFFFU)
N#define USBHSH_INT_PTD_DONE_MAP_INT_DONE_SHIFT   (0U)
N#define USBHSH_INT_PTD_DONE_MAP_INT_DONE(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_INT_PTD_DONE_MAP_INT_DONE_SHIFT)) & USBHSH_INT_PTD_DONE_MAP_INT_DONE_MASK)
N
N/*! @name INT_PTD_SKIP_MAP - Skip map for each INT PTD */
N#define USBHSH_INT_PTD_SKIP_MAP_INT_SKIP_MASK    (0xFFFFFFFFU)
N#define USBHSH_INT_PTD_SKIP_MAP_INT_SKIP_SHIFT   (0U)
N#define USBHSH_INT_PTD_SKIP_MAP_INT_SKIP(x)      (((uint32_t)(((uint32_t)(x)) << USBHSH_INT_PTD_SKIP_MAP_INT_SKIP_SHIFT)) & USBHSH_INT_PTD_SKIP_MAP_INT_SKIP_MASK)
N
N/*! @name LAST_PTD_INUSE - Marks the last PTD in the list for ISO, INT and ATL */
N#define USBHSH_LAST_PTD_INUSE_ATL_LAST_MASK      (0x1FU)
N#define USBHSH_LAST_PTD_INUSE_ATL_LAST_SHIFT     (0U)
N#define USBHSH_LAST_PTD_INUSE_ATL_LAST(x)        (((uint32_t)(((uint32_t)(x)) << USBHSH_LAST_PTD_INUSE_ATL_LAST_SHIFT)) & USBHSH_LAST_PTD_INUSE_ATL_LAST_MASK)
N#define USBHSH_LAST_PTD_INUSE_ISO_LAST_MASK      (0x1F00U)
N#define USBHSH_LAST_PTD_INUSE_ISO_LAST_SHIFT     (8U)
N#define USBHSH_LAST_PTD_INUSE_ISO_LAST(x)        (((uint32_t)(((uint32_t)(x)) << USBHSH_LAST_PTD_INUSE_ISO_LAST_SHIFT)) & USBHSH_LAST_PTD_INUSE_ISO_LAST_MASK)
N#define USBHSH_LAST_PTD_INUSE_INT_LAST_MASK      (0x1F0000U)
N#define USBHSH_LAST_PTD_INUSE_INT_LAST_SHIFT     (16U)
N#define USBHSH_LAST_PTD_INUSE_INT_LAST(x)        (((uint32_t)(((uint32_t)(x)) << USBHSH_LAST_PTD_INUSE_INT_LAST_SHIFT)) & USBHSH_LAST_PTD_INUSE_INT_LAST_MASK)
N
N/*! @name UTMIPLUS_ULPI_DEBUG - Register to read/write registers in the attached USB PHY */
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ADDR_MASK (0xFFU)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ADDR_SHIFT (0U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ADDR(x)   (((uint32_t)(((uint32_t)(x)) << USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ADDR_SHIFT)) & USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ADDR_MASK)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_WDATA_MASK (0xFF00U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_WDATA_SHIFT (8U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_WDATA(x)  (((uint32_t)(((uint32_t)(x)) << USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_WDATA_SHIFT)) & USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_WDATA_MASK)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RDATA_MASK (0xFF0000U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RDATA_SHIFT (16U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RDATA(x)  (((uint32_t)(((uint32_t)(x)) << USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RDATA_SHIFT)) & USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RDATA_MASK)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RW_MASK   (0x1000000U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RW_SHIFT  (24U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RW(x)     (((uint32_t)(((uint32_t)(x)) << USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RW_SHIFT)) & USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_RW_MASK)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ACCESS_MASK (0x2000000U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ACCESS_SHIFT (25U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ACCESS(x) (((uint32_t)(((uint32_t)(x)) << USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ACCESS_SHIFT)) & USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_ACCESS_MASK)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_MODE_MASK (0x80000000U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_MODE_SHIFT (31U)
N#define USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_MODE(x)   (((uint32_t)(((uint32_t)(x)) << USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_MODE_SHIFT)) & USBHSH_UTMIPLUS_ULPI_DEBUG_PHY_MODE_MASK)
N
N/*! @name PORTMODE - Controls the port if it is attached to the host block or the device block */
N#define USBHSH_PORTMODE_ID0_MASK                 (0x1U)
N#define USBHSH_PORTMODE_ID0_SHIFT                (0U)
N#define USBHSH_PORTMODE_ID0(x)                   (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTMODE_ID0_SHIFT)) & USBHSH_PORTMODE_ID0_MASK)
N#define USBHSH_PORTMODE_ID0_EN_MASK              (0x100U)
N#define USBHSH_PORTMODE_ID0_EN_SHIFT             (8U)
N#define USBHSH_PORTMODE_ID0_EN(x)                (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTMODE_ID0_EN_SHIFT)) & USBHSH_PORTMODE_ID0_EN_MASK)
N#define USBHSH_PORTMODE_DEV_ENABLE_MASK          (0x10000U)
N#define USBHSH_PORTMODE_DEV_ENABLE_SHIFT         (16U)
N#define USBHSH_PORTMODE_DEV_ENABLE(x)            (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTMODE_DEV_ENABLE_SHIFT)) & USBHSH_PORTMODE_DEV_ENABLE_MASK)
N#define USBHSH_PORTMODE_SW_CTRL_PDCOM_MASK       (0x40000U)
N#define USBHSH_PORTMODE_SW_CTRL_PDCOM_SHIFT      (18U)
N#define USBHSH_PORTMODE_SW_CTRL_PDCOM(x)         (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTMODE_SW_CTRL_PDCOM_SHIFT)) & USBHSH_PORTMODE_SW_CTRL_PDCOM_MASK)
N#define USBHSH_PORTMODE_SW_PDCOM_MASK            (0x80000U)
N#define USBHSH_PORTMODE_SW_PDCOM_SHIFT           (19U)
N#define USBHSH_PORTMODE_SW_PDCOM(x)              (((uint32_t)(((uint32_t)(x)) << USBHSH_PORTMODE_SW_PDCOM_SHIFT)) & USBHSH_PORTMODE_SW_PDCOM_MASK)
N
N
N/*!
N * @}
N */ /* end of group USBHSH_Register_Masks */
N
N
N/* USBHSH - Peripheral instance base addresses */
N/** Peripheral USBHSH base address */
N#define USBHSH_BASE                              (0x400A3000u)
N/** Peripheral USBHSH base pointer */
N#define USBHSH                                   ((USBHSH_Type *)USBHSH_BASE)
N/** Array initializer of USBHSH peripheral base addresses */
N#define USBHSH_BASE_ADDRS                        { USBHSH_BASE }
N/** Array initializer of USBHSH peripheral base pointers */
N#define USBHSH_BASE_PTRS                         { USBHSH }
N/** Interrupt vectors for the USBHSH peripheral type */
N#define USBHSH_IRQS                              { USB1_IRQn }
N#define USBHSH_NEEDCLK_IRQS                      { USB1_NEEDCLK_IRQn }
N
N/*!
N * @}
N */ /* end of group USBHSH_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- UTICK Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup UTICK_Peripheral_Access_Layer UTICK Peripheral Access Layer
N * @{
N */
N
N/** UTICK - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< Control register., offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t STAT;                              /**< Status register., offset: 0x4 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t CFG;                               /**< Capture configuration register., offset: 0x8 */
X  volatile uint32_t CFG;                                
N  __O  uint32_t CAPCLR;                            /**< Capture clear register., offset: 0xC */
X  volatile  uint32_t CAPCLR;                             
N  __I  uint32_t CAP[4];                            /**< Capture register ., array offset: 0x10, array step: 0x4 */
X  volatile const  uint32_t CAP[4];                             
N} UTICK_Type;
N
N/* ----------------------------------------------------------------------------
N   -- UTICK Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup UTICK_Register_Masks UTICK Register Masks
N * @{
N */
N
N/*! @name CTRL - Control register. */
N#define UTICK_CTRL_DELAYVAL_MASK                 (0x7FFFFFFFU)
N#define UTICK_CTRL_DELAYVAL_SHIFT                (0U)
N#define UTICK_CTRL_DELAYVAL(x)                   (((uint32_t)(((uint32_t)(x)) << UTICK_CTRL_DELAYVAL_SHIFT)) & UTICK_CTRL_DELAYVAL_MASK)
N#define UTICK_CTRL_REPEAT_MASK                   (0x80000000U)
N#define UTICK_CTRL_REPEAT_SHIFT                  (31U)
N#define UTICK_CTRL_REPEAT(x)                     (((uint32_t)(((uint32_t)(x)) << UTICK_CTRL_REPEAT_SHIFT)) & UTICK_CTRL_REPEAT_MASK)
N
N/*! @name STAT - Status register. */
N#define UTICK_STAT_INTR_MASK                     (0x1U)
N#define UTICK_STAT_INTR_SHIFT                    (0U)
N#define UTICK_STAT_INTR(x)                       (((uint32_t)(((uint32_t)(x)) << UTICK_STAT_INTR_SHIFT)) & UTICK_STAT_INTR_MASK)
N#define UTICK_STAT_ACTIVE_MASK                   (0x2U)
N#define UTICK_STAT_ACTIVE_SHIFT                  (1U)
N#define UTICK_STAT_ACTIVE(x)                     (((uint32_t)(((uint32_t)(x)) << UTICK_STAT_ACTIVE_SHIFT)) & UTICK_STAT_ACTIVE_MASK)
N
N/*! @name CFG - Capture configuration register. */
N#define UTICK_CFG_CAPEN0_MASK                    (0x1U)
N#define UTICK_CFG_CAPEN0_SHIFT                   (0U)
N#define UTICK_CFG_CAPEN0(x)                      (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPEN0_SHIFT)) & UTICK_CFG_CAPEN0_MASK)
N#define UTICK_CFG_CAPEN1_MASK                    (0x2U)
N#define UTICK_CFG_CAPEN1_SHIFT                   (1U)
N#define UTICK_CFG_CAPEN1(x)                      (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPEN1_SHIFT)) & UTICK_CFG_CAPEN1_MASK)
N#define UTICK_CFG_CAPEN2_MASK                    (0x4U)
N#define UTICK_CFG_CAPEN2_SHIFT                   (2U)
N#define UTICK_CFG_CAPEN2(x)                      (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPEN2_SHIFT)) & UTICK_CFG_CAPEN2_MASK)
N#define UTICK_CFG_CAPEN3_MASK                    (0x8U)
N#define UTICK_CFG_CAPEN3_SHIFT                   (3U)
N#define UTICK_CFG_CAPEN3(x)                      (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPEN3_SHIFT)) & UTICK_CFG_CAPEN3_MASK)
N#define UTICK_CFG_CAPPOL0_MASK                   (0x100U)
N#define UTICK_CFG_CAPPOL0_SHIFT                  (8U)
N#define UTICK_CFG_CAPPOL0(x)                     (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPPOL0_SHIFT)) & UTICK_CFG_CAPPOL0_MASK)
N#define UTICK_CFG_CAPPOL1_MASK                   (0x200U)
N#define UTICK_CFG_CAPPOL1_SHIFT                  (9U)
N#define UTICK_CFG_CAPPOL1(x)                     (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPPOL1_SHIFT)) & UTICK_CFG_CAPPOL1_MASK)
N#define UTICK_CFG_CAPPOL2_MASK                   (0x400U)
N#define UTICK_CFG_CAPPOL2_SHIFT                  (10U)
N#define UTICK_CFG_CAPPOL2(x)                     (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPPOL2_SHIFT)) & UTICK_CFG_CAPPOL2_MASK)
N#define UTICK_CFG_CAPPOL3_MASK                   (0x800U)
N#define UTICK_CFG_CAPPOL3_SHIFT                  (11U)
N#define UTICK_CFG_CAPPOL3(x)                     (((uint32_t)(((uint32_t)(x)) << UTICK_CFG_CAPPOL3_SHIFT)) & UTICK_CFG_CAPPOL3_MASK)
N
N/*! @name CAPCLR - Capture clear register. */
N#define UTICK_CAPCLR_CAPCLR0_MASK                (0x1U)
N#define UTICK_CAPCLR_CAPCLR0_SHIFT               (0U)
N#define UTICK_CAPCLR_CAPCLR0(x)                  (((uint32_t)(((uint32_t)(x)) << UTICK_CAPCLR_CAPCLR0_SHIFT)) & UTICK_CAPCLR_CAPCLR0_MASK)
N#define UTICK_CAPCLR_CAPCLR1_MASK                (0x2U)
N#define UTICK_CAPCLR_CAPCLR1_SHIFT               (1U)
N#define UTICK_CAPCLR_CAPCLR1(x)                  (((uint32_t)(((uint32_t)(x)) << UTICK_CAPCLR_CAPCLR1_SHIFT)) & UTICK_CAPCLR_CAPCLR1_MASK)
N#define UTICK_CAPCLR_CAPCLR2_MASK                (0x4U)
N#define UTICK_CAPCLR_CAPCLR2_SHIFT               (2U)
N#define UTICK_CAPCLR_CAPCLR2(x)                  (((uint32_t)(((uint32_t)(x)) << UTICK_CAPCLR_CAPCLR2_SHIFT)) & UTICK_CAPCLR_CAPCLR2_MASK)
N#define UTICK_CAPCLR_CAPCLR3_MASK                (0x8U)
N#define UTICK_CAPCLR_CAPCLR3_SHIFT               (3U)
N#define UTICK_CAPCLR_CAPCLR3(x)                  (((uint32_t)(((uint32_t)(x)) << UTICK_CAPCLR_CAPCLR3_SHIFT)) & UTICK_CAPCLR_CAPCLR3_MASK)
N
N/*! @name CAP - Capture register . */
N#define UTICK_CAP_CAP_VALUE_MASK                 (0x7FFFFFFFU)
N#define UTICK_CAP_CAP_VALUE_SHIFT                (0U)
N#define UTICK_CAP_CAP_VALUE(x)                   (((uint32_t)(((uint32_t)(x)) << UTICK_CAP_CAP_VALUE_SHIFT)) & UTICK_CAP_CAP_VALUE_MASK)
N#define UTICK_CAP_VALID_MASK                     (0x80000000U)
N#define UTICK_CAP_VALID_SHIFT                    (31U)
N#define UTICK_CAP_VALID(x)                       (((uint32_t)(((uint32_t)(x)) << UTICK_CAP_VALID_SHIFT)) & UTICK_CAP_VALID_MASK)
N
N/* The count of UTICK_CAP */
N#define UTICK_CAP_COUNT                          (4U)
N
N
N/*!
N * @}
N */ /* end of group UTICK_Register_Masks */
N
N
N/* UTICK - Peripheral instance base addresses */
N/** Peripheral UTICK0 base address */
N#define UTICK0_BASE                              (0x4000E000u)
N/** Peripheral UTICK0 base pointer */
N#define UTICK0                                   ((UTICK_Type *)UTICK0_BASE)
N/** Array initializer of UTICK peripheral base addresses */
N#define UTICK_BASE_ADDRS                         { UTICK0_BASE }
N/** Array initializer of UTICK peripheral base pointers */
N#define UTICK_BASE_PTRS                          { UTICK0 }
N/** Interrupt vectors for the UTICK peripheral type */
N#define UTICK_IRQS                               { UTICK0_IRQn }
N
N/*!
N * @}
N */ /* end of group UTICK_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- WWDT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup WWDT_Peripheral_Access_Layer WWDT Peripheral Access Layer
N * @{
N */
N
N/** WWDT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t MOD;                               /**< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer., offset: 0x0 */
X  volatile uint32_t MOD;                                
N  __IO uint32_t TC;                                /**< Watchdog timer constant register. This 24-bit register determines the time-out value., offset: 0x4 */
X  volatile uint32_t TC;                                 
N  __O  uint32_t FEED;                              /**< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in TC., offset: 0x8 */
X  volatile  uint32_t FEED;                               
N  __I  uint32_t TV;                                /**< Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer., offset: 0xC */
X  volatile const  uint32_t TV;                                 
N       uint8_t RESERVED_0[4];
N  __IO uint32_t WARNINT;                           /**< Watchdog Warning Interrupt compare value., offset: 0x14 */
X  volatile uint32_t WARNINT;                            
N  __IO uint32_t WINDOW;                            /**< Watchdog Window compare value., offset: 0x18 */
X  volatile uint32_t WINDOW;                             
N} WWDT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- WWDT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup WWDT_Register_Masks WWDT Register Masks
N * @{
N */
N
N/*! @name MOD - Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
N#define WWDT_MOD_WDEN_MASK                       (0x1U)
N#define WWDT_MOD_WDEN_SHIFT                      (0U)
N#define WWDT_MOD_WDEN(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDEN_SHIFT)) & WWDT_MOD_WDEN_MASK)
N#define WWDT_MOD_WDRESET_MASK                    (0x2U)
N#define WWDT_MOD_WDRESET_SHIFT                   (1U)
N#define WWDT_MOD_WDRESET(x)                      (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDRESET_SHIFT)) & WWDT_MOD_WDRESET_MASK)
N#define WWDT_MOD_WDTOF_MASK                      (0x4U)
N#define WWDT_MOD_WDTOF_SHIFT                     (2U)
N#define WWDT_MOD_WDTOF(x)                        (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDTOF_SHIFT)) & WWDT_MOD_WDTOF_MASK)
N#define WWDT_MOD_WDINT_MASK                      (0x8U)
N#define WWDT_MOD_WDINT_SHIFT                     (3U)
N#define WWDT_MOD_WDINT(x)                        (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDINT_SHIFT)) & WWDT_MOD_WDINT_MASK)
N#define WWDT_MOD_WDPROTECT_MASK                  (0x10U)
N#define WWDT_MOD_WDPROTECT_SHIFT                 (4U)
N#define WWDT_MOD_WDPROTECT(x)                    (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDPROTECT_SHIFT)) & WWDT_MOD_WDPROTECT_MASK)
N#define WWDT_MOD_LOCK_MASK                       (0x20U)
N#define WWDT_MOD_LOCK_SHIFT                      (5U)
N#define WWDT_MOD_LOCK(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_LOCK_SHIFT)) & WWDT_MOD_LOCK_MASK)
N
N/*! @name TC - Watchdog timer constant register. This 24-bit register determines the time-out value. */
N#define WWDT_TC_COUNT_MASK                       (0xFFFFFFU)
N#define WWDT_TC_COUNT_SHIFT                      (0U)
N#define WWDT_TC_COUNT(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_TC_COUNT_SHIFT)) & WWDT_TC_COUNT_MASK)
N
N/*! @name FEED - Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in TC. */
N#define WWDT_FEED_FEED_MASK                      (0xFFU)
N#define WWDT_FEED_FEED_SHIFT                     (0U)
N#define WWDT_FEED_FEED(x)                        (((uint32_t)(((uint32_t)(x)) << WWDT_FEED_FEED_SHIFT)) & WWDT_FEED_FEED_MASK)
N
N/*! @name TV - Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer. */
N#define WWDT_TV_COUNT_MASK                       (0xFFFFFFU)
N#define WWDT_TV_COUNT_SHIFT                      (0U)
N#define WWDT_TV_COUNT(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_TV_COUNT_SHIFT)) & WWDT_TV_COUNT_MASK)
N
N/*! @name WARNINT - Watchdog Warning Interrupt compare value. */
N#define WWDT_WARNINT_WARNINT_MASK                (0x3FFU)
N#define WWDT_WARNINT_WARNINT_SHIFT               (0U)
N#define WWDT_WARNINT_WARNINT(x)                  (((uint32_t)(((uint32_t)(x)) << WWDT_WARNINT_WARNINT_SHIFT)) & WWDT_WARNINT_WARNINT_MASK)
N
N/*! @name WINDOW - Watchdog Window compare value. */
N#define WWDT_WINDOW_WINDOW_MASK                  (0xFFFFFFU)
N#define WWDT_WINDOW_WINDOW_SHIFT                 (0U)
N#define WWDT_WINDOW_WINDOW(x)                    (((uint32_t)(((uint32_t)(x)) << WWDT_WINDOW_WINDOW_SHIFT)) & WWDT_WINDOW_WINDOW_MASK)
N
N
N/*!
N * @}
N */ /* end of group WWDT_Register_Masks */
N
N
N/* WWDT - Peripheral instance base addresses */
N/** Peripheral WWDT base address */
N#define WWDT_BASE                                (0x4000C000u)
N/** Peripheral WWDT base pointer */
N#define WWDT                                     ((WWDT_Type *)WWDT_BASE)
N/** Array initializer of WWDT peripheral base addresses */
N#define WWDT_BASE_ADDRS                          { WWDT_BASE }
N/** Array initializer of WWDT peripheral base pointers */
N#define WWDT_BASE_PTRS                           { WWDT }
N/** Interrupt vectors for the WWDT peripheral type */
N#define WWDT_IRQS                                { WDT_BOD_IRQn }
N
N/*!
N * @}
N */ /* end of group WWDT_Peripheral_Access_Layer */
N
N
N/*
N** End of section using anonymous unions
N*/
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #pragma pop
N#elif defined(__GNUC__)
S  /* leave anonymous unions enabled */
S#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma language=default
S#else
S  #error Not supported compiler type
N#endif
N
N/*!
N * @}
N */ /* end of group Peripheral_access_layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- Macros for use with bit field definitions (xxx_SHIFT, xxx_MASK).
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Bit_Field_Generic_Macros Macros for use with bit field definitions (xxx_SHIFT, xxx_MASK).
N * @{
N */
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #if (__ARMCC_VERSION >= 6010050)
X  #if (5060422 >= 6010050)
S    #pragma clang system_header
N  #endif
N#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma system_include
N#endif
N
N/**
N * @brief Mask and left-shift a bit field value for use in a register bit range.
N * @param field Name of the register bit field.
N * @param value Value of the bit field.
N * @return Masked and shifted value.
N */
N#define NXP_VAL2FLD(field, value)    (((value) << (field ## _SHIFT)) & (field ## _MASK))
N/**
N * @brief Mask and right-shift a register value to extract a bit field value.
N * @param field Name of the register bit field.
N * @param value Value of the register.
N * @return Masked and shifted bit field value.
N */
N#define NXP_FLD2VAL(field, value)    (((value) & (field ## _MASK)) >> (field ## _SHIFT))
N
N/*!
N * @}
N */ /* end of group Bit_Field_Generic_Macros */
N
N
N/* ----------------------------------------------------------------------------
N   -- SDK Compatibility
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SDK_Compatibility_Symbols SDK Compatibility
N * @{
N */
N
N/** EMC CS base address */
N#define EMC_CS0_BASE                                (0x80000000u)
N#define EMC_CS1_BASE                                (0x90000000u)
N#define EMC_CS2_BASE                                (0x98000000u)
N#define EMC_CS3_BASE                                (0x9C000000u)
N#define EMC_DYCS0_BASE                              (0xA0000000u)
N#define EMC_DYCS1_BASE                              (0xB0000000u)
N#define EMC_DYCS2_BASE                              (0xC0000000u)
N#define EMC_DYCS3_BASE                              (0xD0000000u)
N#define EMC_CS_ADDRESS                              {EMC_CS0_BASE, EMC_CS1_BASE, EMC_CS2_BASE, EMC_CS3_BASE}
N#define EMC_DYCS_ADDRESS                            {EMC_DYCS0_BASE, EMC_DYCS1_BASE, EMC_DYCS2_BASE, EMC_DYCS3_BASE}
N
N/** OTP API */
Ntypedef struct {
N  uint32_t (*otpInit)(void);                                    /** Initializes OTP controller */
N  uint32_t (*otpEnableBankWriteMask)(uint32_t bankMask);        /** Unlock one or more OTP banks for write access */
N  uint32_t (*otpDisableBankWriteMask)(uint32_t bankMask);       /** Lock one or more OTP banks for write access */
N  uint32_t (*otpEnableBankWriteLock)(uint32_t bankIndex, uint32_t regEnableMask, uint32_t regDisableMask,
N                                          uint32_t lockWrite);  /** Locks or unlocks write access to a register of an OTP bank and the write lock */
N  uint32_t (*otpEnableBankReadLock)(uint32_t bankIndex, uint32_t regEnableMask, uint32_t regDisableMask,
N                                         uint32_t lockWrite);   /** Locks or unlocks read access to a register of an OTP bank and the write lock */
N  uint32_t (*otpProgramReg)(uint32_t bankIndex, uint32_t regIndex, uint32_t value);  /** Program a single register in an OTP bank */
N  uint32_t RESERVED_0[5];
N  uint32_t (*rngRead)(void);                                    /** Returns 32-bit number from hardware random number generator */
N  uint32_t (*otpGetDriverVersion)(void);                        /** Returns the version of the OTP driver in ROM */
N} OTP_API_Type;
N
N/** ROM API */
Ntypedef struct {
N  __I uint32_t usbdApiBase;                      /** USB API Base */
X  volatile const uint32_t usbdApiBase;                       
N      uint32_t RESERVED_0[13];
N  __I OTP_API_Type *otpApiBase;                  /** OTP API Base */
X  volatile const OTP_API_Type *otpApiBase;                   
N  __I uint32_t aesApiBase;                       /** AES API Base */
X  volatile const uint32_t aesApiBase;                        
N  __I uint32_t secureApiBase;                    /** Secure API Base */
X  volatile const uint32_t secureApiBase;                     
N} ROM_API_Type;
N
N/** ROM API base address */
N#define ROM_API_BASE                             (0x03000200u)
N/** ROM API base pointer */
N#define ROM_API                                  (*(ROM_API_Type**) ROM_API_BASE)
N/** OTP API base pointer */
N#define OTP_API                                  (ROM_API->otpApiBase)
N
N/*!
N * @}
N */ /* end of group SDK_Compatibility_Symbols */
N
N
N#endif  /* _LPC54608_H_ */
N
L 45 ".\SRC\System\fsl_device_registers.h" 2
N/* CPU specific feature definitions */
N#include "LPC54608_features.h"
L 1 ".\SRC\System\LPC54608_features.h" 1
N/*
N** ###################################################################
N**     Version:             rev. 1.0, 2016-08-12
N**     Build:               b161018
N**
N**     Abstract:
N**         Chip specific module features.
N**
N**     Copyright (c) 2016 Freescale Semiconductor, Inc.
N**     All rights reserved.
N**
N**     Redistribution and use in source and binary forms, with or without modification,
N**     are permitted provided that the following conditions are met:
N**
N**     o Redistributions of source code must retain the above copyright notice, this list
N**       of conditions and the following disclaimer.
N**
N**     o Redistributions in binary form must reproduce the above copyright notice, this
N**       list of conditions and the following disclaimer in the documentation and/or
N**       other materials provided with the distribution.
N**
N**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N**       contributors may be used to endorse or promote products derived from this
N**       software without specific prior written permission.
N**
N**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N**
N**     http:                 www.freescale.com
N**     mail:                 support@freescale.com
N**
N**     Revisions:
N**     - rev. 1.0 (2016-08-12)
N**         Initial version.
N**
N** ###################################################################
N*/
N
N#ifndef _LPC54608_FEATURES_H_
N#define _LPC54608_FEATURES_H_
N
N/* SOC module features */
N
N/* @brief ADC availability on the SoC. */
N#define FSL_FEATURE_SOC_ADC_COUNT (1)
N/* @brief ASYNC_SYSCON availability on the SoC. */
N#define FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT (1)
N/* @brief CRC availability on the SoC. */
N#define FSL_FEATURE_SOC_CRC_COUNT (1)
N/* @brief DMA availability on the SoC. */
N#define FSL_FEATURE_SOC_DMA_COUNT (1)
N/* @brief DMIC availability on the SoC. */
N#define FSL_FEATURE_SOC_DMIC_COUNT (1)
N/* @brief FLEXCOMM availability on the SoC. */
N#define FSL_FEATURE_SOC_FLEXCOMM_COUNT (10)
N/* @brief GINT availability on the SoC. */
N#define FSL_FEATURE_SOC_GINT_COUNT (2)
N/* @brief GPIO availability on the SoC. */
N#define FSL_FEATURE_SOC_GPIO_COUNT (1)
N/* @brief I2C availability on the SoC. */
N#define FSL_FEATURE_SOC_I2C_COUNT (10)
N/* @brief I2S availability on the SoC. */
N#define FSL_FEATURE_SOC_I2S_COUNT (2)
N/* @brief INPUTMUX availability on the SoC. */
N#define FSL_FEATURE_SOC_INPUTMUX_COUNT (1)
N/* @brief IOCON availability on the SoC. */
N#define FSL_FEATURE_SOC_IOCON_COUNT (1)
N/* @brief MRT availability on the SoC. */
N#define FSL_FEATURE_SOC_MRT_COUNT (1)
N/* @brief PINT availability on the SoC. */
N#define FSL_FEATURE_SOC_PINT_COUNT (1)
N/* @brief RTC availability on the SoC. */
N#define FSL_FEATURE_SOC_RTC_COUNT (1)
N/* @brief SCT availability on the SoC. */
N#define FSL_FEATURE_SOC_SCT_COUNT (1)
N/* @brief SPI availability on the SoC. */
N#define FSL_FEATURE_SOC_SPI_COUNT (10)
N/* @brief SPIFI availability on the SoC. */
N#define FSL_FEATURE_SOC_SPIFI_COUNT (1)
N/* @brief SYSCON availability on the SoC. */
N#define FSL_FEATURE_SOC_SYSCON_COUNT (1)
N/* @brief CTIMER availability on the SoC. */
N#define FSL_FEATURE_SOC_CTIMER_COUNT (5)
N/* @brief USART availability on the SoC. */
N#define FSL_FEATURE_SOC_USART_COUNT (10)
N/* @brief USB availability on the SoC. */
N#define FSL_FEATURE_SOC_USB_COUNT (1)
N/* @brief UTICK availability on the SoC. */
N#define FSL_FEATURE_SOC_UTICK_COUNT (1)
N/* @brief WWDT availability on the SoC. */
N#define FSL_FEATURE_SOC_WWDT_COUNT (1)
N/* @brief USBFSH availability on the SoC. */
N#define FSL_FEATURE_SOC_USBFSH_COUNT (1)
N/* @brief USBHSD availability on the SoC. */
N#define FSL_FEATURE_SOC_USBHSD_COUNT (1)
N/* @brief USBHSH availability on the SoC. */
N#define FSL_FEATURE_SOC_USBHSH_COUNT (1)
N/* @brief EEPROM availability on the SoC. */
N#define FSL_FEATURE_SOC_EEPROM_COUNT (1)
N/* @brief EMC availability on the SoC. */
N#define FSL_FEATURE_SOC_EMC_COUNT (1)
N/* @brief ENET availability on the SoC. */
N#define FSL_FEATURE_SOC_LPC_ENET_COUNT (1)
N/* @brief SDIF availability on the SoC. */
N#define FSL_FEATURE_SOC_SDIF_COUNT (1)
N/* @brief SMARTCARD availability on the SoC. */
N#define FSL_FEATURE_SOC_SMARTCARD_COUNT (2)
N/* @brief LCD availability on the SoC. */
N#define FSL_FEATURE_SOC_LCD_COUNT (1)
N/* @brief CAN availability on the SoC. */
N#define FSL_FEATURE_SOC_LPC_CAN_COUNT (2)
N/* @brief SHA availability on the SoC. */
N#define FSL_FEATURE_SOC_SHA_COUNT (0)
N/* @brief AES availability on the SoC. */
N#define FSL_FEATURE_SOC_AES_COUNT (0)
N/* @brief RIT availability on the SoC. */
N#define FSL_FEATURE_SOC_RIT_COUNT (1)
N/* @brief FMC availability on the SoC. */
N#define FSL_FEATURE_SOC_FMC_COUNT (1)
N/* @brief RNG availability on the SoC. */
N#define FSL_FEATURE_SOC_LPC_RNG_COUNT (1)
N
N/* DMA module features */
N
N/* @brief Number of channels */
N#define FSL_FEATURE_DMA_NUMBER_OF_CHANNELS (30)
N
N/* EEPROM module features */
N
N/* @brief Size of the EEPROM */
N#define FSL_FEATURE_EEPROM_SIZE (0x00004000)
N/* @brief Base address of the EEPROM */
N#define FSL_FEATURE_EEPROM_BASE_ADDRESS (0x40108000)
N/* @brief Page count of the EEPROM */
N#define FSL_FEATURE_EEPROM_PAGE_COUNT (128)
N/* @brief Command number for eeprom program */
N#define FSL_FEATURE_EEPROM_PROGRAM_CMD (6)
N/* @brief EEPROM internal clock freqency */
N#define FSL_FEATURE_EEPROM_INTERNAL_FREQ (1500000)
N
N/* IOCON module features */
N
N/* @brief Func bit field width */
N#define FSL_FEATURE_IOCON_FUNC_FIELD_WIDTH (4)
N
N/* PINT module features */
N
N/* @brief Number of connected outputs */
N#define FSL_FEATURE_PINT_NUMBER_OF_CONNECTED_OUTPUTS (8)
N
N/* SCT module features */
N
N/* @brief Number of events */
N#define FSL_FEATURE_SCT_NUMBER_OF_EVENTS (10)
N/* @brief Number of states */
N#define FSL_FEATURE_SCT_NUMBER_OF_STATES (10)
N/* @brief Number of match capture */
N#define FSL_FEATURE_SCT_NUMBER_OF_MATCH_CAPTURE (10)
N
N/* SDIF module features */
N
N/* @brief FIFO depth, every location is a WORD */
N#define FSL_FEATURE_SDIF_FIFO_DEPTH_64_32BITS  (64)
N/* @brief Max DMA buffer size */
N#define FSL_FEATURE_SDIF_INTERNAL_DMA_MAX_BUFFER_SIZE  (4096)
N
N/* SPIFI module features */
N
N/* @brief SPIFI start address */
N#define FSL_FEATURE_SPIFI_START_ADDR (0x10000000)
N/* @brief SPIFI end address */
N#define FSL_FEATURE_SPIFI_END_ADDR (0x17FFFFFF)
N
N/* SYSCON module features */
N
N/* @brief Pointer to ROM IAP entry functions */
N#define FSL_FEATURE_SYSCON_IAP_ENTRY_LOCATION (0x03000205)
N/* @brief Flash page size in bytes */
N#define FSL_FEATURE_SYSCON_FLASH_PAGE_SIZE_BYTES (256)
N/* @brief Flash sector size in bytes */
N#define FSL_FEATURE_SYSCON_FLASH_SECTOR_SIZE_BYTES (32768)
N/* @brief Flash size in bytes */
N#define FSL_FEATURE_SYSCON_FLASH_SIZE_BYTES (524288)
N
N/* USB module features */
N
N/* @brief Size of the USB dedicated RAM */
N#define FSL_FEATURE_USB_USB_RAM (0x00002000)
N/* @brief Base address of the USB dedicated RAM */
N#define FSL_FEATURE_USB_USB_RAM_BASE_ADDRESS (0x40100000)
N
N/* USBFSH module features */
N
N/* @brief Size of the USB dedicated RAM */
N#define FSL_FEATURE_USBFSH_USB_RAM (0x00002000)
N/* @brief Base address of the USB dedicated RAM */
N#define FSL_FEATURE_USBFSH_USB_RAM_BASE_ADDRESS (0x40100000)
N
N/* USBHSD module features */
N
N/* @brief Size of the USB dedicated RAM */
N#define FSL_FEATURE_USBHSD_USB_RAM (0x00002000)
N/* @brief Base address of the USB dedicated RAM */
N#define FSL_FEATURE_USBHSD_USB_RAM_BASE_ADDRESS (0x40100000)
N
N/* USBHSH module features */
N
N/* @brief Size of the USB dedicated RAM */
N#define FSL_FEATURE_USBHSH_USB_RAM (0x00002000)
N/* @brief Base address of the USB dedicated RAM */
N#define FSL_FEATURE_USBHSH_USB_RAM_BASE_ADDRESS (0x40100000)
N
N#endif /* _LPC54608_FEATURES_H_ */
N
L 47 ".\SRC\System\fsl_device_registers.h" 2
N
N#else
S    #error "No valid CPU defined!"
N#endif
N
N#endif /* __FSL_DEVICE_REGISTERS_H__ */
N
N/*******************************************************************************
N * EOF
N ******************************************************************************/
L 39 ".\SRC\Drivers\fsl_common.h" 2
N
N/*!
N * @addtogroup ksdk_common
N * @{
N */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @brief Construct a status code value from a group and code number. */
N#define MAKE_STATUS(group, code) ((((group)*100) + (code)))
N
N/*! @brief Construct the version number for drivers. */
N#define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
N
N/* Debug console type definition. */
N#define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
N#define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
N#define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
N#define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
N#define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
N#define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
N
N/*! @brief Status group numbers. */
Nenum _status_groups
N{
N    kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
N    kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
N    kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
N    kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
N    kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
N    kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
N    kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
N    kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
N    kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
N    kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
N    kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
N    kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
N    kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
N    kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
N    kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
N    kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
N    kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
N    kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
N    kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
N    kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
N    kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
N    kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
N    kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
N    kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
N    kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
N    kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
N    kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
N    kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
N    kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
N    kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
N    kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
N    kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
N    kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
N    kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
N    kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
N    kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
N    kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
N    kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
N    kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
N    kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
N    kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
N    kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
N    kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
N    kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
N    kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
N    kStatusGroup_MCAN = 62,                  /*!< Group number for MCAN status codes. */
N    kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
N    kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
N    kStatusGroup_ApplicationRangeStart = 100, /*!< Starting number for application groups. */
N};
N
N/*! @brief Generic status return codes. */
Nenum _generic_status
N{
N    kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
X    kStatus_Success = ((((kStatusGroup_Generic)*100) + (0))),
N    kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
X    kStatus_Fail = ((((kStatusGroup_Generic)*100) + (1))),
N    kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
X    kStatus_ReadOnly = ((((kStatusGroup_Generic)*100) + (2))),
N    kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
X    kStatus_OutOfRange = ((((kStatusGroup_Generic)*100) + (3))),
N    kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
X    kStatus_InvalidArgument = ((((kStatusGroup_Generic)*100) + (4))),
N    kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
X    kStatus_Timeout = ((((kStatusGroup_Generic)*100) + (5))),
N    kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
X    kStatus_NoTransferInProgress = ((((kStatusGroup_Generic)*100) + (6))),
N};
N
N/*! @brief Type used for all status and error return values. */
Ntypedef int32_t status_t;
N
N/*
N * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
N * defined in previous of this file.
N */
N#include "fsl_clock.h"
L 1 ".\SRC\Drivers\fsl_clock.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _FSL_CLOCK_H_
N#define _FSL_CLOCK_H_
N
N#include "fsl_device_registers.h"
N#include <stdint.h>
N#include <stdbool.h>
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
S#   define __assert_h
S#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
S#define __ARMCLIB_VERSION 5060019
S#   ifndef __ARM_PROMISE
S#      define __ARM_PROMISE __promise
S#   endif
S#   undef __CLIBNS
S#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
S#   else
S#       define __CLIBNS
S#   endif  /* __cplusplus */
S    extern _ARMABI_NORETURN void abort(void);
S    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
S#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
S#   endif
N#else
N#   undef assert
N#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 38 ".\SRC\Drivers\fsl_clock.h" 2
N
N/*! @addtogroup clock */
N/*! @{ */
N
N/*! @file */
N
N/*******************************************************************************
N * Definitions
N *****************************************************************************/
N
N/*! @brief Configure whether driver controls clock
N *
N * When set to 0, peripheral drivers will enable clock in initialize function
N * and disable clock in de-initialize function. When set to 1, peripheral
N * driver will not control the clock, application could contol the clock out of
N * the driver.
N *
N * @note All drivers share this feature switcher. If it is set to 1, application
N * should handle clock enable and disable for all drivers.
N */
N#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
X#if !(0L)
N#define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
N#endif
N/*! @brief Clock ip name array for ROM. */
N#define ADC_CLOCKS \
N    {              \
N        kCLOCK_Adc0 \
N    }
X#define ADC_CLOCKS     {                      kCLOCK_Adc0     }
N/*! @brief Clock ip name array for ROM. */
N#define ROM_CLOCKS \
N    {              \
N        kCLOCK_Rom \
N    }
X#define ROM_CLOCKS     {                      kCLOCK_Rom     }
N/*! @brief Clock ip name array for SRAM. */
N#define SRAM_CLOCKS \
N    {               \
N        kCLOCK_Sram1, kCLOCK_Sram2, kCLOCK_Sram3 \
N    }
X#define SRAM_CLOCKS     {                       kCLOCK_Sram1, kCLOCK_Sram2, kCLOCK_Sram3     }
N/*! @brief Clock ip name array for FLASH. */
N#define FLASH_CLOCKS \
N    {                \
N        kCLOCK_Flash \
N    }
X#define FLASH_CLOCKS     {                        kCLOCK_Flash     }
N/*! @brief Clock ip name array for FMC. */
N#define FMC_CLOCKS \
N    {              \
N        kCLOCK_Fmc \
N    }
X#define FMC_CLOCKS     {                      kCLOCK_Fmc     }
N/*! @brief Clock ip name array for EEPROM. */
N#define EEPROM_CLOCKS  \
N    {                  \
N        kCLOCK_Eeprom  \
N    }
X#define EEPROM_CLOCKS      {                          kCLOCK_Eeprom      }
N/*! @brief Clock ip name array for SPIFI. */
N#define SPIFI_CLOCKS  \
N    {                 \
N        kCLOCK_Spifi  \
N    }
X#define SPIFI_CLOCKS      {                         kCLOCK_Spifi      }
N/*! @brief Clock ip name array for INPUTMUX. */
N#define INPUTMUX_CLOCKS      \
N    {                        \
N        kCLOCK_InputMux      \
N    }
X#define INPUTMUX_CLOCKS          {                                kCLOCK_InputMux          }
N/*! @brief Clock ip name array for IOCON. */
N#define IOCON_CLOCKS         \
N    {                        \
N        kCLOCK_Iocon         \
N    }
X#define IOCON_CLOCKS             {                                kCLOCK_Iocon             }
N/*! @brief Clock ip name array for GPIO. */
N#define GPIO_CLOCKS          \
N    {                        \
N        kCLOCK_Gpio0,kLOCK_Gpio1, kCLOCK_Gpio2, kCLOCK_Gpio3, kCLOCK_Gpio4, kCLOCK_Gpio5     \
N    }
X#define GPIO_CLOCKS              {                                kCLOCK_Gpio0,kLOCK_Gpio1, kCLOCK_Gpio2, kCLOCK_Gpio3, kCLOCK_Gpio4, kCLOCK_Gpio5         }
N/*! @brief Clock ip name array for PINT. */
N#define PINT_CLOCKS          \
N    {                        \
N        kCLOCK_Pint          \
N    }
X#define PINT_CLOCKS              {                                kCLOCK_Pint              }
N/*! @brief Clock ip name array for GINT. */
N#define GINT_CLOCKS          \
N    {                        \
N        kCLOCK_Gint, kCLOCK_Gint          \
N    }
X#define GINT_CLOCKS              {                                kCLOCK_Gint, kCLOCK_Gint              }
N/*! @brief Clock ip name array for DMA. */
N#define DMA_CLOCKS          \
N    {                       \
N        kCLOCK_Dma          \
N    }
X#define DMA_CLOCKS              {                               kCLOCK_Dma              }
N/*! @brief Clock ip name array for CRC. */
N#define CRC_CLOCKS          \
N    {                       \
N        kCLOCK_Crc          \
N    }
X#define CRC_CLOCKS              {                               kCLOCK_Crc              }
N/*! @brief Clock ip name array for WWDT. */
N#define WWDT_CLOCKS          \
N    {                        \
N        kCLOCK_Wwdt          \
N    }
X#define WWDT_CLOCKS              {                                kCLOCK_Wwdt              }
N/*! @brief Clock ip name array for RTC. */
N#define RTC_CLOCKS          \
N    {                       \
N        kCLOCK_Rtc          \
N    }
X#define RTC_CLOCKS              {                               kCLOCK_Rtc              }
N/*! @brief Clock ip name array for ADC0. */
N#define ADC0_CLOCKS          \
N    {                        \
N        kCLOCK_Adc0          \
N    }
X#define ADC0_CLOCKS              {                                kCLOCK_Adc0              }
N/*! @brief Clock ip name array for MRT. */
N#define MRT_CLOCKS           \
N    {                        \
N        kCLOCK_Mrt           \
N    }
X#define MRT_CLOCKS               {                                kCLOCK_Mrt               }
N/*! @brief Clock ip name array for RIT. */
N#define RIT_CLOCKS           \
N    {                        \
N        kCLOCK_Rit           \
N    }
X#define RIT_CLOCKS               {                                kCLOCK_Rit               }
N/*! @brief Clock ip name array for SCT0. */
N#define SCT_CLOCKS          \
N    {                        \
N        kCLOCK_Sct0          \
N    }
X#define SCT_CLOCKS              {                                kCLOCK_Sct0              }
N/*! @brief Clock ip name array for MCAN. */
N#define MCAN_CLOCKS          \
N    {                        \
N        kCLOCK_Mcan0, kCLOCK_Mcan1          \
N    }
X#define MCAN_CLOCKS              {                                kCLOCK_Mcan0, kCLOCK_Mcan1              }
N/*! @brief Clock ip name array for UTICK. */
N#define UTICK_CLOCKS         \
N    {                        \
N        kCLOCK_Utick         \
N    }
X#define UTICK_CLOCKS             {                                kCLOCK_Utick             }
N/*! @brief Clock ip name array for FLEXCOMM. */
N#define FLEXCOMM_CLOCKS                                                        \
N    {                                                                          \
N        kCLOCK_FlexComm0, kCLOCK_FlexComm1, kCLOCK_FlexComm2, kCLOCK_FlexComm3, \
N					kCLOCK_FlexComm4, kCLOCK_FlexComm5, kCLOCK_FlexComm6, kCLOCK_FlexComm7, \
N                                        kCLOCK_FlexComm8, kCLOCK_FlexComm9 \
N    }
X#define FLEXCOMM_CLOCKS                                                            {                                                                                  kCLOCK_FlexComm0, kCLOCK_FlexComm1, kCLOCK_FlexComm2, kCLOCK_FlexComm3, 					kCLOCK_FlexComm4, kCLOCK_FlexComm5, kCLOCK_FlexComm6, kCLOCK_FlexComm7,                                         kCLOCK_FlexComm8, kCLOCK_FlexComm9     }
N/*! @brief Clock ip name array for LPUART. */
N#define LPUART_CLOCKS                                                                                         \
N    {                                                                                                         \
N        kCLOCK_MinUart0, kCLOCK_MinUart1, kCLOCK_MinUart2, kCLOCK_MinUart3, kCLOCK_MinUart4, kCLOCK_MinUart5, \
N            kCLOCK_MinUart6, kCLOCK_MinUart7, kCLOCK_MinUart8,kCLOCK_MinUart9     \
N    }
X#define LPUART_CLOCKS                                                                                             {                                                                                                                 kCLOCK_MinUart0, kCLOCK_MinUart1, kCLOCK_MinUart2, kCLOCK_MinUart3, kCLOCK_MinUart4, kCLOCK_MinUart5,             kCLOCK_MinUart6, kCLOCK_MinUart7, kCLOCK_MinUart8,kCLOCK_MinUart9         }
N
N/*! @brief Clock ip name array for BI2C. */
N#define BI2C_CLOCKS                                                                                                     \
N    {                                                                                                                   \
N        kCLOCK_BI2c0, kCLOCK_BI2c1, kCLOCK_BI2c2, kCLOCK_BI2c3, kCLOCK_BI2c4, kCLOCK_BI2c5, kCLOCK_BI2c6, kCLOCK_BI2c7, \
N        kCLOCK_BI2c8, kCLOCK_BI2c9  \
N    }
X#define BI2C_CLOCKS                                                                                                         {                                                                                                                           kCLOCK_BI2c0, kCLOCK_BI2c1, kCLOCK_BI2c2, kCLOCK_BI2c3, kCLOCK_BI2c4, kCLOCK_BI2c5, kCLOCK_BI2c6, kCLOCK_BI2c7,         kCLOCK_BI2c8, kCLOCK_BI2c9      }
N/*! @brief Clock ip name array for LSPI. */
N#define LPSI_CLOCKS                                                                                                     \
N    {                                                                                                                   \
N        kCLOCK_LSpi0, kCLOCK_LSpi1, kCLOCK_LSpi2, kCLOCK_LSpi3, kCLOCK_LSpi4, kCLOCK_LSpi5, kCLOCK_LSpi6, kCLOCK_LSpi7, \
N        kCLOCK_LSpi8, kCLOCK_LSpi9  \
N    }
X#define LPSI_CLOCKS                                                                                                         {                                                                                                                           kCLOCK_LSpi0, kCLOCK_LSpi1, kCLOCK_LSpi2, kCLOCK_LSpi3, kCLOCK_LSpi4, kCLOCK_LSpi5, kCLOCK_LSpi6, kCLOCK_LSpi7,         kCLOCK_LSpi8, kCLOCK_LSpi9      }
N/*! @brief Clock ip name array for FLEXI2S. */
N#define FLEXI2S_CLOCKS                                                                                        \
N    {                                                                                                         \
N        kCLOCK_FlexI2s0, kCLOCK_FlexI2s1, kCLOCK_FlexI2s2, kCLOCK_FlexI2s3, kCLOCK_FlexI2s4, kCLOCK_FlexI2s5, \
N            kCLOCK_FlexI2s6, kCLOCK_FlexI2s7, kCLOCK_FlexI2s8, kCLOCK_FlexI2s9                                                                  \
N    }
X#define FLEXI2S_CLOCKS                                                                                            {                                                                                                                 kCLOCK_FlexI2s0, kCLOCK_FlexI2s1, kCLOCK_FlexI2s2, kCLOCK_FlexI2s3, kCLOCK_FlexI2s4, kCLOCK_FlexI2s5,             kCLOCK_FlexI2s6, kCLOCK_FlexI2s7, kCLOCK_FlexI2s8, kCLOCK_FlexI2s9                                                                      }
N/*! @brief Clock ip name array for DMIC. */
N#define DMIC_CLOCKS \
N    {               \
N        kCLOCK_DMic \
N    }
X#define DMIC_CLOCKS     {                       kCLOCK_DMic     }
N/*! @brief Clock ip name array for CT32B. */
N#define CTIMER_CLOCKS                                                               \
N    {                                                                               \
N        kCLOCK_Ct32b0, kCLOCK_Ct32b1, kCLOCK_Ct32b2, kCLOCK_Ct32b3, kCLOCK_Ct32b4   \
N    }
X#define CTIMER_CLOCKS                                                                   {                                                                                       kCLOCK_Ct32b0, kCLOCK_Ct32b1, kCLOCK_Ct32b2, kCLOCK_Ct32b3, kCLOCK_Ct32b4       }
N/*! @brief Clock ip name array for LCD. */
N#define LCD_CLOCKS  \
N    {               \
N        kCLOCK_Lcd  \
N    }
X#define LCD_CLOCKS      {                       kCLOCK_Lcd      }
N/*! @brief Clock ip name array for SDIO. */
N#define SDIO_CLOCKS  \
N    {                \
N        kCLOCK_Sdio  \
N    }
X#define SDIO_CLOCKS      {                        kCLOCK_Sdio      }
N/*! @brief Clock ip name array for USBRAM. */
N#define USBRAM_CLOCKS    \
N    {                    \
N        kCLOCK_UsbRam1   \
N    }
X#define USBRAM_CLOCKS        {                            kCLOCK_UsbRam1       }
N/*! @brief Clock ip name array for EMC. */
N#define EMC_CLOCKS       \
N    {                    \
N        kCLOCK_Emc       \
N    }
X#define EMC_CLOCKS           {                            kCLOCK_Emc           }
N/*! @brief Clock ip name array for ETH. */
N#define ETH_CLOCKS       \
N    {                    \
N        kCLOCK_Eth       \
N    }
X#define ETH_CLOCKS           {                            kCLOCK_Eth           }
N/*! @brief Clock ip name array for AES. */
N#define AES_CLOCKS       \
N    {                    \
N        kCLOCK_Aes       \
N    }
X#define AES_CLOCKS           {                            kCLOCK_Aes           }
N/*! @brief Clock ip name array for OTP. */
N#define OTP_CLOCKS       \
N    {                    \
N        kCLOCK_Otp       \
N    }
X#define OTP_CLOCKS           {                            kCLOCK_Otp           }
N/*! @brief Clock ip name array for RNG. */
N#define RNG_CLOCKS       \
N    {                    \
N        kCLOCK_Rng       \
N    }
X#define RNG_CLOCKS           {                            kCLOCK_Rng           }
N/*! @brief Clock ip name array for USBHMR0. */
N#define USBHMR0_CLOCKS       \
N    {                        \
N        kCLOCK_Usbhmr0       \
N    }
X#define USBHMR0_CLOCKS           {                                kCLOCK_Usbhmr0           }
N/*! @brief Clock ip name array for USBHSL0. */
N#define USBHSL0_CLOCKS       \
N    {                        \
N        kCLOCK_Usbhsl0       \
N    }
X#define USBHSL0_CLOCKS           {                                kCLOCK_Usbhsl0           }
N/*! @brief Clock ip name array for SHA0. */
N#define SHA0_CLOCKS       \
N    {                     \
N        kCLOCK_Sha0       \
N    }
X#define SHA0_CLOCKS           {                             kCLOCK_Sha0           }
N/*! @brief Clock ip name array for SMARTCARD. */
N#define SMARTCARD_CLOCKS  \
N    {                     \
N        kCLOCK_SmartCard0, kCLOCK_SmartCard1 \
N    }
X#define SMARTCARD_CLOCKS      {                             kCLOCK_SmartCard0, kCLOCK_SmartCard1     }
N/*! @brief Clock ip name array for USBD. */
N#define USBD_CLOCKS  \
N    {                \
N        kCLOCK_Usbd0, kCLOCK_Usbh1, kCLOCK_Usbd1 \
N    }
X#define USBD_CLOCKS      {                        kCLOCK_Usbd0, kCLOCK_Usbh1, kCLOCK_Usbd1     }
N/*! @brief Clock ip name array for USBH. */
N#define USBH_CLOCKS  \
N    {                \
N        kCLOCK_Usbh1 \
N    }
X#define USBH_CLOCKS      {                        kCLOCK_Usbh1     }
N/*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
N/*------------------------------------------------------------------------------
N clock_ip_name_t definition:
N------------------------------------------------------------------------------*/
N
N#define CLK_GATE_REG_OFFSET_SHIFT 8U
N#define CLK_GATE_REG_OFFSET_MASK 0xFFFFFF00U
N#define CLK_GATE_BIT_SHIFT_SHIFT 0U
N#define CLK_GATE_BIT_SHIFT_MASK 0x000000FFU
N
N#define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
N    ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
N     (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
X#define CLK_GATE_DEFINE(reg_offset, bit_shift)                                      ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) |      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
N
N#define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((uint32_t)(x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIFT)
N#define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((uint32_t)(x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
N
N#define AHB_CLK_CTRL0 0
N#define AHB_CLK_CTRL1 1
N#define AHB_CLK_CTRL2 2
N#define ASYNC_CLK_CTRL0 3
N
N/*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
Ntypedef enum _clock_ip_name
N{
N    kCLOCK_IpInvalid = 0U,
N    kCLOCK_Rom = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 1),
X    kCLOCK_Rom = ((((0) << 8U) & 0xFFFFFF00U) | (((1) << 0U) & 0x000000FFU)),
N    kCLOCK_Sram1 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 3),
X    kCLOCK_Sram1 = ((((0) << 8U) & 0xFFFFFF00U) | (((3) << 0U) & 0x000000FFU)),
N    kCLOCK_Sram2 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 4),
X    kCLOCK_Sram2 = ((((0) << 8U) & 0xFFFFFF00U) | (((4) << 0U) & 0x000000FFU)),
N    kCLOCK_Sram3 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 5),
X    kCLOCK_Sram3 = ((((0) << 8U) & 0xFFFFFF00U) | (((5) << 0U) & 0x000000FFU)),
N    kCLOCK_Flash = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 7),
X    kCLOCK_Flash = ((((0) << 8U) & 0xFFFFFF00U) | (((7) << 0U) & 0x000000FFU)),
N    kCLOCK_Fmc = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 8),
X    kCLOCK_Fmc = ((((0) << 8U) & 0xFFFFFF00U) | (((8) << 0U) & 0x000000FFU)),
N    kCLOCK_Eeprom = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 9),
X    kCLOCK_Eeprom = ((((0) << 8U) & 0xFFFFFF00U) | (((9) << 0U) & 0x000000FFU)),
N    kCLOCK_Spifi = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 10),
X    kCLOCK_Spifi = ((((0) << 8U) & 0xFFFFFF00U) | (((10) << 0U) & 0x000000FFU)),
N    kCLOCK_InputMux = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 11),
X    kCLOCK_InputMux = ((((0) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_Iocon = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 13),
X    kCLOCK_Iocon = ((((0) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_Gpio0 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 14),
X    kCLOCK_Gpio0 = ((((0) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_Gpio1 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 15),
X    kCLOCK_Gpio1 = ((((0) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_Gpio2 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 16),
X    kCLOCK_Gpio2 = ((((0) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_Gpio3 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 17),
X    kCLOCK_Gpio3 = ((((0) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_Pint = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 18),
X    kCLOCK_Pint = ((((0) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_Gint = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 19),
X    kCLOCK_Gint = ((((0) << 8U) & 0xFFFFFF00U) | (((19) << 0U) & 0x000000FFU)),
N    kCLOCK_Dma = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 20),
X    kCLOCK_Dma = ((((0) << 8U) & 0xFFFFFF00U) | (((20) << 0U) & 0x000000FFU)),
N    kCLOCK_Crc = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 21),
X    kCLOCK_Crc = ((((0) << 8U) & 0xFFFFFF00U) | (((21) << 0U) & 0x000000FFU)),
N    kCLOCK_Wwdt = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 22),
X    kCLOCK_Wwdt = ((((0) << 8U) & 0xFFFFFF00U) | (((22) << 0U) & 0x000000FFU)),
N    kCLOCK_Rtc = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 23),
X    kCLOCK_Rtc = ((((0) << 8U) & 0xFFFFFF00U) | (((23) << 0U) & 0x000000FFU)),
N    kCLOCK_Adc0 = CLK_GATE_DEFINE(AHB_CLK_CTRL0, 27),
X    kCLOCK_Adc0 = ((((0) << 8U) & 0xFFFFFF00U) | (((27) << 0U) & 0x000000FFU)),
N    kCLOCK_Mrt = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 0),
X    kCLOCK_Mrt = ((((1) << 8U) & 0xFFFFFF00U) | (((0) << 0U) & 0x000000FFU)),
N    kCLOCK_Rit = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 1),
X    kCLOCK_Rit = ((((1) << 8U) & 0xFFFFFF00U) | (((1) << 0U) & 0x000000FFU)),
N    kCLOCK_Sct0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 2),
X    kCLOCK_Sct0 = ((((1) << 8U) & 0xFFFFFF00U) | (((2) << 0U) & 0x000000FFU)),
N    kCLOCK_Mcan0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 7),
X    kCLOCK_Mcan0 = ((((1) << 8U) & 0xFFFFFF00U) | (((7) << 0U) & 0x000000FFU)),
N    kCLOCK_Mcan1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 8),
X    kCLOCK_Mcan1 = ((((1) << 8U) & 0xFFFFFF00U) | (((8) << 0U) & 0x000000FFU)),
N    kCLOCK_Utick = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 10),
X    kCLOCK_Utick = ((((1) << 8U) & 0xFFFFFF00U) | (((10) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 11),
X    kCLOCK_FlexComm0 = ((((1) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 12),
X    kCLOCK_FlexComm1 = ((((1) << 8U) & 0xFFFFFF00U) | (((12) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm2 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 13),
X    kCLOCK_FlexComm2 = ((((1) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm3 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 14),
X    kCLOCK_FlexComm3 = ((((1) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm4 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 15),
X    kCLOCK_FlexComm4 = ((((1) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm5 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 16),
X    kCLOCK_FlexComm5 = ((((1) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm6 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 17),
X    kCLOCK_FlexComm6 = ((((1) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm7 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 18),
X    kCLOCK_FlexComm7 = ((((1) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 11),
X    kCLOCK_MinUart0 = ((((1) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 12),
X    kCLOCK_MinUart1 = ((((1) << 8U) & 0xFFFFFF00U) | (((12) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart2 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 13),
X    kCLOCK_MinUart2 = ((((1) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart3 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 14),
X    kCLOCK_MinUart3 = ((((1) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart4 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 15),
X    kCLOCK_MinUart4 = ((((1) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart5 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 16),
X    kCLOCK_MinUart5 = ((((1) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart6 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 17),
X    kCLOCK_MinUart6 = ((((1) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart7 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 18),
X    kCLOCK_MinUart7 = ((((1) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 11),
X    kCLOCK_LSpi0 = ((((1) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 12),
X    kCLOCK_LSpi1 = ((((1) << 8U) & 0xFFFFFF00U) | (((12) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi2 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 13),
X    kCLOCK_LSpi2 = ((((1) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi3 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 14),
X    kCLOCK_LSpi3 = ((((1) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi4 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 15),
X    kCLOCK_LSpi4 = ((((1) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi5 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 16),
X    kCLOCK_LSpi5 = ((((1) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi6 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 17),
X    kCLOCK_LSpi6 = ((((1) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi7 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 18),
X    kCLOCK_LSpi7 = ((((1) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 11),
X    kCLOCK_BI2c0 = ((((1) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 12),
X    kCLOCK_BI2c1 = ((((1) << 8U) & 0xFFFFFF00U) | (((12) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c2 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 13),
X    kCLOCK_BI2c2 = ((((1) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c3 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 14),
X    kCLOCK_BI2c3 = ((((1) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c4 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 15),
X    kCLOCK_BI2c4 = ((((1) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c5 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 16),
X    kCLOCK_BI2c5 = ((((1) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c6 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 17),
X    kCLOCK_BI2c6 = ((((1) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c7 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 18),
X    kCLOCK_BI2c7 = ((((1) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 11),
X    kCLOCK_FlexI2s0 = ((((1) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 12),
X    kCLOCK_FlexI2s1 = ((((1) << 8U) & 0xFFFFFF00U) | (((12) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s2 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 13),
X    kCLOCK_FlexI2s2 = ((((1) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s3 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 14),
X    kCLOCK_FlexI2s3 = ((((1) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s4 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 15),
X    kCLOCK_FlexI2s4 = ((((1) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s5 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 16),
X    kCLOCK_FlexI2s5 = ((((1) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s6 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 17),
X    kCLOCK_FlexI2s6 = ((((1) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s7 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 18),
X    kCLOCK_FlexI2s7 = ((((1) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_DMic = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 19),
X    kCLOCK_DMic = ((((1) << 8U) & 0xFFFFFF00U) | (((19) << 0U) & 0x000000FFU)),
N    kCLOCK_Ct32b2 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 22),
X    kCLOCK_Ct32b2 = ((((1) << 8U) & 0xFFFFFF00U) | (((22) << 0U) & 0x000000FFU)),
N    kCLOCK_Usbd0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 25),
X    kCLOCK_Usbd0 = ((((1) << 8U) & 0xFFFFFF00U) | (((25) << 0U) & 0x000000FFU)),
N    kCLOCK_Ct32b0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 26),
X    kCLOCK_Ct32b0 = ((((1) << 8U) & 0xFFFFFF00U) | (((26) << 0U) & 0x000000FFU)),
N    kCLOCK_Ct32b1 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 27),
X    kCLOCK_Ct32b1 = ((((1) << 8U) & 0xFFFFFF00U) | (((27) << 0U) & 0x000000FFU)),
N    kCLOCK_BodyBias0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 29),
X    kCLOCK_BodyBias0 = ((((1) << 8U) & 0xFFFFFF00U) | (((29) << 0U) & 0x000000FFU)),
N    kCLOCK_EzhArchB0 = CLK_GATE_DEFINE(AHB_CLK_CTRL1, 31),
X    kCLOCK_EzhArchB0 = ((((1) << 8U) & 0xFFFFFF00U) | (((31) << 0U) & 0x000000FFU)),
N    kCLOCK_Lcd = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 2),
X    kCLOCK_Lcd = ((((2) << 8U) & 0xFFFFFF00U) | (((2) << 0U) & 0x000000FFU)),
N    kCLOCK_Sdio = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 3),
X    kCLOCK_Sdio = ((((2) << 8U) & 0xFFFFFF00U) | (((3) << 0U) & 0x000000FFU)),
N    kCLOCK_Usbh1 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 4),
X    kCLOCK_Usbh1 = ((((2) << 8U) & 0xFFFFFF00U) | (((4) << 0U) & 0x000000FFU)),
N    kCLOCK_Usbd1 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 5),
X    kCLOCK_Usbd1 = ((((2) << 8U) & 0xFFFFFF00U) | (((5) << 0U) & 0x000000FFU)),
N    kCLOCK_UsbRam1 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 6),
X    kCLOCK_UsbRam1 = ((((2) << 8U) & 0xFFFFFF00U) | (((6) << 0U) & 0x000000FFU)),
N    kCLOCK_Emc = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 7),
X    kCLOCK_Emc = ((((2) << 8U) & 0xFFFFFF00U) | (((7) << 0U) & 0x000000FFU)),
N    kCLOCK_Eth = CLK_GATE_DEFINE(AHB_CLK_CTRL2,8),
X    kCLOCK_Eth = ((((2) << 8U) & 0xFFFFFF00U) | (((8) << 0U) & 0x000000FFU)),
N    kCLOCK_Gpio4 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 9),
X    kCLOCK_Gpio4 = ((((2) << 8U) & 0xFFFFFF00U) | (((9) << 0U) & 0x000000FFU)),
N    kCLOCK_Gpio5 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 10),
X    kCLOCK_Gpio5 = ((((2) << 8U) & 0xFFFFFF00U) | (((10) << 0U) & 0x000000FFU)),
N    kCLOCK_Aes = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 11),
X    kCLOCK_Aes = ((((2) << 8U) & 0xFFFFFF00U) | (((11) << 0U) & 0x000000FFU)),
N    kCLOCK_Otp = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 12),
X    kCLOCK_Otp = ((((2) << 8U) & 0xFFFFFF00U) | (((12) << 0U) & 0x000000FFU)),
N    kCLOCK_Rng = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 13),
X    kCLOCK_Rng = ((((2) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm8 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 14),
X    kCLOCK_FlexComm8 = ((((2) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexComm9 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 15),
X    kCLOCK_FlexComm9 = ((((2) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart8 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 14),
X    kCLOCK_MinUart8 = ((((2) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_MinUart9 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 15),
X    kCLOCK_MinUart9 = ((((2) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi8 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 14),
X    kCLOCK_LSpi8 = ((((2) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_LSpi9 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 15),
X    kCLOCK_LSpi9 = ((((2) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c8 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 14),
X    kCLOCK_BI2c8 = ((((2) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_BI2c9 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 15),
X    kCLOCK_BI2c9 = ((((2) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s8 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 14),
X    kCLOCK_FlexI2s8 = ((((2) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU)),
N    kCLOCK_FlexI2s9 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 15),
X    kCLOCK_FlexI2s9 = ((((2) << 8U) & 0xFFFFFF00U) | (((15) << 0U) & 0x000000FFU)),
N    kCLOCK_Usbhmr0 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 16),
X    kCLOCK_Usbhmr0 = ((((2) << 8U) & 0xFFFFFF00U) | (((16) << 0U) & 0x000000FFU)),
N    kCLOCK_Usbhsl0 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 17),
X    kCLOCK_Usbhsl0 = ((((2) << 8U) & 0xFFFFFF00U) | (((17) << 0U) & 0x000000FFU)),
N    kCLOCK_Sha0 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 18),
X    kCLOCK_Sha0 = ((((2) << 8U) & 0xFFFFFF00U) | (((18) << 0U) & 0x000000FFU)),
N    kCLOCK_SmartCard0 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 19),
X    kCLOCK_SmartCard0 = ((((2) << 8U) & 0xFFFFFF00U) | (((19) << 0U) & 0x000000FFU)),
N    kCLOCK_SmartCard1 = CLK_GATE_DEFINE(AHB_CLK_CTRL2, 20),
X    kCLOCK_SmartCard1 = ((((2) << 8U) & 0xFFFFFF00U) | (((20) << 0U) & 0x000000FFU)),
N
N    kCLOCK_Ct32b3 = CLK_GATE_DEFINE(ASYNC_CLK_CTRL0, 13),
X    kCLOCK_Ct32b3 = ((((3) << 8U) & 0xFFFFFF00U) | (((13) << 0U) & 0x000000FFU)),
N    kCLOCK_Ct32b4 = CLK_GATE_DEFINE(ASYNC_CLK_CTRL0, 14)
X    kCLOCK_Ct32b4 = ((((3) << 8U) & 0xFFFFFF00U) | (((14) << 0U) & 0x000000FFU))
N} clock_ip_name_t;
N
N/*! @brief Clock name used to get clock frequency. */
Ntypedef enum _clock_name
N{
N    kCLOCK_CoreSysClk,  /*!< Core/system clock  (aka MAIN_CLK)                       */
N    kCLOCK_BusClk,      /*!< Bus clock (AHB clock)                                   */
N    kCLOCK_ClockOut,    /*!< CLOCKOUT                                                */
N    kCLOCK_FroHf,       /*!< FRO48/96                                                */
N    kCLOCK_SpiFi,       /*!< SPIFI                                                   */
N    kCLOCK_Adc,         /*!< ADC                                                     */
N    kCLOCK_Usb0,        /*!< USB0                                                    */
N    kCLOCK_Usb1,        /*!< USB1                                                    */
N    kCLOCK_UsbPll,      /*!< USB1 PLL                                                */
N    kCLOCK_Mclk,        /*!< MCLK                                                    */
N    kCLOCK_Sct,         /*!< SCT                                                     */
N    kCLOCK_SDio,        /*!< SDIO                                                    */
N    kCLOCK_EMC,         /*!< EMC                                                     */
N    kCLOCK_LCD,         /*!< LCD                                                     */
N    kCLOCK_MCAN0,       /*!< MCAN0                                                   */
N    kCLOCK_MCAN1,       /*!< MCAN1                                                   */
N    kCLOCK_Fro12M,      /*!< FRO12M                                                  */
N    kCLOCK_ExtClk,      /*!< External Clock                                          */
N    kCLOCK_PllOut,      /*!< PLL Output                                              */
N    kCLOCK_UsbClk,      /*!< USB input                                               */
N    kClock_WdtOsc,      /*!< Watchdog Oscillator                                     */
N    kCLOCK_Frg,         /*!< Frg Clock                                               */
N    kCLOCK_Dmic,        /*!< Digital Mic clock                                       */
N    kCLOCK_AsyncApbClk, /*!< Async APB clock										 */
N    kCLOCK_FlexI2S,     /*!< FlexI2S clock                                           */
N    kCLOCK_Flexcomm0,   /*!< Flexcomm0Clock                                          */
N    kCLOCK_Flexcomm1,   /*!< Flexcomm1Clock                                          */
N    kCLOCK_Flexcomm2,   /*!< Flexcomm2Clock                                          */
N    kCLOCK_Flexcomm3,   /*!< Flexcomm3Clock                                          */
N    kCLOCK_Flexcomm4,   /*!< Flexcomm4Clock                                          */
N    kCLOCK_Flexcomm5,   /*!< Flexcomm5Clock                                          */
N    kCLOCK_Flexcomm6,   /*!< Flexcomm6Clock                                          */
N    kCLOCK_Flexcomm7,   /*!< Flexcomm7Clock                                          */
N    kCLOCK_Flexcomm8,   /*!< Flexcomm8Clock                                          */
N    kCLOCK_Flexcomm9,   /*!< Flexcomm9Clock                                          */
N
N} clock_name_t;
N
N/**
N * Clock source selections for the asynchronous APB clock
N */
Ntypedef enum _async_clock_src
N{
N    kCLOCK_AsyncMainClk = 0, /*!< Main System clock */
N    kCLOCK_AsyncFro12Mhz,    /*!< 12MHz FRO */
N    kCLOCK_AsyncAudioPllClk,
N    kCLOCK_AsyncI2cClkFc6,
N
N} async_clock_src_t;
N
N/*! @brief Clock Mux Switches
N*  The encoding is as follows each connection identified is 64bits wide
N*  starting from LSB upwards
N*
N*  [4 bits for choice, where 1 is A, 2 is B, 3 is C and 4 is D, 0 means end of descriptor] [8 bits mux ID]*
N*
N*/
N
N#define MUX_A(m, choice) (((m) << 0) | ((choice + 1) << 8))
N#define MUX_B(m, choice) (((m) << 12) | ((choice + 1) << 20))
N#define MUX_C(m, choice) (((m) << 24) | ((choice + 1) << 32))
N#define MUX_D(m, choice) (((m) << 36) | ((choice + 1) << 44))
N#define MUX_E(m, choice) (((m) << 48) | ((choice + 1) << 56))
N
N#define CM_MAINCLKSELA 0
N#define CM_MAINCLKSELB 1
N#define CM_CLKOUTCLKSELA 2
N#define CM_SYSPLLCLKSEL 4
N#define CM_AUDPLLCLKSEL 6
N#define CM_SPIFICLKSEL 8
N#define CM_ADCASYNCCLKSEL 9
N#define CM_USB0CLKSEL 10
N#define CM_USB1CLKSEL 11
N#define CM_FXCOMCLKSEL0 12
N#define CM_FXCOMCLKSEL1 13
N#define CM_FXCOMCLKSEL2 14
N#define CM_FXCOMCLKSEL3 15
N#define CM_FXCOMCLKSEL4 16
N#define CM_FXCOMCLKSEL5 17
N#define CM_FXCOMCLKSEL6 18
N#define CM_FXCOMCLKSEL7 19
N#define CM_FXCOMCLKSEL8 20
N#define CM_FXCOMCLKSEL9 21
N#define CM_MCLKCLKSEL 24
N#define CM_FRGCLKSEL 26
N#define CM_DMICCLKSEL 27
N#define CM_SCTCLKSEL  28
N#define CM_LCDCLKSEL  29
N#define CM_SDIOCLKSEL 30
N
N#define CM_ASYNCAPB 31
N
Ntypedef enum _clock_attach_id
N{
N
N    kFRO12M_to_MAIN_CLK = MUX_A(CM_MAINCLKSELA, 0) | MUX_B(CM_MAINCLKSELB, 0),
X    kFRO12M_to_MAIN_CLK = (((0) << 0) | ((0 + 1) << 8)) | (((1) << 12) | ((0 + 1) << 20)),
N    kEXT_CLK_to_MAIN_CLK = MUX_A(CM_MAINCLKSELA, 1) | MUX_B(CM_MAINCLKSELB, 0),
X    kEXT_CLK_to_MAIN_CLK = (((0) << 0) | ((1 + 1) << 8)) | (((1) << 12) | ((0 + 1) << 20)),
N    kWDT_OSC_to_MAIN_CLK = MUX_A(CM_MAINCLKSELA, 2) | MUX_B(CM_MAINCLKSELB, 0),
X    kWDT_OSC_to_MAIN_CLK = (((0) << 0) | ((2 + 1) << 8)) | (((1) << 12) | ((0 + 1) << 20)),
N    kFRO_HF_to_MAIN_CLK = MUX_A(CM_MAINCLKSELA, 3) | MUX_B(CM_MAINCLKSELB, 0),
X    kFRO_HF_to_MAIN_CLK = (((0) << 0) | ((3 + 1) << 8)) | (((1) << 12) | ((0 + 1) << 20)),
N    kSYS_PLL_to_MAIN_CLK = MUX_A(CM_MAINCLKSELB, 2),
X    kSYS_PLL_to_MAIN_CLK = (((1) << 0) | ((2 + 1) << 8)),
N    kOSC32K_to_MAIN_CLK = MUX_A(CM_MAINCLKSELB, 3),
X    kOSC32K_to_MAIN_CLK = (((1) << 0) | ((3 + 1) << 8)),
N
N    kMAIN_CLK_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 0),
X    kMAIN_CLK_to_CLKOUT = (((2) << 0) | ((0 + 1) << 8)),
N    kEXT_CLK_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 1),
X    kEXT_CLK_to_CLKOUT = (((2) << 0) | ((1 + 1) << 8)),
N    kWDT_OSC_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 2),
X    kWDT_OSC_to_CLKOUT = (((2) << 0) | ((2 + 1) << 8)),
N    kFRO_HF_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 3),
X    kFRO_HF_to_CLKOUT = (((2) << 0) | ((3 + 1) << 8)),
N    kSYS_PLL_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 4),
X    kSYS_PLL_to_CLKOUT = (((2) << 0) | ((4 + 1) << 8)),
N    kUSB_PLL_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 5),
X    kUSB_PLL_to_CLKOUT = (((2) << 0) | ((5 + 1) << 8)),
N    kAUDIO_PLL_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 6),
X    kAUDIO_PLL_to_CLKOUT = (((2) << 0) | ((6 + 1) << 8)),
N    kOSC32K_OSC_to_CLKOUT = MUX_A(CM_CLKOUTCLKSELA, 7),
X    kOSC32K_OSC_to_CLKOUT = (((2) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_SYS_PLL = MUX_A(CM_SYSPLLCLKSEL, 0),
X    kFRO12M_to_SYS_PLL = (((4) << 0) | ((0 + 1) << 8)),
N    kEXT_CLK_to_SYS_PLL = MUX_A(CM_SYSPLLCLKSEL, 1),
X    kEXT_CLK_to_SYS_PLL = (((4) << 0) | ((1 + 1) << 8)),
N    kWDT_OSC_to_SYS_PLL = MUX_A(CM_SYSPLLCLKSEL, 2),
X    kWDT_OSC_to_SYS_PLL = (((4) << 0) | ((2 + 1) << 8)),
N    kOSC32K_to_SYS_PLL = MUX_A(CM_SYSPLLCLKSEL, 3),
X    kOSC32K_to_SYS_PLL = (((4) << 0) | ((3 + 1) << 8)),
N    kNONE_to_SYS_PLL = MUX_A(CM_SYSPLLCLKSEL, 7),
X    kNONE_to_SYS_PLL = (((4) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_AUDIO = MUX_A(CM_ASYNCAPB, 0),
X    kFRO12M_to_AUDIO = (((31) << 0) | ((0 + 1) << 8)),
N    kEXT_CLK_to_AUDIO = MUX_A(CM_ASYNCAPB, 1),
X    kEXT_CLK_to_AUDIO = (((31) << 0) | ((1 + 1) << 8)),
N    kNONE_to_AUDIO = MUX_A(CM_ASYNCAPB, 7),
X    kNONE_to_AUDIO = (((31) << 0) | ((7 + 1) << 8)),
N
N    kMAIN_CLK_to_SPIFI_CLK = MUX_A(CM_SPIFICLKSEL, 0),
X    kMAIN_CLK_to_SPIFI_CLK = (((8) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_SPIFI_CLK = MUX_A(CM_SPIFICLKSEL, 1),
X    kSYS_PLL_to_SPIFI_CLK = (((8) << 0) | ((1 + 1) << 8)),
N    kUSB_PLL_to_SPIFI_CLK = MUX_A(CM_SPIFICLKSEL, 2),
X    kUSB_PLL_to_SPIFI_CLK = (((8) << 0) | ((2 + 1) << 8)),
N    kFRO_HF_to_SPIFI_CLK = MUX_A(CM_SPIFICLKSEL, 3),
X    kFRO_HF_to_SPIFI_CLK = (((8) << 0) | ((3 + 1) << 8)),
N    kAUDIO_PLL_to_SPIFI_CLK = MUX_A(CM_SPIFICLKSEL, 4),
X    kAUDIO_PLL_to_SPIFI_CLK = (((8) << 0) | ((4 + 1) << 8)),
N    kNONE_to_SPIFI_CLK = MUX_A(CM_SPIFICLKSEL, 7),
X    kNONE_to_SPIFI_CLK = (((8) << 0) | ((7 + 1) << 8)),
N
N    kFRO_HF_to_ADC_CLK = MUX_A(CM_ADCASYNCCLKSEL, 0),
X    kFRO_HF_to_ADC_CLK = (((9) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_ADC_CLK = MUX_A(CM_ADCASYNCCLKSEL, 1),
X    kSYS_PLL_to_ADC_CLK = (((9) << 0) | ((1 + 1) << 8)),
N    kUSB_PLL_to_ADC_CLK = MUX_A(CM_ADCASYNCCLKSEL, 2),
X    kUSB_PLL_to_ADC_CLK = (((9) << 0) | ((2 + 1) << 8)),
N    kAUDIO_PLL_to_ADC_CLK = MUX_A(CM_ADCASYNCCLKSEL, 3),
X    kAUDIO_PLL_to_ADC_CLK = (((9) << 0) | ((3 + 1) << 8)),
N    kNONE_to_ADC_CLK = MUX_A(CM_ADCASYNCCLKSEL, 7),
X    kNONE_to_ADC_CLK = (((9) << 0) | ((7 + 1) << 8)),
N
N    kFRO_HF_to_USB0_CLK = MUX_A(CM_USB0CLKSEL, 0),
X    kFRO_HF_to_USB0_CLK = (((10) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_USB0_CLK = MUX_A(CM_USB0CLKSEL, 1),
X    kSYS_PLL_to_USB0_CLK = (((10) << 0) | ((1 + 1) << 8)),
N    kUSB_PLL_to_USB0_CLK = MUX_A(CM_USB0CLKSEL, 2),
X    kUSB_PLL_to_USB0_CLK = (((10) << 0) | ((2 + 1) << 8)),
N    kNONE_to_USB0_CLK = MUX_A(CM_USB0CLKSEL, 7),
X    kNONE_to_USB0_CLK = (((10) << 0) | ((7 + 1) << 8)),
N
N    kFRO_HF_to_USB1_CLK = MUX_A(CM_USB1CLKSEL, 0),
X    kFRO_HF_to_USB1_CLK = (((11) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_USB1_CLK = MUX_A(CM_USB1CLKSEL, 1),
X    kSYS_PLL_to_USB1_CLK = (((11) << 0) | ((1 + 1) << 8)),
N    kUSB_PLL_to_USB1_CLK = MUX_A(CM_USB1CLKSEL, 2),
X    kUSB_PLL_to_USB1_CLK = (((11) << 0) | ((2 + 1) << 8)),
N    kNONE_to_USB1_CLK = MUX_A(CM_USB1CLKSEL, 7),
X    kNONE_to_USB1_CLK = (((11) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM0 = MUX_A(CM_FXCOMCLKSEL0, 0),
X    kFRO12M_to_FLEXCOMM0 = (((12) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM0 = MUX_A(CM_FXCOMCLKSEL0, 1),
X    kFRO_HF_to_FLEXCOMM0 = (((12) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM0 = MUX_A(CM_FXCOMCLKSEL0, 2),
X    kAUDIO_PLL_to_FLEXCOMM0 = (((12) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM0 = MUX_A(CM_FXCOMCLKSEL0, 3),
X    kMCLK_to_FLEXCOMM0 = (((12) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM0 = MUX_A(CM_FXCOMCLKSEL0, 4),
X    kFRG_to_FLEXCOMM0 = (((12) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM0 = MUX_A(CM_FXCOMCLKSEL0, 7),
X    kNONE_to_FLEXCOMM0 = (((12) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM1 = MUX_A(CM_FXCOMCLKSEL1, 0),
X    kFRO12M_to_FLEXCOMM1 = (((13) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM1 = MUX_A(CM_FXCOMCLKSEL1, 1),
X    kFRO_HF_to_FLEXCOMM1 = (((13) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM1 = MUX_A(CM_FXCOMCLKSEL1, 2),
X    kAUDIO_PLL_to_FLEXCOMM1 = (((13) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM1 = MUX_A(CM_FXCOMCLKSEL1, 3),
X    kMCLK_to_FLEXCOMM1 = (((13) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM1 = MUX_A(CM_FXCOMCLKSEL1, 4),
X    kFRG_to_FLEXCOMM1 = (((13) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM1 = MUX_A(CM_FXCOMCLKSEL1, 7),
X    kNONE_to_FLEXCOMM1 = (((13) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM2 = MUX_A(CM_FXCOMCLKSEL2, 0),
X    kFRO12M_to_FLEXCOMM2 = (((14) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM2 = MUX_A(CM_FXCOMCLKSEL2, 1),
X    kFRO_HF_to_FLEXCOMM2 = (((14) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM2 = MUX_A(CM_FXCOMCLKSEL2, 2),
X    kAUDIO_PLL_to_FLEXCOMM2 = (((14) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM2 = MUX_A(CM_FXCOMCLKSEL2, 3),
X    kMCLK_to_FLEXCOMM2 = (((14) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM2 = MUX_A(CM_FXCOMCLKSEL2, 4),
X    kFRG_to_FLEXCOMM2 = (((14) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM2 = MUX_A(CM_FXCOMCLKSEL2, 7),
X    kNONE_to_FLEXCOMM2 = (((14) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM3 = MUX_A(CM_FXCOMCLKSEL3, 0),
X    kFRO12M_to_FLEXCOMM3 = (((15) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM3 = MUX_A(CM_FXCOMCLKSEL3, 1),
X    kFRO_HF_to_FLEXCOMM3 = (((15) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM3 = MUX_A(CM_FXCOMCLKSEL3, 2),
X    kAUDIO_PLL_to_FLEXCOMM3 = (((15) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM3 = MUX_A(CM_FXCOMCLKSEL3, 3),
X    kMCLK_to_FLEXCOMM3 = (((15) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM3 = MUX_A(CM_FXCOMCLKSEL3, 4),
X    kFRG_to_FLEXCOMM3 = (((15) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM3 = MUX_A(CM_FXCOMCLKSEL3, 7),
X    kNONE_to_FLEXCOMM3 = (((15) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM4 = MUX_A(CM_FXCOMCLKSEL4, 0),
X    kFRO12M_to_FLEXCOMM4 = (((16) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM4 = MUX_A(CM_FXCOMCLKSEL4, 1),
X    kFRO_HF_to_FLEXCOMM4 = (((16) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM4 = MUX_A(CM_FXCOMCLKSEL4, 2),
X    kAUDIO_PLL_to_FLEXCOMM4 = (((16) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM4 = MUX_A(CM_FXCOMCLKSEL4, 3),
X    kMCLK_to_FLEXCOMM4 = (((16) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM4 = MUX_A(CM_FXCOMCLKSEL4, 4),
X    kFRG_to_FLEXCOMM4 = (((16) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM4 = MUX_A(CM_FXCOMCLKSEL4, 7),
X    kNONE_to_FLEXCOMM4 = (((16) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM5 = MUX_A(CM_FXCOMCLKSEL5, 0),
X    kFRO12M_to_FLEXCOMM5 = (((17) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM5 = MUX_A(CM_FXCOMCLKSEL5, 1),
X    kFRO_HF_to_FLEXCOMM5 = (((17) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM5 = MUX_A(CM_FXCOMCLKSEL5, 2),
X    kAUDIO_PLL_to_FLEXCOMM5 = (((17) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM5 = MUX_A(CM_FXCOMCLKSEL5, 3),
X    kMCLK_to_FLEXCOMM5 = (((17) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM5 = MUX_A(CM_FXCOMCLKSEL5, 4),
X    kFRG_to_FLEXCOMM5 = (((17) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM5 = MUX_A(CM_FXCOMCLKSEL5, 7),
X    kNONE_to_FLEXCOMM5 = (((17) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM6 = MUX_A(CM_FXCOMCLKSEL6, 0),
X    kFRO12M_to_FLEXCOMM6 = (((18) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM6 = MUX_A(CM_FXCOMCLKSEL6, 1),
X    kFRO_HF_to_FLEXCOMM6 = (((18) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM6 = MUX_A(CM_FXCOMCLKSEL6, 2),
X    kAUDIO_PLL_to_FLEXCOMM6 = (((18) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM6 = MUX_A(CM_FXCOMCLKSEL6, 3),
X    kMCLK_to_FLEXCOMM6 = (((18) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM6 = MUX_A(CM_FXCOMCLKSEL6, 4),
X    kFRG_to_FLEXCOMM6 = (((18) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM6 = MUX_A(CM_FXCOMCLKSEL6, 7),
X    kNONE_to_FLEXCOMM6 = (((18) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM7 = MUX_A(CM_FXCOMCLKSEL7, 0),
X    kFRO12M_to_FLEXCOMM7 = (((19) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM7 = MUX_A(CM_FXCOMCLKSEL7, 1),
X    kFRO_HF_to_FLEXCOMM7 = (((19) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM7 = MUX_A(CM_FXCOMCLKSEL7, 2),
X    kAUDIO_PLL_to_FLEXCOMM7 = (((19) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM7 = MUX_A(CM_FXCOMCLKSEL7, 3),
X    kMCLK_to_FLEXCOMM7 = (((19) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM7 = MUX_A(CM_FXCOMCLKSEL7, 4),
X    kFRG_to_FLEXCOMM7 = (((19) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM7 = MUX_A(CM_FXCOMCLKSEL7, 7),
X    kNONE_to_FLEXCOMM7 = (((19) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM8 = MUX_A(CM_FXCOMCLKSEL8, 0),
X    kFRO12M_to_FLEXCOMM8 = (((20) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM8 = MUX_A(CM_FXCOMCLKSEL8, 1),
X    kFRO_HF_to_FLEXCOMM8 = (((20) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM8 = MUX_A(CM_FXCOMCLKSEL8, 2),
X    kAUDIO_PLL_to_FLEXCOMM8 = (((20) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM8 = MUX_A(CM_FXCOMCLKSEL8, 3),
X    kMCLK_to_FLEXCOMM8 = (((20) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM8 = MUX_A(CM_FXCOMCLKSEL8, 4),
X    kFRG_to_FLEXCOMM8 = (((20) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM8 = MUX_A(CM_FXCOMCLKSEL8, 7),
X    kNONE_to_FLEXCOMM8 = (((20) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_FLEXCOMM9 = MUX_A(CM_FXCOMCLKSEL9, 0),
X    kFRO12M_to_FLEXCOMM9 = (((21) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_to_FLEXCOMM9 = MUX_A(CM_FXCOMCLKSEL9, 1),
X    kFRO_HF_to_FLEXCOMM9 = (((21) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_FLEXCOMM9 = MUX_A(CM_FXCOMCLKSEL9, 2),
X    kAUDIO_PLL_to_FLEXCOMM9 = (((21) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_FLEXCOMM9 = MUX_A(CM_FXCOMCLKSEL9, 3),
X    kMCLK_to_FLEXCOMM9 = (((21) << 0) | ((3 + 1) << 8)),
N    kFRG_to_FLEXCOMM9 = MUX_A(CM_FXCOMCLKSEL9, 4),
X    kFRG_to_FLEXCOMM9 = (((21) << 0) | ((4 + 1) << 8)),
N    kNONE_to_FLEXCOMM9 = MUX_A(CM_FXCOMCLKSEL9, 7),
X    kNONE_to_FLEXCOMM9 = (((21) << 0) | ((7 + 1) << 8)),
N
N    kFRO_HF_to_MCLK = MUX_A(CM_MCLKCLKSEL, 0),
X    kFRO_HF_to_MCLK = (((24) << 0) | ((0 + 1) << 8)),
N    kAUDIO_PLL_to_MCLK = MUX_A(CM_MCLKCLKSEL, 1),
X    kAUDIO_PLL_to_MCLK = (((24) << 0) | ((1 + 1) << 8)),
N    kNONE_to_MCLK = MUX_A(CM_MCLKCLKSEL, 7),
X    kNONE_to_MCLK = (((24) << 0) | ((7 + 1) << 8)),
N
N    kMAIN_CLK_to_FRG = MUX_A(CM_FRGCLKSEL, 0),
X    kMAIN_CLK_to_FRG = (((26) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_FRG = MUX_A(CM_FRGCLKSEL, 1),
X    kSYS_PLL_to_FRG = (((26) << 0) | ((1 + 1) << 8)),
N    kFRO12M_to_FRG = MUX_A(CM_FRGCLKSEL, 2),
X    kFRO12M_to_FRG = (((26) << 0) | ((2 + 1) << 8)),
N    kFRO_HF_to_FRG = MUX_A(CM_FRGCLKSEL, 3),
X    kFRO_HF_to_FRG = (((26) << 0) | ((3 + 1) << 8)),
N    kNONE_to_FRG = MUX_A(CM_FRGCLKSEL, 7),
X    kNONE_to_FRG = (((26) << 0) | ((7 + 1) << 8)),
N
N    kFRO12M_to_DMIC = MUX_A(CM_DMICCLKSEL, 0),
X    kFRO12M_to_DMIC = (((27) << 0) | ((0 + 1) << 8)),
N    kFRO_HF_DIV_to_DMIC = MUX_A(CM_DMICCLKSEL, 1),
X    kFRO_HF_DIV_to_DMIC = (((27) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_DMIC = MUX_A(CM_DMICCLKSEL, 2),
X    kAUDIO_PLL_to_DMIC = (((27) << 0) | ((2 + 1) << 8)),
N    kMCLK_to_DMIC = MUX_A(CM_DMICCLKSEL, 3),
X    kMCLK_to_DMIC = (((27) << 0) | ((3 + 1) << 8)),
N    kNONE_to_DMIC = MUX_A(CM_DMICCLKSEL, 7),
X    kNONE_to_DMIC = (((27) << 0) | ((7 + 1) << 8)),
N
N    kMCLK_to_SCT_CLK = MUX_A(CM_SCTCLKSEL, 0),
X    kMCLK_to_SCT_CLK = (((28) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_SCT_CLK = MUX_A(CM_SCTCLKSEL, 1),
X    kSYS_PLL_to_SCT_CLK = (((28) << 0) | ((1 + 1) << 8)),
N    kFRO_HF_to_SCT_CLK = MUX_A(CM_SCTCLKSEL, 2),
X    kFRO_HF_to_SCT_CLK = (((28) << 0) | ((2 + 1) << 8)),
N    kAUDIO_PLL_to_SCT_CLK = MUX_A(CM_SCTCLKSEL, 3),
X    kAUDIO_PLL_to_SCT_CLK = (((28) << 0) | ((3 + 1) << 8)),
N    kNONE_to_SCT_CLK = MUX_A(CM_SCTCLKSEL, 7),
X    kNONE_to_SCT_CLK = (((28) << 0) | ((7 + 1) << 8)),
N
N    kMCLK_to_SDIO_CLK = MUX_A(CM_SDIOCLKSEL, 0),
X    kMCLK_to_SDIO_CLK = (((30) << 0) | ((0 + 1) << 8)),
N    kSYS_PLL_to_SDIO_CLK = MUX_A(CM_SDIOCLKSEL, 1),
X    kSYS_PLL_to_SDIO_CLK = (((30) << 0) | ((1 + 1) << 8)),
N    kUSB_PLL_to_SDIO_CLK = MUX_A(CM_SDIOCLKSEL, 2),
X    kUSB_PLL_to_SDIO_CLK = (((30) << 0) | ((2 + 1) << 8)),
N    kFRO_HF_to_SDIO_CLK = MUX_A(CM_SDIOCLKSEL, 3),
X    kFRO_HF_to_SDIO_CLK = (((30) << 0) | ((3 + 1) << 8)),
N    kAUDIO_PLL_to_SDIO_CLK = MUX_A(CM_SDIOCLKSEL, 3),
X    kAUDIO_PLL_to_SDIO_CLK = (((30) << 0) | ((3 + 1) << 8)),
N    kNONE_to_SDIO_CLK = MUX_A(CM_SDIOCLKSEL, 7),
X    kNONE_to_SDIO_CLK = (((30) << 0) | ((7 + 1) << 8)),
N    
N    kMCLK_to_LCD_CLK = MUX_A(CM_LCDCLKSEL, 0),
X    kMCLK_to_LCD_CLK = (((29) << 0) | ((0 + 1) << 8)),
N    kLCDCLKIN_to_LCD_CLK = MUX_A(CM_LCDCLKSEL, 1),
X    kLCDCLKIN_to_LCD_CLK = (((29) << 0) | ((1 + 1) << 8)),
N    kFRO_HF_to_LCD_CLK = MUX_A(CM_LCDCLKSEL, 2),
X    kFRO_HF_to_LCD_CLK = (((29) << 0) | ((2 + 1) << 8)),
N    kNONE_to_LCD_CLK = MUX_A(CM_LCDCLKSEL, 3),
X    kNONE_to_LCD_CLK = (((29) << 0) | ((3 + 1) << 8)),
N    
N    kMAIN_CLK_to_ASYNC_APB = MUX_A(CM_ASYNCAPB, 0),
X    kMAIN_CLK_to_ASYNC_APB = (((31) << 0) | ((0 + 1) << 8)),
N    kFRO12M_to_ASYNC_APB = MUX_A(CM_ASYNCAPB, 1),
X    kFRO12M_to_ASYNC_APB = (((31) << 0) | ((1 + 1) << 8)),
N    kAUDIO_PLL_to_ASYNC_APB = MUX_A(CM_ASYNCAPB, 2),
X    kAUDIO_PLL_to_ASYNC_APB = (((31) << 0) | ((2 + 1) << 8)),
N    kI2C_CLK_FC6_to_ASYNC_APB = MUX_A(CM_ASYNCAPB, 3),
X    kI2C_CLK_FC6_to_ASYNC_APB = (((31) << 0) | ((3 + 1) << 8)),
N    kNONE_to_NONE = 0x80000000U,
N} clock_attach_id_t;
N
N/*  Clock dividers */
Ntypedef enum _clock_div_name
N{
N    kCLOCK_DivSystickClk = 0,
N    kCLOCK_DivArmTrClkDiv = 1,
N    kCLOCK_DivCan0Clk = 2,
N    kCLOCK_DivCan1Clk = 3,
N    kCLOCK_DivSmartCard0Clk = 4,
N    kCLOCK_DivSmartCard1Clk = 5,
N    kCLOCK_DivAhbClk = 32,
N    kCLOCK_DivClkOut = 33,
N    kCLOCK_DivFrohfClk = 34,
N    kCLOCK_DivSpifiClk = 36,
N    kCLOCK_DivAdcAsyncClk = 37,
N    kCLOCK_DivUsb0Clk = 38,
N    kCLOCK_DivUsb1Clk = 39,
N    kCLOCK_DivFrg = 40,
N    kCLOCK_DivDmicClk = 42,
N    kCLOCK_DivMClk = 43,
N    kCLOCK_DivLcdClk = 44,
N    kCLOCK_DivSctClk = 45,
N    kCLOCK_DivEmcClk = 46,
N    kCLOCK_DivSdioClk = 47
N} clock_div_name_t;
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif /* __cplusplus */
N
Nstatic inline void CLOCK_EnableClock(clock_ip_name_t clk)
N{
N    uint32_t index = CLK_GATE_ABSTRACT_REG_OFFSET(clk);
X    uint32_t index = (((uint32_t)(clk)&0xFFFFFF00U) >> 8U);
N    if (index < 3)
N    {
N        SYSCON->AHBCLKCTRLSET[index] = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
X        ((SYSCON_Type *)(0x40000000u))->AHBCLKCTRLSET[index] = (1U << (((uint32_t)(clk)&0x000000FFU) >> 0U));
N    }
N    else
N    {
N        SYSCON->ASYNCAPBCTRL = SYSCON_ASYNCAPBCTRL_ENABLE(1);
X        ((SYSCON_Type *)(0x40000000u))->ASYNCAPBCTRL = (((uint32_t)(((uint32_t)(1)) << (0U))) & (0x1U));
N        ASYNC_SYSCON->ASYNCAPBCLKCTRLSET = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
X        ((ASYNC_SYSCON_Type *)(0x40040000u))->ASYNCAPBCLKCTRLSET = (1U << (((uint32_t)(clk)&0x000000FFU) >> 0U));
N    }
N}
N
Nstatic inline void CLOCK_DisableClock(clock_ip_name_t clk)
N{
N    uint32_t index = CLK_GATE_ABSTRACT_REG_OFFSET(clk);
X    uint32_t index = (((uint32_t)(clk)&0xFFFFFF00U) >> 8U);
N    if (index < 3)
N    {
N        SYSCON->AHBCLKCTRLCLR[index] = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
X        ((SYSCON_Type *)(0x40000000u))->AHBCLKCTRLCLR[index] = (1U << (((uint32_t)(clk)&0x000000FFU) >> 0U));
N    }
N    else
N    {
N        ASYNC_SYSCON->ASYNCAPBCLKCTRLCLR = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
X        ((ASYNC_SYSCON_Type *)(0x40040000u))->ASYNCAPBCLKCTRLCLR = (1U << (((uint32_t)(clk)&0x000000FFU) >> 0U));
N        SYSCON->ASYNCAPBCTRL = SYSCON_ASYNCAPBCTRL_ENABLE(0);
X        ((SYSCON_Type *)(0x40000000u))->ASYNCAPBCTRL = (((uint32_t)(((uint32_t)(0)) << (0U))) & (0x1U));
N
N    }
N}
N/**
N * @brief FLASH Access time definitions
N */
Ntypedef enum _clock_flashtim
N{
N    kCLOCK_Flash1Cycle = 0, /*!< Flash accesses use 1 CPU clocks */
N    kCLOCK_Flash2Cycle,     /*!< Flash accesses use 2 CPU clocks */
N    kCLOCK_Flash3Cycle,     /*!< Flash accesses use 3 CPU clocks */
N    kCLOCK_Flash4Cycle,     /*!< Flash accesses use 4 CPU clocks */
N    kCLOCK_Flash5Cycle,     /*!< Flash accesses use 5 CPU clocks */
N    kCLOCK_Flash6Cycle,     /*!< Flash accesses use 6 CPU clocks */
N    kCLOCK_Flash7Cycle,     /*!< Flash accesses use 7 CPU clocks */
N    kCLOCK_Flash8Cycle,     /*!< Flash accesses use 8 CPU clocks */
N    kCLOCK_Flash9Cycle      /*!< Flash accesses use 9 CPU clocks */
N} clock_flashtim_t;
N
N/**
N * @brief	Set FLASH memory access time in clocks
N * @param	clks	: Clock cycles for FLASH access
N * @return	Nothing
N */
Nstatic inline void CLOCK_SetFLASHAccessCycles(clock_flashtim_t clks)
N{
N    uint32_t tmp;
N
N    tmp = SYSCON->FLASHCFG & ~(SYSCON_FLASHCFG_FLASHTIM_MASK);
X    tmp = ((SYSCON_Type *)(0x40000000u))->FLASHCFG & ~((0xF000U));
N
N    /* Don't alter lower bits */
N    SYSCON->FLASHCFG = tmp | ((uint32_t)clks << SYSCON_FLASHCFG_FLASHTIM_SHIFT);
X    ((SYSCON_Type *)(0x40000000u))->FLASHCFG = tmp | ((uint32_t)clks << (12U));
N}
N
N/**
N * @brief	Initialize the Core clock to given frequency (12, 48 or 96 MHz).
N * Turns on FRO and uses default CCO, if freq is 12000000, then high speed output is off, else high speed output is
N * enabled.
N * @param	iFreq	: Desired frequency (must be one of #CLK_FRO_12MHZ or #CLK_FRO_48MHZ or #CLK_FRO_96MHZ)
N * @return	returns success or fail status.
N */
Nstatus_t CLOCK_SetupFROClocking(uint32_t iFreq);
N/**
N * @brief	Configure the clock selection muxes.
N * @param	connection	: Clock to be configured.
N * @return	Nothing
N */
Nvoid CLOCK_AttachClk(clock_attach_id_t connection);
N/**
N * @brief	Setup peripheral clock dividers.
N * @param	div_name	: Clock divider name
N * @param divided_by_value: Value to be divided
N * @param reset :  Whether to reset the divider counter.
N * @return	Nothing
N */
Nvoid CLOCK_SetClkDiv(clock_div_name_t div_name, uint32_t divided_by_value, bool reset);
Xvoid CLOCK_SetClkDiv(clock_div_name_t div_name, uint32_t divided_by_value, _Bool reset);
N/**
N * @brief	Set the flash wait states for the input freuqency.
N * @param	iFreq	: Input frequency
N * @return	Nothing
N */
Nvoid CLOCK_SetFLASHAccessCyclesForFreq(uint32_t iFreq);
N/*! @brief	Return Frequency of selected clock
N *  @return	Frequency of selected clock
N */
Nuint32_t CLOCK_GetFreq(clock_name_t clockName);
N/*! @brief	Return Frequency of FRO 12MHz
N *  @return	Frequency of FRO 12MHz
N */
Nuint32_t CLOCK_GetFro12MFreq(void);
N/*! @brief	Return Frequency of ClockOut
N *  @return	Frequency of ClockOut
N */
Nuint32_t CLOCK_GetClockOutClkFreq(void);
N/*! @brief	Return Frequency of Spifi Clock
N *  @return	Frequency of Spifi.
N */
Nuint32_t CLOCK_GetSpifiClkFreq(void);
N/*! @brief	Return Frequency of Adc Clock
N *  @return	Frequency of Adc Clock.
N */
Nuint32_t CLOCK_GetAdcClkFreq(void);
N/*! @brief	Return Frequency of Usb0 Clock
N *  @return	Frequency of Usb0 Clock.
N */
Nuint32_t CLOCK_GetUsb0ClkFreq(void);
N/*! @brief	Return Frequency of Usb1 Clock
N *  @return	Frequency of Usb1 Clock.
N */
Nuint32_t CLOCK_GetUsb1ClkFreq(void);
N/*! @brief	Return Frequency of MClk Clock
N *  @return	Frequency of MClk Clock.
N */
Nuint32_t CLOCK_GetMclkClkFreq(void);
N/*! @brief	Return Frequency of SCTimer Clock
N *  @return	Frequency of SCTimer Clock.
N */
Nuint32_t CLOCK_GetSctClkFreq(void);
N/*! @brief	Return Frequency of SDIO Clock
N *  @return	Frequency of SDIO Clock.
N */
Nuint32_t CLOCK_GetSdioClkFreq(void);
N/*! @brief	Return Frequency of LCD Clock
N *  @return	Frequency of LCD Clock.
N */
Nuint32_t CLOCK_GetLcdClkFreq(void);
N/*! @brief	Return Frequency of LCD CLKIN Clock
N *  @return	Frequency of LCD CLKIN Clock.
N */
Nuint32_t CLOCK_GetLcdClkIn(void);
N/*! @brief	Return Frequency of External Clock
N *  @return	Frequency of External Clock. If no external clock is used returns 0.
N */
Nuint32_t CLOCK_GetExtClkFreq(void);
N/*! @brief	Return Frequency of Watchdog Oscillator
N *  @return	Frequency of Watchdog Oscillator
N */
Nuint32_t CLOCK_GetWdtOscFreq(void);
N/*! @brief	Return Frequency of High-Freq output of FRO
N *  @return	Frequency of High-Freq output of FRO
N */
Nuint32_t CLOCK_GetFroHfFreq(void);
N/*! @brief	Return Frequency of PLL
N *  @return	Frequency of PLL
N */
Nuint32_t CLOCK_GetPllOutFreq(void);
N/*! @brief	Return Frequency of USB PLL
N *  @return	Frequency of PLL
N */
Nuint32_t CLOCK_GetUsbPllOutFreq(void);
N/*! @brief	Return Frequency of AUDIO PLL
N *  @return	Frequency of PLL
N */
Nuint32_t CLOCK_GetAudioPllOutFreq(void);
N/*! @brief	Return Frequency of 32kHz osc
N *  @return	Frequency of 32kHz osc
N */
Nuint32_t CLOCK_GetOsc32KFreq(void);
N/*! @brief	Return Frequency of Core System
N *  @return	Frequency of Core System
N */
Nuint32_t CLOCK_GetCoreSysClkFreq(void);
N/*! @brief	Return Frequency of I2S MCLK Clock
N *  @return	Frequency of I2S MCLK Clock
N */
Nuint32_t CLOCK_GetI2SMClkFreq(void);
N/*! @brief	Return Frequency of Flexcomm functional Clock
N *  @return	Frequency of Flexcomm functional Clock
N */
Nuint32_t CLOCK_GetFlexCommClkFreq(uint32_t id);
N/*! @brief	Return Asynchronous APB Clock source
N *  @return	Asynchronous APB CLock source
N */
N__STATIC_INLINE async_clock_src_t CLOCK_GetAsyncApbClkSrc(void)
Xstatic __inline async_clock_src_t CLOCK_GetAsyncApbClkSrc(void)
N{
N    return (async_clock_src_t)(ASYNC_SYSCON->ASYNCAPBCLKSELA & 0x3);
X    return (async_clock_src_t)(((ASYNC_SYSCON_Type *)(0x40040000u))->ASYNCAPBCLKSELA & 0x3);
N}
N/*! @brief	Return Frequency of Asynchronous APB Clock
N *  @return	Frequency of Asynchronous APB Clock Clock
N */
Nuint32_t CLOCK_GetAsyncApbClkFreq(void);
N/*! @brief	Return Audio PLL input clock rate
N *  @return	Audio PLL input clock rate
N */
Nuint32_t CLOCK_GetAudioPLLInClockRate(void);
N/*! @brief	Return System PLL input clock rate
N *  @return	System PLL input clock rate
N */
Nuint32_t CLOCK_GetSystemPLLInClockRate(void);
N
N/*! @brief	Return System PLL output clock rate
N *  @param	recompute	: Forces a PLL rate recomputation if true
N *  @return	System PLL output clock rate
N *  @note	The PLL rate is cached in the driver in a variable as
N *  the rate computation function can take some time to perform. It
N *  is recommended to use 'false' with the 'recompute' parameter.
N */
Nuint32_t CLOCK_GetSystemPLLOutClockRate(bool recompute);
Xuint32_t CLOCK_GetSystemPLLOutClockRate(_Bool recompute);
N
N/*! @brief	Return System AUDIO PLL output clock rate
N *  @param	recompute	: Forces a AUDIO PLL rate recomputation if true
N *  @return	System AUDIO PLL output clock rate
N *  @note	The AUDIO PLL rate is cached in the driver in a variable as
N *  the rate computation function can take some time to perform. It
N *  is recommended to use 'false' with the 'recompute' parameter.
N */
Nuint32_t CLOCK_GetAudioPLLOutClockRate(bool recompute);
Xuint32_t CLOCK_GetAudioPLLOutClockRate(_Bool recompute);
N
N/*! @brief	Return System USB PLL output clock rate
N *  @param	recompute	: Forces a USB PLL rate recomputation if true
N *  @return	System USB PLL output clock rate
N *  @note	The USB PLL rate is cached in the driver in a variable as
N *  the rate computation function can take some time to perform. It
N *  is recommended to use 'false' with the 'recompute' parameter.
N */
Nuint32_t CLOCK_GetUSbPLLOutClockRate(bool recompute);
Xuint32_t CLOCK_GetUSbPLLOutClockRate(_Bool recompute);
N
N/*! @brief	Enables and disables PLL bypass mode
N *  @brief	bypass	: true to bypass PLL (PLL output = PLL input, false to disable bypass
N *  @return	System PLL output clock rate
N */
N__STATIC_INLINE void CLOCK_SetBypassPLL(bool bypass)
Xstatic __inline void CLOCK_SetBypassPLL(_Bool bypass)
N{
N    if (bypass)
N    {
N        SYSCON->SYSPLLCTRL |= (1UL << SYSCON_SYSPLLCTRL_BYPASS_SHIFT);
X        ((SYSCON_Type *)(0x40000000u))->SYSPLLCTRL |= (1UL << (15U));
N    }
N    else
N    {
N        SYSCON->SYSPLLCTRL &= ~(1UL << SYSCON_SYSPLLCTRL_BYPASS_SHIFT);
X        ((SYSCON_Type *)(0x40000000u))->SYSPLLCTRL &= ~(1UL << (15U));
N    }
N}
N
N/*! @brief	Check if PLL is locked or not
N *  @return	true if the PLL is locked, false if not locked
N */
N__STATIC_INLINE bool CLOCK_IsSystemPLLLocked(void)
Xstatic __inline _Bool CLOCK_IsSystemPLLLocked(void)
N{
N    return (bool)((SYSCON->SYSPLLSTAT & SYSCON_SYSPLLSTAT_LOCK_MASK) != 0);
X    return (_Bool)((((SYSCON_Type *)(0x40000000u))->SYSPLLSTAT & (0x1U)) != 0);
N}
N
N/*! @brief	Check if USB PLL is locked or not
N *  @return	true if the USB PLL is locked, false if not locked
N */
N__STATIC_INLINE bool CLOCK_IsUsbPLLLocked(void)
Xstatic __inline _Bool CLOCK_IsUsbPLLLocked(void)
N{
N    return (bool)((SYSCON->USBPLLSTAT & SYSCON_USBPLLSTAT_LOCK_MASK) != 0);
X    return (_Bool)((((SYSCON_Type *)(0x40000000u))->USBPLLSTAT & (0x1U)) != 0);
N}
N
N/*! @brief	Check if AUDIO PLL is locked or not
N *  @return	true if the AUDIO PLL is locked, false if not locked
N */
N__STATIC_INLINE bool CLOCK_IsAudioPLLLocked(void)
Xstatic __inline _Bool CLOCK_IsAudioPLLLocked(void)
N{
N    return (bool)((SYSCON->AUDPLLSTAT & SYSCON_AUDPLLSTAT_LOCK_MASK) != 0);
X    return (_Bool)((((SYSCON_Type *)(0x40000000u))->AUDPLLSTAT & (0x1U)) != 0);
N}
N
N/*! @brief	Enables and disables SYS OSC
N *  @brief	enable	: true to enable SYS OSC, false to disable SYS OSC
N*/
N__STATIC_INLINE  void CLOCK_Enable_SysOsc(bool enable)
Xstatic __inline  void CLOCK_Enable_SysOsc(_Bool enable)
N{
N    if(enable)
N    {
N        SYSCON->PDRUNCFGCLR[0] |= SYSCON_PDRUNCFG_PDEN_VD2_ANA_MASK;
X        ((SYSCON_Type *)(0x40000000u))->PDRUNCFGCLR[0] |= (0x200U);
N        SYSCON->PDRUNCFGCLR[1] |= SYSCON_PDRUNCFG_PDEN_SYSOSC_MASK;
X        ((SYSCON_Type *)(0x40000000u))->PDRUNCFGCLR[1] |= (0x8U);
N    }
N    
N    else
N    {
N        SYSCON->PDRUNCFGSET[0] = SYSCON_PDRUNCFG_PDEN_VD2_ANA_MASK; 
X        ((SYSCON_Type *)(0x40000000u))->PDRUNCFGSET[0] = (0x200U); 
N        SYSCON->PDRUNCFGSET[1] = SYSCON_PDRUNCFG_PDEN_SYSOSC_MASK;
X        ((SYSCON_Type *)(0x40000000u))->PDRUNCFGSET[1] = (0x8U);
N
N    }
N}
N
N/*! @brief Store the current PLL rate
N *  @param	rate: Current rate of the PLL
N *  @return	Nothing
N **/
Nvoid CLOCK_SetStoredPLLClockRate(uint32_t rate);
N
N/*! @brief Store the current AUDIO PLL rate
N *  @param	rate: Current rate of the PLL
N *  @return	Nothing
N **/
Nvoid CLOCK_SetStoredAudioPLLClockRate(uint32_t rate);
N
N/*! @brief PLL configuration structure flags for 'flags' field
N * These flags control how the PLL configuration function sets up the PLL setup structure.<br>
N *
N * When the PLL_CONFIGFLAG_USEINRATE flag is selected, the 'InputRate' field in the
N * configuration structure must be assigned with the expected PLL frequency. If the
N * PLL_CONFIGFLAG_USEINRATE is not used, 'InputRate' is ignored in the configuration
N * function and the driver will determine the PLL rate from the currently selected
N * PLL source. This flag might be used to configure the PLL input clock more accurately
N * when using the WDT oscillator or a more dyanmic CLKIN source.<br>
N *
N * When the PLL_CONFIGFLAG_FORCENOFRACT flag is selected, the PLL hardware for the
N * automatic bandwidth selection, Spread Spectrum (SS) support, and fractional M-divider
N * are not used.<br>
N */
N#define PLL_CONFIGFLAG_USEINRATE (1 << 0) /*!< Flag to use InputRate in PLL configuration structure for setup */
N#define PLL_CONFIGFLAG_FORCENOFRACT                                                                                    \
N    (1                                                                                                                 \
N     << 2) /*!< Force non-fractional output mode, PLL output will not use the fractional, automatic bandwidth, or SS \ \
N                \ \ \                                                                                                                     \
N                  \ \ \ \ \                                                                                                                     \
N                    \ \ \ \ \ \ \                                                                                                                     \
N                      hardware */
X#define PLL_CONFIGFLAG_FORCENOFRACT                                                                                        (1                                                                                                                      << 2)  
N
N/*! @brief PLL Spread Spectrum (SS) Programmable modulation frequency
N * See (MF) field in the SYSPLLSSCTRL1 register in the UM.
N */
Ntypedef enum _ss_progmodfm
N{
N    kSS_MF_512 = (0 << 20), /*!< Nss = 512 (fm ? 3.9 - 7.8 kHz) */
N    kSS_MF_384 = (1 << 20), /*!< Nss ?= 384 (fm ? 5.2 - 10.4 kHz) */
N    kSS_MF_256 = (2 << 20), /*!< Nss = 256 (fm ? 7.8 - 15.6 kHz) */
N    kSS_MF_128 = (3 << 20), /*!< Nss = 128 (fm ? 15.6 - 31.3 kHz) */
N    kSS_MF_64 = (4 << 20),  /*!< Nss = 64 (fm ? 32.3 - 64.5 kHz) */
N    kSS_MF_32 = (5 << 20),  /*!< Nss = 32 (fm ? 62.5- 125 kHz) */
N    kSS_MF_24 = (6 << 20),  /*!< Nss ?= 24 (fm ? 83.3- 166.6 kHz) */
N    kSS_MF_16 = (7 << 20)   /*!< Nss = 16 (fm ? 125- 250 kHz) */
N} ss_progmodfm_t;
N
N/*! @brief PLL Spread Spectrum (SS) Programmable frequency modulation depth
N * See (MR) field in the SYSPLLSSCTRL1 register in the UM.
N */
Ntypedef enum _ss_progmoddp
N{
N    kSS_MR_K0 = (0 << 23),   /*!< k = 0 (no spread spectrum) */
N    kSS_MR_K1 = (1 << 23),   /*!< k = 1 */
N    kSS_MR_K1_5 = (2 << 23), /*!< k = 1.5 */
N    kSS_MR_K2 = (3 << 23),   /*!< k = 2 */
N    kSS_MR_K3 = (4 << 23),   /*!< k = 3 */
N    kSS_MR_K4 = (5 << 23),   /*!< k = 4 */
N    kSS_MR_K6 = (6 << 23),   /*!< k = 6 */
N    kSS_MR_K8 = (7 << 23)    /*!< k = 8 */
N} ss_progmoddp_t;
N
N/*! @brief PLL Spread Spectrum (SS) Modulation waveform control
N * See (MC) field in the SYSPLLSSCTRL1 register in the UM.<br>
N * Compensation for low pass filtering of the PLL to get a triangular
N * modulation at the output of the PLL, giving a flat frequency spectrum.
N */
Ntypedef enum _ss_modwvctrl
N{
N    kSS_MC_NOC = (0 << 26),  /*!< no compensation */
N    kSS_MC_RECC = (2 << 26), /*!< recommended setting */
N    kSS_MC_MAXC = (3 << 26), /*!< max. compensation */
N} ss_modwvctrl_t;
N
N/*! @brief PLL configuration structure
N *
N * This structure can be used to configure the settings for a PLL
N * setup structure. Fill in the desired configuration for the PLL
N * and call the PLL setup function to fill in a PLL setup structure.
N */
Ntypedef struct _pll_config
N{
N    uint32_t desiredRate; /*!< Desired PLL rate in Hz */
N    uint32_t inputRate;   /*!< PLL input clock in Hz, only used if PLL_CONFIGFLAG_USEINRATE flag is set */
N    uint32_t flags;       /*!< PLL configuration flags, Or'ed value of PLL_CONFIGFLAG_* definitions */
N    ss_progmodfm_t ss_mf; /*!< SS Programmable modulation frequency, only applicable when not using
N                             PLL_CONFIGFLAG_FORCENOFRACT flag */
N    ss_progmoddp_t ss_mr; /*!< SS Programmable frequency modulation depth, only applicable when not using
N                             PLL_CONFIGFLAG_FORCENOFRACT flag */
N    ss_modwvctrl_t
N        ss_mc; /*!< SS Modulation waveform control, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
N    bool mfDither; /*!< false for fixed modulation frequency or true for dithering, only applicable when not using
X    _Bool mfDither; 
N                      PLL_CONFIGFLAG_FORCENOFRACT flag */
N
N} pll_config_t;
N
N/*! @brief PLL setup structure flags for 'flags' field
N* These flags control how the PLL setup function sets up the PLL
N*/
N#define PLL_SETUPFLAG_POWERUP (1 << 0)  /*!< Setup will power on the PLL after setup */
N#define PLL_SETUPFLAG_WAITLOCK (1 << 1) /*!< Setup will wait for PLL lock, implies the PLL will be pwoered on */
N#define PLL_SETUPFLAG_ADGVOLT (1 << 2)  /*!< Optimize system voltage for the new PLL rate */
N
N/*! @brief PLL setup structure
N* This structure can be used to pre-build a PLL setup configuration
N* at run-time and quickly set the PLL to the configuration. It can be
N* populated with the PLL setup function. If powering up or waiting
N* for PLL lock, the PLL input clock source should be configured prior
N* to PLL setup.
N*/
Ntypedef struct _pll_setup
N{
N    uint32_t syspllctrl;      /*!< PLL control register SYSPLLCTRL */
N    uint32_t syspllndec;      /*!< PLL NDEC register SYSPLLNDEC */
N    uint32_t syspllpdec;      /*!< PLL PDEC register SYSPLLPDEC */
N    uint32_t syspllmdec;      /*!< PLL MDEC registers SYSPLLPDEC */
N    uint32_t pllRate;         /*!< Acutal PLL rate */
N    uint32_t flags;           /*!< PLL setup flags, Or'ed value of PLL_SETUPFLAG_* definitions */
N} pll_setup_t;
N
N/*! @brief PLL status definitions
N */
Ntypedef enum _pll_error
N{
N    kStatus_PLL_Success = MAKE_STATUS(kStatusGroup_Generic, 0),         /*!< PLL operation was successful */
X    kStatus_PLL_Success = ((((kStatusGroup_Generic)*100) + (0))),          
N    kStatus_PLL_OutputTooLow = MAKE_STATUS(kStatusGroup_Generic, 1),    /*!< PLL output rate request was too low */
X    kStatus_PLL_OutputTooLow = ((((kStatusGroup_Generic)*100) + (1))),     
N    kStatus_PLL_OutputTooHigh = MAKE_STATUS(kStatusGroup_Generic, 2),   /*!< PLL output rate request was too high */
X    kStatus_PLL_OutputTooHigh = ((((kStatusGroup_Generic)*100) + (2))),    
N    kStatus_PLL_InputTooLow = MAKE_STATUS(kStatusGroup_Generic, 3),     /*!< PLL input rate is too low */
X    kStatus_PLL_InputTooLow = ((((kStatusGroup_Generic)*100) + (3))),      
N    kStatus_PLL_InputTooHigh = MAKE_STATUS(kStatusGroup_Generic, 4),    /*!< PLL input rate is too high */
X    kStatus_PLL_InputTooHigh = ((((kStatusGroup_Generic)*100) + (4))),     
N    kStatus_PLL_OutsideIntLimit = MAKE_STATUS(kStatusGroup_Generic, 5), /*!< Requested output rate isn't possible */
X    kStatus_PLL_OutsideIntLimit = ((((kStatusGroup_Generic)*100) + (5))),  
N    kStatus_PLL_CCOTooLow = MAKE_STATUS(kStatusGroup_Generic, 6),       /*!< Requested CCO rate isn't possible */
X    kStatus_PLL_CCOTooLow = ((((kStatusGroup_Generic)*100) + (6))),        
N    kStatus_PLL_CCOTooHigh = MAKE_STATUS(kStatusGroup_Generic, 7)       /*!< Requested CCO rate isn't possible */
X    kStatus_PLL_CCOTooHigh = ((((kStatusGroup_Generic)*100) + (7)))        
N} pll_error_t;
N
N/*! @brief USB clock source definition. */
Ntypedef enum _clock_usb_src
N{
N    kCLOCK_UsbSrcFro = (uint32_t)kCLOCK_FroHf,            /*!< Use FRO 96 or 48 MHz. */
N    kCLOCK_UsbSrcSystemPll = (uint32_t)kCLOCK_PllOut,     /*!< Use System PLL output. */
N    kCLOCK_UsbSrcMainClock = (uint32_t)kCLOCK_CoreSysClk, /*!< Use Main clock.    */
N    kCLOCK_UsbSrcUsbPll = (uint32_t)kCLOCK_UsbPll,        /*!< Use USB PLL clock.    */
N
N    kCLOCK_UsbSrcNone = SYSCON_USB0CLKSEL_SEL(7)          /*!< Use None, this may be selected in order to reduce power when no output is needed.. */
X    kCLOCK_UsbSrcNone = (((uint32_t)(((uint32_t)(7)) << (0U))) & (0x7U))           
N} clock_usb_src_t;
N
N/*! @brief USB PDEL Divider. */
Ntypedef enum _usb_pll_psel
N{
N    pSel_Divide_1 = 0U,
N    pSel_Divide_2,
N    pSel_Divide_4,
N    pSel_Divide_8
N}usb_pll_psel;
N
N/*! @brief PLL setup structure
N* This structure can be used to pre-build a USB PLL setup configuration
N* at run-time and quickly set the usb PLL to the configuration. It can be
N* populated with the USB PLL setup function. If powering up or waiting
N* for USB PLL lock, the PLL input clock source should be configured prior
N* to USB PLL setup.
N*/
Ntypedef struct _usb_pll_setup
N{
N  uint8_t msel;           /*!< USB PLL control register msel:1U-256U */
N  uint8_t psel;           /*!< USB PLL control register psel:only support inter 1U 2U 4U 8U */
N  uint8_t nsel;           /*!< USB PLL control register nsel:only suppoet inter 1U 2U 3U 4U */
N  bool direct;            /*!< USB PLL CCO output control */
X  _Bool direct;             
N  bool bypass;            /*!< USB PLL inout clock bypass control  */
X  _Bool bypass;             
N  bool fbsel;             /*!< USB PLL ineter mode and non-integer mode control*/
X  _Bool fbsel;              
N  uint32_t inputRate;     /*!< USB PLL input rate */
N} usb_pll_setup_t;
N
N/*! @brief	Return System PLL output clock rate from setup structure
N *  @param	pSetup	: Pointer to a PLL setup structure
N *  @return	System PLL output clock rate the setup structure will generate
N */
Nuint32_t CLOCK_GetSystemPLLOutFromSetup(pll_setup_t *pSetup);
N
N/*! @brief	Return System AUDIO PLL output clock rate from setup structure
N *  @param	pSetup	: Pointer to a PLL setup structure
N *  @return	System PLL output clock rate the setup structure will generate
N */
Nuint32_t CLOCK_GetAudioPLLOutFromSetup(pll_setup_t *pSetup);
N
N/*! @brief	Return System USB PLL output clock rate from setup structure
N *  @param	pSetup	: Pointer to a PLL setup structure
N *  @return	System PLL output clock rate the setup structure will generate
N */
Nuint32_t CLOCK_GetUsbPLLOutFromSetup(const usb_pll_setup_t *pSetup);
N
N/*! @brief	Set PLL output based on the passed PLL setup data
N *  @param	pControl	: Pointer to populated PLL control structure to generate setup with
N *  @param	pSetup		: Pointer to PLL setup structure to be filled
N *  @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N *  @note	Actual frequency for setup may vary from the desired frequency based on the
N *  accuracy of input clocks, rounding, non-fractional PLL mode, etc.
N */
Npll_error_t CLOCK_SetupPLLData(pll_config_t *pControl, pll_setup_t *pSetup);
N
N/*! @brief	Set AUDIO PLL output based on the passed AUDIO PLL setup data
N *  @param	pControl	: Pointer to populated PLL control structure to generate setup with
N *  @param	pSetup		: Pointer to PLL setup structure to be filled
N *  @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N *  @note	Actual frequency for setup may vary from the desired frequency based on the
N *  accuracy of input clocks, rounding, non-fractional PLL mode, etc.
N */
Npll_error_t CLOCK_SetupAudioPLLData(pll_config_t *pControl, pll_setup_t *pSetup);
N
N/*! @brief	Set PLL output from PLL setup structure (precise frequency)
N * @param	pSetup	: Pointer to populated PLL setup structure
N* @param flagcfg : Flag configuration for PLL config structure
N * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N * @note	This function will power off the PLL, setup the PLL with the
N * new setup data, and then optionally powerup the PLL, wait for PLL lock,
N * and adjust system voltages to the new PLL rate. The function will not
N * alter any source clocks (ie, main systen clock) that may use the PLL,
N * so these should be setup prior to and after exiting the function.
N */
Npll_error_t CLOCK_SetupSystemPLLPrec(pll_setup_t *pSetup, uint32_t flagcfg);
N
N/*! @brief	Set AUDIO PLL output from AUDIOPLL setup structure (precise frequency)
N * @param	pSetup	: Pointer to populated PLL setup structure
N* @param flagcfg : Flag configuration for PLL config structure
N * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N * @note	This function will power off the PLL, setup the PLL with the
N * new setup data, and then optionally powerup the AUDIO PLL, wait for PLL lock,
N * and adjust system voltages to the new AUDIOPLL rate. The function will not
N * alter any source clocks (ie, main systen clock) that may use the AUDIO PLL,
N * so these should be setup prior to and after exiting the function.
N */
Npll_error_t CLOCK_SetupAudioPLLPrec(pll_setup_t *pSetup, uint32_t flagcfg);
N
N/**
N * @brief	Set PLL output from PLL setup structure (precise frequency)
N * @param	pSetup	: Pointer to populated PLL setup structure
N * @return	kStatus_PLL_Success on success, or PLL setup error code
N * @note	This function will power off the PLL, setup the PLL with the
N * new setup data, and then optionally powerup the PLL, wait for PLL lock,
N * and adjust system voltages to the new PLL rate. The function will not
N * alter any source clocks (ie, main systen clock) that may use the PLL,
N * so these should be setup prior to and after exiting the function.
N */
Npll_error_t CLOCK_SetPLLFreq(const pll_setup_t *pSetup);
N
N/**
N * @brief	Set USB PLL output from USB PLL setup structure (precise frequency)
N * @param	pSetup	: Pointer to populated USB PLL setup structure
N * @return	kStatus_PLL_Success on success, or USB PLL setup error code
N * @note	This function will power off the USB PLL, setup the PLL with the
N * new setup data, and then optionally powerup the USB PLL, wait for USB PLL lock,
N * and adjust system voltages to the new USB PLL rate. The function will not
N * alter any source clocks (ie, usb pll clock) that may use the USB PLL,
N * so these should be setup prior to and after exiting the function.
N */
Npll_error_t CLOCK_SetUsbPLLFreq(const usb_pll_setup_t *pSetup);
N
N/*! @brief	Set PLL output based on the multiplier and input frequency
N * @param	multiply_by	: multiplier
N * @param	input_freq	: Clock input frequency of the PLL
N * @return	Nothing
N * @note	Unlike the Chip_Clock_SetupSystemPLLPrec() function, this
N * function does not disable or enable PLL power, wait for PLL lock,
N * or adjust system voltages. These must be done in the application.
N * The function will not alter any source clocks (ie, main systen clock)
N * that may use the PLL, so these should be setup prior to and after
N * exiting the function.
N */
Nvoid CLOCK_SetupSystemPLLMult(uint32_t multiply_by, uint32_t input_freq);
N
N/*! @brief Disable USB clock.
N *
N * Disable USB clock.
N */
Nstatic inline void CLOCK_DisableUsbDevicefs0Clock(clock_ip_name_t clk)
N{
N    CLOCK_DisableClock(clk);
N}
N
N/*! @brief Enable USB Device FS clock.
N * @param	src	: clock source
N * @param	freq: clock frequency
N * Enable USB Device Full Speed clock.
N */
Nbool CLOCK_EnableUsbfs0DeviceClock(clock_usb_src_t src, uint32_t freq);
X_Bool CLOCK_EnableUsbfs0DeviceClock(clock_usb_src_t src, uint32_t freq);
N
N/*! @brief Enable USB HOST FS clock.
N * @param	src	: clock source
N * @param	freq: clock frequency
N * Enable USB HOST Full Speed clock.
N */
Nbool CLOCK_EnableUsbfs0HostClock(clock_usb_src_t src, uint32_t freq);
X_Bool CLOCK_EnableUsbfs0HostClock(clock_usb_src_t src, uint32_t freq);
N
N/*! @brief Enable USB Device HS clock.
N * @param	src	: clock source
N * @param	freq: clock frequency
N * Enable USB Device High Speed clock.
N */
Nbool CLOCK_EnableUsbhs0DeviceClock(clock_usb_src_t src, uint32_t freq);
X_Bool CLOCK_EnableUsbhs0DeviceClock(clock_usb_src_t src, uint32_t freq);
N
N/*! @brief Enable USB HOST HS clock.
N * @param	src	: clock source
N * @param	freq: clock frequency
N * Enable USB HOST High Speed clock.
N */
Nbool CLOCK_EnableUsbhs0HostClock(clock_usb_src_t src, uint32_t freq);
X_Bool CLOCK_EnableUsbhs0HostClock(clock_usb_src_t src, uint32_t freq);
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif /* __cplusplus */
N
N/*! @} */
N
N#endif /* _FSL_CLOCK_H_ */
L 137 ".\SRC\Drivers\fsl_common.h" 2
N
N/*
N * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a peripheral
N */
N#if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
N     (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
X#if ((1L && ((1) > 0)) ||      (1L && ((1) > 0)))
N#include "fsl_reset.h"
L 1 ".\SRC\Drivers\fsl_reset.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _FSL_RESET_H_
N#define _FSL_RESET_H_
N
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
S#   define __assert_h
S#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
S#define __ARMCLIB_VERSION 5060019
S#   ifndef __ARM_PROMISE
S#      define __ARM_PROMISE __promise
S#   endif
S#   undef __CLIBNS
S#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
S#   else
S#       define __CLIBNS
S#   endif  /* __cplusplus */
S    extern _ARMABI_NORETURN void abort(void);
S    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
S#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
S#   endif
N#else
N#   undef assert
N#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 35 ".\SRC\Drivers\fsl_reset.h" 2
N#include <stdbool.h>
N#include <stdint.h>
N#include <string.h>
N#include "fsl_device_registers.h"
N
N/*!
N * @addtogroup ksdk_common
N * @{
N */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*!
N * @brief Enumeration for peripheral reset control bits
N *
N * Defines the enumeration for peripheral reset control bits in PRESETCTRL/ASYNCPRESETCTRL registers
N */
Ntypedef enum _SYSCON_RSTn
N{
N    kFLASH_RST_SHIFT_RSTn = 0 | 7U,          /**< Flash controller reset control */
N    kFMC_RST_SHIFT_RSTn = 0 | 8U,            /**< Flash accelerator reset control */
N    kEEPROM_RST_SHIFT_RSTn = 0 | 9U,         /**< EEPROM reset control */
N    kSPIFI_RST_SHIFT_RSTn = 0 | 10U,         /**< SPIFI reset control */
N    kMUX_RST_SHIFT_RSTn = 0 | 11U,           /**< Input mux reset control */
N    kIOCON_RST_SHIFT_RSTn = 0 | 13U,         /**< IOCON reset control */
N    kGPIO0_RST_SHIFT_RSTn = 0 | 14U,         /**< GPIO0 reset control */
N    kGPIO1_RST_SHIFT_RSTn = 0 | 15U,         /**< GPIO1 reset control */
N    kGPIO2_RST_SHIFT_RSTn = 0 | 16U,         /**< GPIO2 reset control */
N    kGPIO3_RST_SHIFT_RSTn = 0 | 17U,         /**< GPIO3 reset control */
N    kPINT_RST_SHIFT_RSTn = 0 | 18U,          /**< Pin interrupt (PINT) reset control */
N    kGINT_RST_SHIFT_RSTn = 0 | 19U,          /**< Grouped interrupt (PINT) reset control. */
N    kDMA_RST_SHIFT_RSTn = 0 | 20U,           /**< DMA reset control */
N    kCRC_RST_SHIFT_RSTn = 0 | 21U,           /**< CRC reset control */
N    kWWDT_RST_SHIFT_RSTn = 0 | 22U,          /**< Watchdog timer reset control */
N    kADC0_RST_SHIFT_RSTn = 0 | 27U,          /**< ADC0 reset control */
N    
N    kMRT_RST_SHIFT_RSTn = 65536 | 0U,        /**< Multi-rate timer (MRT) reset control */
N    kSCT0_RST_SHIFT_RSTn = 65536 | 2U,       /**< SCTimer/PWM 0 (SCT0) reset control */
N    kMCAN0_RST_SHIFT_RSTn = 65536 | 7U,      /**< MCAN0 reset control */
N    kMCAN1_RST_SHIFT_RSTn = 65536 | 8U,      /**< MCAN1 reset control */
N    kUTICK_RST_SHIFT_RSTn = 65536 | 10U,     /**< Micro-tick timer reset control */
N    kFC0_RST_SHIFT_RSTn = 65536 | 11U,       /**< Flexcomm Interface 0 reset control */
N    kFC1_RST_SHIFT_RSTn = 65536 | 12U,       /**< Flexcomm Interface 1 reset control */
N    kFC2_RST_SHIFT_RSTn = 65536 | 13U,       /**< Flexcomm Interface 2 reset control */
N    kFC3_RST_SHIFT_RSTn = 65536 | 14U,       /**< Flexcomm Interface 3 reset control */
N    kFC4_RST_SHIFT_RSTn = 65536 | 15U,       /**< Flexcomm Interface 4 reset control */
N    kFC5_RST_SHIFT_RSTn = 65536 | 16U,       /**< Flexcomm Interface 5 reset control */
N    kFC6_RST_SHIFT_RSTn = 65536 | 17U,       /**< Flexcomm Interface 6 reset control */
N    kFC7_RST_SHIFT_RSTn = 65536 | 18U,       /**< Flexcomm Interface 7 reset control */
N    kDMIC_RST_SHIFT_RSTn = 65536 | 19U,      /**< Digital microphone interface reset control */
N    kCT32B2_RST_SHIFT_RSTn = 65536 | 22U,    /**< CT32B2 reset control */
N    kUSB0D_RST_SHIFT_RSTn = 65536 | 25U,     /**< USB0D reset control */
N    kCT32B0_RST_SHIFT_RSTn = 65536 | 26U,    /**< CT32B0 reset control */
N    kCT32B1_RST_SHIFT_RSTn = 65536 | 27U,    /**< CT32B1 reset control */
N    
N    kLCD_RST_SHIFT_RSTn = 131072 | 2U,       /**< LCD reset control */
N    kSDIO_RST_SHIFT_RSTn = 131072 | 3U,      /**< SDIO reset control */
N    kUSB1H_RST_SHIFT_RSTn = 131072 | 4U,     /**< USB1H reset control */
N    kUSB1D_RST_SHIFT_RSTn = 131072 | 5U,     /**< USB1D reset control */    
N    kUSB1RAM_RST_SHIFT_RSTn = 131072 | 6U,   /**< USB1RAM reset control */
N    kEMC_RST_SHIFT_RSTn = 131072 | 7U,       /**< EMC reset control */
N    kETH_RST_SHIFT_RSTn = 131072 | 8U,       /**< ETH reset control */
N    kGPIO4_RST_SHIFT_RSTn = 131072 | 9U,     /**< GPIO4 reset control */ 
N    kGPIO5_RST_SHIFT_RSTn = 131072 | 10U,    /**< GPIO5 reset control */
N    kAES_RST_SHIFT_RSTn = 131072 | 11U,      /**< AES reset control */
N    kOTP_RST_SHIFT_RSTn = 131072 | 12U,      /**< OTP reset control */
N    kRNG_RST_SHIFT_RSTn = 131072 | 13U,      /**< RNG  reset control */ 
N    kFC8_RST_SHIFT_RSTn = 131072 | 14U,      /**< Flexcomm Interface 8 reset control */
N    kFC9_RST_SHIFT_RSTn = 131072 | 15U,      /**< Flexcomm Interface 9 reset control */
N    kUSB0HMR_RST_SHIFT_RSTn = 131072 | 16U,  /**< USB0HMR reset control */
N    kUSB0HSL_RST_SHIFT_RSTn = 131072 | 17U,  /**< USB0HSL reset control */
N    kSHA_RST_SHIFT_RSTn = 131072 | 18U,      /**< SHA reset control */
N    kSC0_RST_SHIFT_RSTn = 131072 | 19U,      /**< SC0 reset control */
N    kSC1_RST_SHIFT_RSTn = 131072 | 20U,      /**< SC1 reset control */
N    
N    kCT32B3_RST_SHIFT_RSTn = 67108864 | 13U, /**< CT32B3 reset control */
N    kCT32B4_RST_SHIFT_RSTn = 67108864 | 14U, /**< CT32B4 reset control */
N} SYSCON_RSTn_t;
N
N/** Array initializers with peripheral reset bits **/
N#define ADC_RSTS             \
N    {                        \
N        kADC0_RST_SHIFT_RSTn \
N    } /* Reset bits for ADC peripheral */
X#define ADC_RSTS                 {                                kADC0_RST_SHIFT_RSTn     }  
N#define AES_RSTS             \
N    {                        \
N        kAES_RST_SHIFT_RSTn  \
N    } /* Reset bits for AES peripheral */
X#define AES_RSTS                 {                                kAES_RST_SHIFT_RSTn      }  
N#define CRC_RSTS            \
N    {                       \
N        kCRC_RST_SHIFT_RSTn \
N    } /* Reset bits for CRC peripheral */
X#define CRC_RSTS                {                               kCRC_RST_SHIFT_RSTn     }  
N#define CTIMER_RSTS                                                                                     \
N    {                                                                                                   \
N        kCT32B0_RST_SHIFT_RSTn, kCT32B1_RST_SHIFT_RSTn, kCT32B2_RST_SHIFT_RSTn, kCT32B3_RST_SHIFT_RSTn, \
N            kCT32B4_RST_SHIFT_RSTn                                                                      \
N    } /* Reset bits for CTIMER peripheral */
X#define CTIMER_RSTS                                                                                         {                                                                                                           kCT32B0_RST_SHIFT_RSTn, kCT32B1_RST_SHIFT_RSTn, kCT32B2_RST_SHIFT_RSTn, kCT32B3_RST_SHIFT_RSTn,             kCT32B4_RST_SHIFT_RSTn                                                                          }  
N#define DMA_RSTS            \
N    {                       \
N        kDMA_RST_SHIFT_RSTn \
N    } /* Reset bits for DMA peripheral */
X#define DMA_RSTS                {                               kDMA_RST_SHIFT_RSTn     }  
N#define DMIC_RSTS            \
N    {                        \
N        kDMIC_RST_SHIFT_RSTn \
N    } /* Reset bits for DMIC peripheral */
X#define DMIC_RSTS                {                                kDMIC_RST_SHIFT_RSTn     }  
N#define EMC_RSTS             \
N    {                        \
N        kEMC_RST_SHIFT_RSTn  \
N    } /* Reset bits for EMC peripheral */
X#define EMC_RSTS                 {                                kEMC_RST_SHIFT_RSTn      }  
N#define ETH_RST              \
N    {                        \
N        kETH_RST_SHIFT_RSTn  \
N    } /* Reset bits for EMC peripheral */
X#define ETH_RST                  {                                kETH_RST_SHIFT_RSTn      }  
N#define FLEXCOMM_RSTS                                                                                            \
N    {                                                                                                            \
N        kFC0_RST_SHIFT_RSTn, kFC1_RST_SHIFT_RSTn, kFC2_RST_SHIFT_RSTn, kFC3_RST_SHIFT_RSTn, kFC4_RST_SHIFT_RSTn, \
N            kFC5_RST_SHIFT_RSTn, kFC6_RST_SHIFT_RSTn, kFC7_RST_SHIFT_RSTn, kFC8_RST_SHIFT_RSTn, kFC9_RST_SHIFT_RSTn                                       \
N    } /* Reset bits for FLEXCOMM peripheral */
X#define FLEXCOMM_RSTS                                                                                                {                                                                                                                    kFC0_RST_SHIFT_RSTn, kFC1_RST_SHIFT_RSTn, kFC2_RST_SHIFT_RSTn, kFC3_RST_SHIFT_RSTn, kFC4_RST_SHIFT_RSTn,             kFC5_RST_SHIFT_RSTn, kFC6_RST_SHIFT_RSTn, kFC7_RST_SHIFT_RSTn, kFC8_RST_SHIFT_RSTn, kFC9_RST_SHIFT_RSTn                                           }  
N#define GINT_RSTS                                  \
N    {                                              \
N        kGINT_RST_SHIFT_RSTn, kGINT_RST_SHIFT_RSTn \
N    } /* Reset bits for GINT peripheral. GINT0 & GINT1 share same slot */
X#define GINT_RSTS                                      {                                                      kGINT_RST_SHIFT_RSTn, kGINT_RST_SHIFT_RSTn     }  
N#define GPIO_RSTS                                    \
N    {                                                \
N        kGPIO0_RST_SHIFT_RSTn, kGPIO1_RST_SHIFT_RSTn, kGPIO2_RST_SHIFT_RSTn, kGPIO3_RST_SHIFT_RSTn,  \
N        kGPIO4_RST_SHIFT_RSTn, kGPIO5_RST_SHIFT_RSTn                                                 \
N    } /* Reset bits for GPIO peripheral */
X#define GPIO_RSTS                                        {                                                        kGPIO0_RST_SHIFT_RSTn, kGPIO1_RST_SHIFT_RSTn, kGPIO2_RST_SHIFT_RSTn, kGPIO3_RST_SHIFT_RSTn,          kGPIO4_RST_SHIFT_RSTn, kGPIO5_RST_SHIFT_RSTn                                                     }  
N#define INPUTMUX_RSTS       \
N    {                       \
N        kMUX_RST_SHIFT_RSTn \
N    } /* Reset bits for INPUTMUX peripheral */
X#define INPUTMUX_RSTS           {                               kMUX_RST_SHIFT_RSTn     }  
N#define IOCON_RSTS            \
N    {                         \
N        kIOCON_RST_SHIFT_RSTn \
N    } /* Reset bits for IOCON peripheral */
X#define IOCON_RSTS                {                                 kIOCON_RST_SHIFT_RSTn     }  
N#define FLASH_RSTS                                 \
N    {                                              \
N        kFLASH_RST_SHIFT_RSTn, kFMC_RST_SHIFT_RSTn \
N    } /* Reset bits for Flash peripheral */
X#define FLASH_RSTS                                     {                                                      kFLASH_RST_SHIFT_RSTn, kFMC_RST_SHIFT_RSTn     }  
N#define LCD_RSTS                                 \
N    {                                            \
N        kLCD_RST_SHIFT_RSTn                      \
N    } /* Reset bits for LCD peripheral */
X#define LCD_RSTS                                     {                                                    kLCD_RST_SHIFT_RSTn                          }  
N#define MRT_RSTS            \
N    {                       \
N        kMRT_RST_SHIFT_RSTn \
N    } /* Reset bits for MRT peripheral */
X#define MRT_RSTS                {                               kMRT_RST_SHIFT_RSTn     }  
N#define MCAN_RSTS                                   \
N    {                                               \
N        kMCAN0_RST_SHIFT_RSTn,kMCAN1_RST_SHIFT_RSTn \
N    } /* Reset bits for MCAN0&MACN1 peripheral */
X#define MCAN_RSTS                                       {                                                       kMCAN0_RST_SHIFT_RSTn,kMCAN1_RST_SHIFT_RSTn     }  
N#define OTP_RSTS            \
N    {                       \
N        kOTP_RST_SHIFT_RSTn \
N    } /* Reset bits for OTP peripheral */
X#define OTP_RSTS                {                               kOTP_RST_SHIFT_RSTn     }  
N#define PINT_RSTS            \
N    {                        \
N        kPINT_RST_SHIFT_RSTn \
N    } /* Reset bits for PINT peripheral */
X#define PINT_RSTS                {                                kPINT_RST_SHIFT_RSTn     }  
N#define RNG_RSTS             \
N    {                        \
N        kRNG_RST_SHIFT_RSTn  \
N    } /* Reset bits for RNG peripheral */
X#define RNG_RSTS                 {                                kRNG_RST_SHIFT_RSTn      }  
N#define SDIO_RST             \
N    {                        \
N        kSDIO_RST_SHIFT_RSTn \
N    } /* Reset bits for SDIO peripheral */
X#define SDIO_RST                 {                                kSDIO_RST_SHIFT_RSTn     }  
N#define SCT_RSTS             \
N    {                        \
N        kSCT0_RST_SHIFT_RSTn \
N    } /* Reset bits for SCT peripheral */
X#define SCT_RSTS                 {                                kSCT0_RST_SHIFT_RSTn     }  
N#define SHA_RST              \
N    {                        \
N        kSHA_RST_SHIFT_RSTn  \
N    } /* Reset bits for SHA peripheral */
X#define SHA_RST                  {                                kSHA_RST_SHIFT_RSTn      }  
N#define USB0D_RST             \
N    {                         \
N        kUSB0D_RST_SHIFT_RSTn \
N    } /* Reset bits for USB0D peripheral */
X#define USB0D_RST                 {                                 kUSB0D_RST_SHIFT_RSTn     }  
N#define USB0HMR_RST             \
N    {                           \
N        kUSB0HMR_RST_SHIFT_RSTn \
N    } /* Reset bits for USB0HMR peripheral */
X#define USB0HMR_RST                 {                                   kUSB0HMR_RST_SHIFT_RSTn     }  
N#define USB0HSL_RST             \
N    {                           \
N        kUSB0HSL_RST_SHIFT_RSTn \
N    } /* Reset bits for USB0HSL peripheral */
X#define USB0HSL_RST                 {                                   kUSB0HSL_RST_SHIFT_RSTn     }  
N#define USB1H_RST             \
N    {                         \
N        kUSB1H_RST_SHIFT_RSTn \
N    } /* Reset bits for USB1H peripheral */
X#define USB1H_RST                 {                                 kUSB1H_RST_SHIFT_RSTn     }  
N#define USB1D_RST             \
N    {                         \
N        kUSB1D_RST_SHIFT_RSTn \
N    } /* Reset bits for USB1D peripheral */
X#define USB1D_RST                 {                                 kUSB1D_RST_SHIFT_RSTn     }  
N#define USB1RAM_RST             \
N    {                           \
N        kUSB1RAM_RST_SHIFT_RSTn \
N    } /* Reset bits for USB1RAM peripheral */
X#define USB1RAM_RST                 {                                   kUSB1RAM_RST_SHIFT_RSTn     }  
N#define UTICK_RSTS            \
N    {                         \
N        kUTICK_RST_SHIFT_RSTn \
N    } /* Reset bits for UTICK peripheral */
X#define UTICK_RSTS                {                                 kUTICK_RST_SHIFT_RSTn     }  
N#define WWDT_RSTS            \
N    {                        \
N        kWWDT_RST_SHIFT_RSTn \
N    } /* Reset bits for WWDT peripheral */
X#define WWDT_RSTS                {                                kWWDT_RST_SHIFT_RSTn     }  
N
Ntypedef SYSCON_RSTn_t reset_ip_name_t;
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*!
N * @brief Assert reset to peripheral.
N *
N * Asserts reset signal to specified peripheral module.
N *
N * @param peripheral Assert reset to this peripheral. The enum argument contains encoding of reset register
N *                   and reset bit position in the reset register.
N */
Nvoid RESET_SetPeripheralReset(reset_ip_name_t peripheral);
N
N/*!
N * @brief Clear reset to peripheral.
N *
N * Clears reset signal to specified peripheral module, allows it to operate.
N *
N * @param peripheral Clear reset to this peripheral. The enum argument contains encoding of reset register
N *                   and reset bit position in the reset register.
N */
Nvoid RESET_ClearPeripheralReset(reset_ip_name_t peripheral);
N
N/*!
N * @brief Reset peripheral module.
N *
N * Reset peripheral module.
N *
N * @param peripheral Peripheral to reset. The enum argument contains encoding of reset register
N *                   and reset bit position in the reset register.
N */
Nvoid RESET_PeripheralReset(reset_ip_name_t peripheral);
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N/*! @} */
N
N#endif /* _FSL_RESET_H_ */
L 144 ".\SRC\Drivers\fsl_common.h" 2
N#endif
N
N/*! @name Min/max macros */
N/* @{ */
N#if !defined(MIN)
X#if !0L
N#define MIN(a, b) ((a) < (b) ? (a) : (b))
N#endif
N
N#if !defined(MAX)
X#if !0L
N#define MAX(a, b) ((a) > (b) ? (a) : (b))
N#endif
N/* @} */
N
N/*! @brief Computes the number of elements in an array. */
N#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
N
N/*! @name UINT16_MAX/UINT32_MAX value */
N/* @{ */
N#if !defined(UINT16_MAX)
X#if !1L
S#define UINT16_MAX ((uint16_t)-1)
N#endif
N
N#if !defined(UINT32_MAX)
X#if !1L
S#define UINT32_MAX ((uint32_t)-1)
N#endif
N/* @} */
N
N/*! @name Timer utilities */
N/* @{ */
N/*! Macro to convert a microsecond period to raw count value */
N#define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
N/*! Macro to convert a raw count value to microsecond */
N#define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
N
N/*! Macro to convert a millisecond period to raw count value */
N#define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
N/*! Macro to convert a raw count value to millisecond */
N#define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
N/* @} */
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*!
N * @brief Enable specific interrupt.
N *
N * Enable the interrupt not routed from intmux.
N *
N * @param interrupt The IRQ number.
N */
Nstatic inline void EnableIRQ(IRQn_Type interrupt)
N{
N    if (NotAvail_IRQn == interrupt)
N    {
N        return;
N    }
N
N#if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
X#if 0L && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
S    if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
N#endif
N    {
N        NVIC_EnableIRQ(interrupt);
N    }
N}
N
N/*!
N * @brief Disable specific interrupt.
N *
N * Disable the interrupt not routed from intmux.
N *
N * @param interrupt The IRQ number.
N */
Nstatic inline void DisableIRQ(IRQn_Type interrupt)
N{
N    if (NotAvail_IRQn == interrupt)
N    {
N        return;
N    }
N
N#if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
X#if 0L && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
S    if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
N#endif
N    {
N        NVIC_DisableIRQ(interrupt);
N    }
N}
N
N/*!
N * @brief Disable the global IRQ
N *
N * Disable the global interrupt and return the current primask register. User is required to provided the primask
N * register for the EnableGlobalIRQ().
N *
N * @return Current primask value.
N */
Nstatic inline uint32_t DisableGlobalIRQ(void)
N{
N    uint32_t regPrimask = __get_PRIMASK();
N
N    __disable_irq();
N
N    return regPrimask;
N}
N
N/*!
N * @brief Enaable the global IRQ
N *
N * Set the primask register with the provided primask value but not just enable the primask. The idea is for the
N * convinience of integration of RTOS. some RTOS get its own management mechanism of primask. User is required to
N * use the EnableGlobalIRQ() and DisableGlobalIRQ() in pair.
N *
N * @param primask value of primask register to be restored. The primask value is supposed to be provided by the
N * DisableGlobalIRQ().
N */
Nstatic inline void EnableGlobalIRQ(uint32_t primask)
N{
N    __set_PRIMASK(primask);
N}
N
N/*!
N * @brief install IRQ handler
N *
N * @param irq IRQ number
N * @param irqHandler IRQ handler address
N * @return The old IRQ handler address
N */
Nuint32_t InstallIRQHandler(IRQn_Type irq, uint32_t irqHandler);
N
N#if (defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0))
X#if (1L && ((1) > 0))
N/*!
N * @brief Enable specific interrupt for wake-up from deep-sleep mode.
N *
N * Enable the interrupt for wake-up from deep sleep mode.
N * Some interrupts are typically used in sleep mode only and will not occur during
N * deep-sleep mode because relevant clocks are stopped. However, it is possible to enable
N * those clocks (significantly increasing power consumption in the reduced power mode),
N * making these wake-ups possible.
N *
N * @note This function also enables the interrupt in the NVIC (EnableIRQ() is called internally).
N *
N * @param interrupt The IRQ number.
N */
Nvoid EnableDeepSleepIRQ(IRQn_Type interrupt);
N
N/*!
N * @brief Disable specific interrupt for wake-up from deep-sleep mode.
N *
N * Disable the interrupt for wake-up from deep sleep mode.
N * Some interrupts are typically used in sleep mode only and will not occur during
N * deep-sleep mode because relevant clocks are stopped. However, it is possible to enable
N * those clocks (significantly increasing power consumption in the reduced power mode),
N * making these wake-ups possible.
N *
N * @note This function also disables the interrupt in the NVIC (DisableIRQ() is called internally).
N *
N * @param interrupt The IRQ number.
N */
Nvoid DisableDeepSleepIRQ(IRQn_Type interrupt);
N#endif /* FSL_FEATURE_SOC_SYSCON_COUNT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N/*! @} */
N
N#endif /* _FSL_COMMON_H_ */
L 36 ".\SRC\Board\board.h" 2
N#include "fsl_gpio.h"
L 1 ".\SRC\Drivers\fsl_gpio.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SDRVL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _LPC_GPIO_H_
N#define _LPC_GPIO_H_
N
N#include "fsl_common.h"
N
N/*!
N * @addtogroup lpc_gpio
N * @{
N */
N
N/*! @file */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @name Driver version */
N/*@{*/
N/*! @brief LPC GPIO driver version 2.0.0. */
N#define FSL_GPIO_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
N/*@}*/
N
N/*! @brief LPC GPIO direction definition */
Ntypedef enum _gpio_pin_direction
N{
N    kGPIO_DigitalInput = 0U,  /*!< Set current pin as digital input*/
N    kGPIO_DigitalOutput = 1U, /*!< Set current pin as digital output*/
N} gpio_pin_direction_t;
N
N/*!
N * @brief The GPIO pin configuration structure.
N *
N * Every pin can only be configured as either output pin or input pin at a time.
N * If configured as a input pin, then leave the outputConfig unused.
N */
Ntypedef struct _gpio_pin_config
N{
N    gpio_pin_direction_t pinDirection; /*!< GPIO direction, input or output */
N    /* Output configurations, please ignore if configured as a input one */
N    uint8_t outputLogic; /*!< Set default output logic, no use in input */
N} gpio_pin_config_t;
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*! @name GPIO Configuration */
N/*@{*/
N
N/*!
N * @brief Initializes a GPIO pin used by the board.
N *
N * To initialize the GPIO, define a pin configuration, either input or output, in the user file.
N * Then, call the GPIO_PinInit() function.
N *
N * This is an example to define an input pin or output pin configuration:
N * @code
N * // Define a digital input pin configuration,
N * gpio_pin_config_t config =
N * {
N *   kGPIO_DigitalInput,
N *   0,
N * }
N * //Define a digital output pin configuration,
N * gpio_pin_config_t config =
N * {
N *   kGPIO_DigitalOutput,
N *   0,
N * }
N * @endcode
N *
N * @param base   GPIO peripheral base pointer(Typically GPIO)
N * @param port   GPIO port number
N * @param pin    GPIO pin number
N * @param config GPIO pin configuration pointer
N */
Nvoid GPIO_PinInit(GPIO_Type *base, uint32_t port, uint32_t pin, const gpio_pin_config_t *config);
N
N/*@}*/
N
N/*! @name GPIO Output Operations */
N/*@{*/
N
N/*!
N * @brief Sets the output level of the one GPIO pin to the logic 1 or 0.
N *
N * @param base    GPIO peripheral base pointer(Typically GPIO)
N * @param port   GPIO port number
N * @param pin    GPIO pin number
N * @param output  GPIO pin output logic level.
N *        - 0: corresponding pin output low-logic level.
N *        - 1: corresponding pin output high-logic level.
N */
Nstatic inline void GPIO_WritePinOutput(GPIO_Type *base, uint32_t port, uint32_t pin, uint8_t output)
N{
N    base->B[port][pin] = output;
N}
N/*@}*/
N/*! @name GPIO Input Operations */
N/*@{*/
N
N/*!
N * @brief Reads the current input value of the GPIO PIN.
N *
N * @param base GPIO peripheral base pointer(Typically GPIO)
N * @param port   GPIO port number
N * @param pin    GPIO pin number
N * @retval GPIO port input value
N *        - 0: corresponding pin input low-logic level.
N *        - 1: corresponding pin input high-logic level.
N */
Nstatic inline uint32_t GPIO_ReadPinInput(GPIO_Type *base, uint32_t port, uint32_t pin)
N{
N    return (uint32_t)base->B[port][pin];
N}
N/*@}*/
N
N/*!
N * @brief Sets the output level of the multiple GPIO pins to the logic 1.
N *
N * @param base GPIO peripheral base pointer(Typically GPIO)
N * @param port GPIO port number
N * @param mask GPIO pin number macro
N */
Nstatic inline void GPIO_SetPinsOutput(GPIO_Type *base, uint32_t port, uint32_t mask)
N{
N    base->SET[port] = mask;
N}
N
N/*!
N * @brief Sets the output level of the multiple GPIO pins to the logic 0.
N *
N * @param base GPIO peripheral base pointer(Typically GPIO)
N * @param port GPIO port number
N * @param mask GPIO pin number macro
N */
Nstatic inline void GPIO_ClearPinsOutput(GPIO_Type *base, uint32_t port, uint32_t mask)
N{
N    base->CLR[port] = mask;
N}
N
N/*!
N * @brief Reverses current output logic of the multiple GPIO pins.
N *
N * @param base GPIO peripheral base pointer(Typically GPIO)
N * @param port GPIO port number
N * @param mask GPIO pin number macro
N */
Nstatic inline void GPIO_TogglePinsOutput(GPIO_Type *base, uint32_t port, uint32_t mask)
N{
N    base->NOT[port] = mask;
N}
N/*@}*/
N
N/*!
N * @brief Reads the current input value of the whole GPIO port.
N *
N * @param base GPIO peripheral base pointer(Typically GPIO)
N * @param port GPIO port number
N */
Nstatic inline uint32_t GPIO_ReadPinsInput(GPIO_Type *base, uint32_t port)
N{
N    return (uint32_t)base->PIN[port];
N}
N
N/*@}*/
N/*! @name GPIO Mask Operations */
N/*@{*/
N
N/*!
N * @brief Sets port mask, 0 - enable pin, 1 - disable pin.
N *
N * @param base GPIO peripheral base pointer(Typically GPIO)
N * @param port GPIO port number
N * @param mask GPIO pin number macro
N */
Nstatic inline void GPIO_SetPortMask(GPIO_Type *base, uint32_t port, uint32_t mask)
N{
N    base->MASK[port] = mask;
N}
N
N/*!
N * @brief Sets the output level of the masked GPIO port. Only pins enabled by GPIO_SetPortMask() will be affected.
N *
N * @param base    GPIO peripheral base pointer(Typically GPIO)
N * @param port   GPIO port number
N * @param output  GPIO port output value.
N */
Nstatic inline void GPIO_WriteMPort(GPIO_Type *base, uint32_t port, uint32_t output)
N{
N    base->MPIN[port] = output;
N}
N
N/*!
N * @brief Reads the current input value of the masked GPIO port. Only pins enabled by GPIO_SetPortMask() will be
N * affected.
N *
N * @param base   GPIO peripheral base pointer(Typically GPIO)
N * @param port   GPIO port number
N * @retval       masked GPIO port value
N */
Nstatic inline uint32_t GPIO_ReadMPort(GPIO_Type *base, uint32_t port)
N{
N    return (uint32_t)base->MPIN[port];
N}
N
N/*@}*/
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N/*!
N * @}
N */
N
N#endif /* _LPC_GPIO_H_*/
L 37 ".\SRC\Board\board.h" 2
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N/*! @brief The board name */
N#define BOARD_NAME "LPCXPRESSO54608"
N
N#define BOARD_EXTCLKINRATE (0)
N
N/*! @brief The UART to use for debug messages. */
N/* TODO: rename UART to USART */
N#define BOARD_DEBUG_UART_TYPE DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM
N#define BOARD_DEBUG_UART_BASEADDR (uint32_t) USART0
N#define BOARD_DEBUG_UART_CLK_FREQ CLOCK_GetFreq(kCLOCK_Flexcomm0)
N#define BOARD_DEBUG_UART_CLK_ATTACH kFRO12M_to_FLEXCOMM0
N#define BOARD_DEBUG_UART_RST kFC0_RST_SHIFT_RSTn
N#define BOARD_DEBUG_UART_CLKSRC kCLOCK_Flexcomm0
N#define BOARD_UART_IRQ_HANDLER FLEXCOMM0_IRQHandler
N#define BOARD_UART_IRQ FLEXCOMM0_IRQn
N/* TODO: obsolete */
N#define BOARD_DEBUG_SPI_CLK_FREQ 12000000
N
N#ifndef BOARD_DEBUG_UART_BAUDRATE
N#define BOARD_DEBUG_UART_BAUDRATE 115200
N#endif /* BOARD_DEBUG_UART_BAUDRATE */
N
N#define BOARD_LED1_GPIO GPIO
N#define BOARD_LED1_GPIO_PORT 3U
N#define BOARD_LED1_GPIO_PIN 14U
N#define BOARD_LED2_GPIO GPIO
N#define BOARD_LED2_GPIO_PORT 3U
N#define BOARD_LED2_GPIO_PIN 3U
N#define BOARD_LED3_GPIO GPIO
N#define BOARD_LED3_GPIO_PORT 2U
N#define BOARD_LED3_GPIO_PIN 2U
N
N#define BOARD_SW1_GPIO GPIO
N#define BOARD_SW1_GPIO_PORT 0U
N#define BOARD_SW1_GPIO_PIN 4U
N#define BOARD_SW1_NAME "SW1"
N#define BOARD_SW3_IRQ PIN_INT0_IRQn
N#define BOARD_SW3_IRQ_HANDLER PIN_INT0_IRQHandler
N
N#define BOARD_SW2_GPIO GPIO
N#define BOARD_SW2_GPIO_PORT 0U
N#define BOARD_SW2_GPIO_PIN 6U
N#define BOARD_SW2_NAME "SW2"
N#define BOARD_SW2_IRQ PIN_INT0_IRQn
N#define BOARD_SW2_IRQ_HANDLER PIN_INT0_IRQHandler
N
N#define BOARD_SW3_GPIO GPIO
N#define BOARD_SW3_GPIO_PORT 0U
N#define BOARD_SW3_GPIO_PIN 5U
N#define BOARD_SW3_NAME "SW3"
N#define BOARD_SW3_IRQ PIN_INT0_IRQn
N#define BOARD_SW3_IRQ_HANDLER PIN_INT0_IRQHandler
N#define BOARD_SW3_GPIO_PININT_INDEX 0
N
N#define BOARD_SW4_GPIO GPIO
N#define BOARD_SW4_GPIO_PORT 0U
N#define BOARD_SW4_GPIO_PIN 4U
N#define BOARD_SW4_NAME "SW4"
N#define BOARD_SW4_IRQ PIN_INT0_IRQn
N#define BOARD_SW4_IRQ_HANDLER PIN_INT0_IRQHandler
N#define BOARD_SW4_GPIO_PININT_INDEX 0
N
N#define BOARD_SW5_GPIO GPIO
N#define BOARD_SW5_GPIO_PORT 1U
N#define BOARD_SW5_GPIO_PIN 1U
N#define BOARD_SW5_NAME "SW5"
N#define BOARD_SW5_IRQ PIN_INT1_IRQn
N#define BOARD_SW5_IRQ_HANDLER PIN_INT1_IRQHandler
N#define BOARD_SW5_GPIO_PININT_INDEX 0
N
N#define BOARD_SDIF_BASEADDR SDIF
N#define BOARD_SDIF_CLKSRC kCLOCK_SDio
N#define BOARD_SDIF_CLK_ATTACH kMCLK_to_SDIO_CLK
N
N/* Board led color mapping */
N#define LOGIC_LED_ON 0U
N#define LOGIC_LED_OFF 1U
N
N#define LED1_INIT(output)                                                    \
N    GPIO_PinInit(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, BOARD_LED1_GPIO_PIN, \
N                 &(gpio_pin_config_t){kGPIO_DigitalOutput, (output)}) /*!< Enable target LED1 */
X#define LED1_INIT(output)                                                        GPIO_PinInit(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, BOARD_LED1_GPIO_PIN,                  &(gpio_pin_config_t){kGPIO_DigitalOutput, (output)})  
N#define LED1_ON() \
N    GPIO_ClearPinsOutput(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, 1U << BOARD_LED1_GPIO_PIN) /*!< Turn on target LED1 */
X#define LED1_ON()     GPIO_ClearPinsOutput(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, 1U << BOARD_LED1_GPIO_PIN)  
N#define LED1_OFF() \
N    GPIO_SetPinsOutput(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, 1U << BOARD_LED1_GPIO_PIN) /*!< Turn off target LED1 */
X#define LED1_OFF()     GPIO_SetPinsOutput(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, 1U << BOARD_LED1_GPIO_PIN)  
N#define LED1_TOGGLE()                                            \
N    GPIO_TogglePinsOutput(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT, \
N                          1U << BOARD_LED1_GPIO_PIN) /*!< Toggle on target LED1 */
X#define LED1_TOGGLE()                                                GPIO_TogglePinsOutput(BOARD_LED1_GPIO, BOARD_LED1_GPIO_PORT,                           1U << BOARD_LED1_GPIO_PIN)  
N#define LED2_INIT(output)                                                    \
N    GPIO_PinInit(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, BOARD_LED2_GPIO_PIN, \
N                 &(gpio_pin_config_t){kGPIO_DigitalOutput, (output)}) /*!< Enable target LED2 */
X#define LED2_INIT(output)                                                        GPIO_PinInit(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, BOARD_LED2_GPIO_PIN,                  &(gpio_pin_config_t){kGPIO_DigitalOutput, (output)})  
N#define LED2_ON() \
N    GPIO_ClearPinsOutput(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, 1U << BOARD_LED2_GPIO_PIN) /*!< Turn on target LED2 */
X#define LED2_ON()     GPIO_ClearPinsOutput(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, 1U << BOARD_LED2_GPIO_PIN)  
N#define LED2_OFF() \
N    GPIO_SetPinsOutput(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, 1U << BOARD_LED2_GPIO_PIN) /*!< Turn off target LED2 */
X#define LED2_OFF()     GPIO_SetPinsOutput(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, 1U << BOARD_LED2_GPIO_PIN)  
N#define LED2_TOGGLE()                                            \
N    GPIO_TogglePinsOutput(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT, \
N                          1U << BOARD_LED2_GPIO_PIN) /*!< Toggle on target LED2 */
X#define LED2_TOGGLE()                                                GPIO_TogglePinsOutput(BOARD_LED2_GPIO, BOARD_LED2_GPIO_PORT,                           1U << BOARD_LED2_GPIO_PIN)  
N
N#define LED3_INIT(output)                                                    \
N    GPIO_PinInit(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, BOARD_LED3_GPIO_PIN, \
N                 &(gpio_pin_config_t){kGPIO_DigitalOutput, (output)}) /*!< Enable target LED3 */
X#define LED3_INIT(output)                                                        GPIO_PinInit(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, BOARD_LED3_GPIO_PIN,                  &(gpio_pin_config_t){kGPIO_DigitalOutput, (output)})  
N#define LED3_ON() \
N    GPIO_ClearPinsOutput(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, 1U << BOARD_LED3_GPIO_PIN) /*!< Turn on target LED3 */
X#define LED3_ON()     GPIO_ClearPinsOutput(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, 1U << BOARD_LED3_GPIO_PIN)  
N#define LED3_OFF() \
N    GPIO_SetPinsOutput(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, 1U << BOARD_LED3_GPIO_PIN) /*!< Turn off target LED3 */
X#define LED3_OFF()     GPIO_SetPinsOutput(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, 1U << BOARD_LED3_GPIO_PIN)  
N#define LED3_TOGGLE()                                            \
N    GPIO_TogglePinsOutput(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT, \
N                          1U << BOARD_LED3_GPIO_PIN) /*!< Toggle on target LED3 */
X#define LED3_TOGGLE()                                                GPIO_TogglePinsOutput(BOARD_LED3_GPIO, BOARD_LED3_GPIO_PORT,                           1U << BOARD_LED3_GPIO_PIN)  
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif /* __cplusplus */
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
Nstatus_t BOARD_InitDebugConsole(void);
Nvoid BOARD_InitSDRAM(void);
Nvoid BOARD_InitSPIFI_ExternalFlash(void);
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif /* __cplusplus */
N
N#endif /* _BOARD_H_ */
L 3 "SRC\main.c" 2
N#include "fsl_debug_console.h"
L 1 ".\SRC\System\utilities\fsl_debug_console.h" 1
N/*
N * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * Debug console shall provide input and output functions to scan and print formatted data.
N * o Support a format specifier for PRINTF follows this prototype "%[flags][width][.precision][length]specifier"
N *   - [flags] :'-', '+', '#', ' ', '0'
N *   - [width]:  number (0,1...)
N *   - [.precision]: number (0,1...)
N *   - [length]: do not support
N *   - [specifier]: 'd', 'i', 'f', 'F', 'x', 'X', 'o', 'p', 'u', 'c', 's', 'n'
N * o Support a format specifier for SCANF follows this prototype " %[*][width][length]specifier"
N *   - [*]: is supported.
N *   - [width]: number (0,1...)
N *   - [length]: 'h', 'hh', 'l','ll','L'. ignore ('j','z','t')
N *   - [specifier]: 'd', 'i', 'u', 'f', 'F', 'e', 'E', 'g', 'G', 'a', 'A', 'o', 'c', 's'
N */
N
N#ifndef _FSL_DEBUGCONSOLE_H_
N#define _FSL_DEBUGCONSOLE_H_
N
N#include "fsl_common.h"
N
N/*
N * @addtogroup debugconsole
N * @{
N */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @brief Definition to select sdk or toolchain printf, scanf. */
N#ifndef SDK_DEBUGCONSOLE
N#define SDK_DEBUGCONSOLE 1U
N#endif
N
N#if defined(SDK_DEBUGCONSOLE) && !(SDK_DEBUGCONSOLE)
X#if 1L && !(1U)
S#include <stdio.h>
N#endif
N
N/*! @brief Definition to printf the float number. */
N#ifndef PRINTF_FLOAT_ENABLE
N#define PRINTF_FLOAT_ENABLE 0U
N#endif /* PRINTF_FLOAT_ENABLE */
N
N/*! @brief Definition to scanf the float number. */
N#ifndef SCANF_FLOAT_ENABLE
N#define SCANF_FLOAT_ENABLE 0U
N#endif /* SCANF_FLOAT_ENABLE */
N
N/*! @brief Definition to support advanced format specifier for printf. */
N#ifndef PRINTF_ADVANCED_ENABLE
N#define PRINTF_ADVANCED_ENABLE 0U
N#endif /* PRINTF_ADVANCED_ENABLE */
N
N/*! @brief Definition to support advanced format specifier for scanf. */
N#ifndef SCANF_ADVANCED_ENABLE
N#define SCANF_ADVANCED_ENABLE 0U
N#endif /* SCANF_ADVANCED_ENABLE */
N
N#if SDK_DEBUGCONSOLE /* Select printf, scanf, putchar, getchar of SDK version. */
X#if 1U  
N#define PRINTF DbgConsole_Printf
N#define SCANF DbgConsole_Scanf
N#define PUTCHAR DbgConsole_Putchar
N#define GETCHAR DbgConsole_Getchar
N#else /* Select printf, scanf, putchar, getchar of toolchain. */
S#define PRINTF printf
S#define SCANF scanf
S#define PUTCHAR putchar
S#define GETCHAR getchar
N#endif /* SDK_DEBUGCONSOLE */
N
N/*******************************************************************************
N * Prototypes
N ******************************************************************************/
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif /* __cplusplus */
N
N/*! @name Initialization*/
N/* @{ */
N
N/*!
N * @brief Initializes the the peripheral used for debug messages.
N *
N * Call this function to enable debug log messages to be output via the specified peripheral,
N * frequency of peripheral source clock, and base address at the specified baud rate.
N * After this function has returned, stdout and stdin are connected to the selected peripheral.
N *
N * @param baseAddr      Indicates the address of the peripheral used to send debug messages.
N * @param baudRate      The desired baud rate in bits per second.
N * @param device        Low level device type for the debug console, can be one of the following.
N *                      @arg DEBUG_CONSOLE_DEVICE_TYPE_UART,
N *                      @arg DEBUG_CONSOLE_DEVICE_TYPE_LPUART,
N *                      @arg DEBUG_CONSOLE_DEVICE_TYPE_LPSCI,
N *                      @arg DEBUG_CONSOLE_DEVICE_TYPE_USBCDC.
N * @param clkSrcFreq    Frequency of peripheral source clock.
N *
N * @return              Indicates whether initialization was successful or not.
N * @retval kStatus_Success          Execution successfully
N * @retval kStatus_Fail             Execution failure
N * @retval kStatus_InvalidArgument  Invalid argument existed
N */
Nstatus_t DbgConsole_Init(uint32_t baseAddr, uint32_t baudRate, uint8_t device, uint32_t clkSrcFreq);
N
N/*!
N * @brief De-initializes the peripheral used for debug messages.
N *
N * Call this function to disable debug log messages to be output via the specified peripheral
N * base address and at the specified baud rate.
N *
N * @return Indicates whether de-initialization was successful or not.
N */
Nstatus_t DbgConsole_Deinit(void);
N
N#if SDK_DEBUGCONSOLE
X#if 1U
N/*!
N * @brief Writes formatted output to the standard output stream.
N *
N * Call this function to write a formatted output to the standard output stream.
N *
N * @param   fmt_s Format control string.
N * @return  Returns the number of characters printed or a negative value if an error occurs.
N */
Nint DbgConsole_Printf(const char *fmt_s, ...);
N
N/*!
N * @brief Writes a character to stdout.
N *
N * Call this function to write a character to stdout.
N *
N * @param   ch Character to be written.
N * @return  Returns the character written.
N */
Nint DbgConsole_Putchar(int ch);
N
N/*!
N * @brief Reads formatted data from the standard input stream.
N *
N * Call this function to read formatted data from the standard input stream.
N *
N * @param   fmt_ptr Format control string.
N * @return  Returns the number of fields successfully converted and assigned.
N */
Nint DbgConsole_Scanf(char *fmt_ptr, ...);
N
N/*!
N * @brief Reads a character from standard input.
N *
N * Call this function to read a character from standard input.
N *
N * @return Returns the character read.
N */
Nint DbgConsole_Getchar(void);
N
N#endif /* SDK_DEBUGCONSOLE */
N
N/*! @} */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif /* __cplusplus */
N
N/*! @} */
N
N#endif /* _FSL_DEBUGCONSOLE_H_ */
L 4 "SRC\main.c" 2
N#include "fsl_emc.h"
L 1 ".\SRC\Drivers\fsl_emc.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N#ifndef _FSL_EMC_H_
N#define _FSL_EMC_H_
N
N#include "fsl_common.h"
N
N/*!
N * @addtogroup emc
N * @{
N */
N
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @name Driver version */
N/*@{*/
N/*! @brief EMC driver version 2.0.0. */
N#define FSL_EMC_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
N/*@}*/
N
N/*! @brief Define the chip numbers for dynamic and static memory devices. */
N#define EMC_STATIC_MEMDEV_NUM        (4U)
N#define EMC_DYNAMIC_MEMDEV_NUM       (4U)
N#define EMC_ADDRMAP_SHIFT        EMC_DYNAMIC_DYNAMICCONFIG_AM0_SHIFT
N#define EMC_ADDRMAP_MASK         (EMC_DYNAMIC_DYNAMICCONFIG_AM0_MASK |EMC_DYNAMIC_DYNAMICCONFIG_AM1_MASK)
N#define EMC_ADDRMAP(x)    (((uint32_t)(((uint32_t)(x)) << EMC_ADDRMAP_SHIFT)) & EMC_ADDRMAP_MASK)     
N#define EMC_HZ_ONEMHZ   (1000000U)
N#define EMC_MILLISECS_ONESEC   (1000U)
N#define EMC_SDRAM_MODE_CL_SHIFT   (4U)
N#define EMC_SDRAM_MODE_CL_MASK   (0x70U)
N
N/*!
N * @brief Define EMC memory width for static memory device.
N */
Ntypedef enum _emc_static_memwidth
N{
N    kEMC_8BitWidth = 0x0U, /*!< 8 bit memory width. */
N    kEMC_16BitWidth,       /*!< 16 bit memory width. */
N    kEMC_32BitWidth        /*!< 32 bit memory width. */
N} emc_static_memwidth_t;
N
N/*!
N * @brief Define EMC static configuration.
N */
Ntypedef enum _emc_static_special_config
N{ 
N    kEMC_AsynchronosPageEnable = 0x0008U,/*!< Enable the asynchronous page mode. page length four. */
N    kEMC_ActiveHighChipSelect = 0x0040U, /*!< Chip select active high. */
N    kEMC_ByteLaneStateAllLow = 0x0080U,  /*!< Reads/writes the respective valuie bits in BLS3:0 are low. */
N    kEMC_ExtWaitEnable = 0x0100U,        /*!< Extended wait enable. */
N    kEMC_BufferEnable = 0x80000U         /*!< Buffer enable. */
N} emc_static_special_config_t;
N
N/*! @brief EMC dynamic memory device. */
Ntypedef enum _emc_dynamic_device
N{
N    kEMC_Sdram = 0x0U,   /*!< Dynamic memory device: SDRAM. */
N    kEMC_Lpsdram,        /*!< Dynamic memory device: Low-power SDRAM. */
N} emc_dynamic_device_t;
N
N/*! @brief EMC dynamic read strategy. */
Ntypedef enum _emc_dynamic_read
N{
N    kEMC_NoDelay = 0x0U,        /*!< No delay. */ 
N    kEMC_Cmddelay,              /*!< Command delayed strategy, using EMCCLKDELAY. */
N    kEMC_CmdDelayPulseOneclk,   /*!< Command delayed strategy pluse one clock cycle using EMCCLKDELAY. */
N    kEMC_CmddelayPulsetwoclk,   /*!< Command delayed strategy pulse two clock cycle using EMCCLKDELAY. */
N} emc_dynamic_read_t;
N
N/*! @brief EMC endian mode. */
Ntypedef enum _emc_endian_mode
N{
N    kEMC_LittleEndian = 0x0U, /*!< Little endian mode. */
N    kEMC_BigEndian,           /*!< Big endian mode. */
N} emc_endian_mode_t;
N
N/*! @brief EMC Feedback clock input source select. */
Ntypedef enum _emc_fbclk_src
N{
N    kEMC_IntloopbackEmcclk = 0U, /*!< Use the internal loop back from EMC_CLK output. */
N    kEMC_EMCFbclkInput    /*!< Use the external EMC_FBCLK input. */
N} emc_fbclk_src_t;
N
N/*! @brief EMC dynamic timing/delay configure structure. */
Ntypedef struct _emc_dynamic_timing_config
N{
N    emc_dynamic_read_t readConfig;   /* Dynamic read strategy. */
N    uint32_t refreshPeriod_Nanosec;  /*!< The refresh period in unit of nanosecond. */
N    uint32_t tRp_Ns;      /*!< Precharge command period in unit of nanosecond. */
N    uint32_t tRas_Ns;     /*!< Active to precharge command period in unit of nanosecond. */
N    uint32_t tSrex_Ns;    /*!< Self-refresh exit time in unit of nanosecond. */
N    uint32_t tApr_Ns;     /*!< Last data out to active command time in unit of nanosecond. */
N    uint32_t tDal_Ns;     /*!< Data-in to active command in unit of nanosecond. */
N    uint32_t tWr_Ns;      /*!< Write recovery time in unit of nanosecond. */
N    uint32_t tRc_Ns;      /*!< Active to active command period in unit of nanosecond. */       
N    uint32_t tRfc_Ns;     /*!< Auto-refresh period and auto-refresh to active command period in unit of nanosecond. */
N    uint32_t tXsr_Ns;     /*!< Exit self-refresh to active command time in unit of nanosecond. */
N    uint32_t tRrd_Ns;     /*!< Active bank A to active bank B latency in unit of nanosecond. */
N    uint8_t tMrd_Nclk;     /*!< Load mode register to active command time in unit of EMCCLK cycles.*/
N} emc_dynamic_timing_config_t;
N
N/*!
N * @brief EMC dynamic memory controller independent chip configuration structure.
N * Please take refer to the address mapping table in the RM in EMC chapter when you 
N * set the "devAddrMap". Choose the right Bit 14 Bit12 ~ Bit 7 group in the table
N * according to the bus width/banks/row/colum length for you device.
N * Set devAddrMap with the value make up with the seven bits (bit14 bit12 ~ bit 7) 
N * and inset the bit 13 with 0.
N * for example, if the bit 14 and bit12 ~ bit7 is 1000001 is choosen according to the
N * 32bit high-performance bus width with 2 banks, 11 row lwngth, 8 column length. 
N * Set devAddrMap with 0x81.
N */
Ntypedef struct _emc_dynamic_chip_config
N{
N    uint8_t chipIndex;    /*!< Chip Index, range from 0 ~ EMC_DYNAMIC_MEMDEV_NUM - 1. */
N    emc_dynamic_device_t dynamicDevice; /*!< All chips shall use the same device setting. mixed use are not supported. */
N    uint8_t rAS_Nclk;    /*!< Active to read/write delay tRCD. */
N    uint16_t sdramModeReg;   /*!< Sdram mode register setting. */
N    uint16_t sdramExtModeReg; /*!< Used for low-power sdram device. The extended mode register. */
N    uint8_t devAddrMap;  /*!< dynamic device address mapping, choose the address mapping for your specific device. */
N} emc_dynamic_chip_config_t;
N
N/*!
N * @brief EMC static memory controller independent chip configuration structure.
N */
Ntypedef struct _emc_static_chip_config
N{
N    uint8_t chipIndex;
N    emc_static_memwidth_t memWidth; /*!< Memory width. */
N    uint32_t specailConfig;     /*!< Static configuration,a logical OR of "emc_static_special_config_t". */
N    uint32_t tWaitWriteEn_Ns;/*!< The delay form chip select to write enable in unit of nanosecond. */
N    uint32_t tWaitOutEn_Ns;  /*!< The delay from chip selcet to output enable in unit of nanosecond. */
N    uint32_t tWaitReadNoPage_Ns;/*!< In No-page mode, the delay from chip select to read access in unit of nanosecond. */
N    uint32_t tWaitReadPage_Ns;  /*!< In page mode, the read after the first read wait states in unit of nanosecond. */ 
N    uint32_t tWaitWrite_Ns;     /*!< The delay from chip select to write access in unit of nanosecond. */
N    uint32_t tWaitTurn_Ns;      /*!< The Bus turn-around time in unit of nanosecond. */
N} emc_static_chip_config_t;
N
N/*!
N * @brief EMC module basic configuration structure.
N *
N * Defines the static memory controller configure structure and 
N * uses the EMC_Init() function to make necessary initializations.
N *
N */
Ntypedef struct _emc_basic_config
N{
N    emc_endian_mode_t endian;   /*!< Endian mode . */
N    emc_fbclk_src_t fbClkSrc;    /*!< The feedback clock source. */
N    uint8_t emcClkDiv; /*!< EMC_CLK = AHB_CLK / (emc_clkDiv + 1). */
N} emc_basic_config_t;
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*!
N * @name EMC Initialize and de-initialize opeartion
N * @{
N */
N/*!
N * @brief Initializes the basic for EMC.
N * This function ungates the EMC clock, initializes the emc system configure
N * and enable the EMC module. This function must be called in the first step to initialize
N * the external memory.
N *
N * @param base EMC peripheral base address.
N * @param config The EMC basic configuration.
N */
Nvoid EMC_Init(EMC_Type *base, emc_basic_config_t *config);
N
N/*!
N * @brief Initializes the dynamic memory controller.
N * This function initializes the dynamic memory controller in external memory controller.
N * This function must be called after EMC_Init and before accessing the external dynamic memory.
N *
N * @param base EMC peripheral base address.
N * @param timing The timing and latency for dynamica memory controller setting. It shall
N *        be used for all dynamica memory chips, threfore the worst timing value for all
N *        used chips must be given.
N * @param configure The EMC dynamic memory controller chip independent configuration pointer.
N *       This configuration pointer is actually pointer to a configration array. the array number
N *       depends on the "totalChips".
N * @param totalChips The total dynamic memory chip numbers been used or the length of the 
N *        "emc_dynamic_chip_config_t" type memory.
N */
Nvoid EMC_DynamicMemInit(EMC_Type *base, emc_dynamic_timing_config_t *timing, 
N        emc_dynamic_chip_config_t *config, uint32_t totalChips);
N
N/*!
N * @brief Initializes the static memory controller.
N * This function initializes the static memory controller in external memory controller.
N * This function must be called after EMC_Init and before accessing the external static memory.
N *
N * @param base EMC peripheral base address.
N * @param extWait_Ns The extended wait timeout or the read/write transfer time.
N *        This is common for all static memory chips and set with NULL if not required.
N * @param configure The EMC static memory controller chip independent configuration pointer.
N *       This configuration pointer is actually pointer to a configration array. the array number
N *       depends on the "totalChips".
N * @param totalChips The total static memory chip numbers been used or the length of the 
N *        "emc_static_chip_config_t" type memory.
N */
Nvoid EMC_StaticMemInit(EMC_Type *base, uint32_t *extWait_Ns, emc_static_chip_config_t *config, uint32_t totalChips);
N
N/*!
N * @brief Deinitializes the EMC module and gates the clock.
N * This function gates the EMC controller clock. As a result, the EMC
N * module doesn't work after calling this function.
N *
N * @param base EMC peripheral base address.
N */
Nvoid EMC_Deinit(EMC_Type *base);
N
N/* @} */
N
N/*!
N * @name EMC Basic Operation
N * @{
N */
N
N/*!
N * @brief Enables/disables the EMC module.
N *
N * @param base EMC peripheral base address.
N * @param enable True enable EMC module, false disable.
N */
Nstatic inline void EMC_Enable(EMC_Type *base, bool enable)
Xstatic inline void EMC_Enable(EMC_Type *base, _Bool enable)
N{
N    if (enable)
N    {
N        base->CONTROL |= EMC_CONTROL_E_MASK;
X        base->CONTROL |= (0x1U);
N    }
N    else
N    {
N        base->CONTROL &= ~EMC_CONTROL_E_MASK;
X        base->CONTROL &= ~(0x1U);
N    }
N}
N
N/*!
N * @brief Enables/disables the EMC Dynaimc memory controller.
N *
N * @param base EMC peripheral base address.
N * @param enable True enable EMC dynamic memory controller, false disable.
N */
Nstatic inline void EMC_EnableDynamicMemControl(EMC_Type *base, bool enable)
Xstatic inline void EMC_EnableDynamicMemControl(EMC_Type *base, _Bool enable)
N{
N    if (enable)
N    {
N        base->DYNAMICCONTROL |= (EMC_DYNAMICCONTROL_CE_MASK | EMC_DYNAMICCONTROL_CS_MASK);
X        base->DYNAMICCONTROL |= ((0x1U) | (0x2U));
N    }
N    else
N    {
N        base->DYNAMICCONTROL &= ~(EMC_DYNAMICCONTROL_CE_MASK | EMC_DYNAMICCONTROL_CS_MASK);
X        base->DYNAMICCONTROL &= ~((0x1U) | (0x2U));
N    }
N}
N
N/*!
N * @brief Enables/disables the EMC address mirror.
N * Enable the address mirror the EMC_CS1is mirrored to both EMC_CS0
N * and EMC_DYCS0 memory areas. Disable the address mirror enables
N * EMC_cS0 and EMC_DYCS0 memory to be accessed.
N *
N * @param base EMC peripheral base address.
N * @param enable True enable the address mirror, false disable the address mirror.
N */
Nstatic void EMC_MirrorChipAddr(EMC_Type *base, bool enable)
Xstatic void EMC_MirrorChipAddr(EMC_Type *base, _Bool enable)
N{
N    if (enable) 
N    {
N        base->CONTROL |= EMC_CONTROL_M_MASK;
X        base->CONTROL |= (0x2U);
N    }
N    else 
N    {
N        base->CONTROL &= ~EMC_CONTROL_M_MASK;
X        base->CONTROL &= ~(0x2U);
N    }
N}
N
N/*!
N * @brief Enter the self-refresh mode for dynamic memory controller.
N * This function provided self-refresh mode enter or exit for application. 
N *
N * @param base EMC peripheral base address.
N * @param enable   True enter the self-refresh mode, false to exit self-refresh
N *                 and enter the normal mode.
N */
Nstatic inline void EMC_EnterSelfRefreshCommand(EMC_Type *base, bool enable)
Xstatic inline void EMC_EnterSelfRefreshCommand(EMC_Type *base, _Bool enable)
N{
N    if (enable)
N    {
N        base->DYNAMICCONTROL |= EMC_DYNAMICCONTROL_SR_MASK;
X        base->DYNAMICCONTROL |= (0x4U);
N    }
N    else
N    {
N        base->DYNAMICCONTROL &= ~EMC_DYNAMICCONTROL_SR_MASK;
X        base->DYNAMICCONTROL &= ~(0x4U);
N    }
N}
N
N/*!
N * @brief Get the operating mode of the EMC.
N * This function can be used to get the operating mode of the EMC. 
N *
N * @param base EMC peripheral base address.
N * @return The EMC in self-refresh mode if true, else in normal mode.
N */
Nstatic inline bool EMC_IsInSelfrefreshMode(EMC_Type *base)
Xstatic inline _Bool EMC_IsInSelfrefreshMode(EMC_Type *base)
N{
N    return ((base->STATUS & EMC_STATUS_SA_MASK) ? true : false);
X    return ((base->STATUS & (0x4U)) ? 1 : 0);
N}
N
N/*!
N * @brief Enter/exit the low-power mode.
N *
N * @param base EMC peripheral base address.
N * @param enable True Enter the low-power mode, false exit low-power mode
N *        and return to normal mode. 
N */
Nstatic inline void EMC_EnterLowPowerMode(EMC_Type *base, bool enable)
Xstatic inline void EMC_EnterLowPowerMode(EMC_Type *base, _Bool enable)
N{
N    if (enable)
N    {
N        base->CONTROL |= EMC_CONTROL_L_MASK;
X        base->CONTROL |= (0x4U);
N    }
N    else
N    {
N        base->CONTROL &= ~ EMC_CONTROL_L_MASK;
X        base->CONTROL &= ~ (0x4U);
N    }
N}
N
N/* @} */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N/*! @}*/
N
N#endif /* _FSL_EMC_H_*/
L 5 "SRC\main.c" 2
N#include "pin_mux.h"
L 1 ".\SRC\Board\pin_mux.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _PIN_MUX_H_
N#define _PIN_MUX_H_
N
N#include "board.h"
N#include "fsl_common.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif /* __cplusplus*/
N       /*!
N        * @brief configure all pins for this demo/example
N        *
N        */
Nvoid BOARD_InitPins(void);
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif /* __cplusplus*/
N
N#endif /* _PIN_MUX_H_  */
L 6 "SRC\main.c" 2
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 7 "SRC\main.c" 2
N#include <string.h>
N#include <stdbool.h>
N
N#include "eGFX.h"
L 1 ".\SRC\eGFX\eGFX.h" 1
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 8 ".\SRC\eGFX\eGFX.h" 2
N
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
N#define eGFX_DATA_TYPES_H
N
N
Ntypedef int16_t FIXED_7_8;
Ntypedef int16_t FIXED_9_6;
N
Ntypedef int16_t FIXED_0_15;
Ntypedef int16_t FIXED_1_14;
N
N
N#define eGFX_IMAGE_PLANE_1BPP		 0
N#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
N#define eGFX_IMAGE_PLANE_4BPP		    2
N#define eGFX_IMAGE_PLANE_8BPP		   3
N#define eGFX_IMAGE_PLANE_16BPP_565    4
N#define eGFX_IMAGE_PLANE_24BPP        5
N#define eGFX_IMAGE_PLANE_32BPP        6
N
N
N
Ntypedef struct
N{
N    uint8_t Type;
N    uint8_t *Data;
N    uint16_t SizeX;
N    uint16_t SizeY;
N
N} eGFX_ImagePlane;
N
Ntypedef struct
N{
N    int16_t X;
N    int16_t Y;
N} eGFX_Point;
N
Ntypedef struct
N{
N    float X; 	
N    float Y;  
N} eGFX_PointF;
N
Ntypedef struct
N{
N    eGFX_Point P1;
N    eGFX_Point P2;
N} eGFX_Box;
N
Ntypedef struct
N{
N    eGFX_Point Center;
N    uint8_t NumPoints;
N    uint8_t DrawMode;
N    const eGFX_Point *PointList;
N
N} eGFX_ListPrimitive;
N
N
N
N#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
N#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
N#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
N#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
N#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
N#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
N
Ntypedef struct
N{
N    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
N  
N	//Some TT Metrics
N	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
N	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
N	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
N	
N	uint8_t  SpacesPerTab;
N    uint8_t  InterCharacterSpacing;
N   
N	uint8_t  Padding[2];
N
N} eGFX_Font;
N
N
N#define eGFX_PIXEL_ON     0xFFFFFFFF
N#define eGFX_PIXEL_OFF    0
N
Ntypedef uint32_t eGFX_PixelState;
N
N/***
N*       ____  _     _           _
N*      / __ \| |   (_)         | |
N*     | |  | | |__  _  ___  ___| |_ ___
N*     | |  | | '_ \| |/ _ \/ __| __/ __|
N*     | |__| | |_) | |  __/ (__| |_\__ \
N*      \____/|_.__/| |\___|\___|\__|___/
X
N*                 _/ |
N*                |__/
N*/
N
Ntypedef struct 
N{
N	uint32_t Type;
N	uint32_t State;
N	
N}	eGFX_ObjectHeader;
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	uint32_t CurrentStep;
N	uint32_t LastStep;
N}	eGFX_AnimatorHeader;
N
N#define eGFX_OBJECT_STATE_ACTIVE							        	1
N#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
N#define eGFX_OBJECT_STATE_INACTIVE										0
N
N/***
N*                     _                 _                ____  _     _           _
N*         /\         (_)               | |              / __ \| |   (_)         | |
N*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
N*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
N*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
N*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
N*                                                                  _/ |
N*                                                                 |__/
N*/
N
N
N
N#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
N#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
N
N#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
N#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	uint32_t CurrentStep;
N	uint32_t LastStep;
N	eGFX_PointF Target;
N	eGFX_PointF *Current;
N
N	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
N
N} eGFX_PointF_BisectAnimator;
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	uint32_t CurrentStep;
N	uint32_t LastStep;
N	eGFX_PointF Target;
N	eGFX_PointF *Current;
N	float IncrementX;
N	float IncrementY;
N
N} eGFX_PointF_LinearAnimator;
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	uint32_t CurrentStep;
N	uint32_t LastStep;
N	float Target;
N	float *Current;
N	float Increment; //Increment we should make each step
N
N} eGFX_ScalarF_LinearAnimator;
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	uint32_t CurrentStep;
N	uint32_t LastStep;
N	float Target;
N	float *Current;
N	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
N
N} eGFX_ScalarF_BisectAnimator;
N
N/***
N*       _____                 _     _         ____  _     _           _
N*      / ____|               | |   (_)       / __ \| |   (_)         | |
N*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
N*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
N*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
N*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
N*                      | |                              _/ |
N*                      |_|                             |__/
N*/
N
N#define eGFX_OBJECT_TEXTF												0x0000
N#define eGFX_OBJECT_SHADED_TEXTF										0x0001
N#define eGFX_OBJECT_LINEF												0x0002
N#define eGFX_OBJECT_SPRITEF												0x0003
N#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
N#define eGFX_OBJECT_BOXF												0x0005
N#define eGFX_OBJECT_CIRCLEF												0x0006
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	eGFX_PointF Position;
N	char *String;
N	eGFX_Font *Font;
N	
N} eGFX_Obj_TextF;
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	eGFX_PointF Position;
N	char *String;
N	eGFX_Font *Font;
N	float Shading;
N
N} eGFX_Obj_ShadedTextF;
N
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	eGFX_PointF Start;
N	eGFX_PointF End;
N	eGFX_PixelState PixelState; 
N} eGFX_Obj_LineF;
N
N#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
N#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	eGFX_PointF Position;
N	float Radius;
N	eGFX_PixelState PixelState; 
N	uint8_t RenderOption;
N} eGFX_Obj_CircleF;
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	eGFX_PointF Position;
N	eGFX_ImagePlane * Sprite;
N	
N} eGFX_Obj_SpriteF;
N
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N	
N	eGFX_PointF Position;
N	eGFX_ImagePlane * Sprite;
N
N	float Scale;
N
N} eGFX_Obj_ScaledSpriteF;
N
N
N#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
N#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
N
Ntypedef struct
N{
N	uint32_t Type;
N	uint32_t State;
N
N	eGFX_PointF P1;
N	eGFX_PointF P2;
N
N	eGFX_PixelState PixelState;
N
N	uint8_t BoxF_RenderOption;
N
N} eGFX_Obj_BoxF;
N
N
N#endif
L 10 ".\SRC\eGFX\eGFX.h" 2
N
N
N#ifndef _eGFX_H__
N#define _eGFX_H__
N
N#define eGFX_MAX_ANIMATORS										  32
N#define eGFX_MAX_OBJECTS										  64
N
N#define eGFX_SPACES_PER_TAB                                        4
N#define eGFX_MAX_STRING_LEN                                        64
N#define eGFX_MAX_PRINTF_BUF_LENGTH                                 64
N
N#define eGFX_API_LEVEL											   1
N#define eGFX_REVISION											   2
N
N
N#define eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+7)>>3) //We add 8 to round up to the next even byte boundary
N#define eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+1)>>1) //We add 1 to round up to the next even byte boundary
N#define eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)			 (x)
N#define eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)		 (x*2)
N#define eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*3)
N#define	eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*4)
N
N#define eGFX_CALCULATE_1BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
N#define eGFX_CALCULATE_3BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (((x * y * 3))/8) //This is a special type  for sharp 8 color memory LCDs.   Packing is done in the data buffer so the dump to the screen is simple
N#define eGFX_CALCULATE_4BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
N#define eGFX_CALCULATE_8BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
N#define eGFX_CALCULATE_16BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
N#define eGFX_CALCULATE_24BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
N#define eGFX_CALCULATE_32BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
N
N#define ROUND_TO_INT16_T(x)	((int16_t)(x + 0.5f))
N
Nextern const FIXED_1_14 eGFX_Fixed_1_14_SineTable [256];
Nextern const FIXED_7_8 eGFX_Fixed_7_8_SineTable[256];
N
N#define eGFX_GET_INT_FROM_FIXED_7_8(A)				(int16_t)(A>>8)
N#define eGFX_INT_TO_FIXED_7_8(A)					((FIXED_7_8)(A)<<8)
N#define eGFX_GET_FRAC_FROM_FIXED_7_8(A)				(FIXED_7_8)(A&0xFF)
N
N#define eGFX_GET_INT_FROM_FIXED_9_6_(A)				(int16_t)(A>>6)
N#define eGFX_INT_TO_FIXED_9_6(A)					((FIXED_9_6)(A)<<6)
N#define eGFX_GET_FRAC_FROM_FIXED_6_9(A)				(FIXED_9_6)(A&0x3F)
N
NFIXED_7_8 eGFX_GET_INT_FROM_FIXED_7_8_ROUND_TO_NEAREST(FIXED_7_8 A);
NFIXED_7_8 eGFX_FLOAT_TO_FIXED_7_8(float A);
Nint16_t eGFX_FMul_15_0to0_15(int16_t A, int16_t B);
Nint16_t eGFX_FMul_7_8to0_15(int16_t A, int16_t B);
Nint16_t eGFX_FMul_15_0to7_8(int16_t A,int16_t B);
Nint16_t eGFX_FMul_15_0to1_14(int16_t A,int16_t B);
Nint16_t eGFX_ABS(int16_t A);
N
N
N#define eGFX_RGB888_TO_RGB565(R,G,B)	 ( ((R>>2)<<11) | ((G>>2)<<5) | (B>>3))
N
N
N#ifndef TRUE
N	#define TRUE 1
N#endif
N
N#ifndef FALSE
N	#define FALSE 0
N#endif
N
N
N/***
N *      _____ _          _    ____                       _   _
N *     |  __ (_)        | |  / __ \                     | | (_)
N *     | |__) |__  _____| | | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
N *     |  ___/ \ \/ / _ \ | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
N *     | |   | |>  <  __/ | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
N *     |_|   |_/_/\_\___|_|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
N *                                 | |
N *                                 |_|
N */
Nvoid eGFX_PutPixel(const eGFX_ImagePlane *Image,
N                   int16_t x,
N                   int16_t y,
N                   eGFX_PixelState PS);
N
NeGFX_PixelState eGFX_GetPixel(const eGFX_ImagePlane *Image,
N                         int16_t x,
N                         int16_t y);
N
N
N
N
N/***
N *      _____      _           _ _   _              ____                       _   _
N *     |  __ \    (_)         (_) | (_)            / __ \                     | | (_)
N *     | |__) | __ _ _ __ ___  _| |_ ___   _____  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
N *     |  ___/ '__| | '_ ` _ \| | __| \ \ / / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
N *     | |   | |  | | | | | | | | |_| |\ V /  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
N *     |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
N *                                                       | |
N *                                                       |_|
N */
N
N 
Nvoid eGFX_DrawHline(eGFX_ImagePlane *Image,
N                    int16_t XStart,
N                    int16_t XStop,
N                    int16_t Y,
N                    eGFX_PixelState PS);
N
Nvoid eGFX_DrawFilledBox(eGFX_ImagePlane *Image,
N                        eGFX_Box *Box,
N                        eGFX_PixelState PS);
N
Nvoid eGFX_DrawBox(eGFX_ImagePlane *Image,
N                  eGFX_Box *Box,
N                  eGFX_PixelState PS);
N
Nvoid eGFX_DrawVline(eGFX_ImagePlane *Image,
N                    int16_t YStart,
N                    int16_t YStop,
N                    int16_t X,
N                    eGFX_PixelState PS);
N
Nvoid eGFX_DrawLine(eGFX_ImagePlane *Image,
N                   int16_t X1,
N                   int16_t Y1,
N                   int16_t X2,
N                   int16_t Y2,
N                   eGFX_PixelState PS);
N
Nvoid eGFX_DrawListPrimitive(eGFX_ImagePlane *Image,
N                            eGFX_ListPrimitive *LP ,
N                            eGFX_PixelState PS);
N
Nvoid eGFX_DrawScaledListPrimitive(eGFX_ImagePlane *Image,
N                                  eGFX_ListPrimitive *LP ,
N                                  FIXED_7_8 Scale,
N                                  eGFX_PixelState PS);
N
Nvoid eGFX_DrawRotatedListPrimitive(eGFX_ImagePlane *Image,
N                                   eGFX_ListPrimitive *LP ,
N                                   uint8_t Angle,
N                                   eGFX_PixelState PS);
N
Nvoid eGFX_DrawScaledRotatedListPrimitive(eGFX_ImagePlane *Image,
N        eGFX_ListPrimitive *LP ,
N        uint8_t Angle,
N        FIXED_7_8 Scale,
N        eGFX_PixelState PS);
N
Nvoid eGFX_DrawCircle(eGFX_ImagePlane *RC,
N                     int16_t x0,
N                     int16_t y0,
N                     int16_t radius,
N                     eGFX_PixelState PS);
N
Nvoid eGFX_DrawFilledCircle(eGFX_ImagePlane *RC,
N	int16_t x0,
N	int16_t y0,
N	int16_t radius,
N	eGFX_PixelState PS);
N
N
N
N/***
N *       _____ _        _                ____                       _   _
N *      / ____| |      (_)              / __ \                     | | (_)
N *     | (___ | |_ _ __ _ _ __   __ _  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
N *      \___ \| __| '__| | '_ \ / _` | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
N *      ____) | |_| |  | | | | | (_| | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
N *     |_____/ \__|_|  |_|_| |_|\__, |  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
N *                               __/ |        | |
N *                              |___/         |_|
N */
N
Nint16_t eGFX_ScaledDrawCharacter(eGFX_ImagePlane *Image,
N                                 int16_t StartX,
N                                 int16_t StartY,
N                                 uint8_t Character,
N                                 const eGFX_Font *MyFont,
N                                 float ScaleFactor);
N
Nint16_t eGFX_DrawCharacter(eGFX_ImagePlane *Image,
N                           int16_t StartX,
N                           int16_t StartY,
N                           uint8_t Character,
N                           const eGFX_Font *MyFont);
N
Nint16_t eGFX_DrawCharacterFaded(eGFX_ImagePlane *Image,
N                           int16_t StartX,
N                           int16_t StartY,
N                           uint8_t Character,
N                           const eGFX_Font *MyFont,
N                           eGFX_PixelState PS);
N
Nint16_t eGFX_DrawCharacterShaded(eGFX_ImagePlane *Image,
N									int16_t StartX,
N									int16_t StartY,
N									uint8_t Character,
N									const eGFX_Font *MyFont,
N									float Shading);
N
N
Nint16_t eGFX_GetStringWidth(char *String,
N                            const eGFX_Font *MyFont);
N
Nint16_t eGFX_GetStringWidth_CustomSpacing(char *String,
N											const eGFX_Font *MyFont,
N											uint16_t Spacing);
N
N
Nvoid eGFX_DrawHorizontalCenteredString(eGFX_ImagePlane *Image,
N                                       int16_t StartY,
N                                       char *String,
N                                       const eGFX_Font *MyFont);
N
Nint16_t eGFX_DrawRightAlignedCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
N        int16_t StartY,
N        char *String,
N        const eGFX_Font *MyFont,
N        uint16_t CustomCharacterSpacing,
N        int16_t RightSideBuffer);
N
Nvoid eGFX_DrawHorizontalCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
N        int16_t StartY,
N        char *String,
N        const eGFX_Font *MyFont,
N        uint16_t Spacing);
N
Nvoid eGFX_ScaledDrawString(eGFX_ImagePlane *Image,
N                           int16_t StartX,
N                           int16_t StartY,
N                           char *String,
N                           const eGFX_Font *MyFont,
N                           float ScaleFactor);
N
Nint16_t  eGFX_DrawStringFaded(eGFX_ImagePlane *Image,
N						 char *String,
N                         int16_t StartX,
N                         int16_t StartY,
N                         const eGFX_Font *MyFont,
N						eGFX_PixelState PS
N                         );
N
N
Nint16_t  eGFX_DrawStringShaded(eGFX_ImagePlane *Image,
N								char *String,
N								int16_t StartX,
N								int16_t StartY,
N								const eGFX_Font *MyFont,
N								float Shading
N								);
N
Nvoid eGFX_ScaledDrawString_CustomSpacing(eGFX_ImagePlane *Image,
N        int16_t StartX,
N        int16_t StartY,
N        char *String,
N        const eGFX_Font *MyFont,
N        float ScaleFactor ,
N        uint16_t Spacing);
N
Nint16_t  eGFX_DrawString(eGFX_ImagePlane *Image,
N						char * String,
N                         int16_t StartX,
N                         int16_t StartY,
N
N                         const eGFX_Font *MyFont
N                         );
N
Nint16_t  eGFX_printf(eGFX_ImagePlane *Image,
N                     int16_t StartX,
N                     int16_t StartY,
N                     const eGFX_Font *MyFont,
N                     
N                     char *FormatString,...);
N
Nint16_t eGFX_DrawString_CustomSpacing(eGFX_ImagePlane *Image,
N                                      int16_t StartX,
N                                      int16_t StartY,
N                                      char *String,
N                                      const eGFX_Font *MyFont,uint16_t Spacing);
N                                      
Nint16_t  eGFX_printf_Colored(eGFX_ImagePlane *Image,
N                     int16_t StartX,
N                     int16_t StartY,
N                     const eGFX_Font *MyFont,
N											uint32_t Color,
N                     char *FormatString,...);
N
Nint16_t  eGFX_printf_HorizontalCentered_Colored(eGFX_ImagePlane *Image,
N                                         int16_t StartY,
N                                        const eGFX_Font *MyFont,
N                                        uint32_t Color,
N                                        char *FormatString,...);
N/***
N*      _____  _                     ____                       _   _
N*     |  __ \| |                   / __ \                     | | (_)
N*     | |__) | | __ _ _ __   ___  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
N*     |  ___/| |/ _` | '_ \ / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
N*     | |    | | (_| | | | |  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
N*     |_|    |_|\__,_|_| |_|\___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
N*                                        | |
N*                                        |_|
N*/
N
Nvoid eGFX_Blit(eGFX_ImagePlane *Destination,
N               int16_t x,
N               int16_t y,
N               const eGFX_ImagePlane *Sprite);
N
Nvoid eGFX_CenteredBlit(eGFX_ImagePlane *Destination,
N			int16_t x,
N			int16_t y,
N			const eGFX_ImagePlane *Sprite);
N
Nvoid eGFX_BlitFaded(eGFX_ImagePlane *Destination,
N               int16_t x,
N               int16_t y,
N               const eGFX_ImagePlane *Sprite,
N               eGFX_PixelState PS);
N
Nvoid eGFX_BlitShaded(eGFX_ImagePlane *Destination,
N					int16_t x,
N					int16_t y,
N					const eGFX_ImagePlane *Sprite,
N					float Shading);
N                    
Nvoid eGFX_BlitColored(eGFX_ImagePlane *Destination,
N                    int16_t x,
N                    int16_t y,
N                    const eGFX_ImagePlane *Sprite,
N                    uint32_t Color);
N
Nvoid eGFX_ScaledBlit(eGFX_ImagePlane *Destination,
N                     int16_t x,
N                     int16_t y,
N                     const eGFX_ImagePlane *Sprite,
N                     float ScaleFactor);
N
Nuint8_t eGFX_GetBitFromArray(uint8_t *DataArray,uint16_t Bit);
N
N
Nuint8_t eGFX_ImagePlane_GetByte(eGFX_ImagePlane   *Image,
N                                uint16_t X,
N                                uint16_t Y);
N
N
Nvoid eGFX_ImagePlaneInit(eGFX_ImagePlane   *Image, uint8_t * Store, int16_t SizeX, int16_t SizeY, uint8_t Type);
N
Nvoid eGFX_ImagePlane_Clear(eGFX_ImagePlane   *Image);
N
N
N
N/***
N*                     _                 _                        _____ _____
N*         /\         (_)               | |                 /\   |  __ \_   _|
N*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __     /  \  | |__) || |
N*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__|   / /\ \ |  ___/ | |
N*      / ____ \| | | | | | | | | | (_| | || (_) | |     / ____ \| |    _| |_
N*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|    /_/    \_\_|   |_____|
N*
N*
N*/
N
N//Call this in the main loop.   Animators will be stepped at the rate that this is called!
Nvoid eGFX_ProcessAnimators(void);
N
N//Adds an animator object to the list.  returns TRUE if successful.
Nuint32_t eGFX_AddAnimator(void * Animator);
N
N//Clears all animators from the list
Nvoid eGFX_ClearAnimators(void);
N
N//Gets the number of animator objects in the list
Nuint32_t eGFX_GetAnimatorCount(void);
N
N//Returns True if the animator is complete
Nuint32_t eGFX_AnimatorIsComplete(void * A);
N
N//returns TRUE if all of the animators are complete
Nuint32_t eGFX_AnimatorsAreComplete(void);
N
N//Pauses all the animators (sets the state to inactive)
Nvoid eGFX_PauseAnimators(void);
N
N//Starts all the Animators in the list.  (Sets the State to Active)
Nvoid eGFX_StartAnimators(void);
N
N//Resets and Animator to step 0 and starts it again.
Nvoid eGFX_ResetAnimator(void * A);
N
N//Resets and restarts all animators
Nvoid eGFX_ResetAnimators(void);
N
N/***
N*      ___     _     _   ___   ___ _            _
N*     | _ \___(_)_ _| |_| __| | _ |_)___ ___ __| |_
N*     |  _/ _ \ | ' \  _| _|  | _ \ (_-</ -_) _|  _|
N*     |_| \___/_|_||_\__|_|   |___/_/__/\___\__|\__|
N*
N*/
N
N//Initializes  a point bisect animator.  It does not add it to the list
N//returns true if successful, false if not
Nuint32_t eGFX_InitPointF_BisectAnimator(  eGFX_PointF_BisectAnimator *P,
N										eGFX_PointF Target,
N										eGFX_PointF *Current,
N										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N										float FractionalBisect		//The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
N);
N
N//Initializes and adds a point bisect animator to the list.
N//returns true if successful, false if not
Nuint32_t eGFX_AddPointF_BisectAnimator(   eGFX_PointF_BisectAnimator *P,
N										eGFX_PointF Target,
N										eGFX_PointF *Current,
N										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N										float FractionalBisect //The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
N										);
N
Nvoid eGFX_ProcessPointF_BisectAnimator(eGFX_PointF_BisectAnimator *P);
N
N
N/***
N*      ___          _          ___   ___ _            _
N*     / __| __ __ _| |__ _ _ _| __| | _ |_)___ ___ __| |_
N*     \__ \/ _/ _` | / _` | '_| _|  | _ \ (_-</ -_) _|  _|
N*     |___/\__\__,_|_\__,_|_| |_|   |___/_/__/\___\__|\__|
N*
N*/
N
N//Initializes the data struct
Nuint32_t eGFX_InitScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
N	float Target,
N	float *Current,
N	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N	float FractionalBisect);
N
Nuint32_t eGFX_AddScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
N	float Target,
N	float *Current,
N	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N	float FractionalBisect);
N
N
Nvoid eGFX_ProcessScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P);
N
N
N
N
N/***
N*      ___          _            _    _
N*     / __| __ __ _| |__ _ _ _  | |  (_)_ _  ___ __ _ _ _
N*     \__ \/ _/ _` | / _` | '_| | |__| | ' \/ -_) _` | '_|
N*     |___/\__\__,_|_\__,_|_|   |____|_|_||_\___\__,_|_|
N*
N*/
N
N//Initializes the data struct
Nuint32_t eGFX_InitScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
N										float Target,
N										float *Current,
N										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N										float Increment
N										);
N
N
N
N//Initializes and adds a scalarf linear animator and adds it to the list
N//returns true if successful, false if not
Nuint32_t eGFX_AddScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
N										float Target,
N										float *Current,
N										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N										float Increment
N										);
N
N										
Nvoid eGFX_ProcessScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P);
N
N
N/***
N*      ___     _     _   ___   _    _
N*     | _ \___(_)_ _| |_| __| | |  (_)_ _  ___ __ _ _ _
N*     |  _/ _ \ | ' \  _| _|  | |__| | ' \/ -_) _` | '_|
N*     |_| \___/_|_||_\__|_|   |____|_|_||_\___\__,_|_|
N*
N*/
N
N//Initializes the data struct
Nuint32_t eGFX_InitPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
N	eGFX_PointF Target,
N	eGFX_PointF *Current,
N	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N	float IncrementX,
N	float IncrementY
N	);
N
N
N
N//Initializes and adds a scalarf linear animator and adds it to the list
N//returns true if successful, false if not
Nuint32_t eGFX_AddPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
N	eGFX_PointF Target,
N	eGFX_PointF *Current,
N	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
N	float IncrementX,
N	float IncrementY
N	);
N
N
Nvoid eGFX_ProcessPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P);
N
N
N
N
N
N										
N/***
N *       ____  ____       _ ______ _____ _______            _____ _____ 
N *      / __ \|  _ \     | |  ____/ ____|__   __|     /\   |  __ \_   _|
N *     | |  | | |_) |    | | |__ | |       | |       /  \  | |__) || |  
N *     | |  | |  _ < _   | |  __|| |       | |      / /\ \ |  ___/ | |  
N *     | |__| | |_) | |__| | |___| |____   | |     / ____ \| |    _| |_ 
N *      \____/|____/ \____/|______\_____|  |_|    /_/    \_\_|   |_____|
N *                                                                      
N *                                                                      
N */
N		
N//Call this when you are ready to draw all the objects on the list
Nvoid eGFX_DrawObjects(eGFX_ImagePlane * Image);
N
N//Adds a eGFX object to the list
Nuint32_t eGFX_AddObject(void * Object);
N
N//Clears all objects from the list
Nvoid eGFX_ClearObjects(void);
N
N//Gets the number of objects in the object list
Nuint32_t eGFX_GetAnimatorCount(void);
N
N//Disables rendering/processing of the object
Nvoid eGFX_DisableObject(void * Object);
N
N//enable rendering/processing of the object
Nvoid eGFX_EnableObject(void * Object);
N
N/***
N*      _____        _   ___
N*     |_   _|____ _| |_| __|
N*       | |/ -_) \ /  _| _|
N*       |_|\___/_\_\\__|_|
N*
N*/
N
N//Draws a TextF object onto an image Plane
Nvoid eGFX_DrawObject_TextF(eGFX_ImagePlane * Image, eGFX_Obj_TextF *TextF_Object);
N
N//Initializes a TextF object
Nvoid eGFX_InitObjectTextF(eGFX_Obj_TextF * TF,
N							eGFX_PointF Position,
N							eGFX_Font *Font,
N							char * String
N							);	
N
N//Initializes a TextF object and also adds it to the current draw list
Nvoid eGFX_AddObjectTextF(eGFX_Obj_TextF * TF,
N						eGFX_PointF Position,
N						eGFX_Font *Font,
N						char * String
N						);
N
N/***
N*      ___ _            _        _   _____        _   ___
N*     / __| |_  __ _ __| |___ __| | |_   _|____ _| |_| __|
N*     \__ \ ' \/ _` / _` / -_) _` |   | |/ -_) \ /  _| _|
N*     |___/_||_\__,_\__,_\___\__,_|   |_|\___/_\_\\__|_|
N*
N*/
N
Nvoid eGFX_InitObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
N	eGFX_PointF Position,
N	eGFX_Font *Font,
N	char * String,
N	float Shading
N	);
N
N
Nvoid eGFX_AddObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
N	eGFX_PointF Position,
N	eGFX_Font *Font,
N	char * String,
N	float Shading
N	);
N
Nvoid	eGFX_DrawObject_ShadedTextF(eGFX_ImagePlane * Image, eGFX_Obj_ShadedTextF *ShadedTextF_Object);
N
N						
N/***
N*      _    _          ___
N*     | |  (_)_ _  ___| __|
N*     | |__| | ' \/ -_) _|
N*     |____|_|_||_\___|_|
N*
N*/
N
N//Initializes a LineF object
Nvoid eGFX_InitObjectLineF(eGFX_Obj_LineF * LF,
N	eGFX_PointF Start,
N	eGFX_PointF End,
N	eGFX_PixelState PS
N	);
N
N
N//Initializes a LineF object and also adds it to the current draw list
Nvoid eGFX_AddObjectLineF(eGFX_Obj_LineF * LF,
N	eGFX_PointF Start,
N	eGFX_PointF End,
N	eGFX_PixelState PS
N	);
N
N
N//Draws a LineF object onto an image Plane
Nvoid	eGFX_DrawObject_LineF(eGFX_ImagePlane * Image, eGFX_Obj_LineF *LineF_Object);
N
N/***
N*      ___          _ _       ___
N*     / __|_ __ _ _(_) |_ ___| __|
N*     \__ \ '_ \ '_| |  _/ -_) _|
N*     |___/ .__/_| |_|\__\___|_|
N*         |_|
N*/
N
N//Initializes a SpriteF object
Nvoid eGFX_InitObjectSpriteF(eGFX_Obj_SpriteF * S,
N							eGFX_PointF Position,
N							eGFX_ImagePlane *	Sprite
N							);
N
N//Initializes a SpriteF object and adds it to the object list
Nvoid eGFX_AddObjectSpriteF(eGFX_Obj_SpriteF * S,
N							eGFX_PointF Position,
N							eGFX_ImagePlane *	Sprite
N							);
N
N//draws a spritef onto an image plane
Nvoid	eGFX_DrawObject_SpriteF(eGFX_ImagePlane * Image, eGFX_Obj_SpriteF *SpriteF_Object);
N
N/***
N*      ___          _ _       ___   ___          _        _
N*     / __|_ __ _ _(_) |_ ___| __| / __| __ __ _| |___ __| |
N*     \__ \ '_ \ '_| |  _/ -_) _|  \__ \/ _/ _` | / -_) _` |
N*     |___/ .__/_| |_|\__\___|_|   |___/\__\__,_|_\___\__,_|
N*         |_|
N*/
N
N//Initializes a scaled sprited object
Nvoid eGFX_InitObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
N	eGFX_PointF Position,
N	eGFX_ImagePlane *	Sprite,
N	float Scale
N	);
N
N
N//Initializes a scaled sprited object and adds it to the object list
Nvoid eGFX_AddObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
N	eGFX_PointF Position,
N	eGFX_ImagePlane *	Sprite,
N	float Scale
N	);
N
N//draws a scaled spritef onto an image plane
Nvoid	eGFX_DrawObject_ScaledSpriteF(eGFX_ImagePlane * Image, eGFX_Obj_ScaledSpriteF *SpriteF_Object);
N
N
N/***
N*       ___          ___
N*      | _ ) _____ _| __|
N*      | _ \/ _ \ \ / _|
N*      |___/\___/_\_\_|
N*
N*/
N
N
Nvoid eGFX_InitObjectBoxF(eGFX_Obj_BoxF * BF,
N	eGFX_PointF P1,
N	eGFX_PointF P2,
N	eGFX_PixelState PS,
N	uint8_t BoxF_RenderOption
N	);
N
N
Nvoid eGFX_AddObjectBoxF(eGFX_Obj_BoxF * BF,
N	eGFX_PointF P1,
N	eGFX_PointF P2,
N	eGFX_PixelState PS,
N	uint8_t BoxF_RenderOption
N	);
N
N
Nvoid	eGFX_DrawObject_BoxF(eGFX_ImagePlane * Image, eGFX_Obj_BoxF *BoxF_Object);
N
N
N/***
N*       ___ _        _     ___
N*      / __(_)_ _ __| |___| __|
N*     | (__| | '_/ _| / -_) _|
N*      \___|_|_| \__|_\___|_|
N*
N*/
N
N
Nvoid eGFX_InitObjectCircleF(eGFX_Obj_CircleF * CF,
N	eGFX_PointF Position,
N	float Radius,
N	eGFX_PixelState PS,
N	uint8_t CircleF_RenderOption
N	);
N
N
Nvoid eGFX_AddObjectCircleF(eGFX_Obj_CircleF * CF,
N	eGFX_PointF Position,
N	float Radius,
N	eGFX_PixelState PS,
N	uint8_t CircleF_RenderOption
N	);
N
Nvoid	eGFX_DrawObject_CircleF(eGFX_ImagePlane * Image, eGFX_Obj_CircleF *CircleF_Object);
N
N
N#endif
N
N
N#ifdef __cplusplus
S }
N#endif
N
L 11 "SRC\main.c" 2
N#include "eGFX_Driver.h"
L 1 ".\SRC\eGFX\eGFX_Driver.h" 1
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
S#define eGFX_DATA_TYPES_H
S
S
Stypedef int16_t FIXED_7_8;
Stypedef int16_t FIXED_9_6;
S
Stypedef int16_t FIXED_0_15;
Stypedef int16_t FIXED_1_14;
S
S
S#define eGFX_IMAGE_PLANE_1BPP		 0
S#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
S#define eGFX_IMAGE_PLANE_4BPP		    2
S#define eGFX_IMAGE_PLANE_8BPP		   3
S#define eGFX_IMAGE_PLANE_16BPP_565    4
S#define eGFX_IMAGE_PLANE_24BPP        5
S#define eGFX_IMAGE_PLANE_32BPP        6
S
S
S
Stypedef struct
S{
S    uint8_t Type;
S    uint8_t *Data;
S    uint16_t SizeX;
S    uint16_t SizeY;
S
S} eGFX_ImagePlane;
S
Stypedef struct
S{
S    int16_t X;
S    int16_t Y;
S} eGFX_Point;
S
Stypedef struct
S{
S    float X; 	
S    float Y;  
S} eGFX_PointF;
S
Stypedef struct
S{
S    eGFX_Point P1;
S    eGFX_Point P2;
S} eGFX_Box;
S
Stypedef struct
S{
S    eGFX_Point Center;
S    uint8_t NumPoints;
S    uint8_t DrawMode;
S    const eGFX_Point *PointList;
S
S} eGFX_ListPrimitive;
S
S
S
S#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
S#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
S#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
S#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
S
Stypedef struct
S{
S    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
S  
S	//Some TT Metrics
S	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
S	
S	uint8_t  SpacesPerTab;
S    uint8_t  InterCharacterSpacing;
S   
S	uint8_t  Padding[2];
S
S} eGFX_Font;
S
S
S#define eGFX_PIXEL_ON     0xFFFFFFFF
S#define eGFX_PIXEL_OFF    0
S
Stypedef uint32_t eGFX_PixelState;
S
S/***
S*       ____  _     _           _
S*      / __ \| |   (_)         | |
S*     | |  | | |__  _  ___  ___| |_ ___
S*     | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | |_) | |  __/ (__| |_\__ \
S*      \____/|_.__/| |\___|\___|\__|___/
X
S*                 _/ |
S*                |__/
S*/
S
Stypedef struct 
S{
S	uint32_t Type;
S	uint32_t State;
S	
S}	eGFX_ObjectHeader;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S}	eGFX_AnimatorHeader;
S
S#define eGFX_OBJECT_STATE_ACTIVE							        	1
S#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
S#define eGFX_OBJECT_STATE_INACTIVE										0
S
S/***
S*                     _                 _                ____  _     _           _
S*         /\         (_)               | |              / __ \| |   (_)         | |
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
S*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
S*                                                                  _/ |
S*                                                                 |__/
S*/
S
S
S
S#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
S#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
S
S#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
S#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_PointF_BisectAnimator;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S	float IncrementX;
S	float IncrementY;
S
S} eGFX_PointF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float Increment; //Increment we should make each step
S
S} eGFX_ScalarF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_ScalarF_BisectAnimator;
S
S/***
S*       _____                 _     _         ____  _     _           _
S*      / ____|               | |   (_)       / __ \| |   (_)         | |
S*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
S*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
S*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
S*                      | |                              _/ |
S*                      |_|                             |__/
S*/
S
S#define eGFX_OBJECT_TEXTF												0x0000
S#define eGFX_OBJECT_SHADED_TEXTF										0x0001
S#define eGFX_OBJECT_LINEF												0x0002
S#define eGFX_OBJECT_SPRITEF												0x0003
S#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
S#define eGFX_OBJECT_BOXF												0x0005
S#define eGFX_OBJECT_CIRCLEF												0x0006
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	
S} eGFX_Obj_TextF;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	float Shading;
S
S} eGFX_Obj_ShadedTextF;
S
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Start;
S	eGFX_PointF End;
S	eGFX_PixelState PixelState; 
S} eGFX_Obj_LineF;
S
S#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	float Radius;
S	eGFX_PixelState PixelState; 
S	uint8_t RenderOption;
S} eGFX_Obj_CircleF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S	
S} eGFX_Obj_SpriteF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S
S	float Scale;
S
S} eGFX_Obj_ScaledSpriteF;
S
S
S#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S
S	eGFX_PointF P1;
S	eGFX_PointF P2;
S
S	eGFX_PixelState PixelState;
S
S	uint8_t BoxF_RenderOption;
S
S} eGFX_Obj_BoxF;
S
S
N#endif
L 2 ".\SRC\eGFX\eGFX_Driver.h" 2
N
N#ifndef GFX_DRIVER_
N#define GFX_DRIVER_
N
N#define eGFX_PHYSICAL_SCREEN_SIZE_X	((uint16_t) 480)	//This is the actual X and Y size of the physical screen in *pixels*
N#define eGFX_PHYSICAL_SCREEN_SIZE_Y	((uint16_t) 272)
N
N//These are the prototypes for the GFX HAL
Nextern void	eGFX_InitDriver(void);
Nextern void	eGFX_Dump(eGFX_ImagePlane *Image);
Nextern void eGFX_WaitForVSync(void);
N//A Driver *Must* have a backbuffer exposed
Nextern eGFX_ImagePlane eGFX_BackBuffer;
N
N#endif
L 12 "SRC\main.c" 2
N#include "FONT_5_7_1BPP.h"
L 1 ".\SRC\eGFX\Fonts\FONT_5_7_1BPP.h" 1
N#include "eGFX.h" 
L 1 ".\SRC\eGFX\eGFX.h" 1
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include <stdlib.h>
N
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
S#define eGFX_DATA_TYPES_H
S
S
Stypedef int16_t FIXED_7_8;
Stypedef int16_t FIXED_9_6;
S
Stypedef int16_t FIXED_0_15;
Stypedef int16_t FIXED_1_14;
S
S
S#define eGFX_IMAGE_PLANE_1BPP		 0
S#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
S#define eGFX_IMAGE_PLANE_4BPP		    2
S#define eGFX_IMAGE_PLANE_8BPP		   3
S#define eGFX_IMAGE_PLANE_16BPP_565    4
S#define eGFX_IMAGE_PLANE_24BPP        5
S#define eGFX_IMAGE_PLANE_32BPP        6
S
S
S
Stypedef struct
S{
S    uint8_t Type;
S    uint8_t *Data;
S    uint16_t SizeX;
S    uint16_t SizeY;
S
S} eGFX_ImagePlane;
S
Stypedef struct
S{
S    int16_t X;
S    int16_t Y;
S} eGFX_Point;
S
Stypedef struct
S{
S    float X; 	
S    float Y;  
S} eGFX_PointF;
S
Stypedef struct
S{
S    eGFX_Point P1;
S    eGFX_Point P2;
S} eGFX_Box;
S
Stypedef struct
S{
S    eGFX_Point Center;
S    uint8_t NumPoints;
S    uint8_t DrawMode;
S    const eGFX_Point *PointList;
S
S} eGFX_ListPrimitive;
S
S
S
S#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
S#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
S#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
S#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
S
Stypedef struct
S{
S    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
S  
S	//Some TT Metrics
S	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
S	
S	uint8_t  SpacesPerTab;
S    uint8_t  InterCharacterSpacing;
S   
S	uint8_t  Padding[2];
S
S} eGFX_Font;
S
S
S#define eGFX_PIXEL_ON     0xFFFFFFFF
S#define eGFX_PIXEL_OFF    0
S
Stypedef uint32_t eGFX_PixelState;
S
S/***
S*       ____  _     _           _
S*      / __ \| |   (_)         | |
S*     | |  | | |__  _  ___  ___| |_ ___
S*     | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | |_) | |  __/ (__| |_\__ \
S*      \____/|_.__/| |\___|\___|\__|___/
X
S*                 _/ |
S*                |__/
S*/
S
Stypedef struct 
S{
S	uint32_t Type;
S	uint32_t State;
S	
S}	eGFX_ObjectHeader;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S}	eGFX_AnimatorHeader;
S
S#define eGFX_OBJECT_STATE_ACTIVE							        	1
S#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
S#define eGFX_OBJECT_STATE_INACTIVE										0
S
S/***
S*                     _                 _                ____  _     _           _
S*         /\         (_)               | |              / __ \| |   (_)         | |
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
S*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
S*                                                                  _/ |
S*                                                                 |__/
S*/
S
S
S
S#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
S#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
S
S#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
S#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_PointF_BisectAnimator;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S	float IncrementX;
S	float IncrementY;
S
S} eGFX_PointF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float Increment; //Increment we should make each step
S
S} eGFX_ScalarF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_ScalarF_BisectAnimator;
S
S/***
S*       _____                 _     _         ____  _     _           _
S*      / ____|               | |   (_)       / __ \| |   (_)         | |
S*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
S*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
S*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
S*                      | |                              _/ |
S*                      |_|                             |__/
S*/
S
S#define eGFX_OBJECT_TEXTF												0x0000
S#define eGFX_OBJECT_SHADED_TEXTF										0x0001
S#define eGFX_OBJECT_LINEF												0x0002
S#define eGFX_OBJECT_SPRITEF												0x0003
S#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
S#define eGFX_OBJECT_BOXF												0x0005
S#define eGFX_OBJECT_CIRCLEF												0x0006
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	
S} eGFX_Obj_TextF;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	float Shading;
S
S} eGFX_Obj_ShadedTextF;
S
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Start;
S	eGFX_PointF End;
S	eGFX_PixelState PixelState; 
S} eGFX_Obj_LineF;
S
S#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	float Radius;
S	eGFX_PixelState PixelState; 
S	uint8_t RenderOption;
S} eGFX_Obj_CircleF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S	
S} eGFX_Obj_SpriteF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S
S	float Scale;
S
S} eGFX_Obj_ScaledSpriteF;
S
S
S#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S
S	eGFX_PointF P1;
S	eGFX_PointF P2;
S
S	eGFX_PixelState PixelState;
S
S	uint8_t BoxF_RenderOption;
S
S} eGFX_Obj_BoxF;
S
S
N#endif
L 10 ".\SRC\eGFX\eGFX.h" 2
N
N
N#ifndef _eGFX_H__
S#define _eGFX_H__
S
S#define eGFX_MAX_ANIMATORS										  32
S#define eGFX_MAX_OBJECTS										  64
S
S#define eGFX_SPACES_PER_TAB                                        4
S#define eGFX_MAX_STRING_LEN                                        64
S#define eGFX_MAX_PRINTF_BUF_LENGTH                                 64
S
S#define eGFX_API_LEVEL											   1
S#define eGFX_REVISION											   2
S
S
S#define eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+7)>>3) //We add 8 to round up to the next even byte boundary
S#define eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+1)>>1) //We add 1 to round up to the next even byte boundary
S#define eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)			 (x)
S#define eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)		 (x*2)
S#define eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*3)
S#define	eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*4)
S
S#define eGFX_CALCULATE_1BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_3BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (((x * y * 3))/8) //This is a special type  for sharp 8 color memory LCDs.   Packing is done in the data buffer so the dump to the screen is simple
S#define eGFX_CALCULATE_4BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_8BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_16BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_24BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_32BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S
S#define ROUND_TO_INT16_T(x)	((int16_t)(x + 0.5f))
S
Sextern const FIXED_1_14 eGFX_Fixed_1_14_SineTable [256];
Sextern const FIXED_7_8 eGFX_Fixed_7_8_SineTable[256];
S
S#define eGFX_GET_INT_FROM_FIXED_7_8(A)				(int16_t)(A>>8)
S#define eGFX_INT_TO_FIXED_7_8(A)					((FIXED_7_8)(A)<<8)
S#define eGFX_GET_FRAC_FROM_FIXED_7_8(A)				(FIXED_7_8)(A&0xFF)
S
S#define eGFX_GET_INT_FROM_FIXED_9_6_(A)				(int16_t)(A>>6)
S#define eGFX_INT_TO_FIXED_9_6(A)					((FIXED_9_6)(A)<<6)
S#define eGFX_GET_FRAC_FROM_FIXED_6_9(A)				(FIXED_9_6)(A&0x3F)
S
SFIXED_7_8 eGFX_GET_INT_FROM_FIXED_7_8_ROUND_TO_NEAREST(FIXED_7_8 A);
SFIXED_7_8 eGFX_FLOAT_TO_FIXED_7_8(float A);
Sint16_t eGFX_FMul_15_0to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_7_8to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_15_0to7_8(int16_t A,int16_t B);
Sint16_t eGFX_FMul_15_0to1_14(int16_t A,int16_t B);
Sint16_t eGFX_ABS(int16_t A);
S
S
S#define eGFX_RGB888_TO_RGB565(R,G,B)	 ( ((R>>2)<<11) | ((G>>2)<<5) | (B>>3))
S
S
S#ifndef TRUE
S	#define TRUE 1
S#endif
S
S#ifndef FALSE
S	#define FALSE 0
S#endif
S
S
S/***
S *      _____ _          _    ____                       _   _
S *     |  __ (_)        | |  / __ \                     | | (_)
S *     | |__) |__  _____| | | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ \ \/ / _ \ | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |>  <  __/ | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_/_/\_\___|_|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                 | |
S *                                 |_|
S */
Svoid eGFX_PutPixel(const eGFX_ImagePlane *Image,
S                   int16_t x,
S                   int16_t y,
S                   eGFX_PixelState PS);
S
SeGFX_PixelState eGFX_GetPixel(const eGFX_ImagePlane *Image,
S                         int16_t x,
S                         int16_t y);
S
S
S
S
S/***
S *      _____      _           _ _   _              ____                       _   _
S *     |  __ \    (_)         (_) | (_)            / __ \                     | | (_)
S *     | |__) | __ _ _ __ ___  _| |_ ___   _____  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ '__| | '_ ` _ \| | __| \ \ / / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |  | | | | | | | | |_| |\ V /  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                                       | |
S *                                                       |_|
S */
S
S 
Svoid eGFX_DrawHline(eGFX_ImagePlane *Image,
S                    int16_t XStart,
S                    int16_t XStop,
S                    int16_t Y,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledBox(eGFX_ImagePlane *Image,
S                        eGFX_Box *Box,
S                        eGFX_PixelState PS);
S
Svoid eGFX_DrawBox(eGFX_ImagePlane *Image,
S                  eGFX_Box *Box,
S                  eGFX_PixelState PS);
S
Svoid eGFX_DrawVline(eGFX_ImagePlane *Image,
S                    int16_t YStart,
S                    int16_t YStop,
S                    int16_t X,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawLine(eGFX_ImagePlane *Image,
S                   int16_t X1,
S                   int16_t Y1,
S                   int16_t X2,
S                   int16_t Y2,
S                   eGFX_PixelState PS);
S
Svoid eGFX_DrawListPrimitive(eGFX_ImagePlane *Image,
S                            eGFX_ListPrimitive *LP ,
S                            eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledListPrimitive(eGFX_ImagePlane *Image,
S                                  eGFX_ListPrimitive *LP ,
S                                  FIXED_7_8 Scale,
S                                  eGFX_PixelState PS);
S
Svoid eGFX_DrawRotatedListPrimitive(eGFX_ImagePlane *Image,
S                                   eGFX_ListPrimitive *LP ,
S                                   uint8_t Angle,
S                                   eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledRotatedListPrimitive(eGFX_ImagePlane *Image,
S        eGFX_ListPrimitive *LP ,
S        uint8_t Angle,
S        FIXED_7_8 Scale,
S        eGFX_PixelState PS);
S
Svoid eGFX_DrawCircle(eGFX_ImagePlane *RC,
S                     int16_t x0,
S                     int16_t y0,
S                     int16_t radius,
S                     eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledCircle(eGFX_ImagePlane *RC,
S	int16_t x0,
S	int16_t y0,
S	int16_t radius,
S	eGFX_PixelState PS);
S
S
S
S/***
S *       _____ _        _                ____                       _   _
S *      / ____| |      (_)              / __ \                     | | (_)
S *     | (___ | |_ _ __ _ _ __   __ _  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *      \___ \| __| '__| | '_ \ / _` | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *      ____) | |_| |  | | | | | (_| | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_____/ \__|_|  |_|_| |_|\__, |  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                               __/ |        | |
S *                              |___/         |_|
S */
S
Sint16_t eGFX_ScaledDrawCharacter(eGFX_ImagePlane *Image,
S                                 int16_t StartX,
S                                 int16_t StartY,
S                                 uint8_t Character,
S                                 const eGFX_Font *MyFont,
S                                 float ScaleFactor);
S
Sint16_t eGFX_DrawCharacter(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawCharacterFaded(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont,
S                           eGFX_PixelState PS);
S
Sint16_t eGFX_DrawCharacterShaded(eGFX_ImagePlane *Image,
S									int16_t StartX,
S									int16_t StartY,
S									uint8_t Character,
S									const eGFX_Font *MyFont,
S									float Shading);
S
S
Sint16_t eGFX_GetStringWidth(char *String,
S                            const eGFX_Font *MyFont);
S
Sint16_t eGFX_GetStringWidth_CustomSpacing(char *String,
S											const eGFX_Font *MyFont,
S											uint16_t Spacing);
S
S
Svoid eGFX_DrawHorizontalCenteredString(eGFX_ImagePlane *Image,
S                                       int16_t StartY,
S                                       char *String,
S                                       const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawRightAlignedCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t CustomCharacterSpacing,
S        int16_t RightSideBuffer);
S
Svoid eGFX_DrawHorizontalCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t Spacing);
S
Svoid eGFX_ScaledDrawString(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           char *String,
S                           const eGFX_Font *MyFont,
S                           float ScaleFactor);
S
Sint16_t  eGFX_DrawStringFaded(eGFX_ImagePlane *Image,
S						 char *String,
S                         int16_t StartX,
S                         int16_t StartY,
S                         const eGFX_Font *MyFont,
S						eGFX_PixelState PS
S                         );
S
S
Sint16_t  eGFX_DrawStringShaded(eGFX_ImagePlane *Image,
S								char *String,
S								int16_t StartX,
S								int16_t StartY,
S								const eGFX_Font *MyFont,
S								float Shading
S								);
S
Svoid eGFX_ScaledDrawString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartX,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        float ScaleFactor ,
S        uint16_t Spacing);
S
Sint16_t  eGFX_DrawString(eGFX_ImagePlane *Image,
S						char * String,
S                         int16_t StartX,
S                         int16_t StartY,
S
S                         const eGFX_Font *MyFont
S                         );
S
Sint16_t  eGFX_printf(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S                     
S                     char *FormatString,...);
S
Sint16_t eGFX_DrawString_CustomSpacing(eGFX_ImagePlane *Image,
S                                      int16_t StartX,
S                                      int16_t StartY,
S                                      char *String,
S                                      const eGFX_Font *MyFont,uint16_t Spacing);
S                                      
Sint16_t  eGFX_printf_Colored(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S											uint32_t Color,
S                     char *FormatString,...);
S
Sint16_t  eGFX_printf_HorizontalCentered_Colored(eGFX_ImagePlane *Image,
S                                         int16_t StartY,
S                                        const eGFX_Font *MyFont,
S                                        uint32_t Color,
S                                        char *FormatString,...);
S/***
S*      _____  _                     ____                       _   _
S*     |  __ \| |                   / __ \                     | | (_)
S*     | |__) | | __ _ _ __   ___  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S*     |  ___/| |/ _` | '_ \ / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S*     | |    | | (_| | | | |  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S*     |_|    |_|\__,_|_| |_|\___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S*                                        | |
S*                                        |_|
S*/
S
Svoid eGFX_Blit(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_CenteredBlit(eGFX_ImagePlane *Destination,
S			int16_t x,
S			int16_t y,
S			const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_BlitFaded(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite,
S               eGFX_PixelState PS);
S
Svoid eGFX_BlitShaded(eGFX_ImagePlane *Destination,
S					int16_t x,
S					int16_t y,
S					const eGFX_ImagePlane *Sprite,
S					float Shading);
S                    
Svoid eGFX_BlitColored(eGFX_ImagePlane *Destination,
S                    int16_t x,
S                    int16_t y,
S                    const eGFX_ImagePlane *Sprite,
S                    uint32_t Color);
S
Svoid eGFX_ScaledBlit(eGFX_ImagePlane *Destination,
S                     int16_t x,
S                     int16_t y,
S                     const eGFX_ImagePlane *Sprite,
S                     float ScaleFactor);
S
Suint8_t eGFX_GetBitFromArray(uint8_t *DataArray,uint16_t Bit);
S
S
Suint8_t eGFX_ImagePlane_GetByte(eGFX_ImagePlane   *Image,
S                                uint16_t X,
S                                uint16_t Y);
S
S
Svoid eGFX_ImagePlaneInit(eGFX_ImagePlane   *Image, uint8_t * Store, int16_t SizeX, int16_t SizeY, uint8_t Type);
S
Svoid eGFX_ImagePlane_Clear(eGFX_ImagePlane   *Image);
S
S
S
S/***
S*                     _                 _                        _____ _____
S*         /\         (_)               | |                 /\   |  __ \_   _|
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __     /  \  | |__) || |
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__|   / /\ \ |  ___/ | |
S*      / ____ \| | | | | | | | | | (_| | || (_) | |     / ____ \| |    _| |_
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|    /_/    \_\_|   |_____|
S*
S*
S*/
S
S//Call this in the main loop.   Animators will be stepped at the rate that this is called!
Svoid eGFX_ProcessAnimators(void);
S
S//Adds an animator object to the list.  returns TRUE if successful.
Suint32_t eGFX_AddAnimator(void * Animator);
S
S//Clears all animators from the list
Svoid eGFX_ClearAnimators(void);
S
S//Gets the number of animator objects in the list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Returns True if the animator is complete
Suint32_t eGFX_AnimatorIsComplete(void * A);
S
S//returns TRUE if all of the animators are complete
Suint32_t eGFX_AnimatorsAreComplete(void);
S
S//Pauses all the animators (sets the state to inactive)
Svoid eGFX_PauseAnimators(void);
S
S//Starts all the Animators in the list.  (Sets the State to Active)
Svoid eGFX_StartAnimators(void);
S
S//Resets and Animator to step 0 and starts it again.
Svoid eGFX_ResetAnimator(void * A);
S
S//Resets and restarts all animators
Svoid eGFX_ResetAnimators(void);
S
S/***
S*      ___     _     _   ___   ___ _            _
S*     | _ \___(_)_ _| |_| __| | _ |_)___ ___ __| |_
S*     |  _/ _ \ | ' \  _| _|  | _ \ (_-</ -_) _|  _|
S*     |_| \___/_|_||_\__|_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes  a point bisect animator.  It does not add it to the list
S//returns true if successful, false if not
Suint32_t eGFX_InitPointF_BisectAnimator(  eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect		//The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S);
S
S//Initializes and adds a point bisect animator to the list.
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_BisectAnimator(   eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect //The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S										);
S
Svoid eGFX_ProcessPointF_BisectAnimator(eGFX_PointF_BisectAnimator *P);
S
S
S/***
S*      ___          _          ___   ___ _            _
S*     / __| __ __ _| |__ _ _ _| __| | _ |_)___ ___ __| |_
S*     \__ \/ _/ _` | / _` | '_| _|  | _ \ (_-</ -_) _|  _|
S*     |___/\__\__,_|_\__,_|_| |_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
Suint32_t eGFX_AddScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
S
Svoid eGFX_ProcessScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P);
S
S
S
S
S/***
S*      ___          _            _    _
S*     / __| __ __ _| |__ _ _ _  | |  (_)_ _  ___ __ _ _ _
S*     \__ \/ _/ _` | / _` | '_| | |__| | ' \/ -_) _` | '_|
S*     |___/\__\__,_|_\__,_|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S										
Svoid eGFX_ProcessScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P);
S
S
S/***
S*      ___     _     _   ___   _    _
S*     | _ \___(_)_ _| |_| __| | |  (_)_ _  ___ __ _ _ _
S*     |  _/ _ \ | ' \  _| _|  | |__| | ' \/ -_) _` | '_|
S*     |_| \___/_|_||_\__|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
Svoid eGFX_ProcessPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P);
S
S
S
S
S
S										
S/***
S *       ____  ____       _ ______ _____ _______            _____ _____ 
S *      / __ \|  _ \     | |  ____/ ____|__   __|     /\   |  __ \_   _|
S *     | |  | | |_) |    | | |__ | |       | |       /  \  | |__) || |  
S *     | |  | |  _ < _   | |  __|| |       | |      / /\ \ |  ___/ | |  
S *     | |__| | |_) | |__| | |___| |____   | |     / ____ \| |    _| |_ 
S *      \____/|____/ \____/|______\_____|  |_|    /_/    \_\_|   |_____|
S *                                                                      
S *                                                                      
S */
S		
S//Call this when you are ready to draw all the objects on the list
Svoid eGFX_DrawObjects(eGFX_ImagePlane * Image);
S
S//Adds a eGFX object to the list
Suint32_t eGFX_AddObject(void * Object);
S
S//Clears all objects from the list
Svoid eGFX_ClearObjects(void);
S
S//Gets the number of objects in the object list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Disables rendering/processing of the object
Svoid eGFX_DisableObject(void * Object);
S
S//enable rendering/processing of the object
Svoid eGFX_EnableObject(void * Object);
S
S/***
S*      _____        _   ___
S*     |_   _|____ _| |_| __|
S*       | |/ -_) \ /  _| _|
S*       |_|\___/_\_\\__|_|
S*
S*/
S
S//Draws a TextF object onto an image Plane
Svoid eGFX_DrawObject_TextF(eGFX_ImagePlane * Image, eGFX_Obj_TextF *TextF_Object);
S
S//Initializes a TextF object
Svoid eGFX_InitObjectTextF(eGFX_Obj_TextF * TF,
S							eGFX_PointF Position,
S							eGFX_Font *Font,
S							char * String
S							);	
S
S//Initializes a TextF object and also adds it to the current draw list
Svoid eGFX_AddObjectTextF(eGFX_Obj_TextF * TF,
S						eGFX_PointF Position,
S						eGFX_Font *Font,
S						char * String
S						);
S
S/***
S*      ___ _            _        _   _____        _   ___
S*     / __| |_  __ _ __| |___ __| | |_   _|____ _| |_| __|
S*     \__ \ ' \/ _` / _` / -_) _` |   | |/ -_) \ /  _| _|
S*     |___/_||_\__,_\__,_\___\__,_|   |_|\___/_\_\\__|_|
S*
S*/
S
Svoid eGFX_InitObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
S
Svoid eGFX_AddObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
Svoid	eGFX_DrawObject_ShadedTextF(eGFX_ImagePlane * Image, eGFX_Obj_ShadedTextF *ShadedTextF_Object);
S
S						
S/***
S*      _    _          ___
S*     | |  (_)_ _  ___| __|
S*     | |__| | ' \/ -_) _|
S*     |____|_|_||_\___|_|
S*
S*/
S
S//Initializes a LineF object
Svoid eGFX_InitObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Initializes a LineF object and also adds it to the current draw list
Svoid eGFX_AddObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Draws a LineF object onto an image Plane
Svoid	eGFX_DrawObject_LineF(eGFX_ImagePlane * Image, eGFX_Obj_LineF *LineF_Object);
S
S/***
S*      ___          _ _       ___
S*     / __|_ __ _ _(_) |_ ___| __|
S*     \__ \ '_ \ '_| |  _/ -_) _|
S*     |___/ .__/_| |_|\__\___|_|
S*         |_|
S*/
S
S//Initializes a SpriteF object
Svoid eGFX_InitObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//Initializes a SpriteF object and adds it to the object list
Svoid eGFX_AddObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//draws a spritef onto an image plane
Svoid	eGFX_DrawObject_SpriteF(eGFX_ImagePlane * Image, eGFX_Obj_SpriteF *SpriteF_Object);
S
S/***
S*      ___          _ _       ___   ___          _        _
S*     / __|_ __ _ _(_) |_ ___| __| / __| __ __ _| |___ __| |
S*     \__ \ '_ \ '_| |  _/ -_) _|  \__ \/ _/ _` | / -_) _` |
S*     |___/ .__/_| |_|\__\___|_|   |___/\__\__,_|_\___\__,_|
S*         |_|
S*/
S
S//Initializes a scaled sprited object
Svoid eGFX_InitObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S
S//Initializes a scaled sprited object and adds it to the object list
Svoid eGFX_AddObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S//draws a scaled spritef onto an image plane
Svoid	eGFX_DrawObject_ScaledSpriteF(eGFX_ImagePlane * Image, eGFX_Obj_ScaledSpriteF *SpriteF_Object);
S
S
S/***
S*       ___          ___
S*      | _ ) _____ _| __|
S*      | _ \/ _ \ \ / _|
S*      |___/\___/_\_\_|
S*
S*/
S
S
Svoid eGFX_InitObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid	eGFX_DrawObject_BoxF(eGFX_ImagePlane * Image, eGFX_Obj_BoxF *BoxF_Object);
S
S
S/***
S*       ___ _        _     ___
S*      / __(_)_ _ __| |___| __|
S*     | (__| | '_/ _| / -_) _|
S*      \___|_|_| \__|_\___|_|
S*
S*/
S
S
Svoid eGFX_InitObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
Svoid	eGFX_DrawObject_CircleF(eGFX_ImagePlane * Image, eGFX_Obj_CircleF *CircleF_Object);
S
S
N#endif
N
N
N#ifdef __cplusplus
S }
N#endif
N
L 2 ".\SRC\eGFX\Fonts\FONT_5_7_1BPP.h" 2
N
N#ifndef _FONT_5_7_1BPP_H
N#define _FONT_5_7_1BPP_H
N
Nextern const eGFX_Font FONT_5_7_1BPP;
N
N#endif
N
L 13 "SRC\main.c" 2
N#include "pin_mux.h"
N#include "fsl_device_registers.h"
N#include "fsl_i2c.h"
L 1 ".\SRC\Drivers\fsl_i2c.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N#ifndef _FSL_I2C_H_
N#define _FSL_I2C_H_
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 33 ".\SRC\Drivers\fsl_i2c.h" 2
N#include "fsl_device_registers.h"
N#include "fsl_common.h"
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N#define I2C_CFG_MASK 0x1f
N
N/*!
N * @addtogroup i2c_driver
N * @{
N */
N
N/*! @file */
N
N/*! @name Driver version */
N/*@{*/
N/*! @brief I2C driver version 1.0.0. */
N#define NXP_I2C_DRIVER_VERSION (MAKE_VERSION(1, 0, 0))
N/*@}*/
N
N/* definitions for MSTCODE bits in I2C Status register STAT */
N#define I2C_STAT_MSTCODE_IDLE (0)    /*!< Master Idle State Code */
N#define I2C_STAT_MSTCODE_RXREADY (1) /*!< Master Receive Ready State Code */
N#define I2C_STAT_MSTCODE_TXREADY (2) /*!< Master Transmit Ready State Code */
N#define I2C_STAT_MSTCODE_NACKADR (3) /*!< Master NACK by slave on address State Code */
N#define I2C_STAT_MSTCODE_NACKDAT (4) /*!< Master NACK by slave on data State Code */
N
N/* definitions for SLVSTATE bits in I2C Status register STAT */
N#define I2C_STAT_SLVST_ADDR (0)
N#define I2C_STAT_SLVST_RX (1)
N#define I2C_STAT_SLVST_TX (2)
N
N/*! @brief I2C status return codes. */
Nenum _i2c_status
N{
N    kStatus_I2C_Busy = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 0), /*!< The master is already performing a transfer. */
X    kStatus_I2C_Busy = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (0))),  
N    kStatus_I2C_Idle = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 1), /*!< The slave driver is idle. */
X    kStatus_I2C_Idle = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (1))),  
N    kStatus_I2C_Nak =
N        MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 2), /*!< The slave device sent a NAK in response to a byte. */
X        ((((kStatusGroup_FLEXCOMM_I2C)*100) + (2))),  
N    kStatus_I2C_InvalidParameter =
N        MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 3), /*!< Unable to proceed due to invalid parameter. */
X        ((((kStatusGroup_FLEXCOMM_I2C)*100) + (3))),  
N    kStatus_I2C_BitError = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 4), /*!< Transferred bit was not seen on the bus. */
X    kStatus_I2C_BitError = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (4))),  
N    kStatus_I2C_ArbitrationLost = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 5), /*!< Arbitration lost error. */
X    kStatus_I2C_ArbitrationLost = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (5))),  
N    kStatus_I2C_NoTransferInProgress =
N        MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 7), /*!< Attempt to abort a transfer when one is not in progress. */
X        ((((kStatusGroup_FLEXCOMM_I2C)*100) + (7))),  
N    kStatus_I2C_DmaRequestFail = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 7), /*!< DMA request failed. */
X    kStatus_I2C_DmaRequestFail = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (7))),  
N    kStatus_I2C_StartStopError = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 8),
X    kStatus_I2C_StartStopError = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (8))),
N    kStatus_I2C_UnexpectedState = MAKE_STATUS(kStatusGroup_FLEXCOMM_I2C, 9),
X    kStatus_I2C_UnexpectedState = ((((kStatusGroup_FLEXCOMM_I2C)*100) + (9))),
N};
N
N/*! @} */
N
N/*!
N * @addtogroup i2c_master_driver
N * @{
N */
N
N/*!
N * @brief I2C master peripheral flags.
N *
N * @note These enums are meant to be OR'd together to form a bit mask.
N */
Nenum _i2c_master_flags
N{
N    kI2C_MasterPendingFlag = I2C_STAT_MSTPENDING_MASK, /*!< The I2C module is waiting for software interaction. */
X    kI2C_MasterPendingFlag = (0x1U),  
N    kI2C_MasterArbitrationLostFlag = I2C_STAT_MSTARBLOSS_MASK, /*!< The arbitration of the bus was lost. There was collision on the bus */
X    kI2C_MasterArbitrationLostFlag = (0x10U),  
N    kI2C_MasterStartStopErrorFlag = I2C_STAT_MSTSTSTPERR_MASK /*!< There was an error during start or stop phase of the transaction. */
X    kI2C_MasterStartStopErrorFlag = (0x40U)  
N};
N
N/*! @brief Direction of master and slave transfers. */
Ntypedef enum _i2c_direction
N{
N    kI2C_Write = 0U, /*!< Master transmit. */
N    kI2C_Read = 1U   /*!< Master receive. */
N} i2c_direction_t;
N
N/*!
N * @brief Structure with settings to initialize the I2C master module.
N *
N * This structure holds configuration settings for the I2C peripheral. To initialize this
N * structure to reasonable defaults, call the I2C_MasterGetDefaultConfig() function and
N * pass a pointer to your configuration structure instance.
N *
N * The configuration structure can be made constant so it resides in flash.
N */
Ntypedef struct _i2c_master_config
N{
N    bool enableMaster;     /*!< Whether to enable master mode. */
X    _Bool enableMaster;      
N    uint32_t baudRate_Bps; /*!< Desired baud rate in bits per second. */
N    bool enableTimeout;    /*!< Enable internal timeout function. */
X    _Bool enableTimeout;     
N} i2c_master_config_t;
N
N/* Forward declaration of the transfer descriptor and handle typedefs. */
N/*! @brief I2C master transfer typedef */
Ntypedef struct _i2c_master_transfer i2c_master_transfer_t;
N
N/*! @brief I2C master handle typedef */
Ntypedef struct _i2c_master_handle i2c_master_handle_t;
N
N/*!
N * @brief Master completion callback function pointer type.
N *
N * This callback is used only for the non-blocking master transfer API. Specify the callback you wish to use
N * in the call to I2C_MasterTransferCreateHandle().
N *
N * @param base The I2C peripheral base address.
N * @param completionStatus Either kStatus_Success or an error code describing how the transfer completed.
N * @param userData Arbitrary pointer-sized value passed from the application.
N */
Ntypedef void (*i2c_master_transfer_callback_t)(I2C_Type *base,
N                                               i2c_master_handle_t *handle,
N                                               status_t completionStatus,
N                                               void *userData);
N
N/*!
N * @brief Transfer option flags.
N *
N * @note These enumerations are intended to be OR'd together to form a bit mask of options for
N * the #_i2c_master_transfer::flags field.
N */
Nenum _i2c_master_transfer_flags
N{
N    kI2C_TransferDefaultFlag = 0x00U,       /*!< Transfer starts with a start signal, stops with a stop signal. */
N    kI2C_TransferNoStartFlag = 0x01U,       /*!< Don't send a start condition, address, and sub address */
N    kI2C_TransferRepeatedStartFlag = 0x02U, /*!< Send a repeated start condition */
N    kI2C_TransferNoStopFlag = 0x04U,        /*!< Don't send a stop condition. */
N};
N
N/*! @brief States for the state machine used by transactional APIs. */
Nenum _i2c_transfer_states
N{
N    kIdleState = 0,
N    kTransmitSubaddrState,
N    kTransmitDataState,
N    kReceiveDataState,
N    kReceiveLastDataState,
N    kStartState,
N    kStopState,
N    kWaitForCompletionState
N};
N
N/*!
N * @brief Non-blocking transfer descriptor structure.
N *
N * This structure is used to pass transaction parameters to the I2C_MasterTransferNonBlocking() API.
N */
Nstruct _i2c_master_transfer
N{
N    uint32_t flags; /*!< Bit mask of options for the transfer. See enumeration #_i2c_master_transfer_flags for available
N                       options. Set to 0 or #kI2C_TransferDefaultFlag for normal transfers. */
N    uint16_t slaveAddress;     /*!< The 7-bit slave address. */
N    i2c_direction_t direction; /*!< Either #kI2C_Read or #kI2C_Write. */
N    uint32_t subaddress;       /*!< Sub address. Transferred MSB first. */
N    size_t subaddressSize;     /*!< Length of sub address to send in bytes. Maximum size is 4 bytes. */
N    void *data;                /*!< Pointer to data to transfer. */
N    size_t dataSize;           /*!< Number of bytes to transfer. */
N};
N
N/*!
N * @brief Driver handle for master non-blocking APIs.
N * @note The contents of this structure are private and subject to change.
N */
Nstruct _i2c_master_handle
N{
N    uint8_t state;           /*!< Transfer state machine current state. */
N    uint32_t transferCount;  /*!< Indicates progress of the transfer */
N    uint32_t remainingBytes; /*!< Remaining byte count in current state. */
N    uint8_t *buf;            /*!< Buffer pointer for current state. */
N    uint32_t remainingSubaddr;
N    uint8_t subaddrBuf[4];
N    i2c_master_transfer_t transfer;                    /*!< Copy of the current transfer info. */
N    i2c_master_transfer_callback_t completionCallback; /*!< Callback function pointer. */
N    void *userData;                                    /*!< Application data passed to callback. */
N};
N
N/*! @} */
N
N/*!
N * @addtogroup i2c_slave_driver
N * @{
N */
N
N /*!
N * @brief I2C slave peripheral flags.
N *
N * @note These enums are meant to be OR'd together to form a bit mask.
N */
Nenum _i2c_slave_flags
N{
N    kI2C_SlavePendingFlag = I2C_STAT_SLVPENDING_MASK, /*!< The I2C module is waiting for software interaction. */
X    kI2C_SlavePendingFlag = (0x100U),  
N    kI2C_SlaveNotStretching = I2C_STAT_SLVNOTSTR_MASK, /*!< Indicates whether the slave is currently stretching clock (0 = yes, 1 = no). */
X    kI2C_SlaveNotStretching = (0x800U),  
N    kI2C_SlaveSelected = I2C_STAT_SLVSEL_MASK, /*!< Indicates whether the slave is selected by an address match. */
X    kI2C_SlaveSelected = (0x4000U),  
N    kI2C_SaveDeselected = I2C_STAT_SLVDESEL_MASK /*!< Indicates that slave was previously deselected (deselect event took place, w1c). */
X    kI2C_SaveDeselected = (0x8000U)  
N};
N 
N/*! @brief I2C slave address register. */
Ntypedef enum _i2c_slave_address_register
N{
N    kI2C_SlaveAddressRegister0 = 0U, /*!< Slave Address 0 register. */
N    kI2C_SlaveAddressRegister1 = 1U, /*!< Slave Address 1 register. */
N    kI2C_SlaveAddressRegister2 = 2U, /*!< Slave Address 2 register. */
N    kI2C_SlaveAddressRegister3 = 3U, /*!< Slave Address 3 register. */
N} i2c_slave_address_register_t;
N
N/*! @brief Data structure with 7-bit Slave address and Slave address disable. */
Ntypedef struct _i2c_slave_address
N{
N    uint8_t address;     /*!< 7-bit Slave address SLVADR. */
N    bool addressDisable; /*!< Slave address disable SADISABLE. */
X    _Bool addressDisable;  
N} i2c_slave_address_t;
N
N/*! @brief I2C slave address match options. */
Ntypedef enum _i2c_slave_address_qual_mode
N{
N    kI2C_QualModeMask = 0U, /*!< The SLVQUAL0 field (qualAddress) is used as a logical mask for matching address0. */
N    kI2C_QualModeExtend =
N        1U, /*!< The SLVQUAL0 (qualAddress) field is used to extend address 0 matching in a range of addresses. */
N} i2c_slave_address_qual_mode_t;
N
N/*! @brief I2C slave bus speed options. */
Ntypedef enum _i2c_slave_bus_speed
N{
N    kI2C_SlaveStandardMode = 0U,
N    kI2C_SlaveFastMode = 1U,
N    kI2C_SlaveFastModePlus = 2U,
N    kI2C_SlaveHsMode = 3U,
N} i2c_slave_bus_speed_t;
N
N/*!
N * @brief Structure with settings to initialize the I2C slave module.
N *
N * This structure holds configuration settings for the I2C slave peripheral. To initialize this
N * structure to reasonable defaults, call the I2C_SlaveGetDefaultConfig() function and
N * pass a pointer to your configuration structure instance.
N *
N * The configuration structure can be made constant so it resides in flash.
N */
Ntypedef struct _i2c_slave_config
N{
N    i2c_slave_address_t address0;           /*!< Slave's 7-bit address and disable. */
N    i2c_slave_address_t address1;           /*!< Alternate slave 7-bit address and disable. */
N    i2c_slave_address_t address2;           /*!< Alternate slave 7-bit address and disable. */
N    i2c_slave_address_t address3;           /*!< Alternate slave 7-bit address and disable. */
N    i2c_slave_address_qual_mode_t qualMode; /*!< Qualify mode for slave address 0. */
N    uint8_t qualAddress;                    /*!< Slave address qualifier for address 0. */
N    i2c_slave_bus_speed_t
N        busSpeed; /*!< Slave bus speed mode. If the slave function stretches SCL to allow for software response, it must
N                       provide sufficient data setup time to the master before releasing the stretched clock.
N                       This is accomplished by inserting one clock time of CLKDIV at that point.
N                       The #busSpeed value is used to configure CLKDIV
N                       such that one clock time is greater than the tSU;DAT value noted
N                       in the I2C bus specification for the I2C mode that is being used.
N                       If the #busSpeed mode is unknown at compile time, use the longest data setup time
N                       kI2C_SlaveStandardMode (250 ns) */
N    bool enableSlave; /*!< Enable slave mode. */
X    _Bool enableSlave;  
N} i2c_slave_config_t;
N
N/*!
N * @brief Set of events sent to the callback for non blocking slave transfers.
N *
N * These event enumerations are used for two related purposes. First, a bit mask created by OR'ing together
N * events is passed to I2C_SlaveTransferNonBlocking() in order to specify which events to enable.
N * Then, when the slave callback is invoked, it is passed the current event through its @a transfer
N * parameter.
N *
N * @note These enumerations are meant to be OR'd together to form a bit mask of events.
N */
Ntypedef enum _i2c_slave_transfer_event
N{
N    kI2C_SlaveAddressMatchEvent = 0x01U, /*!< Received the slave address after a start or repeated start. */
N    kI2C_SlaveTransmitEvent = 0x02U,     /*!< Callback is requested to provide data to transmit
N                                                (slave-transmitter role). */
N    kI2C_SlaveReceiveEvent = 0x04U,      /*!< Callback is requested to provide a buffer in which to place received
N                                                 data (slave-receiver role). */
N    kI2C_SlaveCompletionEvent = 0x20U,   /*!< All data in the active transfer have been consumed. */
N    kI2C_SlaveDeselectedEvent =
N        0x40U, /*!< The slave function has become deselected (SLVSEL flag changing from 1 to 0. */
N
N    /*! Bit mask of all available events. */
N    kI2C_SlaveAllEvents = kI2C_SlaveAddressMatchEvent | kI2C_SlaveTransmitEvent | kI2C_SlaveReceiveEvent |
N                          kI2C_SlaveCompletionEvent | kI2C_SlaveDeselectedEvent,
N} i2c_slave_transfer_event_t;
N
N/*! @brief I2C slave handle typedef. */
Ntypedef struct _i2c_slave_handle i2c_slave_handle_t;
N
N/*! @brief I2C slave transfer structure */
Ntypedef struct _i2c_slave_transfer
N{
N    i2c_slave_handle_t *handle;       /*!< Pointer to handle that contains this transfer. */
N    i2c_slave_transfer_event_t event; /*!< Reason the callback is being invoked. */
N    uint8_t receivedAddress;          /*!< Matching address send by master. 7-bits plus R/nW bit0 */
N    uint32_t eventMask;               /*!< Mask of enabled events. */
N    uint8_t *rxData;                  /*!< Transfer buffer for receive data */
N    const uint8_t *txData;            /*!< Transfer buffer for transmit data */
N    size_t txSize;                    /*!< Transfer size */
N    size_t rxSize;                    /*!< Transfer size */
N    size_t transferredCount;          /*!< Number of bytes transferred during this transfer. */
N    status_t completionStatus;        /*!< Success or error code describing how the transfer completed. Only applies for
N                                         #kI2C_SlaveCompletionEvent. */
N} i2c_slave_transfer_t;
N
N/*!
N * @brief Slave event callback function pointer type.
N *
N * This callback is used only for the slave non-blocking transfer API. To install a callback,
N * use the I2C_SlaveSetCallback() function after you have created a handle.
N *
N * @param base Base address for the I2C instance on which the event occurred.
N * @param transfer Pointer to transfer descriptor containing values passed to and/or from the callback.
N * @param userData Arbitrary pointer-sized value passed from the application.
N */
Ntypedef void (*i2c_slave_transfer_callback_t)(I2C_Type *base, volatile i2c_slave_transfer_t *transfer, void *userData);
N
N/*!
N * @brief I2C slave software finite state machine states.
N */
Ntypedef enum _i2c_slave_fsm
N{
N    kI2C_SlaveFsmAddressMatch = 0u,
N    kI2C_SlaveFsmReceive = 2u,
N    kI2C_SlaveFsmTransmit = 3u,
N} i2c_slave_fsm_t;
N
N/*!
N * @brief I2C slave handle structure.
N * @note The contents of this structure are private and subject to change.
N */
Nstruct _i2c_slave_handle
N{
N    volatile i2c_slave_transfer_t transfer; /*!< I2C slave transfer. */
N    volatile bool isBusy;                   /*!< Whether transfer is busy. */
X    volatile _Bool isBusy;                    
N    volatile i2c_slave_fsm_t slaveFsm;      /*!< slave transfer state machine. */
N    i2c_slave_transfer_callback_t callback; /*!< Callback function called at transfer event. */
N    void *userData;                         /*!< Callback parameter passed to callback. */
N};
N
N/*! @} */
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*!
N * @addtogroup i2c_master_driver
N * @{
N */
N
N/*! @name Initialization and deinitialization */
N/*@{*/
N
N/*!
N * @brief Provides a default configuration for the I2C master peripheral.
N *
N * This function provides the following default configuration for the I2C master peripheral:
N * @code
N *  masterConfig->enableMaster            = true;
N *  masterConfig->baudRate_Bps            = 100000U;
N *  masterConfig->enableTimeout           = false;
N * @endcode
N *
N * After calling this function, you can override any settings in order to customize the configuration,
N * prior to initializing the master driver with I2C_MasterInit().
N *
N * @param[out] masterConfig User provided configuration structure for default values. Refer to #i2c_master_config_t.
N */
Nvoid I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig);
N
N/*!
N * @brief Initializes the I2C master peripheral.
N *
N * This function enables the peripheral clock and initializes the I2C master peripheral as described by the user
N * provided configuration. A software reset is performed prior to configuration.
N *
N * @param base The I2C peripheral base address.
N * @param masterConfig User provided peripheral configuration. Use I2C_MasterGetDefaultConfig() to get a set of
N * defaults
N *      that you can override.
N * @param srcClock_Hz Frequency in Hertz of the I2C functional clock. Used to calculate the baud rate divisors,
N *      filter widths, and timeout periods.
N */
Nvoid I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz);
N
N/*!
N* @brief Deinitializes the I2C master peripheral.
N*
N * This function disables the I2C master peripheral and gates the clock. It also performs a software
N * reset to restore the peripheral to reset conditions.
N *
N * @param base The I2C peripheral base address.
N */
Nvoid I2C_MasterDeinit(I2C_Type *base);
N
N/*!
N * @brief Performs a software reset.
N *
N * Restores the I2C master peripheral to reset conditions.
N *
N * @param base The I2C peripheral base address.
N */
Nstatic inline void I2C_MasterReset(I2C_Type *base)
N{
N}
N
N/*!
N * @brief Enables or disables the I2C module as master.
N *
N * @param base The I2C peripheral base address.
N * @param enable Pass true to enable or false to disable the specified I2C as master.
N */
Nstatic inline void I2C_MasterEnable(I2C_Type *base, bool enable)
Xstatic inline void I2C_MasterEnable(I2C_Type *base, _Bool enable)
N{
N    if (enable)
N    {
N        base->CFG = (base->CFG & I2C_CFG_MASK) | I2C_CFG_MSTEN_MASK;
X        base->CFG = (base->CFG & 0x1f) | (0x1U);
N    }
N    else
N    {
N        base->CFG = (base->CFG & I2C_CFG_MASK) & ~I2C_CFG_MSTEN_MASK;
X        base->CFG = (base->CFG & 0x1f) & ~(0x1U);
N    }
N}
N
N/*@}*/
N
N/*! @name Status */
N/*@{*/
N
N/*!
N * @brief Gets the I2C status flags.
N *
N * A bit mask with the state of all I2C status flags is returned. For each flag, the corresponding bit
N * in the return value is set if the flag is asserted.
N *
N * @param base The I2C peripheral base address.
N * @return State of the status flags:
N *         - 1: related status flag is set.
N *         - 0: related status flag is not set.
N * @see _i2c_master_flags
N */
Nstatic inline uint32_t I2C_GetStatusFlags(I2C_Type *base)
N{
N    return base->STAT;
N}
N
N/*!
N * @brief Clears the I2C master status flag state.
N *
N * The following status register flags can be cleared:
N * - #kI2C_MasterArbitrationLostFlag
N * - #kI2C_MasterStartStopErrorFlag
N *
N * Attempts to clear other flags has no effect.
N *
N * @param base The I2C peripheral base address.
N * @param statusMask A bitmask of status flags that are to be cleared. The mask is composed of
N *  #_i2c_master_flags enumerators OR'd together. You may pass the result of a previous call to
N *  I2C_GetStatusFlags().
N * @see _i2c_master_flags.
N */
Nstatic inline void I2C_MasterClearStatusFlags(I2C_Type *base, uint32_t statusMask)
N{
N    /* Allow clearing just master status flags */
N    base->STAT = statusMask & (I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
X    base->STAT = statusMask & ((0x10U) | (0x40U));
N}
N
N/*@}*/
N
N/*! @name Interrupts */
N/*@{*/
N
N/*!
N * @brief Enables the I2C master interrupt requests.
N *
N * @param base The I2C peripheral base address.
N * @param interruptMask Bit mask of interrupts to enable. See #_i2c_master_flags for the set
N *      of constants that should be OR'd together to form the bit mask.
N */
Nstatic inline void I2C_EnableInterrupts(I2C_Type *base, uint32_t interruptMask)
N{
N    base->INTENSET = interruptMask;
N}
N
N/*!
N * @brief Disables the I2C master interrupt requests.
N *
N * @param base The I2C peripheral base address.
N * @param interruptMask Bit mask of interrupts to disable. See #_i2c_master_flags for the set
N *      of constants that should be OR'd together to form the bit mask.
N */
Nstatic inline void I2C_DisableInterrupts(I2C_Type *base, uint32_t interruptMask)
N{
N    base->INTENCLR = interruptMask;
N}
N
N/*!
N * @brief Returns the set of currently enabled I2C master interrupt requests.
N *
N * @param base The I2C peripheral base address.
N * @return A bitmask composed of #_i2c_master_flags enumerators OR'd together to indicate the
N *      set of enabled interrupts.
N */
Nstatic inline uint32_t I2C_GetEnabledInterrupts(I2C_Type *base)
N{
N    return base->INTSTAT;
N}
N
N/*@}*/
N
N/*! @name Bus operations */
N/*@{*/
N
N/*!
N * @brief Sets the I2C bus frequency for master transactions.
N *
N * The I2C master is automatically disabled and re-enabled as necessary to configure the baud
N * rate. Do not call this function during a transfer, or the transfer is aborted.
N *
N * @param base The I2C peripheral base address.
N * @param srcClock_Hz I2C functional clock frequency in Hertz.
N * @param baudRate_Bps Requested bus frequency in bits per second.
N */
Nvoid I2C_MasterSetBaudRate(I2C_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz);
N
N/*!
N * @brief Returns whether the bus is idle.
N *
N * Requires the master mode to be enabled.
N *
N * @param base The I2C peripheral base address.
N * @retval true Bus is busy.
N * @retval false Bus is idle.
N */
Nstatic inline bool I2C_MasterGetBusIdleState(I2C_Type *base)
Xstatic inline _Bool I2C_MasterGetBusIdleState(I2C_Type *base)
N{
N    /* True if MSTPENDING flag is set and MSTSTATE is zero == idle */
N    return ((base->STAT & (I2C_STAT_MSTPENDING_MASK | I2C_STAT_MSTSTATE_MASK)) == I2C_STAT_MSTPENDING_MASK);
X    return ((base->STAT & ((0x1U) | (0xEU))) == (0x1U));
N}
N
N/*!
N * @brief Sends a START on the I2C bus.
N *
N * This function is used to initiate a new master mode transfer by sending the START signal.
N * The slave address is sent following the I2C START signal.
N *
N * @param base I2C peripheral base pointer
N * @param address 7-bit slave device address.
N * @param direction Master transfer directions(transmit/receive).
N * @retval kStatus_Success Successfully send the start signal.
N * @retval kStatus_I2C_Busy Current bus is busy.
N */
Nstatus_t I2C_MasterStart(I2C_Type *base, uint8_t address, i2c_direction_t direction);
N
N/*!
N * @brief Sends a STOP signal on the I2C bus.
N *
N * @retval kStatus_Success Successfully send the stop signal.
N * @retval kStatus_I2C_Timeout Send stop signal failed, timeout.
N */
Nstatus_t I2C_MasterStop(I2C_Type *base);
N
N/*!
N * @brief Sends a REPEATED START on the I2C bus.
N *
N * @param base I2C peripheral base pointer
N * @param address 7-bit slave device address.
N * @param direction Master transfer directions(transmit/receive).
N * @retval kStatus_Success Successfully send the start signal.
N * @retval kStatus_I2C_Busy Current bus is busy but not occupied by current I2C master.
N */
Nstatic inline status_t I2C_MasterRepeatedStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
N{
N    return I2C_MasterStart(base, address, direction);
N}
N
N/*!
N * @brief Performs a polling send transfer on the I2C bus.
N *
N * Sends up to @a txSize number of bytes to the previously addressed slave device. The slave may
N * reply with a NAK to any byte in order to terminate the transfer early. If this happens, this
N * function returns #kStatus_I2C_Nak.
N *
N * @param base  The I2C peripheral base address.
N * @param txBuff The pointer to the data to be transferred.
N * @param txSize The length in bytes of the data to be transferred.
N * @param flags Transfer control flag to control special behavior like suppressing start or stop, for normal transfers use kI2C_TransferDefaultFlag
N * @retval kStatus_Success Data was sent successfully.
N * @retval #kStatus_I2C_Busy Another master is currently utilizing the bus.
N * @retval #kStatus_I2C_Nak The slave device sent a NAK in response to a byte.
N * @retval #kStatus_I2C_ArbitrationLost Arbitration lost error.
N */
Nstatus_t I2C_MasterWriteBlocking(I2C_Type *base, const void *txBuff, size_t txSize, uint32_t flags);
N
N/*!
N * @brief Performs a polling receive transfer on the I2C bus.
N *
N * @param base  The I2C peripheral base address.
N * @param rxBuff The pointer to the data to be transferred.
N * @param rxSize The length in bytes of the data to be transferred.
N * @param flags Transfer control flag to control special behavior like suppressing start or stop, for normal transfers use kI2C_TransferDefaultFlag
N * @retval kStatus_Success Data was received successfully.
N * @retval #kStatus_I2C_Busy Another master is currently utilizing the bus.
N * @retval #kStatus_I2C_Nak The slave device sent a NAK in response to a byte.
N * @retval #kStatus_I2C_ArbitrationLost Arbitration lost error.
N */
Nstatus_t I2C_MasterReadBlocking(I2C_Type *base, void *rxBuff, size_t rxSize, uint32_t flags);
N
N/*!
N * @brief Performs a master polling transfer on the I2C bus.
N *
N * @note The API does not return until the transfer succeeds or fails due
N * to arbitration lost or receiving a NAK.
N *
N * @param base I2C peripheral base address.
N * @param xfer Pointer to the transfer structure.
N * @retval kStatus_Success Successfully complete the data transmission.
N * @retval kStatus_I2C_Busy Previous transmission still not finished.
N * @retval kStatus_I2C_Timeout Transfer error, wait signal timeout.
N * @retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost.
N * @retval kStataus_I2C_Nak Transfer error, receive NAK during transfer.
N */
Nstatus_t I2C_MasterTransferBlocking(I2C_Type *base, i2c_master_transfer_t *xfer);
N
N/*@}*/
N
N/*! @name Non-blocking */
N/*@{*/
N
N/*!
N * @brief Creates a new handle for the I2C master non-blocking APIs.
N *
N * The creation of a handle is for use with the non-blocking APIs. Once a handle
N * is created, there is not a corresponding destroy handle. If the user wants to
N * terminate a transfer, the I2C_MasterTransferAbort() API shall be called.
N *
N * @param base The I2C peripheral base address.
N * @param[out] handle Pointer to the I2C master driver handle.
N * @param callback User provided pointer to the asynchronous callback function.
N * @param userData User provided pointer to the application callback data.
N */
Nvoid I2C_MasterTransferCreateHandle(I2C_Type *base,
N                                    i2c_master_handle_t *handle,
N                                    i2c_master_transfer_callback_t callback,
N                                    void *userData);
N
N/*!
N * @brief Performs a non-blocking transaction on the I2C bus.
N *
N * @param base The I2C peripheral base address.
N * @param handle Pointer to the I2C master driver handle.
N * @param xfer The pointer to the transfer descriptor.
N * @retval kStatus_Success The transaction was started successfully.
N * @retval #kStatus_I2C_Busy Either another master is currently utilizing the bus, or a non-blocking
N *      transaction is already in progress.
N */
Nstatus_t I2C_MasterTransferNonBlocking(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer);
N
N/*!
N * @brief Returns number of bytes transferred so far.
N * @param base The I2C peripheral base address.
N * @param handle Pointer to the I2C master driver handle.
N * @param[out] count Number of bytes transferred so far by the non-blocking transaction.
N * @retval kStatus_Success
N * @retval #kStatus_I2C_Busy
N */
Nstatus_t I2C_MasterTransferGetCount(I2C_Type *base, i2c_master_handle_t *handle, size_t *count);
N
N/*!
N * @brief Terminates a non-blocking I2C master transmission early.
N *
N * @note It is not safe to call this function from an IRQ handler that has a higher priority than the
N *      I2C peripheral's IRQ priority.
N *
N * @param base The I2C peripheral base address.
N * @param handle Pointer to the I2C master driver handle.
N * @retval kStatus_Success A transaction was successfully aborted.
N * @retval #kStatus_I2C_Idle There is not a non-blocking transaction currently in progress.
N */
Nvoid I2C_MasterTransferAbort(I2C_Type *base, i2c_master_handle_t *handle);
N
N/*@}*/
N
N/*! @name IRQ handler */
N/*@{*/
N
N/*!
N * @brief Reusable routine to handle master interrupts.
N * @note This function does not need to be called unless you are reimplementing the
N *  nonblocking API's interrupt handler routines to add special functionality.
N * @param base The I2C peripheral base address.
N * @param handle Pointer to the I2C master driver handle.
N */
Nvoid I2C_MasterTransferHandleIRQ(I2C_Type *base, i2c_master_handle_t *handle);
N
N/*@}*/
N
N/*! @} */ /* end of i2c_master_driver */
N
N/*!
N * @addtogroup i2c_slave_driver
N * @{
N */
N
N/*! @name Slave initialization and deinitialization */
N/*@{*/
N
N/*!
N * @brief Provides a default configuration for the I2C slave peripheral.
N *
N * This function provides the following default configuration for the I2C slave peripheral:
N * @code
N *  slaveConfig->enableSlave = true;
N *  slaveConfig->address0.disable = false;
N *  slaveConfig->address0.address = 0u;
N *  slaveConfig->address1.disable = true;
N *  slaveConfig->address2.disable = true;
N *  slaveConfig->address3.disable = true;
N *  slaveConfig->busSpeed = kI2C_SlaveStandardMode;
N * @endcode
N *
N * After calling this function, override any settings  to customize the configuration,
N * prior to initializing the master driver with I2C_SlaveInit(). Be sure to override at least the @a
N * address0.address member of the configuration structure with the desired slave address.
N *
N * @param[out] slaveConfig User provided configuration structure that is set to default values. Refer to
N *      #i2c_slave_config_t.
N */
Nvoid I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig);
N
N/*!
N * @brief Initializes the I2C slave peripheral.
N *
N * This function enables the peripheral clock and initializes the I2C slave peripheral as described by the user
N * provided configuration.
N *
N * @param base The I2C peripheral base address.
N * @param slaveConfig User provided peripheral configuration. Use I2C_SlaveGetDefaultConfig() to get a set of defaults
N *      that you can override.
N * @param srcClock_Hz Frequency in Hertz of the I2C functional clock. Used to calculate CLKDIV value to provide
N * enough
N *                       data setup time for master when slave stretches the clock.
N */
Nstatus_t I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig, uint32_t srcClock_Hz);
N
N/*!
N * @brief Configures Slave Address n register.
N *
N * This function writes new value to Slave Address register.
N *
N * @param base The I2C peripheral base address.
N * @param addressRegister The module supports multiple address registers. The parameter determines which one shall be changed.
N * @param address The slave address to be stored to the address register for matching.
N * @param addressDisable Disable matching of the specified address register.
N  */
Nvoid I2C_SlaveSetAddress(I2C_Type *base,
N                         i2c_slave_address_register_t addressRegister,
N                         uint8_t address,
N                         bool addressDisable);
X                         _Bool addressDisable);
N
N/*!
N* @brief Deinitializes the I2C slave peripheral.
N*
N * This function disables the I2C slave peripheral and gates the clock. It also performs a software
N * reset to restore the peripheral to reset conditions.
N *
N * @param base The I2C peripheral base address.
N */
Nvoid I2C_SlaveDeinit(I2C_Type *base);
N
N/*!
N * @brief Enables or disables the I2C module as slave.
N *
N * @param base The I2C peripheral base address.
N * @param enable True to enable or flase to disable.
N */
Nstatic inline void I2C_SlaveEnable(I2C_Type *base, bool enable)
Xstatic inline void I2C_SlaveEnable(I2C_Type *base, _Bool enable)
N{
N    /* Set or clear the SLVEN bit in the CFG register. */
N    base->CFG = I2C_CFG_SLVEN(enable);
X    base->CFG = (((uint32_t)(((uint32_t)(enable)) << (1U))) & (0x2U));
N}
N
N/*@}*/ /* end of Slave initialization and deinitialization */
N
N/*! @name Slave status */
N/*@{*/
N
N/*!
N * @brief Clears the I2C status flag state.
N *
N * The following status register flags can be cleared:
N * - slave deselected flag
N *
N * Attempts to clear other flags has no effect.
N *
N * @param base The I2C peripheral base address.
N * @param statusMask A bitmask of status flags that are to be cleared. The mask is composed of
N *  #_i2c_slave_flags enumerators OR'd together. You may pass the result of a previous call to
N *  I2C_SlaveGetStatusFlags().
N * @see _i2c_slave_flags.
N */
Nstatic inline void I2C_SlaveClearStatusFlags(I2C_Type *base, uint32_t statusMask)
N{
N    /* Allow clearing just slave status flags */
N    base->STAT = statusMask & I2C_STAT_SLVDESEL_MASK;
X    base->STAT = statusMask & (0x8000U);
N}
N
N/*@}*/ /* end of Slave status */
N
N/*! @name Slave bus operations */
N/*@{*/
N
N/*!
N * @brief Performs a polling send transfer on the I2C bus.
N *
N * The function executes blocking address phase and blocking data phase.
N *
N * @param base  The I2C peripheral base address.
N * @param txBuff The pointer to the data to be transferred.
N * @param txSize The length in bytes of the data to be transferred.
N * @return kStatus_Success Data has been sent.
N * @return kStatus_Fail Unexpected slave state (master data write while master read from slave is expected).
N */
Nstatus_t I2C_SlaveWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize);
N
N/*!
N * @brief Performs a polling receive transfer on the I2C bus.
N *
N * The function executes blocking address phase and blocking data phase.
N *
N * @param base  The I2C peripheral base address.
N * @param rxBuff The pointer to the data to be transferred.
N * @param rxSize The length in bytes of the data to be transferred.
N * @return kStatus_Success Data has been received.
N * @return kStatus_Fail Unexpected slave state (master data read while master write to slave is expected).
N */
Nstatus_t I2C_SlaveReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize);
N
N/*@}*/ /* end of Slave bus operations */
N
N/*! @name Slave non-blocking */
N/*@{*/
N
N/*!
N * @brief Creates a new handle for the I2C slave non-blocking APIs.
N *
N * The creation of a handle is for use with the non-blocking APIs. Once a handle
N * is created, there is not a corresponding destroy handle. If the user wants to
N * terminate a transfer, the I2C_SlaveTransferAbort() API shall be called.
N *
N * @param base The I2C peripheral base address.
N * @param[out] handle Pointer to the I2C slave driver handle.
N * @param callback User provided pointer to the asynchronous callback function.
N * @param userData User provided pointer to the application callback data.
N */
Nvoid I2C_SlaveTransferCreateHandle(I2C_Type *base,
N                                   i2c_slave_handle_t *handle,
N                                   i2c_slave_transfer_callback_t callback,
N                                   void *userData);
N
N/*!
N * @brief Starts accepting slave transfers.
N *
N * Call this API after calling I2C_SlaveInit() and I2C_SlaveTransferCreateHandle() to start processing
N * transactions driven by an I2C master. The slave monitors the I2C bus and pass events to the
N * callback that was passed into the call to I2C_SlaveTransferCreateHandle(). The callback is always invoked
N * from the interrupt context.
N *
N * If no slave Tx transfer is busy, a master read from slave request invokes #kI2C_SlaveTransmitEvent callback.
N * If no slave Rx transfer is busy, a master write to slave request invokes #kI2C_SlaveReceiveEvent callback.
N *
N * The set of events received by the callback is customizable. To do so, set the @a eventMask parameter to
N * the OR'd combination of #i2c_slave_transfer_event_t enumerators for the events you wish to receive.
N * The #kI2C_SlaveTransmitEvent and #kI2C_SlaveReceiveEvent events are always enabled and do not need
N * to be included in the mask. Alternatively, you can pass 0 to get a default set of only the transmit and
N * receive events that are always enabled. In addition, the #kI2C_SlaveAllEvents constant is provided as
N * a convenient way to enable all events.
N *
N * @param base The I2C peripheral base address.
N * @param handle Pointer to i2c_slave_handle_t structure which stores the transfer state.
N * @param eventMask Bit mask formed by OR'ing together #i2c_slave_transfer_event_t enumerators to specify
N *      which events to send to the callback. Other accepted values are 0 to get a default set of
N *      only the transmit and receive events, and #kI2C_SlaveAllEvents to enable all events.
N *
N * @retval kStatus_Success Slave transfers were successfully started.
N * @retval #kStatus_I2C_Busy Slave transfers have already been started on this handle.
N */
Nstatus_t I2C_SlaveTransferNonBlocking(I2C_Type *base, i2c_slave_handle_t *handle, uint32_t eventMask);
N
N/*!
N * @brief Starts accepting master read from slave requests.
N *
N * The function can be called in response to #kI2C_SlaveTransmitEvent callback to start a new slave Tx transfer
N * from within the transfer callback.
N *
N * The set of events received by the callback is customizable. To do so, set the @a eventMask parameter to
N * the OR'd combination of #i2c_slave_transfer_event_t enumerators for the events you wish to receive.
N * The #kI2C_SlaveTransmitEvent and #kI2C_SlaveReceiveEvent events are always enabled and do not need
N * to be included in the mask. Alternatively, you can pass 0 to get a default set of only the transmit and
N * receive events that are always enabled. In addition, the #kI2C_SlaveAllEvents constant is provided as
N * a convenient way to enable all events.
N *
N * @param base The I2C peripheral base address.
N * @param transfer Pointer to #i2c_slave_transfer_t structure.
N * @param txData Pointer to data to send to master.
N * @param txSize Size of txData in bytes.
N * @param eventMask Bit mask formed by OR'ing together #i2c_slave_transfer_event_t enumerators to specify
N *      which events to send to the callback. Other accepted values are 0 to get a default set of
N *      only the transmit and receive events, and #kI2C_SlaveAllEvents to enable all events.
N *
N * @retval kStatus_Success Slave transfers were successfully started.
N * @retval #kStatus_I2C_Busy Slave transfers have already been started on this handle.
N */
Nstatus_t I2C_SlaveSetSendBuffer(
N    I2C_Type *base, volatile i2c_slave_transfer_t *transfer, const void *txData, size_t txSize, uint32_t eventMask);
N
N/*!
N * @brief Starts accepting master write to slave requests.
N  *
N * The function can be called in response to #kI2C_SlaveReceiveEvent callback to start a new slave Rx transfer
N * from within the transfer callback.
N *
N * The set of events received by the callback is customizable. To do so, set the @a eventMask parameter to
N * the OR'd combination of #i2c_slave_transfer_event_t enumerators for the events you wish to receive.
N * The #kI2C_SlaveTransmitEvent and #kI2C_SlaveReceiveEvent events are always enabled and do not need
N * to be included in the mask. Alternatively, you can pass 0 to get a default set of only the transmit and
N * receive events that are always enabled. In addition, the #kI2C_SlaveAllEvents constant is provided as
N * a convenient way to enable all events.
N *
N * @param base The I2C peripheral base address.
N * @param transfer Pointer to #i2c_slave_transfer_t structure.
N * @param rxData Pointer to data to store data from master.
N * @param rxSize Size of rxData in bytes.
N * @param eventMask Bit mask formed by OR'ing together #i2c_slave_transfer_event_t enumerators to specify
N *      which events to send to the callback. Other accepted values are 0 to get a default set of
N *      only the transmit and receive events, and #kI2C_SlaveAllEvents to enable all events.
N *
N * @retval kStatus_Success Slave transfers were successfully started.
N * @retval #kStatus_I2C_Busy Slave transfers have already been started on this handle.
N */
Nstatus_t I2C_SlaveSetReceiveBuffer(
N    I2C_Type *base, volatile i2c_slave_transfer_t *transfer, void *rxData, size_t rxSize, uint32_t eventMask);
N
N/*!
N * @brief Returns the slave address sent by the I2C master.
N *
N * This function should only be called from the address match event callback #kI2C_SlaveAddressMatchEvent.
N *
N * @param base The I2C peripheral base address.
N * @param transfer The I2C slave transfer.
N * @return The 8-bit address matched by the I2C slave. Bit 0 contains the R/w direction bit, and
N *      the 7-bit slave address is in the upper 7 bits.
N */
Nstatic inline uint32_t I2C_SlaveGetReceivedAddress(I2C_Type *base, volatile i2c_slave_transfer_t *transfer)
N{
N    return transfer->receivedAddress;
N}
N
N/*!
N * @brief Aborts the slave non-blocking transfers.
N * @note This API could be called at any time to stop slave for handling the bus events.
N * @param base The I2C peripheral base address.
N * @param handle Pointer to i2c_slave_handle_t structure which stores the transfer state.
N * @retval kStatus_Success
N * @retval #kStatus_I2C_Idle
N */
Nvoid I2C_SlaveTransferAbort(I2C_Type *base, i2c_slave_handle_t *handle);
N
N/*!
N * @brief Gets the slave transfer remaining bytes during a interrupt non-blocking transfer.
N *
N * @param base I2C base pointer.
N * @param handle pointer to i2c_slave_handle_t structure.
N * @param count Number of bytes transferred so far by the non-blocking transaction.
N * @retval kStatus_InvalidArgument count is Invalid.
N * @retval kStatus_Success Successfully return the count.
N */
Nstatus_t I2C_SlaveTransferGetCount(I2C_Type *base, i2c_slave_handle_t *handle, size_t *count);
N
N/*@}*/ /* end of Slave non-blocking */
N
N/*! @name Slave IRQ handler */
N/*@{*/
N
N/*!
N * @brief Reusable routine to handle slave interrupts.
N * @note This function does not need to be called unless you are reimplementing the
N *  non blocking API's interrupt handler routines to add special functionality.
N * @param base The I2C peripheral base address.
N * @param handle Pointer to i2c_slave_handle_t structure which stores the transfer state.
N */
Nvoid I2C_SlaveTransferHandleIRQ(I2C_Type *base, i2c_slave_handle_t *handle);
N
N/*@}*/ /* end of Slave IRQ handler */
N
N/*! @} */ /* end of i2c_slave_driver */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* _FSL_I2C_H_ */
L 16 "SRC\main.c" 2
N#include "fsl_i2s.h"
L 1 ".\SRC\Drivers\fsl_i2s.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N#ifndef _FSL_I2S_H_
N#define _FSL_I2S_H_
N
N#include "fsl_device_registers.h"
N#include "fsl_common.h"
N#include "fsl_flexcomm.h"
L 1 ".\SRC\Drivers\fsl_flexcomm.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N#ifndef _FSL_FLEXCOMM_H_
N#define _FSL_FLEXCOMM_H_
N
N#include "fsl_common.h"
N
N/*!
N * @addtogroup flexcomm_driver
N * @{
N */
N
N/*! @brief FLEXCOMM peripheral modes. */
Ntypedef enum
N{
N    FLEXCOMM_PERIPH_NONE,   /*!< No peripheral */
N    FLEXCOMM_PERIPH_USART,  /*!< USART peripheral */
N    FLEXCOMM_PERIPH_SPI,    /*!< SPI Peripheral */
N    FLEXCOMM_PERIPH_I2C,    /*!< I2C Peripheral */
N    FLEXCOMM_PERIPH_I2S_TX, /*!< I2S TX Peripheral */
N    FLEXCOMM_PERIPH_I2S_RX, /*!< I2S RX Peripheral */
N} FLEXCOMM_PERIPH_T;
N
N/*! @brief Typedef for interrupt handler. */
Ntypedef void (*flexcomm_irq_handler_t)(void *base, void *handle);
N
N/*! @brief Array with IRQ number for each FLEXCOMM module. */
Nextern IRQn_Type const kFlexcommIrqs[];
N
N/*! @brief Returns instance number for FLEXCOMM module with given base address. */
Nuint32_t FLEXCOMM_GetInstance(void *base);
N
N/*! @brief Initializes FLEXCOMM and selects peripheral mode according to the second parameter. */
Nstatus_t FLEXCOMM_Init(void *base, FLEXCOMM_PERIPH_T periph);
N
N/*! @brief Sets IRQ handler for given FLEXCOMM module. It is used by drivers register IRQ handler according to FLEXCOMM
N * mode */
Nvoid FLEXCOMM_SetIRQHandler(void *base, flexcomm_irq_handler_t handler, void *handle);
N
N/*@}*/
N
N#endif /* _FSL_FLEXCOMM_H_*/
L 35 ".\SRC\Drivers\fsl_i2s.h" 2
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*!
N * @addtogroup i2s_driver
N * @{
N */
N
N/*! @file */
N
N/*! @name Driver version */
N/*@{*/
N/*! @brief I2S driver version 2.0.0.
N *
N * Current version: 2.0.0
N *
N * Change log:
N * - Version 2.0.0
N *   - initial version
N */
N#define FSL_I2S_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
N/*@}*/
N
N#ifndef I2S_NUM_BUFFERS
N
N/*! @brief Number of buffers . */
N#define I2S_NUM_BUFFERS (4)
N
N#endif
N
N/*! @brief I2S status codes. */
Nenum _i2s_status
N{
N    kStatus_I2S_BufferComplete =
N        MAKE_STATUS(kStatusGroup_I2S, 0),                /*!< Transfer from/into a single buffer has completed */
X        ((((kStatusGroup_I2S)*100) + (0))),                 
N    kStatus_I2S_Done = MAKE_STATUS(kStatusGroup_I2S, 1), /*!< All buffers transfers have completed */
X    kStatus_I2S_Done = ((((kStatusGroup_I2S)*100) + (1))),  
N    kStatus_I2S_Busy =
N        MAKE_STATUS(kStatusGroup_I2S, 2), /*!< Already performing a transfer and cannot queue another buffer */
X        ((((kStatusGroup_I2S)*100) + (2))),  
N};
N
N/*!
N * @brief I2S flags.
N *
N * @note These enums are meant to be OR'd together to form a bit mask.
N */
Ntypedef enum _i2s_flags
N{
N    kI2S_TxErrorFlag = I2S_FIFOINTENSET_TXERR_MASK, /*!< TX error interrupt */
X    kI2S_TxErrorFlag = (0x1U),  
N    kI2S_TxLevelFlag = I2S_FIFOINTENSET_TXLVL_MASK, /*!< TX level interrupt */
X    kI2S_TxLevelFlag = (0x4U),  
N    kI2S_RxErrorFlag = I2S_FIFOINTENSET_RXERR_MASK, /*!< RX error interrupt */
X    kI2S_RxErrorFlag = (0x2U),  
N    kI2S_RxLevelFlag = I2S_FIFOINTENSET_RXLVL_MASK  /*!< RX level interrupt */
X    kI2S_RxLevelFlag = (0x8U)   
N} i2s_flags_t;
N
N/*! @brief Master / slave mode. */
Ntypedef enum _i2s_master_slave
N{
N    kI2S_MasterSlaveNormalSlave = 0x0,  /*!< Normal slave */
N    kI2S_MasterSlaveWsSyncMaster = 0x1, /*!< WS synchronized master */
N    kI2S_MasterSlaveExtSckMaster = 0x2, /*!< Master using existing SCK */
N    kI2S_MasterSlaveNormalMaster = 0x3  /*!< Normal master */
N} i2s_master_slave_t;
N
N/*! @brief I2S mode. */
Ntypedef enum _i2s_mode
N{
N    kI2S_ModeI2sClassic = 0x0, /*!< I2S classic mode */
N    kI2S_ModeDspWs50 = 0x1,    /*!< DSP mode, WS having 50% duty cycle */
N    kI2S_ModeDspWsShort = 0x2, /*!< DSP mode, WS having one clock long pulse */
N    kI2S_ModeDspWsLong = 0x3   /*!< DSP mode, WS having one data slot long pulse */
N} i2s_mode_t;
N
N/*! @brief I2S configuration structure. */
Ntypedef struct _i2s_config
N{
N    i2s_master_slave_t masterSlave; /*!< Master / slave configuration */
N    i2s_mode_t mode;                /*!< I2S mode */
N    bool rightLow;                  /*!< Right channel data in low portion of FIFO */
X    _Bool rightLow;                   
N    bool leftJust;                  /*!< Left justify data in FIFO */
X    _Bool leftJust;                   
N    bool pdmData;                   /*!< Data source is the D-Mic subsystem */
X    _Bool pdmData;                    
N    bool sckPol;                    /*!< SCK polarity */
X    _Bool sckPol;                     
N    bool wsPol;                     /*!< WS polarity */
X    _Bool wsPol;                      
N    uint16_t divider;               /*!< Flexcomm function clock divider (1 - 4096) */
N    bool oneChannel;                /*!< true mono, false stereo */
X    _Bool oneChannel;                 
N    uint8_t dataLength;             /*!< Data length (4 - 32) */
N    uint16_t frameLength;           /*!< Frame width (4 - 512) */
N    uint16_t position;              /*!< Data position in the frame */
N    uint8_t watermark;              /*!< FIFO trigger level */
N    bool txEmptyZero;               /*!< Transmit zero when buffer becomes empty or last item */
X    _Bool txEmptyZero;                
N    bool pack48; /*!< Packing format for 48-bit data (false - 24 bit values, true - alternating 32-bit and 16-bit
X    _Bool pack48; 
N                    values) */
N} i2s_config_t;
N
N/*! @brief Buffer to transfer from or receive audio data into. */
Ntypedef struct _i2s_transfer
N{
N    volatile uint8_t *data;   /*!< Pointer to data buffer. */
N    volatile size_t dataSize; /*!< Buffer size in bytes. */
N} i2s_transfer_t;
N
N/*! @brief Transactional state of the intialized transfer or receive I2S operation. */
Ntypedef struct _i2s_handle i2s_handle_t;
N
N/*!
N * @brief Callback function invoked from transactional API
N *        on completion of a single buffer transfer.
N *
N * @param base I2S base pointer.
N * @param handle pointer to I2S transaction.
N * @param completionStatus status of the transaction.
N * @param userData optional pointer to user arguments data.
N */
Ntypedef void (*i2s_transfer_callback_t)(I2S_Type *base,
N                                        i2s_handle_t *handle,
N                                        status_t completionStatus,
N                                        void *userData);
N
N/*! @brief Members not to be accessed / modified outside of the driver. */
Nstruct _i2s_handle
N{
N    uint32_t state;                             /*!< State of transfer */
N    i2s_transfer_callback_t completionCallback; /*!< Callback function pointer */
N    void *userData;                             /*!< Application data passed to callback */
N    bool oneChannel;                            /*!< true mono, false stereo */
X    _Bool oneChannel;                             
N    uint8_t dataLength;                         /*!< Data length (4 - 32) */
N    bool pack48;     /*!< Packing format for 48-bit data (false - 24 bit values, true - alternating 32-bit and 16-bit
X    _Bool pack48;     
N                        values) */
N    bool useFifo48H; /*!< When dataLength 17-24: true use FIFOWR48H, false use FIFOWR */
X    _Bool useFifo48H;  
N    volatile i2s_transfer_t i2sQueue[I2S_NUM_BUFFERS]; /*!< Transfer queue storing transfer buffers */
X    volatile i2s_transfer_t i2sQueue[(4)];  
N    volatile uint8_t queueUser;                        /*!< Queue index where user's next transfer will be stored */
N    volatile uint8_t queueDriver;                      /*!< Queue index of buffer actually used by the driver */
N    volatile uint32_t errorCount;                      /*!< Number of buffer underruns/overruns */
N    volatile uint32_t transferCount;                   /*!< Number of bytes transferred */
N    volatile uint8_t watermark;                        /*!< FIFO trigger level */
N};
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*!
N * @name Initialization and deinitialization
N * @{
N */
N
N/*!
N * @brief Initializes the FLEXCOMM peripheral for I2S transmit functionality.
N *
N * Ungates the FLEXCOMM clock and configures the module
N * for I2S transmission using a configuration structure.
N * The configuration structure can be custom filled or set with default values by
N * I2S_TxGetDefaultConfig().
N *
N * @note This API should be called at the beginning of the application to use
N * the I2S driver.
N *
N * @param base I2S base pointer.
N * @param config pointer to I2S configuration structure.
N */
Nvoid I2S_TxInit(I2S_Type *base, const i2s_config_t *config);
N
N/*!
N * @brief Initializes the FLEXCOMM peripheral for I2S receive functionality.
N *
N * Ungates the FLEXCOMM clock and configures the module
N * for I2S receive using a configuration structure.
N * The configuration structure can be custom filled or set with default values by
N * I2S_RxGetDefaultConfig().
N *
N * @note This API should be called at the beginning of the application to use
N * the I2S driver.
N *
N * @param base I2S base pointer.
N * @param config pointer to I2S configuration structure.
N */
Nvoid I2S_RxInit(I2S_Type *base, const i2s_config_t *config);
N
N/*!
N * @brief Sets the I2S Tx configuration structure to default values.
N *
N * This API initializes the configuration structure for use in I2S_TxInit().
N * The initialized structure can remain unchanged in I2S_TxInit(), or it can be modified
N * before calling I2S_TxInit().
N * Example:
N   @code
N   i2s_config_t config;
N   I2S_TxGetDefaultConfig(&config);
N   @endcode
N *
N * Default values:
N * @code
N *   config->masterSlave = kI2S_MasterSlaveNormalMaster;
N *   config->mode = kI2S_ModeI2sClassic;
N *   config->rightLow = false;
N *   config->leftJust = false;
N *   config->pdmData = false;
N *   config->sckPol = false;
N *   config->wsPol = false;
N *   config->divider = 1;
N *   config->oneChannel = false;
N *   config->dataLength = 16;
N *   config->frameLength = 32;
N *   config->position = 0;
N *   config->watermark = 4;
N *   config->txEmptyZero = true;
N *   config->pack48 = false;
N * @endcode
N *
N * @param config pointer to I2S configuration structure.
N */
Nvoid I2S_TxGetDefaultConfig(i2s_config_t *config);
N
N/*!
N * @brief Sets the I2S Rx configuration structure to default values.
N *
N * This API initializes the configuration structure for use in I2S_RxInit().
N * The initialized structure can remain unchanged in I2S_RxInit(), or it can be modified
N * before calling I2S_RxInit().
N * Example:
N   @code
N   i2s_config_t config;
N   I2S_RxGetDefaultConfig(&config);
N   @endcode
N *
N * Default values:
N * @code
N *   config->masterSlave = kI2S_MasterSlaveNormalSlave;
N *   config->mode = kI2S_ModeI2sClassic;
N *   config->rightLow = false;
N *   config->leftJust = false;
N *   config->pdmData = false;
N *   config->sckPol = false;
N *   config->wsPol = false;
N *   config->divider = 1;
N *   config->oneChannel = false;
N *   config->dataLength = 16;
N *   config->frameLength = 32;
N *   config->position = 0;
N *   config->watermark = 4;
N *   config->txEmptyZero = false;
N *   config->pack48 = false;
N * @endcode
N *
N * @param config pointer to I2S configuration structure.
N */
Nvoid I2S_RxGetDefaultConfig(i2s_config_t *config);
N
N/*!
N * @brief De-initializes the I2S peripheral.
N *
N * This API gates the FLEXCOMM clock. The I2S module can't operate unless I2S_TxInit
N * or I2S_RxInit is called to enable the clock.
N *
N * @param base I2S base pointer.
N */
Nvoid I2S_Deinit(I2S_Type *base);
N
N/*! @} */
N
N/*!
N * @name Non-blocking API
N * @{
N */
N
N/*!
N * @brief Initializes handle for transfer of audio data.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N * @param callback function to be called back when transfer is done or fails.
N * @param userData pointer to data passed to callback.
N */
Nvoid I2S_TxTransferCreateHandle(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_callback_t callback, void *userData);
N
N/*!
N * @brief Begins or queue sending of the given data.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N * @param transfer data buffer.
N *
N * @retval kStatus_Success
N * @retval kStatus_I2S_Busy if all queue slots are occupied with unsent buffers.
N */
Nstatus_t I2S_TxTransferNonBlocking(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_t transfer);
N
N/*!
N * @brief Aborts sending of data.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N */
Nvoid I2S_TxTransferAbort(I2S_Type *base, i2s_handle_t *handle);
N
N/*!
N * @brief Initializes handle for reception of audio data.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N * @param callback function to be called back when transfer is done or fails.
N * @param userData pointer to data passed to callback.
N */
Nvoid I2S_RxTransferCreateHandle(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_callback_t callback, void *userData);
N
N/*!
N * @brief Begins or queue reception of data into given buffer.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N * @param transfer data buffer.
N *
N * @retval kStatus_Success
N * @retval kStatus_I2S_Busy if all queue slots are occupied with buffers which are not full.
N */
Nstatus_t I2S_RxTransferNonBlocking(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_t transfer);
N
N/*!
N * @brief Aborts receiving of data.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N */
Nvoid I2S_RxTransferAbort(I2S_Type *base, i2s_handle_t *handle);
N
N/*!
N * @brief Returns number of bytes transferred so far.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N * @param[out] count number of bytes transferred so far by the non-blocking transaction.
N *
N * @retval kStatus_Success
N * @retval kStatus_NoTransferInProgress there is no non-blocking transaction currently in progress.
N */
Nstatus_t I2S_TransferGetCount(I2S_Type *base, i2s_handle_t *handle, size_t *count);
N
N/*!
N * @brief Returns number of buffer underruns or overruns.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N * @param[out] count number of transmit errors encountered so far by the non-blocking transaction.
N *
N * @retval kStatus_Success
N * @retval kStatus_NoTransferInProgress there is no non-blocking transaction currently in progress.
N */
Nstatus_t I2S_TransferGetErrorCount(I2S_Type *base, i2s_handle_t *handle, size_t *count);
N
N/*! @} */
N
N/*!
N * @name Enable / disable
N * @{
N */
N
N/*!
N * @brief Enables I2S operation.
N *
N * @param base I2S base pointer.
N */
Nstatic inline void I2S_Enable(I2S_Type *base)
N{
N    base->CFG1 |= I2S_CFG1_MAINENABLE(1U);
X    base->CFG1 |= (((uint32_t)(((uint32_t)(1U)) << (0U))) & (0x1U));
N}
N
N/*!
N * @brief Disables I2S operation.
N *
N * @param base I2S base pointer.
N */
Nstatic inline void I2S_Disable(I2S_Type *base)
N{
N    base->CFG1 &= (~I2S_CFG1_MAINENABLE(1U));
X    base->CFG1 &= (~(((uint32_t)(((uint32_t)(1U)) << (0U))) & (0x1U)));
N}
N
N/*! @} */
N
N/*!
N * @name Interrupts
N * @{
N */
N
N/*!
N * @brief Enables I2S FIFO interrupts.
N *
N * @param base I2S base pointer.
N * @param interruptMask bit mask of interrupts to enable. See #i2s_flags_t for the set
N *      of constants that should be OR'd together to form the bit mask.
N */
Nstatic inline void I2S_EnableInterrupts(I2S_Type *base, uint32_t interruptMask)
N{
N    base->FIFOINTENSET = interruptMask;
N}
N
N/*!
N * @brief Disables I2S FIFO interrupts.
N *
N * @param base I2S base pointer.
N * @param interruptMask bit mask of interrupts to enable. See #i2s_flags_t for the set
N *      of constants that should be OR'd together to form the bit mask.
N */
Nstatic inline void I2S_DisableInterrupts(I2S_Type *base, uint32_t interruptMask)
N{
N    base->FIFOINTENCLR = interruptMask;
N}
N
N/*!
N * @brief Returns the set of currently enabled I2S FIFO interrupts.
N *
N * @param base I2S base pointer.
N *
N * @return A bitmask composed of #i2s_flags_t enumerators OR'd together
N *         to indicate the set of enabled interrupts.
N */
Nstatic inline uint32_t I2S_GetEnabledInterrupts(I2S_Type *base)
N{
N    return base->FIFOINTENSET;
N}
N
N/*!
N * @brief Invoked from interrupt handler when transmit FIFO level decreases.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N */
Nvoid I2S_TxHandleIRQ(I2S_Type *base, i2s_handle_t *handle);
N
N/*!
N * @brief Invoked from interrupt handler when receive FIFO level decreases.
N *
N * @param base I2S base pointer.
N * @param handle pointer to handle structure.
N */
Nvoid I2S_RxHandleIRQ(I2S_Type *base, i2s_handle_t *handle);
N
N/*! @} */
N
N/*! @} */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* _FSL_I2S_H_ */
L 17 "SRC\main.c" 2
N#include "fsl_wm8904.h"
L 1 ".\SRC\Audio\fsl_wm8904.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _FSL_WM8904_H_
N#define _FSL_WM8904_H_
N
N#include "fsl_common.h"
N
N/*!
N * @addtogroup wm8904
N * @{
N */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @brief WM8904 I2C address. */
N#define WM8904_I2C_ADDRESS (0x1A)
N
N/*! @brief WM8904 I2C bit rate. */
N#define WM8904_I2C_BITRATE (400000U)
N
N/*! @brief WM8904 status return codes. */
Nenum _wm8904_status
N{
N    kStatus_WM8904_Success = 0x0, /*!< Success */
N    kStatus_WM8904_Fail = 0x1     /*!< Failure */
N};
N
N/*! @brief The audio data transfer protocol. */
Ntypedef enum _wm8904_protocol
N{
N    kWM8904_ProtocolRightJustified = 0x0, /*!< Right justified mode */
N    kWM8904_ProtocolLeftJustified = 0x1,  /*!< Left justified mode */
N    kWM8904_ProtocolI2S = 0x2,            /*!< I2S mode */
N    kWM8904_ProtocolDSP = 0x3             /*!< DSP mode */
N} wm8904_protocol_t;
N
N/*! @brief The SYSCLK / fs ratio. */
Ntypedef enum _wm8904_fs_ratio
N{
N    kWM8904_FsRatio64X = 0x0,   /*!< SYSCLK is   64 * sample rate * frame width */
N    kWM8904_FsRatio128X = 0x1,  /*!< SYSCLK is  128 * sample rate * frame width */
N    kWM8904_FsRatio192X = 0x2,  /*!< SYSCLK is  192 * sample rate * frame width */
N    kWM8904_FsRatio256X = 0x3,  /*!< SYSCLK is  256 * sample rate * frame width */
N    kWM8904_FsRatio384X = 0x4,  /*!< SYSCLK is  384 * sample rate * frame width */
N    kWM8904_FsRatio512X = 0x5,  /*!< SYSCLK is  512 * sample rate * frame width */
N    kWM8904_FsRatio768X = 0x6,  /*!< SYSCLK is  768 * sample rate * frame width */
N    kWM8904_FsRatio1024X = 0x7, /*!< SYSCLK is 1024 * sample rate * frame width */
N    kWM8904_FsRatio1408X = 0x8, /*!< SYSCLK is 1408 * sample rate * frame width */
N    kWM8904_FsRatio1536X = 0x9  /*!< SYSCLK is 1536 * sample rate * frame width */
N} wm8904_fs_ratio_t;
N
N/*! @brief Sample rate. */
Ntypedef enum _wm8904_sample_rate
N{
N    kWM8904_SampleRate8kHz = 0x0,  /*!< 8 kHz */
N    kWM8904_SampleRate12kHz = 0x1, /*!< 11.025kHz, 12kHz */
N    kWM8904_SampleRate16kHz = 0x2, /*!< 16kHz */
N    kWM8904_SampleRate24kHz = 0x3, /*!< 22.05kHz, 24kHz */
N    kWM8904_SampleRate32kHz = 0x4, /*!< 32kHz */
N    kWM8904_SampleRate48kHz = 0x5  /*!< 44.1kHz, 48kHz */
N} wm8904_sample_rate_t;
N
N/*! @brief Bit width. */
Ntypedef enum _wm8904_bit_width
N{
N    kWM8904_BitWidth16 = 0x0, /*!< 16 bits */
N    kWM8904_BitWidth20 = 0x1, /*!< 20 bits */
N    kWM8904_BitWidth24 = 0x2, /*!< 24 bits */
N    kWM8904_BitWidth32 = 0x3  /*!< 32 bits */
N} wm8904_bit_width_t;
N
N/*! @brief Audio format configuration. */
Ntypedef struct _wm8904_audio_format
N{
N    wm8904_fs_ratio_t fsRatio;       /*!< SYSCLK / fs ratio */
N    wm8904_sample_rate_t sampleRate; /*!< Sample rate */
N    wm8904_bit_width_t bitWidth;     /*!< Bit width */
N} wm8904_audio_format_t;
N
N/*! @brief WM8904 data. */
Ntypedef struct _wm8904_handle
N{
N    I2C_Type *i2c; /*!< Configured I2C instance */
N} wm8904_handle_t;
N
N/*! @brief Configuration structure of WM8904. */
Ntypedef struct _wm8904_config
N{
N    bool master;                  /*!< Master or slave */
X    _Bool master;                   
N    wm8904_protocol_t protocol;   /*!< Audio transfer protocol */
N    wm8904_audio_format_t format; /*!< Audio format */
N} wm8904_config_t;
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/*!
N * @brief Initializes WM8904.
N *
N * @param handle WM8904 handle structure.
N * @param codec_config WM8904 configuration structure.
N */
Nstatus_t WM8904_Init(wm8904_handle_t *handle, wm8904_config_t *config);
N
N/*!
N * @brief Deinitializes the WM8904 codec.
N *
N * This function resets WM8904.
N *
N * @param handle WM8904 handle structure.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_Deinit(wm8904_handle_t *handle);
N
N/*!
N * @brief Fills the configuration structure with default values.
N *
N * The default values are:
N *
N *   master = false;
N *   protocol = kWM8904_ProtocolI2S;
N *   format.fsRatio = kWM8904_FsRatio64X;
N *   format.sampleRate = kWM8904_SampleRate48kHz;
N *   format.bitWidth = kWM8904_BitWidth16;
N *
N * @param handle WM8904 handle structure to be filled with default values.
N */
Nvoid WM8904_GetDefaultConfig(wm8904_config_t *config);
N
N/*!
N * @brief Sets WM8904 as master or slave.
N *
N * @param handle WM8904 handle structure.
N * @param master true for master, false for slave.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_SetMasterSlave(wm8904_handle_t *handle, bool master);
Xstatus_t WM8904_SetMasterSlave(wm8904_handle_t *handle, _Bool master);
N
N/*!
N * @brief Sets the audio data transfer protocol.
N *
N * @param handle WM8904 handle structure.
N * @param protocol Audio transfer protocol.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_SetProtocol(wm8904_handle_t *handle, wm8904_protocol_t protocol);
N
N/*!
N * @brief Sets the audio data format.
N *
N * @param handle WM8904 handle structure.
N * @param format Audio format parameters.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_SetAudioFormat(wm8904_handle_t *handle, wm8904_audio_format_t *format);
N
N/*!
N * @brief Sets the headphone output volume.
N *
N * The parameter should be from 0 to 63.
N * The resulting volume will be (parameter - 57 dB).
N * 0 for -57 dB, 57 for 0 dB, 63 for +6 dB etc.
N *
N * @param handle WM8904 handle structure.
N * @param volumeLeft Volume of the left channel.
N * @param volumeRight Volume of the right channel.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_SetVolume(wm8904_handle_t *handle, uint16_t volumeLeft, uint16_t volumeRight);
N
N/*!
N * @brief Sets the headphone output mute.
N *
N * @param handle WM8904 handle structure.
N * @param muteLeft true to mute left channel, false to unmute.
N * @param muteRight true to mute right channel, false to unmute.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_SetMute(wm8904_handle_t *handle, bool muteLeft, bool muteRight);
Xstatus_t WM8904_SetMute(wm8904_handle_t *handle, _Bool muteLeft, _Bool muteRight);
N
N/*!
N * @brief Reads content of all WM8904 registers and prints it to debug console.
N *
N * @param handle WM8904 handle structure.
N *
N * @return kStatus_WM8904_Success if successful, different code otherwise.
N */
Nstatus_t WM8904_PrintRegisters(wm8904_handle_t *handle);
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N/*! @} */
N
N#endif /* _FSL_WM8904_H_ */
L 18 "SRC\main.c" 2
N#include "Audio.h"
L 1 ".\SRC\Audio\Audio.h" 1
N#ifndef _AUDIO_H
N#define _AUDIO_H
N
Nvoid InitAudio_CODEC(void);
Nvoid Init_DMIC(void);
N
N
N#endif
N
L 19 "SRC\main.c" 2
N#include "fsl_iocon.h"
L 1 ".\SRC\Drivers\fsl_iocon.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _FSL_IOCON_H_
N#define _FSL_IOCON_H_
N
N#include "fsl_common.h"
N
N/*!
N * @addtogroup lpc_iocon
N * @{
N */
N
N/*! @file */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @name Driver version */
N/*@{*/
N/*! @brief IOCON driver version 2.0.0. */
N#define LPC_IOCON_DRIVER_VERSION (MAKE_VERSION(2, 0, 0))
N/*@}*/
N
N/**
N * @brief Array of IOCON pin definitions passed to IOCON_SetPinMuxing() must be in this format
N */
Ntypedef struct _iocon_group
N{
N    uint32_t port : 8;      /* Pin port */
N    uint32_t pin : 8;       /* Pin number */
N    uint32_t modefunc : 16; /* Function and mode */
N} iocon_group_t;
N
N/**
N * @brief IOCON function and mode selection definitions
N * @note See the User Manual for specific modes and functions supported by the various pins.
N */
N    #if defined(FSL_FEATURE_IOCON_FUNC_FIELD_WIDTH) && (FSL_FEATURE_IOCON_FUNC_FIELD_WIDTH== 4)
X    #if 1L && ((4)== 4)
N    #define IOCON_FUNC0             0x0             /*!< Selects pin function 0 */
N    #define IOCON_FUNC1             0x1             /*!< Selects pin function 1 */
N    #define IOCON_FUNC2             0x2             /*!< Selects pin function 2 */
N    #define IOCON_FUNC3             0x3             /*!< Selects pin function 3 */
N    #define IOCON_FUNC4             0x4             /*!< Selects pin function 4 */
N    #define IOCON_FUNC5             0x5             /*!< Selects pin function 5 */
N    #define IOCON_FUNC6             0x6             /*!< Selects pin function 6 */
N    #define IOCON_FUNC7             0x7             /*!< Selects pin function 7 */
N    #define IOCON_FUNC8             0x8             /*!< Selects pin function 8 */
N    #define IOCON_FUNC9             0x9             /*!< Selects pin function 9 */
N    #define IOCON_FUNC10            0xA             /*!< Selects pin function 10 */
N    #define IOCON_FUNC11            0xB             /*!< Selects pin function 11 */
N    #define IOCON_FUNC12            0xC             /*!< Selects pin function 12 */
N    #define IOCON_FUNC13            0xD             /*!< Selects pin function 13 */
N    #define IOCON_FUNC14            0xE             /*!< Selects pin function 14 */
N    #define IOCON_FUNC15            0xF             /*!< Selects pin function 15 */
N    #define IOCON_MODE_INACT        (0x0 << 4)      /*!< No addition pin function */
N    #define IOCON_MODE_PULLDOWN     (0x1 << 4)      /*!< Selects pull-down function */
N    #define IOCON_MODE_PULLUP       (0x2 << 4)      /*!< Selects pull-up function */
N    #define IOCON_MODE_REPEATER     (0x3 << 4)      /*!< Selects pin repeater function */
N    #define IOCON_HYS_EN            (0x1 << 6)      /*!< Enables hysteresis */
N    #define IOCON_GPIO_MODE         (0x1 << 6)      /*!< GPIO Mode */
N    #define IOCON_I2C_SLEW          (0x1 << 6)      /*!< I2C Slew Rate Control */
N    #define IOCON_INV_EN            (0x1 << 7)      /*!< Enables invert function on input */
N    #define IOCON_ANALOG_EN         (0x0 << 8)      /*!< Enables analog function by setting 0 to bit 7 */
N    #define IOCON_DIGITAL_EN        (0x1 << 8)      /*!< Enables digital function by setting 1 to bit 7(default) */
N    #define IOCON_STDI2C_EN         (0x1 << 9)      /*!< I2C standard mode/fast-mode */
N    #define IOCON_FASTI2C_EN        (0x3 << 9)      /*!< I2C Fast-mode Plus and high-speed slave */
N    #define IOCON_INPFILT_OFF       (0x1 << 9)      /*!< Input filter Off for GPIO pins */
N    #define IOCON_INPFILT_ON        (0x0 << 9)      /*!< Input filter On for GPIO pins */
N    #define IOCON_OPENDRAIN_EN      (0x1 << 11)      /*!< Enables open-drain function */
N    #define IOCON_S_MODE_0CLK       (0x0 << 12)      /*!< Bypass input filter */
N    #define IOCON_S_MODE_1CLK       (0x1 << 12)      /*!< Input pulses shorter than 1 filter clock are rejected */
N    #define IOCON_S_MODE_2CLK       (0x2 << 12)      /*!< Input pulses shorter than 2 filter clock2 are rejected */
N    #define IOCON_S_MODE_3CLK       (0x3 << 12)      /*!< Input pulses shorter than 3 filter clock2 are rejected */
N    #define IOCON_S_MODE(clks)      ((clks) << 12)   /*!< Select clocks for digital input filter mode */
N    #define IOCON_CLKDIV(div)       ((div) << 14)    /*!< Select peripheral clock divider for input filter sampling clock, 2^n, n=0-6 */
N#else
S    #define IOCON_FUNC0 0x0                   /*!< Selects pin function 0 */
S    #define IOCON_FUNC1 0x1                   /*!< Selects pin function 1 */
S    #define IOCON_FUNC2 0x2                   /*!< Selects pin function 2 */
S    #define IOCON_FUNC3 0x3                   /*!< Selects pin function 3 */
S    #define IOCON_FUNC4 0x4                   /*!< Selects pin function 4 */
S    #define IOCON_FUNC5 0x5                   /*!< Selects pin function 5 */
S    #define IOCON_FUNC6 0x6                   /*!< Selects pin function 6 */
S    #define IOCON_FUNC7 0x7                   /*!< Selects pin function 7 */
S    #define IOCON_MODE_INACT (0x0 << 3)       /*!< No addition pin function */
S    #define IOCON_MODE_PULLDOWN (0x1 << 3)    /*!< Selects pull-down function */
S    #define IOCON_MODE_PULLUP (0x2 << 3)      /*!< Selects pull-up function */
S    #define IOCON_MODE_REPEATER (0x3 << 3)    /*!< Selects pin repeater function */
S    #define IOCON_HYS_EN (0x1 << 5)           /*!< Enables hysteresis */
S    #define IOCON_GPIO_MODE (0x1 << 5)        /*!< GPIO Mode */
S    #define IOCON_I2C_SLEW (0x1 << 5)         /*!< I2C Slew Rate Control */
S    #define IOCON_INV_EN (0x1 << 6)           /*!< Enables invert function on input */
S    #define IOCON_ANALOG_EN (0x0 << 7)        /*!< Enables analog function by setting 0 to bit 7 */
S    #define IOCON_DIGITAL_EN (0x1 << 7)       /*!< Enables digital function by setting 1 to bit 7(default) */
S    #define IOCON_STDI2C_EN (0x1 << 8)        /*!< I2C standard mode/fast-mode */
S    #define IOCON_FASTI2C_EN (0x3 << 8)       /*!< I2C Fast-mode Plus and high-speed slave */
S    #define IOCON_INPFILT_OFF (0x1 << 8)      /*!< Input filter Off for GPIO pins */
S    #define IOCON_INPFILT_ON (0x0 << 8)       /*!< Input filter On for GPIO pins */
S    #define IOCON_OPENDRAIN_EN (0x1 << 10)    /*!< Enables open-drain function */
S    #define IOCON_S_MODE_0CLK (0x0 << 11)     /*!< Bypass input filter */
S    #define IOCON_S_MODE_1CLK (0x1 << 11)     /*!< Input pulses shorter than 1 filter clock are rejected */
S    #define IOCON_S_MODE_2CLK (0x2 << 11)     /*!< Input pulses shorter than 2 filter clock2 are rejected */
S    #define IOCON_S_MODE_3CLK (0x3 << 11)     /*!< Input pulses shorter than 3 filter clock2 are rejected */
S    #define IOCON_S_MODE(clks) ((clks) << 11) /*!< Select clocks for digital input filter mode */
S    #define IOCON_CLKDIV(div) \
S        ((div) << 13) /*!< Select peripheral clock divider for input filter sampling clock, 2^n, n=0-6 */
X    #define IOCON_CLKDIV(div)         ((div) << 13)  
N#endif
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N/**
N * @brief   Sets I/O Control pin mux
N * @param   base        : The base of IOCON peripheral on the chip
N * @param   port        : GPIO port to mux
N * @param   pin         : GPIO pin to mux
N * @param   modefunc    : OR'ed values of type IOCON_*
N * @return  Nothing
N */
N__STATIC_INLINE void IOCON_PinMuxSet(IOCON_Type *base, uint8_t port, uint8_t pin, uint32_t modefunc)
Xstatic __inline void IOCON_PinMuxSet(IOCON_Type *base, uint8_t port, uint8_t pin, uint32_t modefunc)
N{
N    base->PIO[port][pin] = modefunc;
N}
N
N/**
N * @brief   Set all I/O Control pin muxing
N * @param   base        : The base of IOCON peripheral on the chip
N * @param   pinArray    : Pointer to array of pin mux selections
N * @param   arrayLength : Number of entries in pinArray
N * @return  Nothing
N */
N__STATIC_INLINE void IOCON_SetPinMuxing(IOCON_Type *base, const iocon_group_t *pinArray, uint32_t arrayLength)
Xstatic __inline void IOCON_SetPinMuxing(IOCON_Type *base, const iocon_group_t *pinArray, uint32_t arrayLength)
N{
N    uint32_t i;
N
N    for (i = 0; i < arrayLength; i++)
N    {
N        IOCON_PinMuxSet(base, pinArray[i].port, pinArray[i].pin, pinArray[i].modefunc);
N    }
N}
N
N/* @} */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* _FSL_IOCON_H_ */
L 20 "SRC\main.c" 2
N#include "fsl_common.h"
N#include "clock_config.h"
N#include "fsl_power.h"
L 1 ".\SRC\Drivers\fsl_power.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N#ifndef _FSL_POWER_H_
N#define _FSL_POWER_H_
N
N#include "fsl_common.h"
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N#define MAKE_PD_BITS(reg, slot) ((reg << 8) | slot)
N#define PDRCFG0 0x0U
N#define PDRCFG1 0x1U
N
Ntypedef enum pd_bits
N{
N    kPDRUNCFG_LP_REG = MAKE_PD_BITS(PDRCFG0, 2U),
X    kPDRUNCFG_LP_REG = ((0x0U << 8) | 2U),
N    kPDRUNCFG_PD_FRO_EN = MAKE_PD_BITS(PDRCFG0, 4U),
X    kPDRUNCFG_PD_FRO_EN = ((0x0U << 8) | 4U),
N    kPDRUNCFG_PD_TS = MAKE_PD_BITS(PDRCFG0, 6U),
X    kPDRUNCFG_PD_TS = ((0x0U << 8) | 6U),
N    kPDRUNCFG_PD_BOD_RESET = MAKE_PD_BITS(PDRCFG0, 7U),
X    kPDRUNCFG_PD_BOD_RESET = ((0x0U << 8) | 7U),
N    kPDRUNCFG_PD_BOD_INTR = MAKE_PD_BITS(PDRCFG0, 8U),
X    kPDRUNCFG_PD_BOD_INTR = ((0x0U << 8) | 8U),
N    kPDRUNCFG_PD_VD2_ANA = MAKE_PD_BITS(PDRCFG0, 9U),
X    kPDRUNCFG_PD_VD2_ANA = ((0x0U << 8) | 9U),
N    kPDRUNCFG_PD_ADC0 = MAKE_PD_BITS(PDRCFG0, 10U),
X    kPDRUNCFG_PD_ADC0 = ((0x0U << 8) | 10U),
N    kPDRUNCFG_PD_RAM0 = MAKE_PD_BITS(PDRCFG0, 13U),
X    kPDRUNCFG_PD_RAM0 = ((0x0U << 8) | 13U),
N    kPDRUNCFG_PD_RAM1 = MAKE_PD_BITS(PDRCFG0, 14U),
X    kPDRUNCFG_PD_RAM1 = ((0x0U << 8) | 14U),
N    kPDRUNCFG_PD_RAM2 = MAKE_PD_BITS(PDRCFG0, 15U),
X    kPDRUNCFG_PD_RAM2 = ((0x0U << 8) | 15U),
N    kPDRUNCFG_PD_RAM3 = MAKE_PD_BITS(PDRCFG0, 16U),
X    kPDRUNCFG_PD_RAM3 = ((0x0U << 8) | 16U),
N    kPDRUNCFG_PD_ROM = MAKE_PD_BITS(PDRCFG0, 17U),
X    kPDRUNCFG_PD_ROM = ((0x0U << 8) | 17U),
N    kPDRUNCFG_PD_VDDA = MAKE_PD_BITS(PDRCFG0, 19U),
X    kPDRUNCFG_PD_VDDA = ((0x0U << 8) | 19U),
N    kPDRUNCFG_PD_WDT_OSC = MAKE_PD_BITS(PDRCFG0, 20U),
X    kPDRUNCFG_PD_WDT_OSC = ((0x0U << 8) | 20U),
N    kPDRUNCFG_PD_USB0_PHY = MAKE_PD_BITS(PDRCFG0, 21U),
X    kPDRUNCFG_PD_USB0_PHY = ((0x0U << 8) | 21U),
N    kPDRUNCFG_PD_SYS_PLL0 = MAKE_PD_BITS(PDRCFG0, 22U),
X    kPDRUNCFG_PD_SYS_PLL0 = ((0x0U << 8) | 22U),
N    kPDRUNCFG_PD_VREFP = MAKE_PD_BITS(PDRCFG0, 23U),
X    kPDRUNCFG_PD_VREFP = ((0x0U << 8) | 23U),
N    kPDRUNCFG_PD_FLASH_BG = MAKE_PD_BITS(PDRCFG0, 25U),
X    kPDRUNCFG_PD_FLASH_BG = ((0x0U << 8) | 25U),
N    kPDRUNCFG_PD_VD3 = MAKE_PD_BITS(PDRCFG0, 26U),
X    kPDRUNCFG_PD_VD3 = ((0x0U << 8) | 26U),
N    kPDRUNCFG_PD_VD4 = MAKE_PD_BITS(PDRCFG0, 27U),
X    kPDRUNCFG_PD_VD4 = ((0x0U << 8) | 27U),
N    kPDRUNCFG_PD_VD5 = MAKE_PD_BITS(PDRCFG0, 28U),
X    kPDRUNCFG_PD_VD5 = ((0x0U << 8) | 28U),
N    kPDRUNCFG_PD_VD6 = MAKE_PD_BITS(PDRCFG0, 29U),
X    kPDRUNCFG_PD_VD6 = ((0x0U << 8) | 29U),
N    kPDRUNCFG_REQ_DELAY = MAKE_PD_BITS(PDRCFG0, 30U),
X    kPDRUNCFG_REQ_DELAY = ((0x0U << 8) | 30U),
N    kPDRUNCFG_FORCE_RBB = MAKE_PD_BITS(PDRCFG0, 31U),
X    kPDRUNCFG_FORCE_RBB = ((0x0U << 8) | 31U),
N
N    kPDRUNCFG_PD_USB1_PHY = MAKE_PD_BITS(PDRCFG1, 0U),
X    kPDRUNCFG_PD_USB1_PHY = ((0x1U << 8) | 0U),
N    kPDRUNCFG_PD_USB_PLL = MAKE_PD_BITS(PDRCFG1, 1U),
X    kPDRUNCFG_PD_USB_PLL = ((0x1U << 8) | 1U),
N    kPDRUNCFG_PD_AUDIO_PLL = MAKE_PD_BITS(PDRCFG1, 2U),
X    kPDRUNCFG_PD_AUDIO_PLL = ((0x1U << 8) | 2U),
N    kPDRUNCFG_PD_SYS_OSC = MAKE_PD_BITS(PDRCFG1, 3U),
X    kPDRUNCFG_PD_SYS_OSC = ((0x1U << 8) | 3U),
N    kPDRUNCFG_PD_EEPROM = MAKE_PD_BITS(PDRCFG1, 5U),
X    kPDRUNCFG_PD_EEPROM = ((0x1U << 8) | 5U),
N    kPDRUNCFG_PD_rng = MAKE_PD_BITS(PDRCFG1, 6U),
X    kPDRUNCFG_PD_rng = ((0x1U << 8) | 6U),
N
N    kPDRUNCFG_ForceUnsigned = 0x80000000U,
N} pd_bit_t;
N
N/* Power mode configuration API parameter */
Ntypedef enum _power_mode_config
N{
N    kPmu_Sleep = 0U,
N    kPmu_Deep_Sleep = 1U,
N    kPmu_Deep_PowerDown = 2U,
N} power_mode_cfg_t;
N
N/*******************************************************************************
N * API
N ******************************************************************************/
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*!
N* @name Power Configuration
N* @{
N*/
N
N/*!
N * @brief API to enable PDRUNCFG bit in the Syscon. Note that enabling the bit powers down the peripheral
N *
N * @param en    peripheral for which to enable the PDRUNCFG bit
N * @return none
N */
Nstatic inline void POWER_EnablePD(pd_bit_t en)
N{
N    /* PDRUNCFGSET */
N    SYSCON->PDRUNCFGSET[(en >> 8UL)] = (1UL << (en & 0xffU));
X    ((SYSCON_Type *)(0x40000000u))->PDRUNCFGSET[(en >> 8UL)] = (1UL << (en & 0xffU));
N}
N
N/*!
N * @brief API to disable PDRUNCFG bit in the Syscon. Note that disabling the bit powers up the peripheral
N *
N * @param en    peripheral for which to disable the PDRUNCFG bit
N * @return none
N */
Nstatic inline void POWER_DisablePD(pd_bit_t en)
N{
N    /* PDRUNCFGCLR */
N    SYSCON->PDRUNCFGCLR[(en >> 8UL)] = (1UL << (en & 0xffU));
X    ((SYSCON_Type *)(0x40000000u))->PDRUNCFGCLR[(en >> 8UL)] = (1UL << (en & 0xffU));
N}
N
N/*!
N * @brief API to enable deep sleep bit in the ARM Core.
N *
N * @param none
N * @return none
N */
Nstatic inline void POWER_EnableDeepSleep(void)
N{
N    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR |= (1UL << 2U);
N}
N
N/*!
N * @brief API to disable deep sleep bit in the ARM Core.
N *
N * @param none
N * @return none
N */
Nstatic inline void POWER_DisableDeepSleep(void)
N{
N    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR |= (1UL << 2U);
N}
N
N/*!
N * @brief API to power down flash controller.
N *
N * @param none
N * @return none
N */
Nstatic inline void POWER_PowerDownFlash(void)
N{
N    /* TURN OFF clock ip_2113 (only needed for FLASH programming, will be turned on by ROM API) */
N    CLOCK_DisableClock(kCLOCK_Flash);
N
N    /* TURN OFF clock ip_2113 (only needed for FLASH programming, will be turned on by ROM API) */
N    CLOCK_DisableClock(kCLOCK_Fmc);
N}
N
N/*!
N * @brief API to power up flash controller.
N *
N * @param none
N * @return none
N */
Nstatic inline void POWER_PowerUpFlash(void)
N{
N    /* TURN OFF clock ip_2113 (only needed for FLASH programming, will be turned on by ROM API) */
N    CLOCK_EnableClock(kCLOCK_Fmc);
N}
N
N/*!
N * @brief Power Library API to power the PLLs.
N *
N * @param none
N * @return none
N */
Nvoid POWER_SetPLL(void);
N
N/*!
N * @brief Power Library API to power the USB PHY.
N *
N * @param none
N * @return none
N */
Nvoid POWER_SetUsbPhy(void);
N
N/*!
N * @brief Power Library API to enter different power mode.
N *
N * @param exclude_from_pd  Bit mask of the PDRUNCFG0(low 32bits) and PDRUNCFG1(high 32bits) that needs to be powered on during power mode selected.
N * @return none
N */
Nvoid POWER_EnterPowerMode(power_mode_cfg_t mode, uint64_t exclude_from_pd);
N
N/*!
N * @brief Power Library API to enter sleep mode.
N *
N * @return none
N */
Nvoid POWER_EnterSleep(void);
N
N/*!
N * @brief Power Library API to enter deep sleep mode.
N *
N * @param exclude_from_pd  Bit mask of the PDRUNCFG0(low 32bits) and PDRUNCFG1(high 32bits) bits that needs to be powered on during deep sleep
N * @return none
N */
Nvoid POWER_EnterDeepSleep(uint64_t exclude_from_pd);
N
N/*!
N * @brief Power Library API to enter deep power down mode.
N *
N * @param exclude_from_pd   Bit mask of the PDRUNCFG0(low 32bits) and PDRUNCFG1(high 32bits) that needs to be powered on during deep power 
N *                          down mode, but this is has no effect as the voltages are cut off.
N 
N * @return none
N */
Nvoid POWER_EnterDeepPowerDown(uint64_t exclude_from_pd);
N
N/*!
N * @brief Power Library API to choose normal regulation and set the voltage for the desired operating frequency.
N *
N * @param freq  - The desired frequency at which the part would like to operate, 
N *                note that the voltage and flash wait states should be set before changing frequency
N * @return none
N */
Nvoid POWER_SetVoltageForFreq(uint32_t freq);
N
N/*!
N * @brief Power Library API to choose normal regulation and set the voltage for the desired operating frequency.
N *
N * @param freq  - The desired frequency at which the part would like to operate, 
N *                note that the voltage and flash wait states should be set before changing frequency
N * @return none
N */
Nvoid POWER_SetVoltageForFreq(uint32_t freq);
N
N/*!
N * @brief Power Library API to return the library version.
N *
N * @param none
N * @return version number of the power library
N */
Nuint32_t POWER_GetLibVersion(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FSL_POWER_H_ */
L 23 "SRC\main.c" 2
N
N#include "fsl_i2c.h"
N#include "fsl_ft5406.h"
L 1 ".\SRC\System\fsl_ft5406.h" 1
N/*
N * Copyright (c) 2016, Freescale Semiconductor, Inc.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * o Redistributions of source code must retain the above copyright notice, this list
N *   of conditions and the following disclaimer.
N *
N * o Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N *
N * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
N *   contributors may be used to endorse or promote products derived from this
N *   software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef _FSL_FT5406_H_
N#define _FSL_FT5406_H_
N
N#include "fsl_common.h"
N
N/*!
N * @addtogroup ft5406
N * @{
N */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*! @brief FT5406 I2C address. */
N#define FT5406_I2C_ADDRESS (0x38)
N
N/*! @brief FT5406 maximum number of simultaneously detected touches. */
N#define FT5406_MAX_TOUCHES (5U)
N
N/*! @brief FT5406 register address where touch data begin. */
N#define FT5406_TOUCH_DATA_SUBADDR (1)
N
N/*! @brief FT5406 raw touch data length. */
N#define FT5406_TOUCH_DATA_LEN (0x20)
N
Ntypedef enum _touch_event
N{
N    kTouch_Down = 0,    /*!< The state changed to touched. */
N    kTouch_Up = 1,      /*!< The state changed to not touched. */
N    kTouch_Contact = 2, /*!< There is a continuous touch being detected. */
N    kTouch_Reserved = 3 /*!< No touch information available. */
N} touch_event_t;
N
Ntypedef struct _touch_point
N{
N    touch_event_t TOUCH_EVENT; /*!< Indicates the state or event of the touch point. */
N    uint8_t TOUCH_ID; /*!< Id of the touch point. This numeric value stays constant between down and up event. */
N    uint16_t TOUCH_X; /*!< X coordinate of the touch point */
N    uint16_t TOUCH_Y; /*!< Y coordinate of the touch point */
N} touch_point_t;
N
Ntypedef struct _ft5406_handle
N{
N    I2C_Type *base;
N    i2c_master_transfer_t xfer;
N    uint8_t touch_buf[FT5406_TOUCH_DATA_LEN];
X    uint8_t touch_buf[(0x20)];
N} ft5406_handle_t;
N
Nstatus_t FT5406_Init(ft5406_handle_t *handle, I2C_Type *base);
N
Nstatus_t FT5406_Denit(ft5406_handle_t *handle);
N
Nstatus_t FT5406_GetSingleTouch(ft5406_handle_t *handle, touch_event_t *touch_event, int *touch_x, int *touch_y);
N
Nstatus_t FT5406_GetMultiTouch(ft5406_handle_t *handle, int *touch_count, touch_point_t touch_array[FT5406_MAX_TOUCHES]);
Xstatus_t FT5406_GetMultiTouch(ft5406_handle_t *handle, int *touch_count, touch_point_t touch_array[(5U)]);
N
N#endif
L 26 "SRC\main.c" 2
N
N#include "arm_math.h"
L 1 ".\SRC\System\CMSIS\Include\arm_math.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2015 ARM Limited. All rights reserved.
N*
N* $Date:        20. October 2015
N* $Revision:    V1.4.5 b
N*
N* Project:      CMSIS DSP Library
N* Title:        arm_math.h
N*
N* Description:  Public header file for CMSIS DSP Library
N*
N* Target Processor: Cortex-M7/Cortex-M4/Cortex-M3/Cortex-M0
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N * -------------------------------------------------------------------- */
N
N/**
N   \mainpage CMSIS DSP Software Library
N   *
N   * Introduction
N   * ------------
N   *
N   * This user manual describes the CMSIS DSP software library,
N   * a suite of common signal processing functions for use on Cortex-M processor based devices.
N   *
N   * The library is divided into a number of functions each covering a specific category:
N   * - Basic math functions
N   * - Fast math functions
N   * - Complex math functions
N   * - Filters
N   * - Matrix functions
N   * - Transforms
N   * - Motor control functions
N   * - Statistical functions
N   * - Support functions
N   * - Interpolation functions
N   *
N   * The library has separate functions for operating on 8-bit integers, 16-bit integers,
N   * 32-bit integer and 32-bit floating-point values.
N   *
N   * Using the Library
N   * ------------
N   *
N   * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> folder.
N   * - arm_cortexM7lfdp_math.lib (Little endian and Double Precision Floating Point Unit on Cortex-M7)
N   * - arm_cortexM7bfdp_math.lib (Big endian and Double Precision Floating Point Unit on Cortex-M7)
N   * - arm_cortexM7lfsp_math.lib (Little endian and Single Precision Floating Point Unit on Cortex-M7)
N   * - arm_cortexM7bfsp_math.lib (Big endian and Single Precision Floating Point Unit on Cortex-M7)
N   * - arm_cortexM7l_math.lib (Little endian on Cortex-M7)
N   * - arm_cortexM7b_math.lib (Big endian on Cortex-M7)
N   * - arm_cortexM4lf_math.lib (Little endian and Floating Point Unit on Cortex-M4)
N   * - arm_cortexM4bf_math.lib (Big endian and Floating Point Unit on Cortex-M4)
N   * - arm_cortexM4l_math.lib (Little endian on Cortex-M4)
N   * - arm_cortexM4b_math.lib (Big endian on Cortex-M4)
N   * - arm_cortexM3l_math.lib (Little endian on Cortex-M3)
N   * - arm_cortexM3b_math.lib (Big endian on Cortex-M3)
N   * - arm_cortexM0l_math.lib (Little endian on Cortex-M0 / CortexM0+)
N   * - arm_cortexM0b_math.lib (Big endian on Cortex-M0 / CortexM0+)
N   *
N   * The library functions are declared in the public file <code>arm_math.h</code> which is placed in the <code>Include</code> folder.
N   * Simply include this file and link the appropriate library in the application and begin calling the library functions. The Library supports single
N   * public header file <code> arm_math.h</code> for Cortex-M7/M4/M3/M0/M0+ with little endian and big endian. Same header file will be used for floating point unit(FPU) variants.
N   * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
N   * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
N   *
N   * Examples
N   * --------
N   *
N   * The library ships with a number of examples which demonstrate how to use the library functions.
N   *
N   * Toolchain Support
N   * ------------
N   *
N   * The library has been developed and tested with MDK-ARM version 5.14.0.0
N   * The library is being tested in GCC and IAR toolchains and updates on this activity will be made available shortly.
N   *
N   * Building the Library
N   * ------------
N   *
N   * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in the <code>CMSIS\\DSP_Lib\\Source\\ARM</code> folder.
N   * - arm_cortexM_math.uvprojx
N   *
N   *
N   * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecting a specific target, and defining the optional pre processor MACROs detailed above.
N   *
N   * Pre-processor Macros
N   * ------------
N   *
N   * Each library project have differant pre-processor macros.
N   *
N   * - UNALIGNED_SUPPORT_DISABLE:
N   *
N   * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory access
N   *
N   * - ARM_MATH_BIG_ENDIAN:
N   *
N   * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default library builds for little endian targets.
N   *
N   * - ARM_MATH_MATRIX_CHECK:
N   *
N   * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
N   *
N   * - ARM_MATH_ROUNDING:
N   *
N   * Define macro ARM_MATH_ROUNDING for rounding on support functions
N   *
N   * - ARM_MATH_CMx:
N   *
N   * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for building library on Cortex-M3 target
N   * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building library on Cortex-M0+ target, and
N   * ARM_MATH_CM7 for building the library on cortex-M7.
N   *
N   * - __FPU_PRESENT:
N   *
N   * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro for M4bf and M4lf libraries
N   *
N   * <hr>
N   * CMSIS-DSP in ARM::CMSIS Pack
N   * -----------------------------
N   *
N   * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directories:
N   * |File/Folder                   |Content                                                                 |
N   * |------------------------------|------------------------------------------------------------------------|
N   * |\b CMSIS\\Documentation\\DSP  | This documentation                                                     |
N   * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                               |
N   * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library functions      |
N   * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                                |
N   *
N   * <hr>
N   * Revision History of CMSIS-DSP
N   * ------------
N   * Please refer to \ref ChangeLog_pg.
N   *
N   * Copyright Notice
N   * ------------
N   *
N   * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
N   */
N
N
N/**
N * @defgroup groupMath Basic Math Functions
N */
N
N/**
N * @defgroup groupFastMath Fast Math Functions
N * This set of functions provides a fast approximation to sine, cosine, and square root.
N * As compared to most of the other functions in the CMSIS math library, the fast math functions
N * operate on individual values and not arrays.
N * There are separate functions for Q15, Q31, and floating-point data.
N *
N */
N
N/**
N * @defgroup groupCmplxMath Complex Math Functions
N * This set of functions operates on complex data vectors.
N * The data in the complex arrays is stored in an interleaved fashion
N * (real, imag, real, imag, ...).
N * In the API functions, the number of samples in a complex array refers
N * to the number of complex values; the array contains twice this number of
N * real values.
N */
N
N/**
N * @defgroup groupFilters Filtering Functions
N */
N
N/**
N * @defgroup groupMatrix Matrix Functions
N *
N * This set of functions provides basic matrix math operations.
N * The functions operate on matrix data structures.  For example,
N * the type
N * definition for the floating-point matrix structure is shown
N * below:
N * <pre>
N *     typedef struct
N *     {
N *       uint16_t numRows;     // number of rows of the matrix.
N *       uint16_t numCols;     // number of columns of the matrix.
N *       float32_t *pData;     // points to the data of the matrix.
N *     } arm_matrix_instance_f32;
N * </pre>
N * There are similar definitions for Q15 and Q31 data types.
N *
N * The structure specifies the size of the matrix and then points to
N * an array of data.  The array is of size <code>numRows X numCols</code>
N * and the values are arranged in row order.  That is, the
N * matrix element (i, j) is stored at:
N * <pre>
N *     pData[i*numCols + j]
N * </pre>
N *
N * \par Init Functions
N * There is an associated initialization function for each type of matrix
N * data structure.
N * The initialization function sets the values of the internal structure fields.
N * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
N * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
N *
N * \par
N * Use of the initialization function is optional. However, if initialization function is used
N * then the instance structure cannot be placed into a const data section.
N * To place the instance structure in a const data
N * section, manually initialize the data structure.  For example:
N * <pre>
N * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
N * </pre>
N * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
N * specifies the number of columns, and <code>pData</code> points to the
N * data array.
N *
N * \par Size Checking
N * By default all of the matrix functions perform size checking on the input and
N * output matrices.  For example, the matrix addition function verifies that the
N * two input matrices and the output matrix all have the same number of rows and
N * columns.  If the size check fails the functions return:
N * <pre>
N *     ARM_MATH_SIZE_MISMATCH
N * </pre>
N * Otherwise the functions return
N * <pre>
N *     ARM_MATH_SUCCESS
N * </pre>
N * There is some overhead associated with this matrix size checking.
N * The matrix size checking is enabled via the \#define
N * <pre>
N *     ARM_MATH_MATRIX_CHECK
N * </pre>
N * within the library project settings.  By default this macro is defined
N * and size checking is enabled.  By changing the project settings and
N * undefining this macro size checking is eliminated and the functions
N * run a bit faster.  With size checking disabled the functions always
N * return <code>ARM_MATH_SUCCESS</code>.
N */
N
N/**
N * @defgroup groupTransforms Transform Functions
N */
N
N/**
N * @defgroup groupController Controller Functions
N */
N
N/**
N * @defgroup groupStats Statistics Functions
N */
N/**
N * @defgroup groupSupport Support Functions
N */
N
N/**
N * @defgroup groupInterpolation Interpolation Functions
N * These functions perform 1- and 2-dimensional interpolation of data.
N * Linear interpolation is used for 1-dimensional data and
N * bilinear interpolation is used for 2-dimensional data.
N */
N
N/**
N * @defgroup groupExamples Examples
N */
N#ifndef _ARM_MATH_H
N#define _ARM_MATH_H
N
N/* ignore some GCC warnings */
N#if defined ( __GNUC__ )
X#if 0L
S#pragma GCC diagnostic push
S#pragma GCC diagnostic ignored "-Wsign-conversion"
S#pragma GCC diagnostic ignored "-Wconversion"
S#pragma GCC diagnostic ignored "-Wunused-parameter"
N#endif
N
N#define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
N
N#if defined(ARM_MATH_CM7)
X#if 0L
S  #include "core_cm7.h"
N#elif defined (ARM_MATH_CM4)
X#elif 1L
N  #include "core_cm4.h"
L 1 ".\SRC\System\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
S#define __CORE_CM4_H_GENERIC
S
S#include <stdint.h>
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/**
S  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/**
S  \ingroup Cortex_M4
S  @{
S */
S
S/*  CMSIS CM4 definitions */
S#define __CM4_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
S#define __CM4_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
S#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
S                                    __CM4_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) |                                     __CM4_CMSIS_VERSION_SUB           )         
S
S#define __CORTEX_M                (0x04U)                                      /*!< Cortex-M Core */
S
S
S#if   defined ( __CC_ARM )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
S#endif
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
S*/
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1U
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #if (__FPU_PRESENT == 1U)
S      #define __FPU_USED       1U
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0U
S    #endif
S  #else
S    #define __FPU_USED         0U
S  #endif
S
S#endif
S
S#include "core_cmInstr.h"                /* Core Instruction Access */
S#include "core_cmFunc.h"                 /* Core Function Access */
S#include "core_cmSimd.h"                 /* Compiler specific SIMD Intrinsics */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
S
S#ifndef __CORE_CM4_H_DEPENDANT
S#define __CORE_CM4_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000U
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0U
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions */
S
S/* following defines should be used for structure members */
S#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
S#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
S#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
S
S/*@} end of group Cortex_M4 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S  - Core FPU Register
S ******************************************************************************/
S/**
S  \defgroup CMSIS_core_register Defines and Type Definitions
S  \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_CORE  Status and Control Registers
S  \brief      Core Register type definitions.
S  @{
S */
S
S/**
S  \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} APSR_Type;
S
S/* APSR Register Definitions */
S#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
S#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
S
S#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
S#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
S
S#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
S#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
S
S#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
S#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
S
S#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
S#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
S
S#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
S#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
S
S
S/**
S  \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} IPSR_Type;
S
S/* IPSR Register Definitions */
S#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0) */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} xPSR_Type;
S
S/* xPSR Register Definitions */
S#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
S#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
S
S#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
S#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
S
S#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
S#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
S
S#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
S#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
S
S#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
S#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
S
S#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
S#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
S
S#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
S#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
S
S#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
S#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
S
S#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
S#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} CONTROL_Type;
S
S/* CONTROL Register Definitions */
S#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
S#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
S
S#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
S#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
S
S#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
S
S/*@} end of group CMSIS_CORE */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S  \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
S        uint32_t RESERVED0[24U];
S  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
S        uint32_t RSERVED1[24U];
S  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
S        uint32_t RESERVED2[24U];
S  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
S        uint32_t RESERVED3[24U];
S  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
S        uint32_t RESERVED4[56U];
S  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S        uint32_t RESERVED5[644U];
S  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCB     System Control Block (SCB)
S  \brief    Type definitions for the System Control Block Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
S  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
S  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
S  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
S  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
S  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
S  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
S  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
S  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
S  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
S  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
S  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
S  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
S  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
S  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
S  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
S  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
S        uint32_t RESERVED0[5U];
S  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Register Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* SCB Hard Fault Status Register Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S  \brief    Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
S#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
S
S#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
S#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S  \brief    Type definitions for the System Timer Registers.
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
S  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
S  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __OM  union
S  {
S    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
S    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
S    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
S  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
S        uint32_t RESERVED0[864U];
S  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
S        uint32_t RESERVED1[15U];
S  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
S        uint32_t RESERVED2[15U];
S  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
S        uint32_t RESERVED3[29U];
S  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
S  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
S  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
S        uint32_t RESERVED4[43U];
S  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
S  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
S        uint32_t RESERVED5[6U];
S  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
S  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
S  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
S  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
S  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
S  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
S  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
S  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
S  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
S  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
S  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
S  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
S  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
S        uint32_t RESERVED1[1U];
S  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
S  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
S  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
S        uint32_t RESERVED2[1U];
S  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
S  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
S  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S  \brief    Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
S  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S        uint32_t RESERVED0[2U];
S  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S        uint32_t RESERVED1[55U];
S  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S        uint32_t RESERVED2[131U];
S  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S        uint32_t RESERVED3[759U];
S  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S        uint32_t RESERVED4[1U];
S  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S        uint32_t RESERVED5[39U];
S  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S        uint32_t RESERVED7[8U];
S  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if (__MPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
S  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
S  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
S  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S#if (__FPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
S  \brief    Type definitions for the Floating Point Unit (FPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Floating Point Unit (FPU).
S */
Stypedef struct
S{
S        uint32_t RESERVED0[1U];
S  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
S  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
S  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
S  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
S  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
S} FPU_Type;
S
S/* Floating-Point Context Control Register Definitions */
S#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
S#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
S
S#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
S#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
S
S#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
S#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
S
S#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
S#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
S
S#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
S#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
S
S#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
S#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
S
S#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
S#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
S
S#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
S#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
S
S#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
S#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
S
S/* Floating-Point Context Address Register Definitions */
S#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
S#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
S
S/* Floating-Point Default Status Control Register Definitions */
S#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
S#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
S
S#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
S#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
S
S#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
S#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
S
S#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
S#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
S
S/* Media and FP Feature Register 0 Definitions */
S#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
S#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
S
S#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
S#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
S
S#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
S#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
S
S#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
S#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
S
S#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
S#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
S
S#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
S#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
S
S#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
S#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
S
S#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
S#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
S
S/* Media and FP Feature Register 1 Definitions */
S#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
S#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
S
S#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
S#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
S
S#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
S#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
S
S#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
S#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
S
S/*@} end of group CMSIS_FPU */
S#endif
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S  \brief    Type definitions for the Core Debug Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
S  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
S  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
S  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register Definitions */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register Definitions */
S#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register Definitions */
S#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_bitfield     Core register bit field macros
S  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
S  @{
S */
S
S/**
S  \brief   Mask and shift a bit field value for use in a register bit range.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of the bit field.
S  \return           Masked and shifted value.
S*/
S#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
S
S/**
S  \brief     Mask and shift a register value to extract a bit filed value.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of register.
S  \return           Masked and shifted bit field value.
S*/
S#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
S
S/*@} end of group CMSIS_core_bitfield */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_base     Core Definitions
S  \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M4 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
S
S#if (__MPU_PRESENT == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
S#endif
S
S#if (__FPU_PRESENT == 1U)
S  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
S  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/**
S  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S  \brief    Functions that manage interrupts and exceptions via the NVIC.
S  @{
S */
S
S/**
S  \brief   Set Priority Grouping
S  \details Sets the priority grouping field using the required unlock sequence.
S           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S           Only values from 0..7 are used.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
S  reg_value  =  (reg_value                                   |
S                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/**
S  \brief   Get Priority Grouping
S  \details Reads the priority grouping field from the NVIC Interrupt Controller.
S  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
S{
S  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
S}
S
S
S/**
S  \brief   Enable External Interrupt
S  \details Enables a device-specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Disable External Interrupt
S  \details Disables a device-specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Get Pending Interrupt
S  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
S  \param [in]      IRQn  Interrupt number.
S  \return             0  Interrupt status is not pending.
S  \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S}
S
S
S/**
S  \brief   Set Pending Interrupt
S  \details Sets the pending bit of an external interrupt.
S  \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Clear Pending Interrupt
S  \details Clears the pending bit of an external interrupt.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Get Active Interrupt
S  \details Reads the active register in NVIC and returns the active bit.
S  \param [in]      IRQn  Interrupt number.
S  \return             0  Interrupt status is not active.
S  \return             1  Interrupt status is active.
S */
S__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
S{
S  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S}
S
S
S/**
S  \brief   Set Interrupt Priority
S  \details Sets the priority of an interrupt.
S  \note    The priority cannot be set for every core interrupt.
S  \param [in]      IRQn  Interrupt number.
S  \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if ((int32_t)(IRQn) < 0)
S  {
S    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S  else
S  {
S    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Priority
S  \details Reads the priority of an interrupt.
S           The interrupt number can be positive to specify an external (device specific) interrupt,
S           or negative to specify an internal (core) interrupt.
S  \param [in]   IRQn  Interrupt number.
S  \return             Interrupt Priority.
S                      Value is aligned automatically to the implemented priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if ((int32_t)(IRQn) < 0)
S  {
S    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
S  }
S  else
S  {
S    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
S  }
S}
S
S
S/**
S  \brief   Encode Priority
S  \details Encodes the priority for an interrupt with the given priority group,
S           preemptive priority value, and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S  \param [in]     PriorityGroup  Used priority group.
S  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S  \param [in]       SubPriority  Subpriority value (starting from 0).
S  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  return (
S           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
S           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
S         );
S}
S
S
S/**
S  \brief   Decode Priority
S  \details Decodes an interrupt priority value with a given priority group to
S           preemptive priority value and subpriority value.
S           In case of a conflict between priority grouping and available
S           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S  \param [in]     PriorityGroup  Used priority group.
S  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S  \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
S  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
S  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
S}
S
S
S/**
S  \brief   System Reset
S  \details Initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                          /* Ensure all outstanding memory accesses included
S                                                                       buffered write are completed before reset */
S  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
S                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
S  __DSB();                                                          /* Ensure completion of memory access */
S
S  for(;;)                                                           /* wait until reset */
S  {
S    __NOP();
S  }
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S  \brief    Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0U)
S
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_core_DebugFunctions ITM Functions
S  \brief    Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
S#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/**
S  \brief   ITM Send Character
S  \details Transmits a character via the ITM channel 0, and
S           \li Just returns when no debugger is connected that has booked the output.
S           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S  \param [in]     ch  Character to transmit.
S  \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
S      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0U].u32 == 0UL)
S    {
S      __NOP();
S    }
S    ITM->PORT[0U].u8 = (uint8_t)ch;
S  }
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Receive Character
S  \details Inputs a character via the external variable \ref ITM_RxBuffer.
S  \return             Received character.
S  \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void)
S{
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
S  {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/**
S  \brief   ITM Check Character
S  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S  \return          0  No character available.
S  \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void)
S{
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
S  {
S    return (0);                              /* no character available */
S  }
S  else
S  {
S    return (1);                              /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
S#endif /* __CORE_CM4_H_DEPENDANT */
S
N#endif /* __CMSIS_GENERIC */
L 305 ".\SRC\System\CMSIS\Include\arm_math.h" 2
N#elif defined (ARM_MATH_CM3)
S  #include "core_cm3.h"
S#elif defined (ARM_MATH_CM0)
S  #include "core_cm0.h"
S  #define ARM_MATH_CM0_FAMILY
S#elif defined (ARM_MATH_CM0PLUS)
S  #include "core_cm0plus.h"
S  #define ARM_MATH_CM0_FAMILY
S#else
S  #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_CM0PLUS or ARM_MATH_CM0"
N#endif
N
N#undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
N#include "string.h"
N#include "math.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 320 ".\SRC\System\CMSIS\Include\arm_math.h" 2
N#ifdef   __cplusplus
Sextern "C"
S{
N#endif
N
N
N  /**
N   * @brief Macros required for reciprocal calculation in Normalized LMS
N   */
N
N#define DELTA_Q31          (0x100)
N#define DELTA_Q15          0x5
N#define INDEX_MASK         0x0000003F
N#ifndef PI
N#define PI                 3.14159265358979f
N#endif
N
N  /**
N   * @brief Macros required for SINE and COSINE Fast math approximations
N   */
N
N#define FAST_MATH_TABLE_SIZE  512
N#define FAST_MATH_Q31_SHIFT   (32 - 10)
N#define FAST_MATH_Q15_SHIFT   (16 - 10)
N#define CONTROLLER_Q31_SHIFT  (32 - 9)
N#define TABLE_SIZE  256
N#define TABLE_SPACING_Q31     0x400000
N#define TABLE_SPACING_Q15     0x80
N
N  /**
N   * @brief Macros required for SINE and COSINE Controller functions
N   */
N  /* 1.31(q31) Fixed value of 2/360 */
N  /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
N#define INPUT_SPACING         0xB60B61
N
N  /**
N   * @brief Macro for Unaligned Support
N   */
N#ifndef UNALIGNED_SUPPORT_DISABLE
N    #define ALIGN4
N#else
S  #if defined  (__GNUC__)
S    #define ALIGN4 __attribute__((aligned(4)))
S  #else
S    #define ALIGN4 __align(4)
S  #endif
N#endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
N
N  /**
N   * @brief Error status returned by some functions in the library.
N   */
N
N  typedef enum
N  {
N    ARM_MATH_SUCCESS = 0,                /**< No error */
N    ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
N    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
N    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
N    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
N    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
N    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
N  } arm_status;
N
N  /**
N   * @brief 8-bit fractional data type in 1.7 format.
N   */
N  typedef int8_t q7_t;
N
N  /**
N   * @brief 16-bit fractional data type in 1.15 format.
N   */
N  typedef int16_t q15_t;
N
N  /**
N   * @brief 32-bit fractional data type in 1.31 format.
N   */
N  typedef int32_t q31_t;
N
N  /**
N   * @brief 64-bit fractional data type in 1.63 format.
N   */
N  typedef int64_t q63_t;
N
N  /**
N   * @brief 32-bit floating-point type definition.
N   */
N  typedef float float32_t;
N
N  /**
N   * @brief 64-bit floating-point type definition.
N   */
N  typedef double float64_t;
N
N  /**
N   * @brief definition to read/write two 16 bit values.
N   */
N#if defined __CC_ARM
X#if 1L
N  #define __SIMD32_TYPE int32_t __packed
N  #define CMSIS_UNUSED __attribute__((unused))
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED __attribute__((unused))
S
S#elif defined __GNUC__
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED __attribute__((unused))
S
S#elif defined __ICCARM__
S  #define __SIMD32_TYPE int32_t __packed
S  #define CMSIS_UNUSED
S
S#elif defined __CSMC__
S  #define __SIMD32_TYPE int32_t
S  #define CMSIS_UNUSED
S
S#elif defined __TASKING__
S  #define __SIMD32_TYPE __unaligned int32_t
S  #define CMSIS_UNUSED
S
S#else
S  #error Unknown compiler
N#endif
N
N#define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
N#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
N#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
N#define __SIMD64(addr)        (*(int64_t **) & (addr))
N
N#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
X#if 0L || 0L
S  /**
S   * @brief definition to pack two 16 bit values.
S   */
S#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) | \
S                                         (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
X#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) |                                          (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
S#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) | \
S                                         (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
X#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) |                                          (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
S
N#endif
N
N
N   /**
N   * @brief definition to pack four 8 bit values.
N   */
N#ifndef ARM_MATH_BIG_ENDIAN
N
N#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
N                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
N                                (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
N                                (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
N#else
S
S#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
S                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
S                                (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
S                                (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
S
N#endif
N
N
N  /**
N   * @brief Clips Q63 to Q31 values.
N   */
N  static __INLINE q31_t clip_q63_to_q31(
X  static __inline q31_t clip_q63_to_q31(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
N  }
N
N  /**
N   * @brief Clips Q63 to Q15 values.
N   */
N  static __INLINE q15_t clip_q63_to_q15(
X  static __inline q15_t clip_q63_to_q15(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
N  }
N
N  /**
N   * @brief Clips Q31 to Q7 values.
N   */
N  static __INLINE q7_t clip_q31_to_q7(
X  static __inline q7_t clip_q31_to_q7(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
N      ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
N  }
N
N  /**
N   * @brief Clips Q31 to Q15 values.
N   */
N  static __INLINE q15_t clip_q31_to_q15(
X  static __inline q15_t clip_q31_to_q15(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
N  }
N
N  /**
N   * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
N   */
N
N  static __INLINE q63_t mult32x64(
X  static __inline q63_t mult32x64(
N  q63_t x,
N  q31_t y)
N  {
N    return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
N            (((q63_t) (x >> 32) * y)));
N  }
N
N/*
N  #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
N  #define __CLZ __clz
N  #endif
N */
N/* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
N#if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
X#if 0L && ((0L)  )
S  static __INLINE uint32_t __CLZ(
S  q31_t data);
S
S  static __INLINE uint32_t __CLZ(
S  q31_t data)
S  {
S    uint32_t count = 0;
S    uint32_t mask = 0x80000000;
S
S    while((data & mask) == 0)
S    {
S      count += 1u;
S      mask = mask >> 1u;
S    }
S
S    return (count);
S  }
N#endif
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
N   */
N
N  static __INLINE uint32_t arm_recip_q31(
X  static __inline uint32_t arm_recip_q31(
N  q31_t in,
N  q31_t * dst,
N  q31_t * pRecipTable)
N  {
N    q31_t out;
N    uint32_t tempVal;
N    uint32_t index, i;
N    uint32_t signBits;
N
N    if(in > 0)
N    {
N      signBits = ((uint32_t) (__CLZ( in) - 1));
X      signBits = ((uint32_t) (__clz( in) - 1));
N    }
N    else
N    {
N      signBits = ((uint32_t) (__CLZ(-in) - 1));
X      signBits = ((uint32_t) (__clz(-in) - 1));
N    }
N
N    /* Convert input sample to 1.31 format */
N    in = (in << signBits);
N
N    /* calculation of index for initial approximated Val */
N    index = (uint32_t)(in >> 24);
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /* 1.31 with exp 1 */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0u; i < 2u; i++)
N    {
N      tempVal = (uint32_t) (((q63_t) in * out) >> 31);
N      tempVal = 0x7FFFFFFFu - tempVal;
N      /*      1.31 with exp 1 */
N      /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
N      out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1u);
N  }
N
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
N   */
N  static __INLINE uint32_t arm_recip_q15(
X  static __inline uint32_t arm_recip_q15(
N  q15_t in,
N  q15_t * dst,
N  q15_t * pRecipTable)
N  {
N    q15_t out = 0;
N    uint32_t tempVal = 0;
N    uint32_t index = 0, i = 0;
N    uint32_t signBits = 0;
N
N    if(in > 0)
N    {
N      signBits = ((uint32_t)(__CLZ( in) - 17));
X      signBits = ((uint32_t)(__clz( in) - 17));
N    }
N    else
N    {
N      signBits = ((uint32_t)(__CLZ(-in) - 17));
X      signBits = ((uint32_t)(__clz(-in) - 17));
N    }
N
N    /* Convert input sample to 1.15 format */
N    in = (in << signBits);
N
N    /* calculation of index for initial approximated Val */
N    index = (uint32_t)(in >>  8);
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /*      1.15 with exp 1  */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0u; i < 2u; i++)
N    {
N      tempVal = (uint32_t) (((q31_t) in * out) >> 15);
N      tempVal = 0x7FFFu - tempVal;
N      /*      1.15 with exp 1 */
N      out = (q15_t) (((q31_t) out * tempVal) >> 14);
N      /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1);
N  }
N
N
N  /*
N   * @brief C custom defined intrinisic function for only M0 processors
N   */
N#if defined(ARM_MATH_CM0_FAMILY)
X#if 0L
S  static __INLINE q31_t __SSAT(
S  q31_t x,
S  uint32_t y)
S  {
S    int32_t posMax, negMin;
S    uint32_t i;
S
S    posMax = 1;
S    for (i = 0; i < (y - 1); i++)
S    {
S      posMax = posMax * 2;
S    }
S
S    if(x > 0)
S    {
S      posMax = (posMax - 1);
S
S      if(x > posMax)
S      {
S        x = posMax;
S      }
S    }
S    else
S    {
S      negMin = -posMax;
S
S      if(x < negMin)
S      {
S        x = negMin;
S      }
S    }
S    return (x);
S  }
N#endif /* end of ARM_MATH_CM0_FAMILY */
N
N
N  /*
N   * @brief C custom defined intrinsic function for M3 and M0 processors
N   */
N#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
X#if 0L || 0L
S
S  /*
S   * @brief C custom defined QADD8 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __QADD8(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s, t, u;
S
S    r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
S    s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
S    t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
S    u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
S
S    return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined QSUB8 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __QSUB8(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s, t, u;
S
S    r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
S    s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
S    t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
S    u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
S
S    return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined QADD16 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __QADD16(
S  uint32_t x,
S  uint32_t y)
S  {
S/*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass! for armCC */
S    q31_t r = 0, s = 0;
S
S    r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
S    s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined SHADD16 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SHADD16(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S    s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined QSUB16 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __QSUB16(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
S    s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined SHSUB16 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SHSUB16(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S    s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined QASX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __QASX(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
S    s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined SHASX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SHASX(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S    s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined QSAX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __QSAX(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
S    s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined SHSAX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SHSAX(
S  uint32_t x,
S  uint32_t y)
S  {
S    q31_t r, s;
S
S    r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S    s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
S
S    return ((uint32_t)((s << 16) | (r      )));
S  }
S
S
S  /*
S   * @brief C custom defined SMUSDX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMUSDX(
S  uint32_t x,
S  uint32_t y)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
S  }
S
S  /*
S   * @brief C custom defined SMUADX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMUADX(
S  uint32_t x,
S  uint32_t y)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
S  }
S
S
S  /*
S   * @brief C custom defined QADD for M3 and M0 processors
S   */
S  static __INLINE int32_t __QADD(
S  int32_t x,
S  int32_t y)
S  {
S    return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
S  }
S
S
S  /*
S   * @brief C custom defined QSUB for M3 and M0 processors
S   */
S  static __INLINE int32_t __QSUB(
S  int32_t x,
S  int32_t y)
S  {
S    return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
S  }
S
S
S  /*
S   * @brief C custom defined SMLAD for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMLAD(
S  uint32_t x,
S  uint32_t y,
S  uint32_t sum)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
S                       ( ((q31_t)sum    )                                  )   ));
S  }
S
S
S  /*
S   * @brief C custom defined SMLADX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMLADX(
S  uint32_t x,
S  uint32_t y,
S  uint32_t sum)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
S                       ( ((q31_t)sum    )                                  )   ));
S  }
S
S
S  /*
S   * @brief C custom defined SMLSDX for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMLSDX(
S  uint32_t x,
S  uint32_t y,
S  uint32_t sum)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
S                       ( ((q31_t)sum    )                                  )   ));
S  }
S
S
S  /*
S   * @brief C custom defined SMLALD for M3 and M0 processors
S   */
S  static __INLINE uint64_t __SMLALD(
S  uint32_t x,
S  uint32_t y,
S  uint64_t sum)
S  {
S/*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
S    return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
S                       ( ((q63_t)sum    )                                  )   ));
S  }
S
S
S  /*
S   * @brief C custom defined SMLALDX for M3 and M0 processors
S   */
S  static __INLINE uint64_t __SMLALDX(
S  uint32_t x,
S  uint32_t y,
S  uint64_t sum)
S  {
S/*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
S    return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
S                       ( ((q63_t)sum    )                                  )   ));
S  }
S
S
S  /*
S   * @brief C custom defined SMUAD for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMUAD(
S  uint32_t x,
S  uint32_t y)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
S  }
S
S
S  /*
S   * @brief C custom defined SMUSD for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SMUSD(
S  uint32_t x,
S  uint32_t y)
S  {
S    return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
S                       ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
S  }
S
S
S  /*
S   * @brief C custom defined SXTB16 for M3 and M0 processors
S   */
S  static __INLINE uint32_t __SXTB16(
S  uint32_t x)
S  {
S    return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
S                       ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
S  }
S
N#endif /* defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N
N
N  /**
N   * @brief Instance structure for the Q7 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;        /**< number of filter coefficients in the filter. */
N    q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q7;
N
N  /**
N   * @brief Instance structure for the Q15 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of filter coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q7 FIR filter.
N   * @param[in]  S          points to an instance of the Q7 FIR filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_q7(
N  const arm_fir_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q7 FIR filter.
N   * @param[in,out] S          points to an instance of the Q7 FIR structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed.
N   */
N  void arm_fir_init_q7(
N  arm_fir_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR filter.
N   * @param[in]  S          points to an instance of the Q15 FIR structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q15 FIR filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_fast_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR filter.
N   * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greater than or equal to 4.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed at a time.
N   * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if
N   * <code>numTaps</code> is not a supported value.
N   */
N  arm_status arm_fir_init_q15(
N  arm_fir_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR filter.
N   * @param[in]  S          points to an instance of the Q31 FIR filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q31 FIR structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_fast_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR filter.
N   * @param[in,out] S          points to an instance of the Q31 FIR structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed at a time.
N   */
N  void arm_fir_init_q31(
N  arm_fir_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR filter.
N   * @param[in]  S          points to an instance of the floating-point FIR structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_f32(
N  const arm_fir_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR filter.
N   * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
N   * @param[in]     numTaps    Number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of samples that are processed at a time.
N   */
N  void arm_fir_init_f32(
N  arm_fir_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q15_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
N  } arm_biquad_casd_df1_inst_q15;
N
N  /**
N   * @brief Instance structure for the Q31 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
N  } arm_biquad_casd_df1_inst_q31;
N
N  /**
N   * @brief Instance structure for the floating-point Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;       /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_casd_df1_inst_f32;
N
N
N  /**
N   * @brief Processing function for the Q15 Biquad cascade filter.
N   * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format
N   */
N  void arm_biquad_cascade_df1_init_q15(
N  arm_biquad_casd_df1_inst_q15 * S,
N  uint8_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int8_t postShift);
N
N
N  /**
N   * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_fast_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 Biquad cascade filter
N   * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_fast_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format
N   */
N  void arm_biquad_cascade_df1_init_q31(
N  arm_biquad_casd_df1_inst_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int8_t postShift);
N
N
N  /**
N   * @brief Processing function for the floating-point Biquad cascade filter.
N   * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df1_f32(
N  const arm_biquad_casd_df1_inst_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_df1_init_f32(
N  arm_biquad_casd_df1_inst_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float32_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f32;
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float64_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f64;
N
N  /**
N   * @brief Instance structure for the Q15 matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q15_t *pData;         /**< points to the data of the matrix. */
N  } arm_matrix_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 matrix structure.
N   */
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q31_t *pData;         /**< points to the data of the matrix. */
N  } arm_matrix_instance_q31;
N
N
N  /**
N   * @brief Floating-point matrix addition.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_add_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix addition.
N   * @param[in]   pSrcA  points to the first input matrix structure
N   * @param[in]   pSrcB  points to the second input matrix structure
N   * @param[out]  pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_add_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix addition.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_add_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point, complex, matrix multiplication.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_cmplx_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15, complex,  matrix multiplication.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_cmplx_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Q31, complex, matrix multiplication.
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_cmplx_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix transpose.
N   * @param[in]  pSrc  points to the input matrix
N   * @param[out] pDst  points to the output matrix
N   * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_trans_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix transpose.
N   * @param[in]  pSrc  points to the input matrix
N   * @param[out] pDst  points to the output matrix
N   * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_trans_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix transpose.
N   * @param[in]  pSrc  points to the input matrix
N   * @param[out] pDst  points to the output matrix
N   * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_trans_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix multiplication
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix multiplication
N   * @param[in]  pSrcA   points to the first input matrix structure
N   * @param[in]  pSrcB   points to the second input matrix structure
N   * @param[out] pDst    points to output matrix structure
N   * @param[in]  pState  points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N
N  /**
N   * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA   points to the first input matrix structure
N   * @param[in]  pSrcB   points to the second input matrix structure
N   * @param[out] pDst    points to output matrix structure
N   * @param[in]  pState  points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_fast_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N
N  /**
N   * @brief Q31 matrix multiplication
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_mult_fast_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix subtraction
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_sub_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix subtraction
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_sub_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix subtraction
N   * @param[in]  pSrcA  points to the first input matrix structure
N   * @param[in]  pSrcB  points to the second input matrix structure
N   * @param[out] pDst   points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_sub_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix scaling.
N   * @param[in]  pSrc   points to the input matrix
N   * @param[in]  scale  scale factor
N   * @param[out] pDst   points to the output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_scale_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  float32_t scale,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix scaling.
N   * @param[in]  pSrc        points to input matrix
N   * @param[in]  scaleFract  fractional portion of the scale factor
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_scale_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  q15_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q15 * pDst);
N
N
N  /**
N   * @brief Q31 matrix scaling.
N   * @param[in]  pSrc        points to input matrix
N   * @param[in]  scaleFract  fractional portion of the scale factor
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N  arm_status arm_mat_scale_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  q31_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief  Q31 matrix initialization.
N   * @param[in,out] S         points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows     number of rows in the matrix.
N   * @param[in]     nColumns  number of columns in the matrix.
N   * @param[in]     pData     points to the matrix data array.
N   */
N  void arm_mat_init_q31(
N  arm_matrix_instance_q31 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q31_t * pData);
N
N
N  /**
N   * @brief  Q15 matrix initialization.
N   * @param[in,out] S         points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows     number of rows in the matrix.
N   * @param[in]     nColumns  number of columns in the matrix.
N   * @param[in]     pData     points to the matrix data array.
N   */
N  void arm_mat_init_q15(
N  arm_matrix_instance_q15 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q15_t * pData);
N
N
N  /**
N   * @brief  Floating-point matrix initialization.
N   * @param[in,out] S         points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows     number of rows in the matrix.
N   * @param[in]     nColumns  number of columns in the matrix.
N   * @param[in]     pData     points to the matrix data array.
N   */
N  void arm_mat_init_f32(
N  arm_matrix_instance_f32 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  float32_t * pData);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 PID Control.
N   */
N  typedef struct
N  {
N    q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
N#ifdef ARM_MATH_CM0_FAMILY
S    q15_t A1;
S    q15_t A2;
N#else
N    q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
N#endif
N    q15_t state[3];     /**< The state array of length 3. */
N    q15_t Kp;           /**< The proportional gain. */
N    q15_t Ki;           /**< The integral gain. */
N    q15_t Kd;           /**< The derivative gain. */
N  } arm_pid_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 PID Control.
N   */
N  typedef struct
N  {
N    q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
N    q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
N    q31_t A2;            /**< The derived gain, A2 = Kd . */
N    q31_t state[3];      /**< The state array of length 3. */
N    q31_t Kp;            /**< The proportional gain. */
N    q31_t Ki;            /**< The integral gain. */
N    q31_t Kd;            /**< The derivative gain. */
N  } arm_pid_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point PID Control.
N   */
N  typedef struct
N  {
N    float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
N    float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
N    float32_t A2;          /**< The derived gain, A2 = Kd . */
N    float32_t state[3];    /**< The state array of length 3. */
N    float32_t Kp;          /**< The proportional gain. */
N    float32_t Ki;          /**< The integral gain. */
N    float32_t Kd;          /**< The derivative gain. */
N  } arm_pid_instance_f32;
N
N
N
N  /**
N   * @brief  Initialization function for the floating-point PID Control.
N   * @param[in,out] S               points to an instance of the PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   */
N  void arm_pid_init_f32(
N  arm_pid_instance_f32 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the floating-point PID Control.
N   * @param[in,out] S  is an instance of the floating-point PID Control structure
N   */
N  void arm_pid_reset_f32(
N  arm_pid_instance_f32 * S);
N
N
N  /**
N   * @brief  Initialization function for the Q31 PID Control.
N   * @param[in,out] S               points to an instance of the Q15 PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   */
N  void arm_pid_init_q31(
N  arm_pid_instance_q31 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the Q31 PID Control.
N   * @param[in,out] S   points to an instance of the Q31 PID Control structure
N   */
N
N  void arm_pid_reset_q31(
N  arm_pid_instance_q31 * S);
N
N
N  /**
N   * @brief  Initialization function for the Q15 PID Control.
N   * @param[in,out] S               points to an instance of the Q15 PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   */
N  void arm_pid_init_q15(
N  arm_pid_instance_q15 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the Q15 PID Control.
N   * @param[in,out] S  points to an instance of the q15 PID Control structure
N   */
N  void arm_pid_reset_q15(
N  arm_pid_instance_q15 * S);
N
N
N  /**
N   * @brief Instance structure for the floating-point Linear Interpolate function.
N   */
N  typedef struct
N  {
N    uint32_t nValues;           /**< nValues */
N    float32_t x1;               /**< x1 */
N    float32_t xSpacing;         /**< xSpacing */
N    float32_t *pYData;          /**< pointer to the table of Y values */
N  } arm_linear_interp_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    float32_t *pData;   /**< points to the data table. */
N  } arm_bilinear_interp_instance_f32;
N
N   /**
N   * @brief Instance structure for the Q31 bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q31_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q31;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q15_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q15;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q7_t *pData;        /**< points to the data table. */
N  } arm_bilinear_interp_instance_q7;
N
N
N  /**
N   * @brief Q7 vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Floating-point vector multiplication.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_mult_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q15(
N  arm_cfft_radix2_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q15(
N  const arm_cfft_radix2_instance_q15 * S,
N  q15_t * pSrc);
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q15(
N  arm_cfft_radix4_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_q15(
N  const arm_cfft_radix4_instance_q15 * S,
N  q15_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q31;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q31(
N  arm_cfft_radix2_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q31(
N  const arm_cfft_radix2_instance_q31 * S,
N  q31_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Q31 CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q31;
N
N/* Deprecated */
N  void arm_cfft_radix4_q31(
N  const arm_cfft_radix4_instance_q31 * S,
N  q31_t * pSrc);
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q31(
N  arm_cfft_radix4_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;             /**< value of 1/fftLen. */
N  } arm_cfft_radix2_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_f32(
N  arm_cfft_radix2_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_f32(
N  const arm_cfft_radix2_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;             /**< value of 1/fftLen. */
N  } arm_cfft_radix4_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_f32(
N  arm_cfft_radix4_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_f32(
N  const arm_cfft_radix4_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q15;
N
Nvoid arm_cfft_q15(
N    const arm_cfft_instance_q15 * S,
N    q15_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q31;
N
Nvoid arm_cfft_q31(
N    const arm_cfft_instance_q31 * S,
N    q31_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_f32;
N
N  void arm_cfft_f32(
N  const arm_cfft_instance_f32 * S,
N  float32_t * p1,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the Q15 RFFT/RIFFT function.
N   */
N  typedef struct
N  {
N    uint32_t fftLenReal;                      /**< length of the real FFT. */
N    uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
N    q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q15;
N
N  arm_status arm_rfft_init_q15(
N  arm_rfft_instance_q15 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q15(
N  const arm_rfft_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst);
N
N  /**
N   * @brief Instance structure for the Q31 RFFT/RIFFT function.
N   */
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
N    q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q31;
N
N  arm_status arm_rfft_init_q31(
N  arm_rfft_instance_q31 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q31(
N  const arm_rfft_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint16_t fftLenBy2;                         /**< length of the complex FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
N    float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
N    arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
N  } arm_rfft_instance_f32;
N
N  arm_status arm_rfft_init_f32(
N  arm_rfft_instance_f32 * S,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_f32(
N  const arm_rfft_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
Ntypedef struct
N  {
N    arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
N    uint16_t fftLenRFFT;             /**< length of the real sequence */
N    float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
N  } arm_rfft_fast_instance_f32 ;
N
Narm_status arm_rfft_fast_init_f32 (
N   arm_rfft_fast_instance_f32 * S,
N   uint16_t fftLen);
N
Nvoid arm_rfft_fast_f32(
N  arm_rfft_fast_instance_f32 * S,
N  float32_t * p, float32_t * pOut,
N  uint8_t ifftFlag);
N
N  /**
N   * @brief Instance structure for the floating-point DCT4/IDCT4 function.
N   */
N  typedef struct
N  {
N    uint16_t N;                          /**< length of the DCT4. */
N    uint16_t Nby2;                       /**< half of the length of the DCT4. */
N    float32_t normalize;                 /**< normalizing factor. */
N    float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    float32_t *pCosFactor;               /**< points to the cosFactor table. */
N    arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_f32;
N
N
N  /**
N   * @brief  Initialization function for the floating-point DCT4/IDCT4.
N   * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
N   * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
N   * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length.
N   */
N  arm_status arm_dct4_init_f32(
N  arm_dct4_instance_f32 * S,
N  arm_rfft_instance_f32 * S_RFFT,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  float32_t normalize);
N
N
N  /**
N   * @brief Processing function for the floating-point DCT4/IDCT4.
N   * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure.
N   * @param[in]     pState         points to state buffer.
N   * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
N   */
N  void arm_dct4_f32(
N  const arm_dct4_instance_f32 * S,
N  float32_t * pState,
N  float32_t * pInlineBuffer);
N
N
N  /**
N   * @brief Instance structure for the Q31 DCT4/IDCT4 function.
N   */
N  typedef struct
N  {
N    uint16_t N;                          /**< length of the DCT4. */
N    uint16_t Nby2;                       /**< half of the length of the DCT4. */
N    q31_t normalize;                     /**< normalizing factor. */
N    q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
N    q31_t *pCosFactor;                   /**< points to the cosFactor table. */
N    arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q31;
N
N
N  /**
N   * @brief  Initialization function for the Q31 DCT4/IDCT4.
N   * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
N   * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
N   * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N  arm_status arm_dct4_init_q31(
N  arm_dct4_instance_q31 * S,
N  arm_rfft_instance_q31 * S_RFFT,
N  arm_cfft_radix4_instance_q31 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q31_t normalize);
N
N
N  /**
N   * @brief Processing function for the Q31 DCT4/IDCT4.
N   * @param[in]     S              points to an instance of the Q31 DCT4 structure.
N   * @param[in]     pState         points to state buffer.
N   * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
N   */
N  void arm_dct4_q31(
N  const arm_dct4_instance_q31 * S,
N  q31_t * pState,
N  q31_t * pInlineBuffer);
N
N
N  /**
N   * @brief Instance structure for the Q15 DCT4/IDCT4 function.
N   */
N  typedef struct
N  {
N    uint16_t N;                          /**< length of the DCT4. */
N    uint16_t Nby2;                       /**< half of the length of the DCT4. */
N    q15_t normalize;                     /**< normalizing factor. */
N    q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
N    q15_t *pCosFactor;                   /**< points to the cosFactor table. */
N    arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q15;
N
N
N  /**
N   * @brief  Initialization function for the Q15 DCT4/IDCT4.
N   * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
N   * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
N   * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N  arm_status arm_dct4_init_q15(
N  arm_dct4_instance_q15 * S,
N  arm_rfft_instance_q15 * S_RFFT,
N  arm_cfft_radix4_instance_q15 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q15_t normalize);
N
N
N  /**
N   * @brief Processing function for the Q15 DCT4/IDCT4.
N   * @param[in]     S              points to an instance of the Q15 DCT4 structure.
N   * @param[in]     pState         points to state buffer.
N   * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
N   */
N  void arm_dct4_q15(
N  const arm_dct4_instance_q15 * S,
N  q15_t * pState,
N  q15_t * pInlineBuffer);
N
N
N  /**
N   * @brief Floating-point vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q7 vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector addition.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_add_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Floating-point vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q7 vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector subtraction.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_sub_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a floating-point vector by a scalar.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  scale      scale factor to be applied
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_scale_f32(
N  float32_t * pSrc,
N  float32_t scale,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a Q7 vector by a scalar.
N   * @param[in]  pSrc        points to the input vector
N   * @param[in]  scaleFract  fractional portion of the scale value
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to the output vector
N   * @param[in]  blockSize   number of samples in the vector
N   */
N  void arm_scale_q7(
N  q7_t * pSrc,
N  q7_t scaleFract,
N  int8_t shift,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a Q15 vector by a scalar.
N   * @param[in]  pSrc        points to the input vector
N   * @param[in]  scaleFract  fractional portion of the scale value
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to the output vector
N   * @param[in]  blockSize   number of samples in the vector
N   */
N  void arm_scale_q15(
N  q15_t * pSrc,
N  q15_t scaleFract,
N  int8_t shift,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Multiplies a Q31 vector by a scalar.
N   * @param[in]  pSrc        points to the input vector
N   * @param[in]  scaleFract  fractional portion of the scale value
N   * @param[in]  shift       number of bits to shift the result by
N   * @param[out] pDst        points to the output vector
N   * @param[in]  blockSize   number of samples in the vector
N   */
N  void arm_scale_q31(
N  q31_t * pSrc,
N  q31_t scaleFract,
N  int8_t shift,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q7 vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Floating-point vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q15 vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Q31 vector absolute value.
N   * @param[in]  pSrc       points to the input buffer
N   * @param[out] pDst       points to the output buffer
N   * @param[in]  blockSize  number of samples in each vector
N   */
N  void arm_abs_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Dot product of floating-point vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t blockSize,
N  float32_t * result);
N
N
N  /**
N   * @brief Dot product of Q7 vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  uint32_t blockSize,
N  q31_t * result);
N
N
N  /**
N   * @brief Dot product of Q15 vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N
N  /**
N   * @brief Dot product of Q31 vectors.
N   * @param[in]  pSrcA      points to the first input vector
N   * @param[in]  pSrcB      points to the second input vector
N   * @param[in]  blockSize  number of samples in each vector
N   * @param[out] result     output result returned here
N   */
N  void arm_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N
N  /**
N   * @brief  Shifts the elements of a Q7 vector a specified number of bits.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_shift_q7(
N  q7_t * pSrc,
N  int8_t shiftBits,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Shifts the elements of a Q15 vector a specified number of bits.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_shift_q15(
N  q15_t * pSrc,
N  int8_t shiftBits,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Shifts the elements of a Q31 vector a specified number of bits.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_shift_q31(
N  q31_t * pSrc,
N  int8_t shiftBits,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a floating-point vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_f32(
N  float32_t * pSrc,
N  float32_t offset,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a Q7 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_q7(
N  q7_t * pSrc,
N  q7_t offset,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a Q15 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_q15(
N  q15_t * pSrc,
N  q15_t offset,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Adds a constant offset to a Q31 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[in]  offset     is the offset to be added
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_offset_q31(
N  q31_t * pSrc,
N  q31_t offset,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a floating-point vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a Q7 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a Q15 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Negates the elements of a Q31 vector.
N   * @param[in]  pSrc       points to the input vector
N   * @param[out] pDst       points to the output vector
N   * @param[in]  blockSize  number of samples in the vector
N   */
N  void arm_negate_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a floating-point vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a Q7 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a Q15 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Copies the elements of a Q31 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_copy_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a floating-point vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_f32(
N  float32_t value,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a Q7 vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_q7(
N  q7_t value,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a Q15 vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_q15(
N  q15_t value,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Fills a constant value into a Q31 vector.
N   * @param[in]  value      input value to be filled
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_fill_q31(
N  q31_t value,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Convolution of floating-point sequences.
N * @param[in]  pSrcA    points to the first input sequence.
N * @param[in]  srcALen  length of the first input sequence.
N * @param[in]  pSrcB    points to the second input sequence.
N * @param[in]  srcBLen  length of the second input sequence.
N * @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1.
N */
N  void arm_conv_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences.
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
N   */
N  void arm_conv_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N * @brief Convolution of Q15 sequences.
N * @param[in]  pSrcA    points to the first input sequence.
N * @param[in]  srcALen  length of the first input sequence.
N * @param[in]  pSrcB    points to the second input sequence.
N * @param[in]  srcBLen  length of the second input sequence.
N * @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1.
N */
N  void arm_conv_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_fast_q15(
N          q15_t * pSrcA,
N          uint32_t srcALen,
N          q15_t * pSrcB,
N          uint32_t srcBLen,
N          q15_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
N   */
N  void arm_conv_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Convolution of Q31 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N    /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   */
N  void arm_conv_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
N   */
N  void arm_conv_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Partial convolution of floating-point sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_fast_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q7 sequences
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N   * @brief Partial convolution of Q7 sequences.
N   * @param[in]  pSrcA       points to the first input sequence.
N   * @param[in]  srcALen     length of the first input sequence.
N   * @param[in]  pSrcB       points to the second input sequence.
N   * @param[in]  srcBLen     length of the second input sequence.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  firstIndex  is the first output sample to start with.
N   * @param[in]  numPoints   is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N  arm_status arm_conv_partial_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR decimator.
N   */
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
N    q15_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR decimator.
N   */
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
N    q31_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR decimator.
N   */
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTaps.*/
N    float32_t *pState;          /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_f32;
N
N
N  /**
N   * @brief Processing function for the floating-point FIR decimator.
N   * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_f32(
N  const arm_fir_decimate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR decimator.
N   * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
N   * @param[in]     numTaps    number of coefficients in the filter.
N   * @param[in]     M          decimation factor.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N  arm_status arm_fir_decimate_init_f32(
N  arm_fir_decimate_instance_f32 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator.
N   * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_fast_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR decimator.
N   * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
N   * @param[in]     numTaps    number of coefficients in the filter.
N   * @param[in]     M          decimation factor.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N  arm_status arm_fir_decimate_init_q15(
N  arm_fir_decimate_instance_q15 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator.
N   * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
N   * @param[in]  pSrc  points to the block of input data.
N   * @param[out] pDst  points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   */
N  void arm_fir_decimate_q31(
N  const arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_decimate_fast_q31(
N  arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR decimator.
N   * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
N   * @param[in]     numTaps    number of coefficients in the filter.
N   * @param[in]     M          decimation factor.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N  arm_status arm_fir_decimate_init_q31(
N  arm_fir_decimate_instance_q31 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR interpolator.
N   */
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR interpolator.
N   */
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q31_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR interpolator.
N   */
N  typedef struct
N  {
N    uint8_t L;                     /**< upsample factor. */
N    uint16_t phaseLength;          /**< length of each polyphase filter component. */
N    float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*phaseLength. */
N    float32_t *pState;             /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
N  } arm_fir_interpolate_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q15 FIR interpolator.
N   * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_interpolate_q15(
N  const arm_fir_interpolate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR interpolator.
N   * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]     L          upsample factor.
N   * @param[in]     numTaps    number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficient buffer.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N  arm_status arm_fir_interpolate_init_q15(
N  arm_fir_interpolate_instance_q15 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR interpolator.
N   * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_interpolate_q31(
N  const arm_fir_interpolate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR interpolator.
N   * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
N   * @param[in]     L          upsample factor.
N   * @param[in]     numTaps    number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficient buffer.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N  arm_status arm_fir_interpolate_init_q31(
N  arm_fir_interpolate_instance_q31 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR interpolator.
N   * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of input samples to process per call.
N   */
N  void arm_fir_interpolate_f32(
N  const arm_fir_interpolate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR interpolator.
N   * @param[in,out] S          points to an instance of the floating-point FIR interpolator structure.
N   * @param[in]     L          upsample factor.
N   * @param[in]     numTaps    number of filter coefficients in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficient buffer.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     blockSize  number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N  arm_status arm_fir_interpolate_init_f32(
N  arm_fir_interpolate_instance_f32 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the high precision Q31 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
N  } arm_biquad_cas_df1_32x64_ins_q31;
N
N
N  /**
N   * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cas_df1_32x64_q31(
N  const arm_biquad_cas_df1_32x64_ins_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficients format
N   */
N  void arm_biquad_cas_df1_32x64_init_q31(
N  arm_biquad_cas_df1_32x64_ins_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q63_t * pState,
N  uint8_t postShift);
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_stereo_df2T_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float64_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f64;
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  S          points to an instance of the filter data structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df2T_f32(
N  const arm_biquad_cascade_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels
N   * @param[in]  S          points to an instance of the filter data structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_stereo_df2T_f32(
N  const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  S          points to an instance of the filter data structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_biquad_cascade_df2T_f64(
N  const arm_biquad_cascade_df2T_instance_f64 * S,
N  float64_t * pSrc,
N  float64_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the filter data structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_df2T_init_f32(
N  arm_biquad_cascade_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the filter data structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_stereo_df2T_init_f32(
N  arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] S          points to an instance of the filter data structure.
N   * @param[in]     numStages  number of 2nd order stages in the filter.
N   * @param[in]     pCoeffs    points to the filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   */
N  void arm_biquad_cascade_df2T_init_f64(
N  arm_biquad_cascade_df2T_instance_f64 * S,
N  uint8_t numStages,
N  float64_t * pCoeffs,
N  float64_t * pState);
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    q15_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
N    q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    q31_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
N    q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
N    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_f32;
N
N
N  /**
N   * @brief Initialization function for the Q15 FIR lattice filter.
N   * @param[in] S          points to an instance of the Q15 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] pState     points to the state buffer.  The array is of length numStages.
N   */
N  void arm_fir_lattice_init_q15(
N  arm_fir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR lattice filter.
N   * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_lattice_q15(
N  const arm_fir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the Q31 FIR lattice filter.
N   * @param[in] S          points to an instance of the Q31 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] pState     points to the state buffer.   The array is of length numStages.
N   */
N  void arm_fir_lattice_init_q31(
N  arm_fir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR lattice filter.
N   * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_lattice_q31(
N  const arm_fir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Initialization function for the floating-point FIR lattice filter.
N * @param[in] S          points to an instance of the floating-point FIR lattice structure.
N * @param[in] numStages  number of filter stages.
N * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
N * @param[in] pState     points to the state buffer.  The array is of length numStages.
N */
N  void arm_fir_lattice_init_f32(
N  arm_fir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR lattice filter.
N   * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_fir_lattice_f32(
N  const arm_fir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of stages in the filter. */
N    q15_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
N    q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of stages in the filter. */
N    q31_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
N    q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of stages in the filter. */
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages+blockSize. */
N    float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array is of length numStages. */
N    float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_f32;
N
N
N  /**
N   * @brief Processing function for the floating-point IIR lattice filter.
N   * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_f32(
N  const arm_iir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the floating-point IIR lattice filter.
N   * @param[in] S          points to an instance of the floating-point IIR lattice structure.
N   * @param[in] numStages  number of stages in the filter.
N   * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-1.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_init_f32(
N  arm_iir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pkCoeffs,
N  float32_t * pvCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 IIR lattice filter.
N   * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_q31(
N  const arm_iir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the Q31 IIR lattice filter.
N   * @param[in] S          points to an instance of the Q31 IIR lattice structure.
N   * @param[in] numStages  number of stages in the filter.
N   * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_init_q31(
N  arm_iir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pkCoeffs,
N  q31_t * pvCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 IIR lattice filter.
N   * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[out] pDst       points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_iir_lattice_q15(
N  const arm_iir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Initialization function for the Q15 IIR lattice filter.
N * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
N * @param[in] numStages  number of stages in the filter.
N * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages.
N * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
N * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
N * @param[in] blockSize  number of samples to process per call.
N */
N  void arm_iir_lattice_init_q15(
N  arm_iir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pkCoeffs,
N  q15_t * pvCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the floating-point LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;        /**< step size that controls filter coefficient updates. */
N  } arm_lms_instance_f32;
N
N
N  /**
N   * @brief Processing function for floating-point LMS filter.
N   * @param[in]  S          points to an instance of the floating-point LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_f32(
N  const arm_lms_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for floating-point LMS filter.
N   * @param[in] S          points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to the coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_lms_init_f32(
N  arm_lms_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N  } arm_lms_instance_q15;
N
N
N  /**
N   * @brief Initialization function for the Q15 LMS filter.
N   * @param[in] S          points to an instance of the Q15 LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to the coefficient buffer.
N   * @param[in] pState     points to the state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_init_q15(
N  arm_lms_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N
N  /**
N   * @brief Processing function for Q15 LMS filter.
N   * @param[in]  S          points to an instance of the Q15 LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_q15(
N  const arm_lms_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N  } arm_lms_instance_q31;
N
N
N  /**
N   * @brief Processing function for Q31 LMS filter.
N   * @param[in]  S          points to an instance of the Q15 LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_q31(
N  const arm_lms_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q31 LMS filter.
N   * @param[in] S          points to an instance of the Q31 LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_init_q31(
N  arm_lms_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N
N  /**
N   * @brief Instance structure for the floating-point normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;         /**< step size that control filter coefficient updates. */
N    float32_t energy;     /**< saves previous frame energy. */
N    float32_t x0;         /**< saves previous input sample. */
N  } arm_lms_norm_instance_f32;
N
N
N  /**
N   * @brief Processing function for floating-point normalized LMS filter.
N   * @param[in]  S          points to an instance of the floating-point normalized LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_norm_f32(
N  arm_lms_norm_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for floating-point normalized LMS filter.
N   * @param[in] S          points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   */
N  void arm_lms_norm_init_f32(
N  arm_lms_norm_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;             /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;    /**< bit shift applied to coefficients. */
N    q31_t *recipTable;    /**< points to the reciprocal initial value table. */
N    q31_t energy;         /**< saves previous frame energy. */
N    q31_t x0;             /**< saves previous input sample. */
N  } arm_lms_norm_instance_q31;
N
N
N  /**
N   * @brief Processing function for Q31 normalized LMS filter.
N   * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_norm_q31(
N  arm_lms_norm_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q31 normalized LMS filter.
N   * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_norm_init_q31(
N  arm_lms_norm_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N
N  /**
N   * @brief Instance structure for the Q15 normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< Number of coefficients in the filter. */
N    q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;             /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;    /**< bit shift applied to coefficients. */
N    q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
N    q15_t energy;         /**< saves previous frame energy. */
N    q15_t x0;             /**< saves previous input sample. */
N  } arm_lms_norm_instance_q15;
N
N
N  /**
N   * @brief Processing function for Q15 normalized LMS filter.
N   * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in]  pSrc       points to the block of input data.
N   * @param[in]  pRef       points to the block of reference data.
N   * @param[out] pOut       points to the block of output data.
N   * @param[out] pErr       points to the block of error data.
N   * @param[in]  blockSize  number of samples to process.
N   */
N  void arm_lms_norm_q15(
N  arm_lms_norm_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q15 normalized LMS filter.
N   * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in] numTaps    number of filter coefficients.
N   * @param[in] pCoeffs    points to coefficient buffer.
N   * @param[in] pState     points to state buffer.
N   * @param[in] mu         step size that controls filter coefficient updates.
N   * @param[in] blockSize  number of samples to process.
N   * @param[in] postShift  bit shift applied to coefficients.
N   */
N  void arm_lms_norm_init_q15(
N  arm_lms_norm_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N
N  /**
N   * @brief Correlation of floating-point sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N   /**
N   * @brief Correlation of Q15 sequences
N   * @param[in]  pSrcA     points to the first input sequence.
N   * @param[in]  srcALen   length of the first input sequence.
N   * @param[in]  pSrcB     points to the second input sequence.
N   * @param[in]  srcBLen   length of the second input sequence.
N   * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   */
N  void arm_correlate_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Correlation of Q15 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N
N  void arm_correlate_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N
N  void arm_correlate_fast_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in]  pSrcA     points to the first input sequence.
N   * @param[in]  srcALen   length of the first input sequence.
N   * @param[in]  pSrcB     points to the second input sequence.
N   * @param[in]  srcBLen   length of the second input sequence.
N   * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   */
N  void arm_correlate_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Correlation of Q31 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N  /**
N   * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in]  pSrcA      points to the first input sequence.
N   * @param[in]  srcALen    length of the first input sequence.
N   * @param[in]  pSrcB      points to the second input sequence.
N   * @param[in]  srcBLen    length of the second input sequence.
N   * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   */
N  void arm_correlate_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in]  pSrcA    points to the first input sequence.
N   * @param[in]  srcALen  length of the first input sequence.
N   * @param[in]  pSrcB    points to the second input sequence.
N   * @param[in]  srcBLen  length of the second input sequence.
N   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   */
N  void arm_correlate_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Instance structure for the floating-point sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_f32;
N
N  /**
N   * @brief Instance structure for the Q31 sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q31;
N
N  /**
N   * @brief Instance structure for the Q15 sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q7 sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q7;
N
N
N  /**
N   * @brief Processing function for the floating-point sparse FIR filter.
N   * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
N   * @param[in]  pSrc        points to the block of input data.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   */
N  void arm_fir_sparse_f32(
N  arm_fir_sparse_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  float32_t * pScratchIn,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point sparse FIR filter.
N   * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_f32(
N  arm_fir_sparse_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 sparse FIR filter.
N   * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
N   * @param[in]  pSrc        points to the block of input data.
N   * @param[out] pDst        points to the block of output data
N   * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   */
N  void arm_fir_sparse_q31(
N  arm_fir_sparse_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  q31_t * pScratchIn,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 sparse FIR filter.
N   * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_q31(
N  arm_fir_sparse_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 sparse FIR filter.
N   * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
N   * @param[in]  pSrc         points to the block of input data.
N   * @param[out] pDst         points to the block of output data
N   * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
N   * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   */
N  void arm_fir_sparse_q15(
N  arm_fir_sparse_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  q15_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 sparse FIR filter.
N   * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_q15(
N  arm_fir_sparse_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q7 sparse FIR filter.
N   * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
N   * @param[in]  pSrc         points to the block of input data.
N   * @param[out] pDst         points to the block of output data
N   * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
N   * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   */
N  void arm_fir_sparse_q7(
N  arm_fir_sparse_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  q7_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q7 sparse FIR filter.
N   * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     pCoeffs    points to the array of filter coefficients.
N   * @param[in]     pState     points to the state buffer.
N   * @param[in]     pTapDelay  points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   */
N  void arm_fir_sparse_init_q7(
N  arm_fir_sparse_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Floating-point sin_cos function.
N   * @param[in]  theta   input value in degrees
N   * @param[out] pSinVal  points to the processed sine output.
N   * @param[out] pCosVal  points to the processed cos output.
N   */
N  void arm_sin_cos_f32(
N  float32_t theta,
N  float32_t * pSinVal,
N  float32_t * pCosVal);
N
N
N  /**
N   * @brief  Q31 sin_cos function.
N   * @param[in]  theta    scaled input value in degrees
N   * @param[out] pSinVal  points to the processed sine output.
N   * @param[out] pCosVal  points to the processed cosine output.
N   */
N  void arm_sin_cos_q31(
N  q31_t theta,
N  q31_t * pSinVal,
N  q31_t * pCosVal);
N
N
N  /**
N   * @brief  Floating-point complex conjugate.
N   * @param[in]  pSrc        points to the input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_conj_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex conjugate.
N   * @param[in]  pSrc        points to the input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_conj_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex conjugate.
N   * @param[in]  pSrc        points to the input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_conj_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Floating-point complex magnitude squared
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_squared_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex magnitude squared
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_squared_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex magnitude squared
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_squared_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup PID PID Motor Control
N   *
N   * A Proportional Integral Derivative (PID) controller is a generic feedback control
N   * loop mechanism widely used in industrial control systems.
N   * A PID controller is the most commonly used type of feedback controller.
N   *
N   * This set of functions implements (PID) controllers
N   * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
N   * of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
N   * is the input sample value. The functions return the output value.
N   *
N   * \par Algorithm:
N   * <pre>
N   *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
N   *    A0 = Kp + Ki + Kd
N   *    A1 = (-Kp ) - (2 * Kd )
N   *    A2 = Kd  </pre>
N   *
N   * \par
N   * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative constant
N   *
N   * \par
N   * \image html PID.gif "Proportional Integral Derivative Controller"
N   *
N   * \par
N   * The PID controller calculates an "error" value as the difference between
N   * the measured output and the reference input.
N   * The controller attempts to minimize the error by adjusting the process control inputs.
N   * The proportional value determines the reaction to the current error,
N   * the integral value determines the reaction based on the sum of recent errors,
N   * and the derivative value determines the reaction based on the rate at which the error has been changing.
N   *
N   * \par Instance Structure
N   * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instance data structure.
N   * A separate instance structure must be defined for each PID Controller.
N   * There are separate instance structure declarations for each of the 3 supported data types.
N   *
N   * \par Reset Functions
N   * There is also an associated reset function for each data type which clears the state array.
N   *
N   * \par Initialization Functions
N   * There is also an associated initialization function for each data type.
N   * The initialization function performs the following operations:
N   * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
N   * - Zeros out the values in the state buffer.
N   *
N   * \par
N   * Instance structure cannot be placed into a const data section and it is recommended to use the initialization function.
N   *
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the fixed-point versions of the PID Controller functions.
N   * In particular, the overflow and saturation behavior of the accumulator used in each function must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup PID
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point PID Control.
N   * @param[in,out] S   is an instance of the floating-point PID Control structure
N   * @param[in]     in  input sample to process
N   * @return out processed output sample.
N   */
N  static __INLINE float32_t arm_pid_f32(
X  static __inline float32_t arm_pid_f32(
N  arm_pid_instance_f32 * S,
N  float32_t in)
N  {
N    float32_t out;
N
N    /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
N    out = (S->A0 * in) +
N      (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @brief  Process function for the Q31 PID Control.
N   * @param[in,out] S  points to an instance of the Q31 PID Control structure
N   * @param[in]     in  input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 64-bit accumulator.
N   * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit.
N   * Thus, if the accumulator result overflows it wraps around rather than clip.
N   * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there are four additions.
N   * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format and then saturated to 1.31 format.
N   */
N  static __INLINE q31_t arm_pid_q31(
X  static __inline q31_t arm_pid_q31(
N  arm_pid_instance_q31 * S,
N  q31_t in)
N  {
N    q63_t acc;
N    q31_t out;
N
N    /* acc = A0 * x[n]  */
N    acc = (q63_t) S->A0 * in;
N
N    /* acc += A1 * x[n-1] */
N    acc += (q63_t) S->A1 * S->state[0];
N
N    /* acc += A2 * x[n-2]  */
N    acc += (q63_t) S->A2 * S->state[1];
N
N    /* convert output to 1.31 format to add y[n-1] */
N    out = (q31_t) (acc >> 31u);
N
N    /* out += y[n-1] */
N    out += S->state[2];
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N  }
N
N
N  /**
N   * @brief  Process function for the Q15 PID Control.
N   * @param[in,out] S   points to an instance of the Q15 PID Control structure
N   * @param[in]     in  input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using a 64-bit internal accumulator.
N   * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30 result.
N   * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
N   * There is no risk of internal overflow with this approach and the full precision of intermediate multiplications is preserved.
N   * After all additions have been performed, the accumulator is truncated to 34.15 format by discarding low 15 bits.
N   * Lastly, the accumulator is saturated to yield a result in 1.15 format.
N   */
N  static __INLINE q15_t arm_pid_q15(
X  static __inline q15_t arm_pid_q15(
N  arm_pid_instance_q15 * S,
N  q15_t in)
N  {
N    q63_t acc;
N    q15_t out;
N
N#ifndef ARM_MATH_CM0_FAMILY
N    __SIMD32_TYPE *vstate;
X    int32_t __packed *vstate;
N
N    /* Implementation of PID controller */
N
N    /* acc = A0 * x[n]  */
N    acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
X    acc = (q31_t) __smuad((uint32_t)S->A0, (uint32_t)in);
N
N    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
N    vstate = __SIMD32_CONST(S->state);
X    vstate = ((int32_t __packed *)(S->state));
N    acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
X    acc = (q63_t)__smlald((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
N#else
S    /* acc = A0 * x[n]  */
S    acc = ((q31_t) S->A0) * in;
S
S    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
S    acc += (q31_t) S->A1 * S->state[0];
S    acc += (q31_t) S->A2 * S->state[1];
N#endif
N
N    /* acc += y[n-1] */
N    acc += (q31_t) S->state[2] << 15;
N
N    /* saturate the output */
N    out = (q15_t) (__SSAT((acc >> 15), 16));
X    out = (q15_t) (__ssat((acc >> 15), 16));
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N  }
N
N  /**
N   * @} end of PID group
N   */
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  src   points to the instance of the input floating-point matrix structure.
N   * @param[out] dst   points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N  arm_status arm_mat_inverse_f32(
N  const arm_matrix_instance_f32 * src,
N  arm_matrix_instance_f32 * dst);
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  src   points to the instance of the input floating-point matrix structure.
N   * @param[out] dst   points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N  arm_status arm_mat_inverse_f64(
N  const arm_matrix_instance_f64 * src,
N  arm_matrix_instance_f64 * dst);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup clarke Vector Clarke Transform
N   * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time invariant vector.
N   * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calculate currents
N   * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
N   * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
N   * \image html clarke.gif Stator current space vector and its components in (a,b).
N   * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code>
N   * can be calculated using only <code>Ia</code> and <code>Ib</code>.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeFormula.gif
N   * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
N   * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup clarke
N   * @{
N   */
N
N  /**
N   *
N   * @brief  Floating-point Clarke transform
N   * @param[in]  Ia       input three-phase coordinate <code>a</code>
N   * @param[in]  Ib       input three-phase coordinate <code>b</code>
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   */
N  static __INLINE void arm_clarke_f32(
X  static __inline void arm_clarke_f32(
N  float32_t Ia,
N  float32_t Ib,
N  float32_t * pIalpha,
N  float32_t * pIbeta)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
N    *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
N  }
N
N
N  /**
N   * @brief  Clarke transform for Q31 version
N   * @param[in]  Ia       input three-phase coordinate <code>a</code>
N   * @param[in]  Ib       input three-phase coordinate <code>b</code>
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N  static __INLINE void arm_clarke_q31(
X  static __inline void arm_clarke_q31(
N  q31_t Ia,
N  q31_t Ib,
N  q31_t * pIalpha,
N  q31_t * pIbeta)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIalpha from Ia by equation pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
N
N    /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
N    product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
N
N    /* pIbeta is calculated by adding the intermediate products */
N    *pIbeta = __QADD(product1, product2);
X    *pIbeta = __qadd(product1, product2);
N  }
N
N  /**
N   * @} end of clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q31 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_q7_to_q31(
N  q7_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_clarke Vector Inverse Clarke Transform
N   * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous stator phases.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeInvFormula.gif
N   * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
N   * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_clarke
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Clarke transform
N   * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out] pIa     points to output three-phase coordinate <code>a</code>
N   * @param[out] pIb     points to output three-phase coordinate <code>b</code>
N   */
N  static __INLINE void arm_inv_clarke_f32(
X  static __inline void arm_inv_clarke_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pIa,
N  float32_t * pIb)
N  {
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibeta */
N    *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
N  }
N
N
N  /**
N   * @brief  Inverse Clarke transform for Q31 version
N   * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out] pIa     points to output three-phase coordinate <code>a</code>
N   * @param[out] pIb     points to output three-phase coordinate <code>b</code>
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the subtraction, hence there is no risk of overflow.
N   */
N  static __INLINE void arm_inv_clarke_q31(
X  static __inline void arm_inv_clarke_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pIa,
N  q31_t * pIb)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
N
N    /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
N
N    /* pIb is calculated by subtracting the products */
N    *pIb = __QSUB(product2, product1);
X    *pIb = __qsub(product2, product1);
N  }
N
N  /**
N   * @} end of inv_clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q15 vector.
N   * @param[in]  pSrc       input pointer
N   * @param[out] pDst       output pointer
N   * @param[in]  blockSize  number of samples to process
N   */
N  void arm_q7_to_q15(
N  q7_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup park Vector Park Transform
N   *
N   * Forward Park transform converts the input two-coordinate vector to flux and torque components.
N   * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and the <code>Ibeta</code> currents
N   * from the stationary to the moving reference frame and control the spatial relationship between
N   * the stator vector current and rotor flux vector.
N   * If we consider the d axis aligned with the rotor flux, the diagram below shows the
N   * current vector and the relationship from the two reference frames:
N   * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q rotating reference frame"
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkFormula.gif
N   * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
N   * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup park
N   * @{
N   */
N
N  /**
N   * @brief Floating-point Park transform
N   * @param[in]  Ialpha  input two-phase vector coordinate alpha
N   * @param[in]  Ibeta   input two-phase vector coordinate beta
N   * @param[out] pId     points to output   rotor reference frame d
N   * @param[out] pIq     points to output   rotor reference frame q
N   * @param[in]  sinVal  sine value of rotation angle theta
N   * @param[in]  cosVal  cosine value of rotation angle theta
N   *
N   * The function implements the forward Park transform.
N   *
N   */
N  static __INLINE void arm_park_f32(
X  static __inline void arm_park_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pId,
N  float32_t * pIq,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
N    *pId = Ialpha * cosVal + Ibeta * sinVal;
N
N    /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
N    *pIq = -Ialpha * sinVal + Ibeta * cosVal;
N  }
N
N
N  /**
N   * @brief  Park transform for Q31 version
N   * @param[in]  Ialpha  input two-phase vector coordinate alpha
N   * @param[in]  Ibeta   input two-phase vector coordinate beta
N   * @param[out] pId     points to output rotor reference frame d
N   * @param[out] pIq     points to output rotor reference frame q
N   * @param[in]  sinVal  sine value of rotation angle theta
N   * @param[in]  cosVal  cosine value of rotation angle theta
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition and subtraction, hence there is no risk of overflow.
N   */
N  static __INLINE void arm_park_q31(
X  static __inline void arm_park_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pId,
N  q31_t * pIq,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Ialpha * cosVal) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * sinVal) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Ialpha * sinVal) */
N    product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * cosVal) */
N    product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
N
N    /* Calculate pId by adding the two intermediate products 1 and 2 */
N    *pId = __QADD(product1, product2);
X    *pId = __qadd(product1, product2);
N
N    /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
N    *pIq = __QSUB(product4, product3);
X    *pIq = __qsub(product4, product3);
N  }
N
N  /**
N   * @} end of park group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q7_to_float(
N  q7_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_park Vector Inverse Park transform
N   * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkInvFormula.gif
N   * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
N   * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_park
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Park transform
N   * @param[in]  Id       input coordinate of rotor reference frame d
N   * @param[in]  Iq       input coordinate of rotor reference frame q
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]  sinVal   sine value of rotation angle theta
N   * @param[in]  cosVal   cosine value of rotation angle theta
N   */
N  static __INLINE void arm_inv_park_f32(
X  static __inline void arm_inv_park_f32(
N  float32_t Id,
N  float32_t Iq,
N  float32_t * pIalpha,
N  float32_t * pIbeta,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
N    *pIalpha = Id * cosVal - Iq * sinVal;
N
N    /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
N    *pIbeta = Id * sinVal + Iq * cosVal;
N  }
N
N
N  /**
N   * @brief  Inverse Park transform for   Q31 version
N   * @param[in]  Id       input coordinate of rotor reference frame d
N   * @param[in]  Iq       input coordinate of rotor reference frame q
N   * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]  sinVal   sine value of rotation angle theta
N   * @param[in]  cosVal   cosine value of rotation angle theta
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N  static __INLINE void arm_inv_park_q31(
X  static __inline void arm_inv_park_q31(
N  q31_t Id,
N  q31_t Iq,
N  q31_t * pIalpha,
N  q31_t * pIbeta,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Id * cosVal) */
N    product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * sinVal) */
N    product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Id * sinVal) */
N    product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * cosVal) */
N    product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
N
N    /* Calculate pIalpha by using the two intermediate products 1 and 2 */
N    *pIalpha = __QSUB(product1, product2);
X    *pIalpha = __qsub(product1, product2);
N
N    /* Calculate pIbeta by using the two intermediate products 3 and 4 */
N    *pIbeta = __QADD(product4, product3);
X    *pIbeta = __qadd(product4, product3);
N  }
N
N  /**
N   * @} end of Inverse park group
N   */
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q31_to_float(
N  q31_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup LinearInterpolate Linear Interpolation
N   *
N   * Linear interpolation is a method of curve fitting using linear polynomials.
N   * Linear interpolation works by effectively drawing a straight line between two neighboring samples and returning the appropriate point along that line
N   *
N   * \par
N   * \image html LinearInterp.gif "Linear interpolation"
N   *
N   * \par
N   * A  Linear Interpolate function calculates an output value(y), for the input(x)
N   * using linear interpolation of the input values x0, x1( nearest input values) and the output values y0 and y1(nearest output values)
N   *
N   * \par Algorithm:
N   * <pre>
N   *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
N   *       where x0, x1 are nearest values of input x
N   *             y0, y1 are nearest values to output y
N   * </pre>
N   *
N   * \par
N   * This set of functions implements Linear interpolation process
N   * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
N   * sample of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the Linear Interpolate function data structure.
N   * <code>x</code> is the input sample value. The functions returns the output value.
N   *
N   * \par
N   * if x is outside of the table boundary, Linear interpolation returns first value of the table
N   * if x is below input range and returns last value of table if x is above range.
N   */
N
N  /**
N   * @addtogroup LinearInterpolate
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point Linear Interpolation Function.
N   * @param[in,out] S  is an instance of the floating-point Linear Interpolation structure
N   * @param[in]     x  input sample to process
N   * @return y processed output sample.
N   *
N   */
N  static __INLINE float32_t arm_linear_interp_f32(
X  static __inline float32_t arm_linear_interp_f32(
N  arm_linear_interp_instance_f32 * S,
N  float32_t x)
N  {
N    float32_t y;
N    float32_t x0, x1;                            /* Nearest input values */
N    float32_t y0, y1;                            /* Nearest output values */
N    float32_t xSpacing = S->xSpacing;            /* spacing between input values */
N    int32_t i;                                   /* Index variable */
N    float32_t *pYData = S->pYData;               /* pointer to output table */
N
N    /* Calculation of index */
N    i = (int32_t) ((x - S->x1) / xSpacing);
N
N    if(i < 0)
N    {
N      /* Iniatilize output for below specified range as least output value of table */
N      y = pYData[0];
N    }
N    else if((uint32_t)i >= S->nValues)
N    {
N      /* Iniatilize output for above specified range as last output value of table */
N      y = pYData[S->nValues - 1];
N    }
N    else
N    {
N      /* Calculation of nearest input values */
N      x0 = S->x1 +  i      * xSpacing;
N      x1 = S->x1 + (i + 1) * xSpacing;
N
N      /* Read of nearest output values */
N      y0 = pYData[i];
N      y1 = pYData[i + 1];
N
N      /* Calculation of output */
N      y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
N
N    }
N
N    /* returns output value */
N    return (y);
N  }
N
N
N   /**
N   *
N   * @brief  Process function for the Q31 Linear Interpolation Function.
N   * @param[in] pYData   pointer to Q31 Linear Interpolation table
N   * @param[in] x        input sample to process
N   * @param[in] nValues  number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N  static __INLINE q31_t arm_linear_interp_q31(
X  static __inline q31_t arm_linear_interp_q31(
N  q31_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q31_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & (q31_t)0xFFF00000) >> 20);
N
N    if(index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if(index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* shift left by 11 to keep fract in 1.31 format */
N      fract = (x & 0x000FFFFF) << 11;
N
N      /* Read two nearest output values from the index in 1.31(q31) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1];
N
N      /* Calculation of y0 * (1-fract) and y is in 2.30 format */
N      y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
N
N      /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
N      y += ((q31_t) (((q63_t) y1 * fract) >> 32));
N
N      /* Convert y to 1.31 format */
N      return (y << 1u);
N    }
N  }
N
N
N  /**
N   *
N   * @brief  Process function for the Q15 Linear Interpolation Function.
N   * @param[in] pYData   pointer to Q15 Linear Interpolation table
N   * @param[in] x        input sample to process
N   * @param[in] nValues  number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N  static __INLINE q15_t arm_linear_interp_q15(
X  static __inline q15_t arm_linear_interp_q15(
N  q15_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q63_t y;                                     /* output */
N    q15_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & (int32_t)0xFFF00000) >> 20);
N
N    if(index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if(index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index */
N      y0 = pYData[index];
N      y1 = pYData[index + 1];
N
N      /* Calculation of y0 * (1-fract) and y is in 13.35 format */
N      y = ((q63_t) y0 * (0xFFFFF - fract));
N
N      /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
N      y += ((q63_t) y1 * (fract));
N
N      /* convert y to 1.15 format */
N      return (q15_t) (y >> 20);
N    }
N  }
N
N
N  /**
N   *
N   * @brief  Process function for the Q7 Linear Interpolation Function.
N   * @param[in] pYData   pointer to Q7 Linear Interpolation table
N   * @param[in] x        input sample to process
N   * @param[in] nValues  number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   */
N  static __INLINE q7_t arm_linear_interp_q7(
X  static __inline q7_t arm_linear_interp_q7(
N  q7_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q7_t y0, y1;                                 /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    uint32_t index;                              /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    if (x < 0)
N    {
N      return (pYData[0]);
N    }
N    index = (x >> 20) & 0xfff;
N
N    if(index >= (nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index and are in 1.7(q7) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1];
N
N      /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
N      y = ((y0 * (0xFFFFF - fract)));
N
N      /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
N      y += (y1 * fract);
N
N      /* convert y to 1.7(q7) format */
N      return (q7_t) (y >> 20);
N     }
N  }
N
N  /**
N   * @} end of LinearInterpolate group
N   */
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for floating-point data.
N   * @param[in] x  input value in radians.
N   * @return  sin(x).
N   */
N  float32_t arm_sin_f32(
N  float32_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q31 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  sin(x).
N   */
N  q31_t arm_sin_q31(
N  q31_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q15 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  sin(x).
N   */
N  q15_t arm_sin_q15(
N  q15_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
N   * @param[in] x  input value in radians.
N   * @return  cos(x).
N   */
N  float32_t arm_cos_f32(
N  float32_t x);
N
N
N  /**
N   * @brief Fast approximation to the trigonometric cosine function for Q31 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  cos(x).
N   */
N  q31_t arm_cos_q31(
N  q31_t x);
N
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
N   * @param[in] x  Scaled input value in radians.
N   * @return  cos(x).
N   */
N  q15_t arm_cos_q15(
N  q15_t x);
N
N
N  /**
N   * @ingroup groupFastMath
N   */
N
N
N  /**
N   * @defgroup SQRT Square Root
N   *
N   * Computes the square root of a number.
N   * There are separate functions for Q15, Q31, and floating-point data types.
N   * The square root function is computed using the Newton-Raphson algorithm.
N   * This is an iterative algorithm of the form:
N   * <pre>
N   *      x1 = x0 - f(x0)/f'(x0)
N   * </pre>
N   * where <code>x1</code> is the current estimate,
N   * <code>x0</code> is the previous estimate, and
N   * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
N   * For the square root function, the algorithm reduces to:
N   * <pre>
N   *     x0 = in/2                         [initial guess]
N   *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
N   * </pre>
N   */
N
N
N  /**
N   * @addtogroup SQRT
N   * @{
N   */
N
N  /**
N   * @brief  Floating-point square root function.
N   * @param[in]  in    input value.
N   * @param[out] pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  static __INLINE arm_status arm_sqrt_f32(
X  static __inline arm_status arm_sqrt_f32(
N  float32_t in,
N  float32_t * pOut)
N  {
N    if(in >= 0.0f)
N    {
N
N#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
X#if   (1U == 1) && 1L
N      *pOut = __sqrtf(in);
N#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
S      *pOut = __builtin_sqrtf(in);
S#elif (__FPU_USED == 1) && defined(__GNUC__)
S      *pOut = __builtin_sqrtf(in);
S#elif (__FPU_USED == 1) && defined ( __ICCARM__ ) && (__VER__ >= 6040000)
S      __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
S#else
S      *pOut = sqrtf(in);
N#endif
N
N      return (ARM_MATH_SUCCESS);
N    }
N    else
N    {
N      *pOut = 0.0f;
N      return (ARM_MATH_ARGUMENT_ERROR);
N    }
N  }
N
N
N  /**
N   * @brief Q31 square root function.
N   * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF.
N   * @param[out] pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q31(
N  q31_t in,
N  q31_t * pOut);
N
N
N  /**
N   * @brief  Q15 square root function.
N   * @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
N   * @param[out] pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q15(
N  q15_t in,
N  q15_t * pOut);
N
N  /**
N   * @} end of SQRT group
N   */
N
N
N  /**
N   * @brief floating-point Circular write function.
N   */
N  static __INLINE void arm_circularWrite_f32(
X  static __inline void arm_circularWrite_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const int32_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = (uint16_t)wOffset;
N  }
N
N
N
N  /**
N   * @brief floating-point Circular Read function.
N   */
N  static __INLINE void arm_circularRead_f32(
X  static __inline void arm_circularRead_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  int32_t * dst,
N  int32_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (int32_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value  */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief Q15 Circular write function.
N   */
N  static __INLINE void arm_circularWrite_q15(
X  static __inline void arm_circularWrite_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q15_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = (uint16_t)wOffset;
N  }
N
N
N  /**
N   * @brief Q15 Circular Read function.
N   */
N  static __INLINE void arm_circularRead_q15(
X  static __inline void arm_circularRead_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q15_t * dst,
N  q15_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (q15_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief Q7 Circular write function.
N   */
N  static __INLINE void arm_circularWrite_q7(
X  static __inline void arm_circularWrite_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q7_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = (uint16_t)wOffset;
N  }
N
N
N  /**
N   * @brief Q7 Circular Read function.
N   */
N  static __INLINE void arm_circularRead_q7(
X  static __inline void arm_circularRead_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q7_t * dst,
N  q7_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (q7_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_power_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Mean value of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_mean_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Variance of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_var_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Variance of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_var_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Variance of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_var_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Root Mean Square of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_rms_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_rms_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_rms_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Standard deviation of the elements of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_std_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N
N  /**
N   * @brief  Standard deviation of the elements of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_std_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N
N  /**
N   * @brief  Standard deviation of the elements of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output value.
N   */
N  void arm_std_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N
N  /**
N   * @brief  Floating-point complex magnitude
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex magnitude
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex magnitude
N   * @param[in]  pSrc        points to the complex input vector
N   * @param[out] pDst        points to the real output vector
N   * @param[in]  numSamples  number of complex samples in the input vector
N   */
N  void arm_cmplx_mag_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q15 complex dot product
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   * @param[out] realResult  real part of the result returned here
N   * @param[out] imagResult  imaginary part of the result returned here
N   */
N  void arm_cmplx_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t numSamples,
N  q31_t * realResult,
N  q31_t * imagResult);
N
N
N  /**
N   * @brief  Q31 complex dot product
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   * @param[out] realResult  real part of the result returned here
N   * @param[out] imagResult  imaginary part of the result returned here
N   */
N  void arm_cmplx_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t numSamples,
N  q63_t * realResult,
N  q63_t * imagResult);
N
N
N  /**
N   * @brief  Floating-point complex dot product
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   * @param[out] realResult  real part of the result returned here
N   * @param[out] imagResult  imaginary part of the result returned here
N   */
N  void arm_cmplx_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t numSamples,
N  float32_t * realResult,
N  float32_t * imagResult);
N
N
N  /**
N   * @brief  Q15 complex-by-real multiplication
N   * @param[in]  pSrcCmplx   points to the complex input vector
N   * @param[in]  pSrcReal    points to the real input vector
N   * @param[out] pCmplxDst   points to the complex output vector
N   * @param[in]  numSamples  number of samples in each vector
N   */
N  void arm_cmplx_mult_real_q15(
N  q15_t * pSrcCmplx,
N  q15_t * pSrcReal,
N  q15_t * pCmplxDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex-by-real multiplication
N   * @param[in]  pSrcCmplx   points to the complex input vector
N   * @param[in]  pSrcReal    points to the real input vector
N   * @param[out] pCmplxDst   points to the complex output vector
N   * @param[in]  numSamples  number of samples in each vector
N   */
N  void arm_cmplx_mult_real_q31(
N  q31_t * pSrcCmplx,
N  q31_t * pSrcReal,
N  q31_t * pCmplxDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Floating-point complex-by-real multiplication
N   * @param[in]  pSrcCmplx   points to the complex input vector
N   * @param[in]  pSrcReal    points to the real input vector
N   * @param[out] pCmplxDst   points to the complex output vector
N   * @param[in]  numSamples  number of samples in each vector
N   */
N  void arm_cmplx_mult_real_f32(
N  float32_t * pSrcCmplx,
N  float32_t * pSrcReal,
N  float32_t * pCmplxDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Minimum value of a Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] result     is output pointer
N   * @param[in]  index      is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * result,
N  uint32_t * index);
N
N
N  /**
N   * @brief  Minimum value of a Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output pointer
N   * @param[in]  pIndex     is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N
N  /**
N   * @brief  Minimum value of a Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output pointer
N   * @param[out] pIndex     is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N
N  /**
N   * @brief  Minimum value of a floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[in]  blockSize  is the number of samples to process
N   * @param[out] pResult    is output pointer
N   * @param[out] pIndex     is the array index of the minimum value in the input buffer.
N   */
N  void arm_min_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a Q7 vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a Q15 vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a Q31 vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N
N/**
N * @brief Maximum value of a floating-point vector.
N * @param[in]  pSrc       points to the input buffer
N * @param[in]  blockSize  length of the input vector
N * @param[out] pResult    maximum value returned here
N * @param[out] pIndex     index of maximum value returned here
N */
N  void arm_max_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N
N  /**
N   * @brief  Q15 complex-by-complex multiplication
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_mult_cmplx_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Q31 complex-by-complex multiplication
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_mult_cmplx_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief  Floating-point complex-by-complex multiplication
N   * @param[in]  pSrcA       points to the first input vector
N   * @param[in]  pSrcB       points to the second input vector
N   * @param[out] pDst        points to the output vector
N   * @param[in]  numSamples  number of complex samples in each vector
N   */
N  void arm_cmplx_mult_cmplx_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q31 vector.
N   * @param[in]  pSrc       points to the floating-point input vector
N   * @param[out] pDst       points to the Q31 output vector
N   * @param[in]  blockSize  length of the input vector
N   */
N  void arm_float_to_q31(
N  float32_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q15 vector.
N   * @param[in]  pSrc       points to the floating-point input vector
N   * @param[out] pDst       points to the Q15 output vector
N   * @param[in]  blockSize  length of the input vector
N   */
N  void arm_float_to_q15(
N  float32_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q7 vector.
N   * @param[in]  pSrc       points to the floating-point input vector
N   * @param[out] pDst       points to the Q7 output vector
N   * @param[in]  blockSize  length of the input vector
N   */
N  void arm_float_to_q7(
N  float32_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q15 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q31_to_q15(
N  q31_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q31_to_q7(
N  q31_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to floating-point vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q15_to_float(
N  q15_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q31 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q15_to_q31(
N  q15_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q7 vector.
N   * @param[in]  pSrc       is input pointer
N   * @param[out] pDst       is output pointer
N   * @param[in]  blockSize  is the number of samples to process
N   */
N  void arm_q15_to_q7(
N  q15_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup BilinearInterpolate Bilinear Interpolation
N   *
N   * Bilinear interpolation is an extension of linear interpolation applied to a two dimensional grid.
N   * The underlying function <code>f(x, y)</code> is sampled on a regular grid and the interpolation process
N   * determines values between the grid points.
N   * Bilinear interpolation is equivalent to two step linear interpolation, first in the x-dimension and then in the y-dimension.
N   * Bilinear interpolation is often used in image processing to rescale images.
N   * The CMSIS DSP library provides bilinear interpolation functions for Q7, Q15, Q31, and floating-point data types.
N   *
N   * <b>Algorithm</b>
N   * \par
N   * The instance structure used by the bilinear interpolation functions describes a two dimensional data table.
N   * For floating-point, the instance structure is defined as:
N   * <pre>
N   *   typedef struct
N   *   {
N   *     uint16_t numRows;
N   *     uint16_t numCols;
N   *     float32_t *pData;
N   * } arm_bilinear_interp_instance_f32;
N   * </pre>
N   *
N   * \par
N   * where <code>numRows</code> specifies the number of rows in the table;
N   * <code>numCols</code> specifies the number of columns in the table;
N   * and <code>pData</code> points to an array of size <code>numRows*numCols</code> values.
N   * The data table <code>pTable</code> is organized in row order and the supplied data values fall on integer indexes.
N   * That is, table element (x,y) is located at <code>pTable[x + y*numCols]</code> where x and y are integers.
N   *
N   * \par
N   * Let <code>(x, y)</code> specify the desired interpolation point.  Then define:
N   * <pre>
N   *     XF = floor(x)
N   *     YF = floor(y)
N   * </pre>
N   * \par
N   * The interpolated output point is computed as:
N   * <pre>
N   *  f(x, y) = f(XF, YF) * (1-(x-XF)) * (1-(y-YF))
N   *           + f(XF+1, YF) * (x-XF)*(1-(y-YF))
N   *           + f(XF, YF+1) * (1-(x-XF))*(y-YF)
N   *           + f(XF+1, YF+1) * (x-XF)*(y-YF)
N   * </pre>
N   * Note that the coordinates (x, y) contain integer and fractional components.
N   * The integer components specify which portion of the table to use while the
N   * fractional components control the interpolation processor.
N   *
N   * \par
N   * if (x,y) are outside of the table boundary, Bilinear interpolation returns zero output.
N   */
N
N  /**
N   * @addtogroup BilinearInterpolate
N   * @{
N   */
N
N
N  /**
N  *
N  * @brief  Floating-point bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate.
N  * @param[in]     Y  interpolation coordinate.
N  * @return out interpolated value.
N  */
N  static __INLINE float32_t arm_bilinear_interp_f32(
X  static __inline float32_t arm_bilinear_interp_f32(
N  const arm_bilinear_interp_instance_f32 * S,
N  float32_t X,
N  float32_t Y)
N  {
N    float32_t out;
N    float32_t f00, f01, f10, f11;
N    float32_t *pData = S->pData;
N    int32_t xIndex, yIndex, index;
N    float32_t xdiff, ydiff;
N    float32_t b1, b2, b3, b4;
N
N    xIndex = (int32_t) X;
N    yIndex = (int32_t) Y;
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(xIndex < 0 || xIndex > (S->numRows - 1) || yIndex < 0 || yIndex > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* Calculation of index for two nearest points in X-direction */
N    index = (xIndex - 1) + (yIndex - 1) * S->numCols;
N
N
N    /* Read two nearest points in X-direction */
N    f00 = pData[index];
N    f01 = pData[index + 1];
N
N    /* Calculation of index for two nearest points in Y-direction */
N    index = (xIndex - 1) + (yIndex) * S->numCols;
N
N
N    /* Read two nearest points in Y-direction */
N    f10 = pData[index];
N    f11 = pData[index + 1];
N
N    /* Calculation of intermediate values */
N    b1 = f00;
N    b2 = f01 - f00;
N    b3 = f10 - f00;
N    b4 = f00 - f01 - f10 + f11;
N
N    /* Calculation of fractional part in X */
N    xdiff = X - xIndex;
N
N    /* Calculation of fractional part in Y */
N    ydiff = Y - yIndex;
N
N    /* Calculation of bi-linear interpolated output */
N    out = b1 + b2 * xdiff + b3 * ydiff + b4 * xdiff * ydiff;
N
N    /* return to application */
N    return (out);
N  }
N
N
N  /**
N  *
N  * @brief  Q31 bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate in 12.20 format.
N  * @param[in]     Y  interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N  static __INLINE q31_t arm_bilinear_interp_q31(
X  static __inline q31_t arm_bilinear_interp_q31(
N  arm_bilinear_interp_instance_q31 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q31_t out;                                   /* Temporary output */
N    q31_t acc = 0;                               /* output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q31_t x1, x2, y1, y2;                        /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q31_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & (q31_t)0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & (q31_t)0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* shift left xfract by 11 to keep 1.31 format */
N    xfract = (X & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + (int32_t)nCols * (cI)    ];
N    x2 = pYData[(rI) + (int32_t)nCols * (cI) + 1];
N
N    /* 20 bits for the fractional part */
N    /* shift left yfract by 11 to keep 1.31 format */
N    yfract = (Y & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + (int32_t)nCols * (cI + 1)    ];
N    y2 = pYData[(rI) + (int32_t)nCols * (cI + 1) + 1];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 3.29(q29) format */
N    out = ((q31_t) (((q63_t) x1  * (0x7FFFFFFF - xfract)) >> 32));
N    acc = ((q31_t) (((q63_t) out * (0x7FFFFFFF - yfract)) >> 32));
N
N    /* x2 * (xfract) * (1-yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) x2 * (0x7FFFFFFF - yfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (xfract) >> 32));
N
N    /* y1 * (1 - xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y1 * (0x7FFFFFFF - xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* y2 * (xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y2 * (xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* Convert acc to 1.31(q31) format */
N    return ((q31_t)(acc << 2));
N  }
N
N
N  /**
N  * @brief  Q15 bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate in 12.20 format.
N  * @param[in]     Y  interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N  static __INLINE q15_t arm_bilinear_interp_q15(
X  static __inline q15_t arm_bilinear_interp_q15(
N  arm_bilinear_interp_instance_q15 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q15_t x1, x2, y1, y2;                        /* Nearest output values */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    int32_t rI, cI;                              /* Row and column indices */
N    q15_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & (q31_t)0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & (q31_t)0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI)    ];
N    x2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI) + 1];
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1)    ];
N    y2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1) + 1];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 13.51 format */
N
N    /* x1 is in 1.15(q15), xfract in 12.20 format and out is in 13.35 format */
N    /* convert 13.35 to 13.31 by right shifting  and out is in 1.31 */
N    out = (q31_t) (((q63_t) x1 * (0xFFFFF - xfract)) >> 4u);
N    acc = ((q63_t) out * (0xFFFFF - yfract));
N
N    /* x2 * (xfract) * (1-yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) x2 * (0xFFFFF - yfract)) >> 4u);
N    acc += ((q63_t) out * (xfract));
N
N    /* y1 * (1 - xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y1 * (0xFFFFF - xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* y2 * (xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y2 * (xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* acc is in 13.51 format and down shift acc by 36 times */
N    /* Convert out to 1.15 format */
N    return ((q15_t)(acc >> 36));
N  }
N
N
N  /**
N  * @brief  Q7 bilinear interpolation.
N  * @param[in,out] S  points to an instance of the interpolation structure.
N  * @param[in]     X  interpolation coordinate in 12.20 format.
N  * @param[in]     Y  interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N  static __INLINE q7_t arm_bilinear_interp_q7(
X  static __inline q7_t arm_bilinear_interp_q7(
N  arm_bilinear_interp_instance_q7 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q7_t x1, x2, y1, y2;                         /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q7_t *pYData = S->pData;                     /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & (q31_t)0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & (q31_t)0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & (q31_t)0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI)    ];
N    x2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI) + 1];
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & (q31_t)0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1)    ];
N    y2 = pYData[((uint32_t)rI) + nCols * ((uint32_t)cI + 1) + 1];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 16.47 format */
N    out = ((x1 * (0xFFFFF - xfract)));
N    acc = (((q63_t) out * (0xFFFFF - yfract)));
N
N    /* x2 * (xfract) * (1-yfract)  in 2.22 and adding to acc */
N    out = ((x2 * (0xFFFFF - yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* y1 * (1 - xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y1 * (0xFFFFF - xfract)));
N    acc += (((q63_t) out * (yfract)));
N
N    /* y2 * (xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y2 * (yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* acc in 16.47 format and down shift by 40 to convert to 1.7 format */
N    return ((q7_t)(acc >> 40));
N  }
N
N  /**
N   * @} end of BilinearInterpolate group
N   */
N
N
N/* SMMLAR */
N#define multAcc_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multAcc_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N/* SMMLSR */
N#define multSub_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multSub_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N/* SMMULR */
N#define mult_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
X#define mult_32x32_keep32_R(a, x, y)     a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
N
N/* SMMLA */
N#define multAcc_32x32_keep32(a, x, y) \
N    a += (q31_t) (((q63_t) x * y) >> 32)
X#define multAcc_32x32_keep32(a, x, y)     a += (q31_t) (((q63_t) x * y) >> 32)
N
N/* SMMLS */
N#define multSub_32x32_keep32(a, x, y) \
N    a -= (q31_t) (((q63_t) x * y) >> 32)
X#define multSub_32x32_keep32(a, x, y)     a -= (q31_t) (((q63_t) x * y) >> 32)
N
N/* SMMUL */
N#define mult_32x32_keep32(a, x, y) \
N    a = (q31_t) (((q63_t) x * y ) >> 32)
X#define mult_32x32_keep32(a, x, y)     a = (q31_t) (((q63_t) x * y ) >> 32)
N
N
N#if defined ( __CC_ARM )
X#if 1L
N  /* Enter low optimization region - place directly above function definition */
N  #if defined( ARM_MATH_CM4 ) || defined( ARM_MATH_CM7)
X  #if 1L || 0L
N    #define LOW_OPTIMIZATION_ENTER \
N       _Pragma ("push")         \
N       _Pragma ("O1")
X    #define LOW_OPTIMIZATION_ENTER        _Pragma ("push")                _Pragma ("O1")
N  #else
S    #define LOW_OPTIMIZATION_ENTER
N  #endif
N
N  /* Exit low optimization region - place directly after end of function definition */
N  #if defined( ARM_MATH_CM4 ) || defined( ARM_MATH_CM7)
X  #if 1L || 0L
N    #define LOW_OPTIMIZATION_EXIT \
N       _Pragma ("pop")
X    #define LOW_OPTIMIZATION_EXIT        _Pragma ("pop")
N  #else
S    #define LOW_OPTIMIZATION_EXIT
N  #endif
N
N  /* Enter low optimization region - place directly above function definition */
N  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
N
N  /* Exit low optimization region - place directly after end of function definition */
N  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__GNUC__)
S  #define LOW_OPTIMIZATION_ENTER __attribute__(( optimize("-O1") ))
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__ICCARM__)
S  /* Enter low optimization region - place directly above function definition */
S  #if defined( ARM_MATH_CM4 ) || defined( ARM_MATH_CM7)
S    #define LOW_OPTIMIZATION_ENTER \
S       _Pragma ("optimize=low")
X    #define LOW_OPTIMIZATION_ENTER        _Pragma ("optimize=low")
S  #else
S    #define LOW_OPTIMIZATION_ENTER
S  #endif
S
S  /* Exit low optimization region - place directly after end of function definition */
S  #define LOW_OPTIMIZATION_EXIT
S
S  /* Enter low optimization region - place directly above function definition */
S  #if defined( ARM_MATH_CM4 ) || defined( ARM_MATH_CM7)
S    #define IAR_ONLY_LOW_OPTIMIZATION_ENTER \
S       _Pragma ("optimize=low")
X    #define IAR_ONLY_LOW_OPTIMIZATION_ENTER        _Pragma ("optimize=low")
S  #else
S    #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #endif
S
S  /* Exit low optimization region - place directly after end of function definition */
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__CSMC__)
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__TASKING__)
S  #define LOW_OPTIMIZATION_ENTER
S  #define LOW_OPTIMIZATION_EXIT
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
N#endif
N
N
N#ifdef   __cplusplus
S}
N#endif
N
N
N#if defined ( __GNUC__ )
X#if 0L
S#pragma GCC diagnostic pop
N#endif
N
N#endif /* _ARM_MATH_H */
N
N/**
N *
N * End of file.
N */
L 28 "SRC\main.c" 2
N
N
N#include "Sprites_16BPP_565.h"
L 1 ".\SRC\eGFX\Sprites\Sprites_16BPP_565.h" 1
N#include "stdint.h" 
N#include "eGFX.h" 
L 1 ".\SRC\eGFX\eGFX.h" 1
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include <stdlib.h>
N
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
S#define eGFX_DATA_TYPES_H
S
S
Stypedef int16_t FIXED_7_8;
Stypedef int16_t FIXED_9_6;
S
Stypedef int16_t FIXED_0_15;
Stypedef int16_t FIXED_1_14;
S
S
S#define eGFX_IMAGE_PLANE_1BPP		 0
S#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
S#define eGFX_IMAGE_PLANE_4BPP		    2
S#define eGFX_IMAGE_PLANE_8BPP		   3
S#define eGFX_IMAGE_PLANE_16BPP_565    4
S#define eGFX_IMAGE_PLANE_24BPP        5
S#define eGFX_IMAGE_PLANE_32BPP        6
S
S
S
Stypedef struct
S{
S    uint8_t Type;
S    uint8_t *Data;
S    uint16_t SizeX;
S    uint16_t SizeY;
S
S} eGFX_ImagePlane;
S
Stypedef struct
S{
S    int16_t X;
S    int16_t Y;
S} eGFX_Point;
S
Stypedef struct
S{
S    float X; 	
S    float Y;  
S} eGFX_PointF;
S
Stypedef struct
S{
S    eGFX_Point P1;
S    eGFX_Point P2;
S} eGFX_Box;
S
Stypedef struct
S{
S    eGFX_Point Center;
S    uint8_t NumPoints;
S    uint8_t DrawMode;
S    const eGFX_Point *PointList;
S
S} eGFX_ListPrimitive;
S
S
S
S#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
S#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
S#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
S#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
S
Stypedef struct
S{
S    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
S  
S	//Some TT Metrics
S	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
S	
S	uint8_t  SpacesPerTab;
S    uint8_t  InterCharacterSpacing;
S   
S	uint8_t  Padding[2];
S
S} eGFX_Font;
S
S
S#define eGFX_PIXEL_ON     0xFFFFFFFF
S#define eGFX_PIXEL_OFF    0
S
Stypedef uint32_t eGFX_PixelState;
S
S/***
S*       ____  _     _           _
S*      / __ \| |   (_)         | |
S*     | |  | | |__  _  ___  ___| |_ ___
S*     | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | |_) | |  __/ (__| |_\__ \
S*      \____/|_.__/| |\___|\___|\__|___/
X
S*                 _/ |
S*                |__/
S*/
S
Stypedef struct 
S{
S	uint32_t Type;
S	uint32_t State;
S	
S}	eGFX_ObjectHeader;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S}	eGFX_AnimatorHeader;
S
S#define eGFX_OBJECT_STATE_ACTIVE							        	1
S#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
S#define eGFX_OBJECT_STATE_INACTIVE										0
S
S/***
S*                     _                 _                ____  _     _           _
S*         /\         (_)               | |              / __ \| |   (_)         | |
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
S*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
S*                                                                  _/ |
S*                                                                 |__/
S*/
S
S
S
S#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
S#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
S
S#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
S#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_PointF_BisectAnimator;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S	float IncrementX;
S	float IncrementY;
S
S} eGFX_PointF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float Increment; //Increment we should make each step
S
S} eGFX_ScalarF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_ScalarF_BisectAnimator;
S
S/***
S*       _____                 _     _         ____  _     _           _
S*      / ____|               | |   (_)       / __ \| |   (_)         | |
S*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
S*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
S*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
S*                      | |                              _/ |
S*                      |_|                             |__/
S*/
S
S#define eGFX_OBJECT_TEXTF												0x0000
S#define eGFX_OBJECT_SHADED_TEXTF										0x0001
S#define eGFX_OBJECT_LINEF												0x0002
S#define eGFX_OBJECT_SPRITEF												0x0003
S#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
S#define eGFX_OBJECT_BOXF												0x0005
S#define eGFX_OBJECT_CIRCLEF												0x0006
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	
S} eGFX_Obj_TextF;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	float Shading;
S
S} eGFX_Obj_ShadedTextF;
S
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Start;
S	eGFX_PointF End;
S	eGFX_PixelState PixelState; 
S} eGFX_Obj_LineF;
S
S#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	float Radius;
S	eGFX_PixelState PixelState; 
S	uint8_t RenderOption;
S} eGFX_Obj_CircleF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S	
S} eGFX_Obj_SpriteF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S
S	float Scale;
S
S} eGFX_Obj_ScaledSpriteF;
S
S
S#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S
S	eGFX_PointF P1;
S	eGFX_PointF P2;
S
S	eGFX_PixelState PixelState;
S
S	uint8_t BoxF_RenderOption;
S
S} eGFX_Obj_BoxF;
S
S
N#endif
L 10 ".\SRC\eGFX\eGFX.h" 2
N
N
N#ifndef _eGFX_H__
S#define _eGFX_H__
S
S#define eGFX_MAX_ANIMATORS										  32
S#define eGFX_MAX_OBJECTS										  64
S
S#define eGFX_SPACES_PER_TAB                                        4
S#define eGFX_MAX_STRING_LEN                                        64
S#define eGFX_MAX_PRINTF_BUF_LENGTH                                 64
S
S#define eGFX_API_LEVEL											   1
S#define eGFX_REVISION											   2
S
S
S#define eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+7)>>3) //We add 8 to round up to the next even byte boundary
S#define eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+1)>>1) //We add 1 to round up to the next even byte boundary
S#define eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)			 (x)
S#define eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)		 (x*2)
S#define eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*3)
S#define	eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*4)
S
S#define eGFX_CALCULATE_1BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_3BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (((x * y * 3))/8) //This is a special type  for sharp 8 color memory LCDs.   Packing is done in the data buffer so the dump to the screen is simple
S#define eGFX_CALCULATE_4BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_8BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_16BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_24BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_32BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S
S#define ROUND_TO_INT16_T(x)	((int16_t)(x + 0.5f))
S
Sextern const FIXED_1_14 eGFX_Fixed_1_14_SineTable [256];
Sextern const FIXED_7_8 eGFX_Fixed_7_8_SineTable[256];
S
S#define eGFX_GET_INT_FROM_FIXED_7_8(A)				(int16_t)(A>>8)
S#define eGFX_INT_TO_FIXED_7_8(A)					((FIXED_7_8)(A)<<8)
S#define eGFX_GET_FRAC_FROM_FIXED_7_8(A)				(FIXED_7_8)(A&0xFF)
S
S#define eGFX_GET_INT_FROM_FIXED_9_6_(A)				(int16_t)(A>>6)
S#define eGFX_INT_TO_FIXED_9_6(A)					((FIXED_9_6)(A)<<6)
S#define eGFX_GET_FRAC_FROM_FIXED_6_9(A)				(FIXED_9_6)(A&0x3F)
S
SFIXED_7_8 eGFX_GET_INT_FROM_FIXED_7_8_ROUND_TO_NEAREST(FIXED_7_8 A);
SFIXED_7_8 eGFX_FLOAT_TO_FIXED_7_8(float A);
Sint16_t eGFX_FMul_15_0to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_7_8to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_15_0to7_8(int16_t A,int16_t B);
Sint16_t eGFX_FMul_15_0to1_14(int16_t A,int16_t B);
Sint16_t eGFX_ABS(int16_t A);
S
S
S#define eGFX_RGB888_TO_RGB565(R,G,B)	 ( ((R>>2)<<11) | ((G>>2)<<5) | (B>>3))
S
S
S#ifndef TRUE
S	#define TRUE 1
S#endif
S
S#ifndef FALSE
S	#define FALSE 0
S#endif
S
S
S/***
S *      _____ _          _    ____                       _   _
S *     |  __ (_)        | |  / __ \                     | | (_)
S *     | |__) |__  _____| | | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ \ \/ / _ \ | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |>  <  __/ | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_/_/\_\___|_|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                 | |
S *                                 |_|
S */
Svoid eGFX_PutPixel(const eGFX_ImagePlane *Image,
S                   int16_t x,
S                   int16_t y,
S                   eGFX_PixelState PS);
S
SeGFX_PixelState eGFX_GetPixel(const eGFX_ImagePlane *Image,
S                         int16_t x,
S                         int16_t y);
S
S
S
S
S/***
S *      _____      _           _ _   _              ____                       _   _
S *     |  __ \    (_)         (_) | (_)            / __ \                     | | (_)
S *     | |__) | __ _ _ __ ___  _| |_ ___   _____  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ '__| | '_ ` _ \| | __| \ \ / / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |  | | | | | | | | |_| |\ V /  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                                       | |
S *                                                       |_|
S */
S
S 
Svoid eGFX_DrawHline(eGFX_ImagePlane *Image,
S                    int16_t XStart,
S                    int16_t XStop,
S                    int16_t Y,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledBox(eGFX_ImagePlane *Image,
S                        eGFX_Box *Box,
S                        eGFX_PixelState PS);
S
Svoid eGFX_DrawBox(eGFX_ImagePlane *Image,
S                  eGFX_Box *Box,
S                  eGFX_PixelState PS);
S
Svoid eGFX_DrawVline(eGFX_ImagePlane *Image,
S                    int16_t YStart,
S                    int16_t YStop,
S                    int16_t X,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawLine(eGFX_ImagePlane *Image,
S                   int16_t X1,
S                   int16_t Y1,
S                   int16_t X2,
S                   int16_t Y2,
S                   eGFX_PixelState PS);
S
Svoid eGFX_DrawListPrimitive(eGFX_ImagePlane *Image,
S                            eGFX_ListPrimitive *LP ,
S                            eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledListPrimitive(eGFX_ImagePlane *Image,
S                                  eGFX_ListPrimitive *LP ,
S                                  FIXED_7_8 Scale,
S                                  eGFX_PixelState PS);
S
Svoid eGFX_DrawRotatedListPrimitive(eGFX_ImagePlane *Image,
S                                   eGFX_ListPrimitive *LP ,
S                                   uint8_t Angle,
S                                   eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledRotatedListPrimitive(eGFX_ImagePlane *Image,
S        eGFX_ListPrimitive *LP ,
S        uint8_t Angle,
S        FIXED_7_8 Scale,
S        eGFX_PixelState PS);
S
Svoid eGFX_DrawCircle(eGFX_ImagePlane *RC,
S                     int16_t x0,
S                     int16_t y0,
S                     int16_t radius,
S                     eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledCircle(eGFX_ImagePlane *RC,
S	int16_t x0,
S	int16_t y0,
S	int16_t radius,
S	eGFX_PixelState PS);
S
S
S
S/***
S *       _____ _        _                ____                       _   _
S *      / ____| |      (_)              / __ \                     | | (_)
S *     | (___ | |_ _ __ _ _ __   __ _  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *      \___ \| __| '__| | '_ \ / _` | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *      ____) | |_| |  | | | | | (_| | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_____/ \__|_|  |_|_| |_|\__, |  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                               __/ |        | |
S *                              |___/         |_|
S */
S
Sint16_t eGFX_ScaledDrawCharacter(eGFX_ImagePlane *Image,
S                                 int16_t StartX,
S                                 int16_t StartY,
S                                 uint8_t Character,
S                                 const eGFX_Font *MyFont,
S                                 float ScaleFactor);
S
Sint16_t eGFX_DrawCharacter(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawCharacterFaded(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont,
S                           eGFX_PixelState PS);
S
Sint16_t eGFX_DrawCharacterShaded(eGFX_ImagePlane *Image,
S									int16_t StartX,
S									int16_t StartY,
S									uint8_t Character,
S									const eGFX_Font *MyFont,
S									float Shading);
S
S
Sint16_t eGFX_GetStringWidth(char *String,
S                            const eGFX_Font *MyFont);
S
Sint16_t eGFX_GetStringWidth_CustomSpacing(char *String,
S											const eGFX_Font *MyFont,
S											uint16_t Spacing);
S
S
Svoid eGFX_DrawHorizontalCenteredString(eGFX_ImagePlane *Image,
S                                       int16_t StartY,
S                                       char *String,
S                                       const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawRightAlignedCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t CustomCharacterSpacing,
S        int16_t RightSideBuffer);
S
Svoid eGFX_DrawHorizontalCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t Spacing);
S
Svoid eGFX_ScaledDrawString(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           char *String,
S                           const eGFX_Font *MyFont,
S                           float ScaleFactor);
S
Sint16_t  eGFX_DrawStringFaded(eGFX_ImagePlane *Image,
S						 char *String,
S                         int16_t StartX,
S                         int16_t StartY,
S                         const eGFX_Font *MyFont,
S						eGFX_PixelState PS
S                         );
S
S
Sint16_t  eGFX_DrawStringShaded(eGFX_ImagePlane *Image,
S								char *String,
S								int16_t StartX,
S								int16_t StartY,
S								const eGFX_Font *MyFont,
S								float Shading
S								);
S
Svoid eGFX_ScaledDrawString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartX,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        float ScaleFactor ,
S        uint16_t Spacing);
S
Sint16_t  eGFX_DrawString(eGFX_ImagePlane *Image,
S						char * String,
S                         int16_t StartX,
S                         int16_t StartY,
S
S                         const eGFX_Font *MyFont
S                         );
S
Sint16_t  eGFX_printf(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S                     
S                     char *FormatString,...);
S
Sint16_t eGFX_DrawString_CustomSpacing(eGFX_ImagePlane *Image,
S                                      int16_t StartX,
S                                      int16_t StartY,
S                                      char *String,
S                                      const eGFX_Font *MyFont,uint16_t Spacing);
S                                      
Sint16_t  eGFX_printf_Colored(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S											uint32_t Color,
S                     char *FormatString,...);
S
Sint16_t  eGFX_printf_HorizontalCentered_Colored(eGFX_ImagePlane *Image,
S                                         int16_t StartY,
S                                        const eGFX_Font *MyFont,
S                                        uint32_t Color,
S                                        char *FormatString,...);
S/***
S*      _____  _                     ____                       _   _
S*     |  __ \| |                   / __ \                     | | (_)
S*     | |__) | | __ _ _ __   ___  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S*     |  ___/| |/ _` | '_ \ / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S*     | |    | | (_| | | | |  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S*     |_|    |_|\__,_|_| |_|\___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S*                                        | |
S*                                        |_|
S*/
S
Svoid eGFX_Blit(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_CenteredBlit(eGFX_ImagePlane *Destination,
S			int16_t x,
S			int16_t y,
S			const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_BlitFaded(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite,
S               eGFX_PixelState PS);
S
Svoid eGFX_BlitShaded(eGFX_ImagePlane *Destination,
S					int16_t x,
S					int16_t y,
S					const eGFX_ImagePlane *Sprite,
S					float Shading);
S                    
Svoid eGFX_BlitColored(eGFX_ImagePlane *Destination,
S                    int16_t x,
S                    int16_t y,
S                    const eGFX_ImagePlane *Sprite,
S                    uint32_t Color);
S
Svoid eGFX_ScaledBlit(eGFX_ImagePlane *Destination,
S                     int16_t x,
S                     int16_t y,
S                     const eGFX_ImagePlane *Sprite,
S                     float ScaleFactor);
S
Suint8_t eGFX_GetBitFromArray(uint8_t *DataArray,uint16_t Bit);
S
S
Suint8_t eGFX_ImagePlane_GetByte(eGFX_ImagePlane   *Image,
S                                uint16_t X,
S                                uint16_t Y);
S
S
Svoid eGFX_ImagePlaneInit(eGFX_ImagePlane   *Image, uint8_t * Store, int16_t SizeX, int16_t SizeY, uint8_t Type);
S
Svoid eGFX_ImagePlane_Clear(eGFX_ImagePlane   *Image);
S
S
S
S/***
S*                     _                 _                        _____ _____
S*         /\         (_)               | |                 /\   |  __ \_   _|
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __     /  \  | |__) || |
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__|   / /\ \ |  ___/ | |
S*      / ____ \| | | | | | | | | | (_| | || (_) | |     / ____ \| |    _| |_
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|    /_/    \_\_|   |_____|
S*
S*
S*/
S
S//Call this in the main loop.   Animators will be stepped at the rate that this is called!
Svoid eGFX_ProcessAnimators(void);
S
S//Adds an animator object to the list.  returns TRUE if successful.
Suint32_t eGFX_AddAnimator(void * Animator);
S
S//Clears all animators from the list
Svoid eGFX_ClearAnimators(void);
S
S//Gets the number of animator objects in the list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Returns True if the animator is complete
Suint32_t eGFX_AnimatorIsComplete(void * A);
S
S//returns TRUE if all of the animators are complete
Suint32_t eGFX_AnimatorsAreComplete(void);
S
S//Pauses all the animators (sets the state to inactive)
Svoid eGFX_PauseAnimators(void);
S
S//Starts all the Animators in the list.  (Sets the State to Active)
Svoid eGFX_StartAnimators(void);
S
S//Resets and Animator to step 0 and starts it again.
Svoid eGFX_ResetAnimator(void * A);
S
S//Resets and restarts all animators
Svoid eGFX_ResetAnimators(void);
S
S/***
S*      ___     _     _   ___   ___ _            _
S*     | _ \___(_)_ _| |_| __| | _ |_)___ ___ __| |_
S*     |  _/ _ \ | ' \  _| _|  | _ \ (_-</ -_) _|  _|
S*     |_| \___/_|_||_\__|_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes  a point bisect animator.  It does not add it to the list
S//returns true if successful, false if not
Suint32_t eGFX_InitPointF_BisectAnimator(  eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect		//The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S);
S
S//Initializes and adds a point bisect animator to the list.
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_BisectAnimator(   eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect //The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S										);
S
Svoid eGFX_ProcessPointF_BisectAnimator(eGFX_PointF_BisectAnimator *P);
S
S
S/***
S*      ___          _          ___   ___ _            _
S*     / __| __ __ _| |__ _ _ _| __| | _ |_)___ ___ __| |_
S*     \__ \/ _/ _` | / _` | '_| _|  | _ \ (_-</ -_) _|  _|
S*     |___/\__\__,_|_\__,_|_| |_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
Suint32_t eGFX_AddScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
S
Svoid eGFX_ProcessScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P);
S
S
S
S
S/***
S*      ___          _            _    _
S*     / __| __ __ _| |__ _ _ _  | |  (_)_ _  ___ __ _ _ _
S*     \__ \/ _/ _` | / _` | '_| | |__| | ' \/ -_) _` | '_|
S*     |___/\__\__,_|_\__,_|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S										
Svoid eGFX_ProcessScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P);
S
S
S/***
S*      ___     _     _   ___   _    _
S*     | _ \___(_)_ _| |_| __| | |  (_)_ _  ___ __ _ _ _
S*     |  _/ _ \ | ' \  _| _|  | |__| | ' \/ -_) _` | '_|
S*     |_| \___/_|_||_\__|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
Svoid eGFX_ProcessPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P);
S
S
S
S
S
S										
S/***
S *       ____  ____       _ ______ _____ _______            _____ _____ 
S *      / __ \|  _ \     | |  ____/ ____|__   __|     /\   |  __ \_   _|
S *     | |  | | |_) |    | | |__ | |       | |       /  \  | |__) || |  
S *     | |  | |  _ < _   | |  __|| |       | |      / /\ \ |  ___/ | |  
S *     | |__| | |_) | |__| | |___| |____   | |     / ____ \| |    _| |_ 
S *      \____/|____/ \____/|______\_____|  |_|    /_/    \_\_|   |_____|
S *                                                                      
S *                                                                      
S */
S		
S//Call this when you are ready to draw all the objects on the list
Svoid eGFX_DrawObjects(eGFX_ImagePlane * Image);
S
S//Adds a eGFX object to the list
Suint32_t eGFX_AddObject(void * Object);
S
S//Clears all objects from the list
Svoid eGFX_ClearObjects(void);
S
S//Gets the number of objects in the object list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Disables rendering/processing of the object
Svoid eGFX_DisableObject(void * Object);
S
S//enable rendering/processing of the object
Svoid eGFX_EnableObject(void * Object);
S
S/***
S*      _____        _   ___
S*     |_   _|____ _| |_| __|
S*       | |/ -_) \ /  _| _|
S*       |_|\___/_\_\\__|_|
S*
S*/
S
S//Draws a TextF object onto an image Plane
Svoid eGFX_DrawObject_TextF(eGFX_ImagePlane * Image, eGFX_Obj_TextF *TextF_Object);
S
S//Initializes a TextF object
Svoid eGFX_InitObjectTextF(eGFX_Obj_TextF * TF,
S							eGFX_PointF Position,
S							eGFX_Font *Font,
S							char * String
S							);	
S
S//Initializes a TextF object and also adds it to the current draw list
Svoid eGFX_AddObjectTextF(eGFX_Obj_TextF * TF,
S						eGFX_PointF Position,
S						eGFX_Font *Font,
S						char * String
S						);
S
S/***
S*      ___ _            _        _   _____        _   ___
S*     / __| |_  __ _ __| |___ __| | |_   _|____ _| |_| __|
S*     \__ \ ' \/ _` / _` / -_) _` |   | |/ -_) \ /  _| _|
S*     |___/_||_\__,_\__,_\___\__,_|   |_|\___/_\_\\__|_|
S*
S*/
S
Svoid eGFX_InitObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
S
Svoid eGFX_AddObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
Svoid	eGFX_DrawObject_ShadedTextF(eGFX_ImagePlane * Image, eGFX_Obj_ShadedTextF *ShadedTextF_Object);
S
S						
S/***
S*      _    _          ___
S*     | |  (_)_ _  ___| __|
S*     | |__| | ' \/ -_) _|
S*     |____|_|_||_\___|_|
S*
S*/
S
S//Initializes a LineF object
Svoid eGFX_InitObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Initializes a LineF object and also adds it to the current draw list
Svoid eGFX_AddObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Draws a LineF object onto an image Plane
Svoid	eGFX_DrawObject_LineF(eGFX_ImagePlane * Image, eGFX_Obj_LineF *LineF_Object);
S
S/***
S*      ___          _ _       ___
S*     / __|_ __ _ _(_) |_ ___| __|
S*     \__ \ '_ \ '_| |  _/ -_) _|
S*     |___/ .__/_| |_|\__\___|_|
S*         |_|
S*/
S
S//Initializes a SpriteF object
Svoid eGFX_InitObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//Initializes a SpriteF object and adds it to the object list
Svoid eGFX_AddObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//draws a spritef onto an image plane
Svoid	eGFX_DrawObject_SpriteF(eGFX_ImagePlane * Image, eGFX_Obj_SpriteF *SpriteF_Object);
S
S/***
S*      ___          _ _       ___   ___          _        _
S*     / __|_ __ _ _(_) |_ ___| __| / __| __ __ _| |___ __| |
S*     \__ \ '_ \ '_| |  _/ -_) _|  \__ \/ _/ _` | / -_) _` |
S*     |___/ .__/_| |_|\__\___|_|   |___/\__\__,_|_\___\__,_|
S*         |_|
S*/
S
S//Initializes a scaled sprited object
Svoid eGFX_InitObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S
S//Initializes a scaled sprited object and adds it to the object list
Svoid eGFX_AddObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S//draws a scaled spritef onto an image plane
Svoid	eGFX_DrawObject_ScaledSpriteF(eGFX_ImagePlane * Image, eGFX_Obj_ScaledSpriteF *SpriteF_Object);
S
S
S/***
S*       ___          ___
S*      | _ ) _____ _| __|
S*      | _ \/ _ \ \ / _|
S*      |___/\___/_\_\_|
S*
S*/
S
S
Svoid eGFX_InitObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid	eGFX_DrawObject_BoxF(eGFX_ImagePlane * Image, eGFX_Obj_BoxF *BoxF_Object);
S
S
S/***
S*       ___ _        _     ___
S*      / __(_)_ _ __| |___| __|
S*     | (__| | '_/ _| / -_) _|
S*      \___|_|_| \__|_\___|_|
S*
S*/
S
S
Svoid eGFX_InitObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
Svoid	eGFX_DrawObject_CircleF(eGFX_ImagePlane * Image, eGFX_Obj_CircleF *CircleF_Object);
S
S
N#endif
N
N
N#ifdef __cplusplus
S }
N#endif
N
L 3 ".\SRC\eGFX\Sprites\Sprites_16BPP_565.h" 2
N
N#ifndef _SPRITES_16BPP_565_H
N#define _SPRITES_16BPP_565_H
N
N////***************************************************************************
N////                         Sprite_16BPP_565_equalizer
N////***************************************************************************
N
N
N__attribute__ ((section ("ExtFlashSection"))) extern const eGFX_ImagePlane 	Sprite_16BPP_565_equalizer;
N
N////***************************************************************************
N////                         Sprite_16BPP_565_home_icon
N////***************************************************************************
N
N
N__attribute__ ((section ("ExtFlashSection"))) extern const eGFX_ImagePlane 	Sprite_16BPP_565_home_icon;
N
N////***************************************************************************
N////                         Sprite_16BPP_565_Mushroom_Super_icon_red
N////***************************************************************************
N
N
N__attribute__ ((section ("ExtFlashSection"))) extern const eGFX_ImagePlane 	Sprite_16BPP_565_Mushroom_Super_icon_red;
N
N////***************************************************************************
N////                         Sprite_16BPP_565_piramid_silver
N////***************************************************************************
N
N
N__attribute__ ((section ("ExtFlashSection"))) extern const eGFX_ImagePlane 	Sprite_16BPP_565_piramid_silver;
N
N////***************************************************************************
N////                         Sprite_16BPP_565_whirl_silver
N////***************************************************************************
N
N
N__attribute__ ((section ("ExtFlashSection"))) extern const eGFX_ImagePlane 	Sprite_16BPP_565_whirl_silver;
N
N#endif
N
L 31 "SRC\main.c" 2
N
N#include "OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP.h"
L 1 ".\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP.h" 1
N#include "eGFX.h" 
L 1 ".\SRC\eGFX\eGFX.h" 1
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include <stdlib.h>
N
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
S#define eGFX_DATA_TYPES_H
S
S
Stypedef int16_t FIXED_7_8;
Stypedef int16_t FIXED_9_6;
S
Stypedef int16_t FIXED_0_15;
Stypedef int16_t FIXED_1_14;
S
S
S#define eGFX_IMAGE_PLANE_1BPP		 0
S#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
S#define eGFX_IMAGE_PLANE_4BPP		    2
S#define eGFX_IMAGE_PLANE_8BPP		   3
S#define eGFX_IMAGE_PLANE_16BPP_565    4
S#define eGFX_IMAGE_PLANE_24BPP        5
S#define eGFX_IMAGE_PLANE_32BPP        6
S
S
S
Stypedef struct
S{
S    uint8_t Type;
S    uint8_t *Data;
S    uint16_t SizeX;
S    uint16_t SizeY;
S
S} eGFX_ImagePlane;
S
Stypedef struct
S{
S    int16_t X;
S    int16_t Y;
S} eGFX_Point;
S
Stypedef struct
S{
S    float X; 	
S    float Y;  
S} eGFX_PointF;
S
Stypedef struct
S{
S    eGFX_Point P1;
S    eGFX_Point P2;
S} eGFX_Box;
S
Stypedef struct
S{
S    eGFX_Point Center;
S    uint8_t NumPoints;
S    uint8_t DrawMode;
S    const eGFX_Point *PointList;
S
S} eGFX_ListPrimitive;
S
S
S
S#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
S#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
S#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
S#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
S
Stypedef struct
S{
S    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
S  
S	//Some TT Metrics
S	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
S	
S	uint8_t  SpacesPerTab;
S    uint8_t  InterCharacterSpacing;
S   
S	uint8_t  Padding[2];
S
S} eGFX_Font;
S
S
S#define eGFX_PIXEL_ON     0xFFFFFFFF
S#define eGFX_PIXEL_OFF    0
S
Stypedef uint32_t eGFX_PixelState;
S
S/***
S*       ____  _     _           _
S*      / __ \| |   (_)         | |
S*     | |  | | |__  _  ___  ___| |_ ___
S*     | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | |_) | |  __/ (__| |_\__ \
S*      \____/|_.__/| |\___|\___|\__|___/
X
S*                 _/ |
S*                |__/
S*/
S
Stypedef struct 
S{
S	uint32_t Type;
S	uint32_t State;
S	
S}	eGFX_ObjectHeader;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S}	eGFX_AnimatorHeader;
S
S#define eGFX_OBJECT_STATE_ACTIVE							        	1
S#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
S#define eGFX_OBJECT_STATE_INACTIVE										0
S
S/***
S*                     _                 _                ____  _     _           _
S*         /\         (_)               | |              / __ \| |   (_)         | |
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
S*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
S*                                                                  _/ |
S*                                                                 |__/
S*/
S
S
S
S#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
S#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
S
S#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
S#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_PointF_BisectAnimator;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S	float IncrementX;
S	float IncrementY;
S
S} eGFX_PointF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float Increment; //Increment we should make each step
S
S} eGFX_ScalarF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_ScalarF_BisectAnimator;
S
S/***
S*       _____                 _     _         ____  _     _           _
S*      / ____|               | |   (_)       / __ \| |   (_)         | |
S*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
S*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
S*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
S*                      | |                              _/ |
S*                      |_|                             |__/
S*/
S
S#define eGFX_OBJECT_TEXTF												0x0000
S#define eGFX_OBJECT_SHADED_TEXTF										0x0001
S#define eGFX_OBJECT_LINEF												0x0002
S#define eGFX_OBJECT_SPRITEF												0x0003
S#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
S#define eGFX_OBJECT_BOXF												0x0005
S#define eGFX_OBJECT_CIRCLEF												0x0006
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	
S} eGFX_Obj_TextF;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	float Shading;
S
S} eGFX_Obj_ShadedTextF;
S
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Start;
S	eGFX_PointF End;
S	eGFX_PixelState PixelState; 
S} eGFX_Obj_LineF;
S
S#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	float Radius;
S	eGFX_PixelState PixelState; 
S	uint8_t RenderOption;
S} eGFX_Obj_CircleF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S	
S} eGFX_Obj_SpriteF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S
S	float Scale;
S
S} eGFX_Obj_ScaledSpriteF;
S
S
S#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S
S	eGFX_PointF P1;
S	eGFX_PointF P2;
S
S	eGFX_PixelState PixelState;
S
S	uint8_t BoxF_RenderOption;
S
S} eGFX_Obj_BoxF;
S
S
N#endif
L 10 ".\SRC\eGFX\eGFX.h" 2
N
N
N#ifndef _eGFX_H__
S#define _eGFX_H__
S
S#define eGFX_MAX_ANIMATORS										  32
S#define eGFX_MAX_OBJECTS										  64
S
S#define eGFX_SPACES_PER_TAB                                        4
S#define eGFX_MAX_STRING_LEN                                        64
S#define eGFX_MAX_PRINTF_BUF_LENGTH                                 64
S
S#define eGFX_API_LEVEL											   1
S#define eGFX_REVISION											   2
S
S
S#define eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+7)>>3) //We add 8 to round up to the next even byte boundary
S#define eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+1)>>1) //We add 1 to round up to the next even byte boundary
S#define eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)			 (x)
S#define eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)		 (x*2)
S#define eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*3)
S#define	eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*4)
S
S#define eGFX_CALCULATE_1BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_3BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (((x * y * 3))/8) //This is a special type  for sharp 8 color memory LCDs.   Packing is done in the data buffer so the dump to the screen is simple
S#define eGFX_CALCULATE_4BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_8BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_16BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_24BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_32BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S
S#define ROUND_TO_INT16_T(x)	((int16_t)(x + 0.5f))
S
Sextern const FIXED_1_14 eGFX_Fixed_1_14_SineTable [256];
Sextern const FIXED_7_8 eGFX_Fixed_7_8_SineTable[256];
S
S#define eGFX_GET_INT_FROM_FIXED_7_8(A)				(int16_t)(A>>8)
S#define eGFX_INT_TO_FIXED_7_8(A)					((FIXED_7_8)(A)<<8)
S#define eGFX_GET_FRAC_FROM_FIXED_7_8(A)				(FIXED_7_8)(A&0xFF)
S
S#define eGFX_GET_INT_FROM_FIXED_9_6_(A)				(int16_t)(A>>6)
S#define eGFX_INT_TO_FIXED_9_6(A)					((FIXED_9_6)(A)<<6)
S#define eGFX_GET_FRAC_FROM_FIXED_6_9(A)				(FIXED_9_6)(A&0x3F)
S
SFIXED_7_8 eGFX_GET_INT_FROM_FIXED_7_8_ROUND_TO_NEAREST(FIXED_7_8 A);
SFIXED_7_8 eGFX_FLOAT_TO_FIXED_7_8(float A);
Sint16_t eGFX_FMul_15_0to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_7_8to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_15_0to7_8(int16_t A,int16_t B);
Sint16_t eGFX_FMul_15_0to1_14(int16_t A,int16_t B);
Sint16_t eGFX_ABS(int16_t A);
S
S
S#define eGFX_RGB888_TO_RGB565(R,G,B)	 ( ((R>>2)<<11) | ((G>>2)<<5) | (B>>3))
S
S
S#ifndef TRUE
S	#define TRUE 1
S#endif
S
S#ifndef FALSE
S	#define FALSE 0
S#endif
S
S
S/***
S *      _____ _          _    ____                       _   _
S *     |  __ (_)        | |  / __ \                     | | (_)
S *     | |__) |__  _____| | | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ \ \/ / _ \ | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |>  <  __/ | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_/_/\_\___|_|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                 | |
S *                                 |_|
S */
Svoid eGFX_PutPixel(const eGFX_ImagePlane *Image,
S                   int16_t x,
S                   int16_t y,
S                   eGFX_PixelState PS);
S
SeGFX_PixelState eGFX_GetPixel(const eGFX_ImagePlane *Image,
S                         int16_t x,
S                         int16_t y);
S
S
S
S
S/***
S *      _____      _           _ _   _              ____                       _   _
S *     |  __ \    (_)         (_) | (_)            / __ \                     | | (_)
S *     | |__) | __ _ _ __ ___  _| |_ ___   _____  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ '__| | '_ ` _ \| | __| \ \ / / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |  | | | | | | | | |_| |\ V /  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                                       | |
S *                                                       |_|
S */
S
S 
Svoid eGFX_DrawHline(eGFX_ImagePlane *Image,
S                    int16_t XStart,
S                    int16_t XStop,
S                    int16_t Y,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledBox(eGFX_ImagePlane *Image,
S                        eGFX_Box *Box,
S                        eGFX_PixelState PS);
S
Svoid eGFX_DrawBox(eGFX_ImagePlane *Image,
S                  eGFX_Box *Box,
S                  eGFX_PixelState PS);
S
Svoid eGFX_DrawVline(eGFX_ImagePlane *Image,
S                    int16_t YStart,
S                    int16_t YStop,
S                    int16_t X,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawLine(eGFX_ImagePlane *Image,
S                   int16_t X1,
S                   int16_t Y1,
S                   int16_t X2,
S                   int16_t Y2,
S                   eGFX_PixelState PS);
S
Svoid eGFX_DrawListPrimitive(eGFX_ImagePlane *Image,
S                            eGFX_ListPrimitive *LP ,
S                            eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledListPrimitive(eGFX_ImagePlane *Image,
S                                  eGFX_ListPrimitive *LP ,
S                                  FIXED_7_8 Scale,
S                                  eGFX_PixelState PS);
S
Svoid eGFX_DrawRotatedListPrimitive(eGFX_ImagePlane *Image,
S                                   eGFX_ListPrimitive *LP ,
S                                   uint8_t Angle,
S                                   eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledRotatedListPrimitive(eGFX_ImagePlane *Image,
S        eGFX_ListPrimitive *LP ,
S        uint8_t Angle,
S        FIXED_7_8 Scale,
S        eGFX_PixelState PS);
S
Svoid eGFX_DrawCircle(eGFX_ImagePlane *RC,
S                     int16_t x0,
S                     int16_t y0,
S                     int16_t radius,
S                     eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledCircle(eGFX_ImagePlane *RC,
S	int16_t x0,
S	int16_t y0,
S	int16_t radius,
S	eGFX_PixelState PS);
S
S
S
S/***
S *       _____ _        _                ____                       _   _
S *      / ____| |      (_)              / __ \                     | | (_)
S *     | (___ | |_ _ __ _ _ __   __ _  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *      \___ \| __| '__| | '_ \ / _` | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *      ____) | |_| |  | | | | | (_| | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_____/ \__|_|  |_|_| |_|\__, |  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                               __/ |        | |
S *                              |___/         |_|
S */
S
Sint16_t eGFX_ScaledDrawCharacter(eGFX_ImagePlane *Image,
S                                 int16_t StartX,
S                                 int16_t StartY,
S                                 uint8_t Character,
S                                 const eGFX_Font *MyFont,
S                                 float ScaleFactor);
S
Sint16_t eGFX_DrawCharacter(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawCharacterFaded(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont,
S                           eGFX_PixelState PS);
S
Sint16_t eGFX_DrawCharacterShaded(eGFX_ImagePlane *Image,
S									int16_t StartX,
S									int16_t StartY,
S									uint8_t Character,
S									const eGFX_Font *MyFont,
S									float Shading);
S
S
Sint16_t eGFX_GetStringWidth(char *String,
S                            const eGFX_Font *MyFont);
S
Sint16_t eGFX_GetStringWidth_CustomSpacing(char *String,
S											const eGFX_Font *MyFont,
S											uint16_t Spacing);
S
S
Svoid eGFX_DrawHorizontalCenteredString(eGFX_ImagePlane *Image,
S                                       int16_t StartY,
S                                       char *String,
S                                       const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawRightAlignedCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t CustomCharacterSpacing,
S        int16_t RightSideBuffer);
S
Svoid eGFX_DrawHorizontalCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t Spacing);
S
Svoid eGFX_ScaledDrawString(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           char *String,
S                           const eGFX_Font *MyFont,
S                           float ScaleFactor);
S
Sint16_t  eGFX_DrawStringFaded(eGFX_ImagePlane *Image,
S						 char *String,
S                         int16_t StartX,
S                         int16_t StartY,
S                         const eGFX_Font *MyFont,
S						eGFX_PixelState PS
S                         );
S
S
Sint16_t  eGFX_DrawStringShaded(eGFX_ImagePlane *Image,
S								char *String,
S								int16_t StartX,
S								int16_t StartY,
S								const eGFX_Font *MyFont,
S								float Shading
S								);
S
Svoid eGFX_ScaledDrawString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartX,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        float ScaleFactor ,
S        uint16_t Spacing);
S
Sint16_t  eGFX_DrawString(eGFX_ImagePlane *Image,
S						char * String,
S                         int16_t StartX,
S                         int16_t StartY,
S
S                         const eGFX_Font *MyFont
S                         );
S
Sint16_t  eGFX_printf(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S                     
S                     char *FormatString,...);
S
Sint16_t eGFX_DrawString_CustomSpacing(eGFX_ImagePlane *Image,
S                                      int16_t StartX,
S                                      int16_t StartY,
S                                      char *String,
S                                      const eGFX_Font *MyFont,uint16_t Spacing);
S                                      
Sint16_t  eGFX_printf_Colored(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S											uint32_t Color,
S                     char *FormatString,...);
S
Sint16_t  eGFX_printf_HorizontalCentered_Colored(eGFX_ImagePlane *Image,
S                                         int16_t StartY,
S                                        const eGFX_Font *MyFont,
S                                        uint32_t Color,
S                                        char *FormatString,...);
S/***
S*      _____  _                     ____                       _   _
S*     |  __ \| |                   / __ \                     | | (_)
S*     | |__) | | __ _ _ __   ___  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S*     |  ___/| |/ _` | '_ \ / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S*     | |    | | (_| | | | |  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S*     |_|    |_|\__,_|_| |_|\___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S*                                        | |
S*                                        |_|
S*/
S
Svoid eGFX_Blit(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_CenteredBlit(eGFX_ImagePlane *Destination,
S			int16_t x,
S			int16_t y,
S			const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_BlitFaded(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite,
S               eGFX_PixelState PS);
S
Svoid eGFX_BlitShaded(eGFX_ImagePlane *Destination,
S					int16_t x,
S					int16_t y,
S					const eGFX_ImagePlane *Sprite,
S					float Shading);
S                    
Svoid eGFX_BlitColored(eGFX_ImagePlane *Destination,
S                    int16_t x,
S                    int16_t y,
S                    const eGFX_ImagePlane *Sprite,
S                    uint32_t Color);
S
Svoid eGFX_ScaledBlit(eGFX_ImagePlane *Destination,
S                     int16_t x,
S                     int16_t y,
S                     const eGFX_ImagePlane *Sprite,
S                     float ScaleFactor);
S
Suint8_t eGFX_GetBitFromArray(uint8_t *DataArray,uint16_t Bit);
S
S
Suint8_t eGFX_ImagePlane_GetByte(eGFX_ImagePlane   *Image,
S                                uint16_t X,
S                                uint16_t Y);
S
S
Svoid eGFX_ImagePlaneInit(eGFX_ImagePlane   *Image, uint8_t * Store, int16_t SizeX, int16_t SizeY, uint8_t Type);
S
Svoid eGFX_ImagePlane_Clear(eGFX_ImagePlane   *Image);
S
S
S
S/***
S*                     _                 _                        _____ _____
S*         /\         (_)               | |                 /\   |  __ \_   _|
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __     /  \  | |__) || |
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__|   / /\ \ |  ___/ | |
S*      / ____ \| | | | | | | | | | (_| | || (_) | |     / ____ \| |    _| |_
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|    /_/    \_\_|   |_____|
S*
S*
S*/
S
S//Call this in the main loop.   Animators will be stepped at the rate that this is called!
Svoid eGFX_ProcessAnimators(void);
S
S//Adds an animator object to the list.  returns TRUE if successful.
Suint32_t eGFX_AddAnimator(void * Animator);
S
S//Clears all animators from the list
Svoid eGFX_ClearAnimators(void);
S
S//Gets the number of animator objects in the list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Returns True if the animator is complete
Suint32_t eGFX_AnimatorIsComplete(void * A);
S
S//returns TRUE if all of the animators are complete
Suint32_t eGFX_AnimatorsAreComplete(void);
S
S//Pauses all the animators (sets the state to inactive)
Svoid eGFX_PauseAnimators(void);
S
S//Starts all the Animators in the list.  (Sets the State to Active)
Svoid eGFX_StartAnimators(void);
S
S//Resets and Animator to step 0 and starts it again.
Svoid eGFX_ResetAnimator(void * A);
S
S//Resets and restarts all animators
Svoid eGFX_ResetAnimators(void);
S
S/***
S*      ___     _     _   ___   ___ _            _
S*     | _ \___(_)_ _| |_| __| | _ |_)___ ___ __| |_
S*     |  _/ _ \ | ' \  _| _|  | _ \ (_-</ -_) _|  _|
S*     |_| \___/_|_||_\__|_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes  a point bisect animator.  It does not add it to the list
S//returns true if successful, false if not
Suint32_t eGFX_InitPointF_BisectAnimator(  eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect		//The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S);
S
S//Initializes and adds a point bisect animator to the list.
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_BisectAnimator(   eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect //The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S										);
S
Svoid eGFX_ProcessPointF_BisectAnimator(eGFX_PointF_BisectAnimator *P);
S
S
S/***
S*      ___          _          ___   ___ _            _
S*     / __| __ __ _| |__ _ _ _| __| | _ |_)___ ___ __| |_
S*     \__ \/ _/ _` | / _` | '_| _|  | _ \ (_-</ -_) _|  _|
S*     |___/\__\__,_|_\__,_|_| |_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
Suint32_t eGFX_AddScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
S
Svoid eGFX_ProcessScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P);
S
S
S
S
S/***
S*      ___          _            _    _
S*     / __| __ __ _| |__ _ _ _  | |  (_)_ _  ___ __ _ _ _
S*     \__ \/ _/ _` | / _` | '_| | |__| | ' \/ -_) _` | '_|
S*     |___/\__\__,_|_\__,_|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S										
Svoid eGFX_ProcessScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P);
S
S
S/***
S*      ___     _     _   ___   _    _
S*     | _ \___(_)_ _| |_| __| | |  (_)_ _  ___ __ _ _ _
S*     |  _/ _ \ | ' \  _| _|  | |__| | ' \/ -_) _` | '_|
S*     |_| \___/_|_||_\__|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
Svoid eGFX_ProcessPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P);
S
S
S
S
S
S										
S/***
S *       ____  ____       _ ______ _____ _______            _____ _____ 
S *      / __ \|  _ \     | |  ____/ ____|__   __|     /\   |  __ \_   _|
S *     | |  | | |_) |    | | |__ | |       | |       /  \  | |__) || |  
S *     | |  | |  _ < _   | |  __|| |       | |      / /\ \ |  ___/ | |  
S *     | |__| | |_) | |__| | |___| |____   | |     / ____ \| |    _| |_ 
S *      \____/|____/ \____/|______\_____|  |_|    /_/    \_\_|   |_____|
S *                                                                      
S *                                                                      
S */
S		
S//Call this when you are ready to draw all the objects on the list
Svoid eGFX_DrawObjects(eGFX_ImagePlane * Image);
S
S//Adds a eGFX object to the list
Suint32_t eGFX_AddObject(void * Object);
S
S//Clears all objects from the list
Svoid eGFX_ClearObjects(void);
S
S//Gets the number of objects in the object list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Disables rendering/processing of the object
Svoid eGFX_DisableObject(void * Object);
S
S//enable rendering/processing of the object
Svoid eGFX_EnableObject(void * Object);
S
S/***
S*      _____        _   ___
S*     |_   _|____ _| |_| __|
S*       | |/ -_) \ /  _| _|
S*       |_|\___/_\_\\__|_|
S*
S*/
S
S//Draws a TextF object onto an image Plane
Svoid eGFX_DrawObject_TextF(eGFX_ImagePlane * Image, eGFX_Obj_TextF *TextF_Object);
S
S//Initializes a TextF object
Svoid eGFX_InitObjectTextF(eGFX_Obj_TextF * TF,
S							eGFX_PointF Position,
S							eGFX_Font *Font,
S							char * String
S							);	
S
S//Initializes a TextF object and also adds it to the current draw list
Svoid eGFX_AddObjectTextF(eGFX_Obj_TextF * TF,
S						eGFX_PointF Position,
S						eGFX_Font *Font,
S						char * String
S						);
S
S/***
S*      ___ _            _        _   _____        _   ___
S*     / __| |_  __ _ __| |___ __| | |_   _|____ _| |_| __|
S*     \__ \ ' \/ _` / _` / -_) _` |   | |/ -_) \ /  _| _|
S*     |___/_||_\__,_\__,_\___\__,_|   |_|\___/_\_\\__|_|
S*
S*/
S
Svoid eGFX_InitObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
S
Svoid eGFX_AddObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
Svoid	eGFX_DrawObject_ShadedTextF(eGFX_ImagePlane * Image, eGFX_Obj_ShadedTextF *ShadedTextF_Object);
S
S						
S/***
S*      _    _          ___
S*     | |  (_)_ _  ___| __|
S*     | |__| | ' \/ -_) _|
S*     |____|_|_||_\___|_|
S*
S*/
S
S//Initializes a LineF object
Svoid eGFX_InitObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Initializes a LineF object and also adds it to the current draw list
Svoid eGFX_AddObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Draws a LineF object onto an image Plane
Svoid	eGFX_DrawObject_LineF(eGFX_ImagePlane * Image, eGFX_Obj_LineF *LineF_Object);
S
S/***
S*      ___          _ _       ___
S*     / __|_ __ _ _(_) |_ ___| __|
S*     \__ \ '_ \ '_| |  _/ -_) _|
S*     |___/ .__/_| |_|\__\___|_|
S*         |_|
S*/
S
S//Initializes a SpriteF object
Svoid eGFX_InitObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//Initializes a SpriteF object and adds it to the object list
Svoid eGFX_AddObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//draws a spritef onto an image plane
Svoid	eGFX_DrawObject_SpriteF(eGFX_ImagePlane * Image, eGFX_Obj_SpriteF *SpriteF_Object);
S
S/***
S*      ___          _ _       ___   ___          _        _
S*     / __|_ __ _ _(_) |_ ___| __| / __| __ __ _| |___ __| |
S*     \__ \ '_ \ '_| |  _/ -_) _|  \__ \/ _/ _` | / -_) _` |
S*     |___/ .__/_| |_|\__\___|_|   |___/\__\__,_|_\___\__,_|
S*         |_|
S*/
S
S//Initializes a scaled sprited object
Svoid eGFX_InitObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S
S//Initializes a scaled sprited object and adds it to the object list
Svoid eGFX_AddObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S//draws a scaled spritef onto an image plane
Svoid	eGFX_DrawObject_ScaledSpriteF(eGFX_ImagePlane * Image, eGFX_Obj_ScaledSpriteF *SpriteF_Object);
S
S
S/***
S*       ___          ___
S*      | _ ) _____ _| __|
S*      | _ \/ _ \ \ / _|
S*      |___/\___/_\_\_|
S*
S*/
S
S
Svoid eGFX_InitObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid	eGFX_DrawObject_BoxF(eGFX_ImagePlane * Image, eGFX_Obj_BoxF *BoxF_Object);
S
S
S/***
S*       ___ _        _     ___
S*      / __(_)_ _ __| |___| __|
S*     | (__| | '_/ _| / -_) _|
S*      \___|_|_| \__|_\___|_|
S*
S*/
S
S
Svoid eGFX_InitObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
Svoid	eGFX_DrawObject_CircleF(eGFX_ImagePlane * Image, eGFX_Obj_CircleF *CircleF_Object);
S
S
N#endif
N
N
N#ifdef __cplusplus
S }
N#endif
N
L 2 ".\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP.h" 2
N
N#ifndef _OCR_A_EXTENDED__20PX__BOLD__SINGLEBITPERPIXELGRIDFIT_1BPP_H
N#define _OCR_A_EXTENDED__20PX__BOLD__SINGLEBITPERPIXELGRIDFIT_1BPP_H
N
Nextern const eGFX_Font OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP;
N
N#endif
N
L 33 "SRC\main.c" 2
N#include "Consolas__26px__Regular__AntiAliasGridFit_1BPP.h"
L 1 ".\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP\Consolas__26px__Regular__AntiAliasGridFit_1BPP.h" 1
N#include "eGFX.h" 
L 1 ".\SRC\eGFX\eGFX.h" 1
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include <stdlib.h>
N
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
S#define eGFX_DATA_TYPES_H
S
S
Stypedef int16_t FIXED_7_8;
Stypedef int16_t FIXED_9_6;
S
Stypedef int16_t FIXED_0_15;
Stypedef int16_t FIXED_1_14;
S
S
S#define eGFX_IMAGE_PLANE_1BPP		 0
S#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
S#define eGFX_IMAGE_PLANE_4BPP		    2
S#define eGFX_IMAGE_PLANE_8BPP		   3
S#define eGFX_IMAGE_PLANE_16BPP_565    4
S#define eGFX_IMAGE_PLANE_24BPP        5
S#define eGFX_IMAGE_PLANE_32BPP        6
S
S
S
Stypedef struct
S{
S    uint8_t Type;
S    uint8_t *Data;
S    uint16_t SizeX;
S    uint16_t SizeY;
S
S} eGFX_ImagePlane;
S
Stypedef struct
S{
S    int16_t X;
S    int16_t Y;
S} eGFX_Point;
S
Stypedef struct
S{
S    float X; 	
S    float Y;  
S} eGFX_PointF;
S
Stypedef struct
S{
S    eGFX_Point P1;
S    eGFX_Point P2;
S} eGFX_Box;
S
Stypedef struct
S{
S    eGFX_Point Center;
S    uint8_t NumPoints;
S    uint8_t DrawMode;
S    const eGFX_Point *PointList;
S
S} eGFX_ListPrimitive;
S
S
S
S#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
S#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
S#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
S#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
S
Stypedef struct
S{
S    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
S  
S	//Some TT Metrics
S	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
S	
S	uint8_t  SpacesPerTab;
S    uint8_t  InterCharacterSpacing;
S   
S	uint8_t  Padding[2];
S
S} eGFX_Font;
S
S
S#define eGFX_PIXEL_ON     0xFFFFFFFF
S#define eGFX_PIXEL_OFF    0
S
Stypedef uint32_t eGFX_PixelState;
S
S/***
S*       ____  _     _           _
S*      / __ \| |   (_)         | |
S*     | |  | | |__  _  ___  ___| |_ ___
S*     | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | |_) | |  __/ (__| |_\__ \
S*      \____/|_.__/| |\___|\___|\__|___/
X
S*                 _/ |
S*                |__/
S*/
S
Stypedef struct 
S{
S	uint32_t Type;
S	uint32_t State;
S	
S}	eGFX_ObjectHeader;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S}	eGFX_AnimatorHeader;
S
S#define eGFX_OBJECT_STATE_ACTIVE							        	1
S#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
S#define eGFX_OBJECT_STATE_INACTIVE										0
S
S/***
S*                     _                 _                ____  _     _           _
S*         /\         (_)               | |              / __ \| |   (_)         | |
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
S*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
S*                                                                  _/ |
S*                                                                 |__/
S*/
S
S
S
S#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
S#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
S
S#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
S#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_PointF_BisectAnimator;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S	float IncrementX;
S	float IncrementY;
S
S} eGFX_PointF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float Increment; //Increment we should make each step
S
S} eGFX_ScalarF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_ScalarF_BisectAnimator;
S
S/***
S*       _____                 _     _         ____  _     _           _
S*      / ____|               | |   (_)       / __ \| |   (_)         | |
S*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
S*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
S*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
S*                      | |                              _/ |
S*                      |_|                             |__/
S*/
S
S#define eGFX_OBJECT_TEXTF												0x0000
S#define eGFX_OBJECT_SHADED_TEXTF										0x0001
S#define eGFX_OBJECT_LINEF												0x0002
S#define eGFX_OBJECT_SPRITEF												0x0003
S#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
S#define eGFX_OBJECT_BOXF												0x0005
S#define eGFX_OBJECT_CIRCLEF												0x0006
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	
S} eGFX_Obj_TextF;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	float Shading;
S
S} eGFX_Obj_ShadedTextF;
S
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Start;
S	eGFX_PointF End;
S	eGFX_PixelState PixelState; 
S} eGFX_Obj_LineF;
S
S#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	float Radius;
S	eGFX_PixelState PixelState; 
S	uint8_t RenderOption;
S} eGFX_Obj_CircleF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S	
S} eGFX_Obj_SpriteF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S
S	float Scale;
S
S} eGFX_Obj_ScaledSpriteF;
S
S
S#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S
S	eGFX_PointF P1;
S	eGFX_PointF P2;
S
S	eGFX_PixelState PixelState;
S
S	uint8_t BoxF_RenderOption;
S
S} eGFX_Obj_BoxF;
S
S
N#endif
L 10 ".\SRC\eGFX\eGFX.h" 2
N
N
N#ifndef _eGFX_H__
S#define _eGFX_H__
S
S#define eGFX_MAX_ANIMATORS										  32
S#define eGFX_MAX_OBJECTS										  64
S
S#define eGFX_SPACES_PER_TAB                                        4
S#define eGFX_MAX_STRING_LEN                                        64
S#define eGFX_MAX_PRINTF_BUF_LENGTH                                 64
S
S#define eGFX_API_LEVEL											   1
S#define eGFX_REVISION											   2
S
S
S#define eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+7)>>3) //We add 8 to round up to the next even byte boundary
S#define eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+1)>>1) //We add 1 to round up to the next even byte boundary
S#define eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)			 (x)
S#define eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)		 (x*2)
S#define eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*3)
S#define	eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*4)
S
S#define eGFX_CALCULATE_1BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_3BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (((x * y * 3))/8) //This is a special type  for sharp 8 color memory LCDs.   Packing is done in the data buffer so the dump to the screen is simple
S#define eGFX_CALCULATE_4BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_8BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_16BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_24BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_32BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S
S#define ROUND_TO_INT16_T(x)	((int16_t)(x + 0.5f))
S
Sextern const FIXED_1_14 eGFX_Fixed_1_14_SineTable [256];
Sextern const FIXED_7_8 eGFX_Fixed_7_8_SineTable[256];
S
S#define eGFX_GET_INT_FROM_FIXED_7_8(A)				(int16_t)(A>>8)
S#define eGFX_INT_TO_FIXED_7_8(A)					((FIXED_7_8)(A)<<8)
S#define eGFX_GET_FRAC_FROM_FIXED_7_8(A)				(FIXED_7_8)(A&0xFF)
S
S#define eGFX_GET_INT_FROM_FIXED_9_6_(A)				(int16_t)(A>>6)
S#define eGFX_INT_TO_FIXED_9_6(A)					((FIXED_9_6)(A)<<6)
S#define eGFX_GET_FRAC_FROM_FIXED_6_9(A)				(FIXED_9_6)(A&0x3F)
S
SFIXED_7_8 eGFX_GET_INT_FROM_FIXED_7_8_ROUND_TO_NEAREST(FIXED_7_8 A);
SFIXED_7_8 eGFX_FLOAT_TO_FIXED_7_8(float A);
Sint16_t eGFX_FMul_15_0to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_7_8to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_15_0to7_8(int16_t A,int16_t B);
Sint16_t eGFX_FMul_15_0to1_14(int16_t A,int16_t B);
Sint16_t eGFX_ABS(int16_t A);
S
S
S#define eGFX_RGB888_TO_RGB565(R,G,B)	 ( ((R>>2)<<11) | ((G>>2)<<5) | (B>>3))
S
S
S#ifndef TRUE
S	#define TRUE 1
S#endif
S
S#ifndef FALSE
S	#define FALSE 0
S#endif
S
S
S/***
S *      _____ _          _    ____                       _   _
S *     |  __ (_)        | |  / __ \                     | | (_)
S *     | |__) |__  _____| | | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ \ \/ / _ \ | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |>  <  __/ | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_/_/\_\___|_|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                 | |
S *                                 |_|
S */
Svoid eGFX_PutPixel(const eGFX_ImagePlane *Image,
S                   int16_t x,
S                   int16_t y,
S                   eGFX_PixelState PS);
S
SeGFX_PixelState eGFX_GetPixel(const eGFX_ImagePlane *Image,
S                         int16_t x,
S                         int16_t y);
S
S
S
S
S/***
S *      _____      _           _ _   _              ____                       _   _
S *     |  __ \    (_)         (_) | (_)            / __ \                     | | (_)
S *     | |__) | __ _ _ __ ___  _| |_ ___   _____  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ '__| | '_ ` _ \| | __| \ \ / / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |  | | | | | | | | |_| |\ V /  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                                       | |
S *                                                       |_|
S */
S
S 
Svoid eGFX_DrawHline(eGFX_ImagePlane *Image,
S                    int16_t XStart,
S                    int16_t XStop,
S                    int16_t Y,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledBox(eGFX_ImagePlane *Image,
S                        eGFX_Box *Box,
S                        eGFX_PixelState PS);
S
Svoid eGFX_DrawBox(eGFX_ImagePlane *Image,
S                  eGFX_Box *Box,
S                  eGFX_PixelState PS);
S
Svoid eGFX_DrawVline(eGFX_ImagePlane *Image,
S                    int16_t YStart,
S                    int16_t YStop,
S                    int16_t X,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawLine(eGFX_ImagePlane *Image,
S                   int16_t X1,
S                   int16_t Y1,
S                   int16_t X2,
S                   int16_t Y2,
S                   eGFX_PixelState PS);
S
Svoid eGFX_DrawListPrimitive(eGFX_ImagePlane *Image,
S                            eGFX_ListPrimitive *LP ,
S                            eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledListPrimitive(eGFX_ImagePlane *Image,
S                                  eGFX_ListPrimitive *LP ,
S                                  FIXED_7_8 Scale,
S                                  eGFX_PixelState PS);
S
Svoid eGFX_DrawRotatedListPrimitive(eGFX_ImagePlane *Image,
S                                   eGFX_ListPrimitive *LP ,
S                                   uint8_t Angle,
S                                   eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledRotatedListPrimitive(eGFX_ImagePlane *Image,
S        eGFX_ListPrimitive *LP ,
S        uint8_t Angle,
S        FIXED_7_8 Scale,
S        eGFX_PixelState PS);
S
Svoid eGFX_DrawCircle(eGFX_ImagePlane *RC,
S                     int16_t x0,
S                     int16_t y0,
S                     int16_t radius,
S                     eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledCircle(eGFX_ImagePlane *RC,
S	int16_t x0,
S	int16_t y0,
S	int16_t radius,
S	eGFX_PixelState PS);
S
S
S
S/***
S *       _____ _        _                ____                       _   _
S *      / ____| |      (_)              / __ \                     | | (_)
S *     | (___ | |_ _ __ _ _ __   __ _  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *      \___ \| __| '__| | '_ \ / _` | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *      ____) | |_| |  | | | | | (_| | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_____/ \__|_|  |_|_| |_|\__, |  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                               __/ |        | |
S *                              |___/         |_|
S */
S
Sint16_t eGFX_ScaledDrawCharacter(eGFX_ImagePlane *Image,
S                                 int16_t StartX,
S                                 int16_t StartY,
S                                 uint8_t Character,
S                                 const eGFX_Font *MyFont,
S                                 float ScaleFactor);
S
Sint16_t eGFX_DrawCharacter(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawCharacterFaded(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont,
S                           eGFX_PixelState PS);
S
Sint16_t eGFX_DrawCharacterShaded(eGFX_ImagePlane *Image,
S									int16_t StartX,
S									int16_t StartY,
S									uint8_t Character,
S									const eGFX_Font *MyFont,
S									float Shading);
S
S
Sint16_t eGFX_GetStringWidth(char *String,
S                            const eGFX_Font *MyFont);
S
Sint16_t eGFX_GetStringWidth_CustomSpacing(char *String,
S											const eGFX_Font *MyFont,
S											uint16_t Spacing);
S
S
Svoid eGFX_DrawHorizontalCenteredString(eGFX_ImagePlane *Image,
S                                       int16_t StartY,
S                                       char *String,
S                                       const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawRightAlignedCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t CustomCharacterSpacing,
S        int16_t RightSideBuffer);
S
Svoid eGFX_DrawHorizontalCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t Spacing);
S
Svoid eGFX_ScaledDrawString(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           char *String,
S                           const eGFX_Font *MyFont,
S                           float ScaleFactor);
S
Sint16_t  eGFX_DrawStringFaded(eGFX_ImagePlane *Image,
S						 char *String,
S                         int16_t StartX,
S                         int16_t StartY,
S                         const eGFX_Font *MyFont,
S						eGFX_PixelState PS
S                         );
S
S
Sint16_t  eGFX_DrawStringShaded(eGFX_ImagePlane *Image,
S								char *String,
S								int16_t StartX,
S								int16_t StartY,
S								const eGFX_Font *MyFont,
S								float Shading
S								);
S
Svoid eGFX_ScaledDrawString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartX,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        float ScaleFactor ,
S        uint16_t Spacing);
S
Sint16_t  eGFX_DrawString(eGFX_ImagePlane *Image,
S						char * String,
S                         int16_t StartX,
S                         int16_t StartY,
S
S                         const eGFX_Font *MyFont
S                         );
S
Sint16_t  eGFX_printf(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S                     
S                     char *FormatString,...);
S
Sint16_t eGFX_DrawString_CustomSpacing(eGFX_ImagePlane *Image,
S                                      int16_t StartX,
S                                      int16_t StartY,
S                                      char *String,
S                                      const eGFX_Font *MyFont,uint16_t Spacing);
S                                      
Sint16_t  eGFX_printf_Colored(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S											uint32_t Color,
S                     char *FormatString,...);
S
Sint16_t  eGFX_printf_HorizontalCentered_Colored(eGFX_ImagePlane *Image,
S                                         int16_t StartY,
S                                        const eGFX_Font *MyFont,
S                                        uint32_t Color,
S                                        char *FormatString,...);
S/***
S*      _____  _                     ____                       _   _
S*     |  __ \| |                   / __ \                     | | (_)
S*     | |__) | | __ _ _ __   ___  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S*     |  ___/| |/ _` | '_ \ / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S*     | |    | | (_| | | | |  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S*     |_|    |_|\__,_|_| |_|\___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S*                                        | |
S*                                        |_|
S*/
S
Svoid eGFX_Blit(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_CenteredBlit(eGFX_ImagePlane *Destination,
S			int16_t x,
S			int16_t y,
S			const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_BlitFaded(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite,
S               eGFX_PixelState PS);
S
Svoid eGFX_BlitShaded(eGFX_ImagePlane *Destination,
S					int16_t x,
S					int16_t y,
S					const eGFX_ImagePlane *Sprite,
S					float Shading);
S                    
Svoid eGFX_BlitColored(eGFX_ImagePlane *Destination,
S                    int16_t x,
S                    int16_t y,
S                    const eGFX_ImagePlane *Sprite,
S                    uint32_t Color);
S
Svoid eGFX_ScaledBlit(eGFX_ImagePlane *Destination,
S                     int16_t x,
S                     int16_t y,
S                     const eGFX_ImagePlane *Sprite,
S                     float ScaleFactor);
S
Suint8_t eGFX_GetBitFromArray(uint8_t *DataArray,uint16_t Bit);
S
S
Suint8_t eGFX_ImagePlane_GetByte(eGFX_ImagePlane   *Image,
S                                uint16_t X,
S                                uint16_t Y);
S
S
Svoid eGFX_ImagePlaneInit(eGFX_ImagePlane   *Image, uint8_t * Store, int16_t SizeX, int16_t SizeY, uint8_t Type);
S
Svoid eGFX_ImagePlane_Clear(eGFX_ImagePlane   *Image);
S
S
S
S/***
S*                     _                 _                        _____ _____
S*         /\         (_)               | |                 /\   |  __ \_   _|
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __     /  \  | |__) || |
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__|   / /\ \ |  ___/ | |
S*      / ____ \| | | | | | | | | | (_| | || (_) | |     / ____ \| |    _| |_
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|    /_/    \_\_|   |_____|
S*
S*
S*/
S
S//Call this in the main loop.   Animators will be stepped at the rate that this is called!
Svoid eGFX_ProcessAnimators(void);
S
S//Adds an animator object to the list.  returns TRUE if successful.
Suint32_t eGFX_AddAnimator(void * Animator);
S
S//Clears all animators from the list
Svoid eGFX_ClearAnimators(void);
S
S//Gets the number of animator objects in the list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Returns True if the animator is complete
Suint32_t eGFX_AnimatorIsComplete(void * A);
S
S//returns TRUE if all of the animators are complete
Suint32_t eGFX_AnimatorsAreComplete(void);
S
S//Pauses all the animators (sets the state to inactive)
Svoid eGFX_PauseAnimators(void);
S
S//Starts all the Animators in the list.  (Sets the State to Active)
Svoid eGFX_StartAnimators(void);
S
S//Resets and Animator to step 0 and starts it again.
Svoid eGFX_ResetAnimator(void * A);
S
S//Resets and restarts all animators
Svoid eGFX_ResetAnimators(void);
S
S/***
S*      ___     _     _   ___   ___ _            _
S*     | _ \___(_)_ _| |_| __| | _ |_)___ ___ __| |_
S*     |  _/ _ \ | ' \  _| _|  | _ \ (_-</ -_) _|  _|
S*     |_| \___/_|_||_\__|_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes  a point bisect animator.  It does not add it to the list
S//returns true if successful, false if not
Suint32_t eGFX_InitPointF_BisectAnimator(  eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect		//The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S);
S
S//Initializes and adds a point bisect animator to the list.
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_BisectAnimator(   eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect //The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S										);
S
Svoid eGFX_ProcessPointF_BisectAnimator(eGFX_PointF_BisectAnimator *P);
S
S
S/***
S*      ___          _          ___   ___ _            _
S*     / __| __ __ _| |__ _ _ _| __| | _ |_)___ ___ __| |_
S*     \__ \/ _/ _` | / _` | '_| _|  | _ \ (_-</ -_) _|  _|
S*     |___/\__\__,_|_\__,_|_| |_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
Suint32_t eGFX_AddScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
S
Svoid eGFX_ProcessScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P);
S
S
S
S
S/***
S*      ___          _            _    _
S*     / __| __ __ _| |__ _ _ _  | |  (_)_ _  ___ __ _ _ _
S*     \__ \/ _/ _` | / _` | '_| | |__| | ' \/ -_) _` | '_|
S*     |___/\__\__,_|_\__,_|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S										
Svoid eGFX_ProcessScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P);
S
S
S/***
S*      ___     _     _   ___   _    _
S*     | _ \___(_)_ _| |_| __| | |  (_)_ _  ___ __ _ _ _
S*     |  _/ _ \ | ' \  _| _|  | |__| | ' \/ -_) _` | '_|
S*     |_| \___/_|_||_\__|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
Svoid eGFX_ProcessPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P);
S
S
S
S
S
S										
S/***
S *       ____  ____       _ ______ _____ _______            _____ _____ 
S *      / __ \|  _ \     | |  ____/ ____|__   __|     /\   |  __ \_   _|
S *     | |  | | |_) |    | | |__ | |       | |       /  \  | |__) || |  
S *     | |  | |  _ < _   | |  __|| |       | |      / /\ \ |  ___/ | |  
S *     | |__| | |_) | |__| | |___| |____   | |     / ____ \| |    _| |_ 
S *      \____/|____/ \____/|______\_____|  |_|    /_/    \_\_|   |_____|
S *                                                                      
S *                                                                      
S */
S		
S//Call this when you are ready to draw all the objects on the list
Svoid eGFX_DrawObjects(eGFX_ImagePlane * Image);
S
S//Adds a eGFX object to the list
Suint32_t eGFX_AddObject(void * Object);
S
S//Clears all objects from the list
Svoid eGFX_ClearObjects(void);
S
S//Gets the number of objects in the object list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Disables rendering/processing of the object
Svoid eGFX_DisableObject(void * Object);
S
S//enable rendering/processing of the object
Svoid eGFX_EnableObject(void * Object);
S
S/***
S*      _____        _   ___
S*     |_   _|____ _| |_| __|
S*       | |/ -_) \ /  _| _|
S*       |_|\___/_\_\\__|_|
S*
S*/
S
S//Draws a TextF object onto an image Plane
Svoid eGFX_DrawObject_TextF(eGFX_ImagePlane * Image, eGFX_Obj_TextF *TextF_Object);
S
S//Initializes a TextF object
Svoid eGFX_InitObjectTextF(eGFX_Obj_TextF * TF,
S							eGFX_PointF Position,
S							eGFX_Font *Font,
S							char * String
S							);	
S
S//Initializes a TextF object and also adds it to the current draw list
Svoid eGFX_AddObjectTextF(eGFX_Obj_TextF * TF,
S						eGFX_PointF Position,
S						eGFX_Font *Font,
S						char * String
S						);
S
S/***
S*      ___ _            _        _   _____        _   ___
S*     / __| |_  __ _ __| |___ __| | |_   _|____ _| |_| __|
S*     \__ \ ' \/ _` / _` / -_) _` |   | |/ -_) \ /  _| _|
S*     |___/_||_\__,_\__,_\___\__,_|   |_|\___/_\_\\__|_|
S*
S*/
S
Svoid eGFX_InitObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
S
Svoid eGFX_AddObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
Svoid	eGFX_DrawObject_ShadedTextF(eGFX_ImagePlane * Image, eGFX_Obj_ShadedTextF *ShadedTextF_Object);
S
S						
S/***
S*      _    _          ___
S*     | |  (_)_ _  ___| __|
S*     | |__| | ' \/ -_) _|
S*     |____|_|_||_\___|_|
S*
S*/
S
S//Initializes a LineF object
Svoid eGFX_InitObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Initializes a LineF object and also adds it to the current draw list
Svoid eGFX_AddObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Draws a LineF object onto an image Plane
Svoid	eGFX_DrawObject_LineF(eGFX_ImagePlane * Image, eGFX_Obj_LineF *LineF_Object);
S
S/***
S*      ___          _ _       ___
S*     / __|_ __ _ _(_) |_ ___| __|
S*     \__ \ '_ \ '_| |  _/ -_) _|
S*     |___/ .__/_| |_|\__\___|_|
S*         |_|
S*/
S
S//Initializes a SpriteF object
Svoid eGFX_InitObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//Initializes a SpriteF object and adds it to the object list
Svoid eGFX_AddObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//draws a spritef onto an image plane
Svoid	eGFX_DrawObject_SpriteF(eGFX_ImagePlane * Image, eGFX_Obj_SpriteF *SpriteF_Object);
S
S/***
S*      ___          _ _       ___   ___          _        _
S*     / __|_ __ _ _(_) |_ ___| __| / __| __ __ _| |___ __| |
S*     \__ \ '_ \ '_| |  _/ -_) _|  \__ \/ _/ _` | / -_) _` |
S*     |___/ .__/_| |_|\__\___|_|   |___/\__\__,_|_\___\__,_|
S*         |_|
S*/
S
S//Initializes a scaled sprited object
Svoid eGFX_InitObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S
S//Initializes a scaled sprited object and adds it to the object list
Svoid eGFX_AddObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S//draws a scaled spritef onto an image plane
Svoid	eGFX_DrawObject_ScaledSpriteF(eGFX_ImagePlane * Image, eGFX_Obj_ScaledSpriteF *SpriteF_Object);
S
S
S/***
S*       ___          ___
S*      | _ ) _____ _| __|
S*      | _ \/ _ \ \ / _|
S*      |___/\___/_\_\_|
S*
S*/
S
S
Svoid eGFX_InitObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid	eGFX_DrawObject_BoxF(eGFX_ImagePlane * Image, eGFX_Obj_BoxF *BoxF_Object);
S
S
S/***
S*       ___ _        _     ___
S*      / __(_)_ _ __| |___| __|
S*     | (__| | '_/ _| / -_) _|
S*      \___|_|_| \__|_\___|_|
S*
S*/
S
S
Svoid eGFX_InitObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
Svoid	eGFX_DrawObject_CircleF(eGFX_ImagePlane * Image, eGFX_Obj_CircleF *CircleF_Object);
S
S
N#endif
N
N
N#ifdef __cplusplus
S }
N#endif
N
L 2 ".\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP\Consolas__26px__Regular__AntiAliasGridFit_1BPP.h" 2
N
N#ifndef _CONSOLAS__26PX__REGULAR__ANTIALIASGRIDFIT_1BPP_H
N#define _CONSOLAS__26PX__REGULAR__ANTIALIASGRIDFIT_1BPP_H
N
N extern const eGFX_Font Consolas__26px__Regular__AntiAliasGridFit_1BPP;
N
N#endif
N
L 34 "SRC\main.c" 2
N#include "Magneto__26px__Regular__AntiAliasGridFit_16BPP_565.h" 
L 1 ".\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565.h" 1
N#include "eGFX.h" 
L 1 ".\SRC\eGFX\eGFX.h" 1
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include <stdlib.h>
N
N#include "eGFX_DataTypes.h"
L 1 ".\SRC\eGFX\eGFX_DataTypes.h" 1
N#include "stdint.h"
N
N
N#ifndef eGFX_DATA_TYPES_H
S#define eGFX_DATA_TYPES_H
S
S
Stypedef int16_t FIXED_7_8;
Stypedef int16_t FIXED_9_6;
S
Stypedef int16_t FIXED_0_15;
Stypedef int16_t FIXED_1_14;
S
S
S#define eGFX_IMAGE_PLANE_1BPP		 0
S#define eGFX_IMAGE_PLANE_3BPP_RGB    	 1
S#define eGFX_IMAGE_PLANE_4BPP		    2
S#define eGFX_IMAGE_PLANE_8BPP		   3
S#define eGFX_IMAGE_PLANE_16BPP_565    4
S#define eGFX_IMAGE_PLANE_24BPP        5
S#define eGFX_IMAGE_PLANE_32BPP        6
S
S
S
Stypedef struct
S{
S    uint8_t Type;
S    uint8_t *Data;
S    uint16_t SizeX;
S    uint16_t SizeY;
S
S} eGFX_ImagePlane;
S
Stypedef struct
S{
S    int16_t X;
S    int16_t Y;
S} eGFX_Point;
S
Stypedef struct
S{
S    float X; 	
S    float Y;  
S} eGFX_PointF;
S
Stypedef struct
S{
S    eGFX_Point P1;
S    eGFX_Point P2;
S} eGFX_Box;
S
Stypedef struct
S{
S    eGFX_Point Center;
S    uint8_t NumPoints;
S    uint8_t DrawMode;
S    const eGFX_Point *PointList;
S
S} eGFX_ListPrimitive;
S
S
S
S#define eGFX_LIST_PRIMITIVE_CONNECTED                              0x01
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED                           0x02
S#define eGFX_LIST_PRIMITIVE_CLOSED								   0x03
S#define eGFX_LIST_PRIMITIVE_CONNECTED_YFLIPPED			 		   0x04
S#define eGFX_LIST_PRIMITIVE_DISCONNECTED_YFLIPPED		   		   0x05
S#define eGFX_LIST_PRIMITIVE_CLOSED_YFLIPPED			   			   0x06
S
Stypedef struct
S{
S    const eGFX_ImagePlane *CharacterSprites[0x80-0x20];
S  
S	//Some TT Metrics
S	int32_t Ascent; //Ascent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t Descent; //Descent scaled up by 65536 to store fractional value		(Q15.16)
S	int32_t LineSpacing; //Linespacing scaled up by 65536 to store fractional value  (Q15.16)
S	
S	uint8_t  SpacesPerTab;
S    uint8_t  InterCharacterSpacing;
S   
S	uint8_t  Padding[2];
S
S} eGFX_Font;
S
S
S#define eGFX_PIXEL_ON     0xFFFFFFFF
S#define eGFX_PIXEL_OFF    0
S
Stypedef uint32_t eGFX_PixelState;
S
S/***
S*       ____  _     _           _
S*      / __ \| |   (_)         | |
S*     | |  | | |__  _  ___  ___| |_ ___
S*     | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | |_) | |  __/ (__| |_\__ \
S*      \____/|_.__/| |\___|\___|\__|___/
X
S*                 _/ |
S*                |__/
S*/
S
Stypedef struct 
S{
S	uint32_t Type;
S	uint32_t State;
S	
S}	eGFX_ObjectHeader;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S}	eGFX_AnimatorHeader;
S
S#define eGFX_OBJECT_STATE_ACTIVE							        	1
S#define eGFX_OBJECT_STATE_ANIMATION_ACTIVE								2
S#define eGFX_OBJECT_STATE_INACTIVE										0
S
S/***
S*                     _                 _                ____  _     _           _
S*         /\         (_)               | |              / __ \| |   (_)         | |
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __  | |  | | |__  _  ___  ___| |_ ___
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__| | |  | | '_ \| |/ _ \/ __| __/ __|
S*      / ____ \| | | | | | | | | | (_| | || (_) | |    | |__| | |_) | |  __/ (__| |_\__ \
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|     \____/|_.__/| |\___|\___|\__|___/
X
S*                                                                  _/ |
S*                                                                 |__/
S*/
S
S
S
S#define eGFX_OBJECT_POINTF_BISECT_ANIMATOR								0xF0
S#define eGFX_OBJECT_POINTF_LINEAR_ANIMATOR								0xF1
S
S#define eGFX_OBJECT_SCALARF_BISECT_ANIMATOR								0xF2
S#define eGFX_OBJECT_SCALARF_LINEAR_ANIMATOR								0xF3
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_PointF_BisectAnimator;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	eGFX_PointF Target;
S	eGFX_PointF *Current;
S	float IncrementX;
S	float IncrementY;
S
S} eGFX_PointF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float Increment; //Increment we should make each step
S
S} eGFX_ScalarF_LinearAnimator;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	uint32_t CurrentStep;
S	uint32_t LastStep;
S	float Target;
S	float *Current;
S	float FractionalBisect; //The amount of percentage of the distance the point should move each step. must between a number between zero and 1
S
S} eGFX_ScalarF_BisectAnimator;
S
S/***
S*       _____                 _     _         ____  _     _           _
S*      / ____|               | |   (_)       / __ \| |   (_)         | |
S*     | |  __ _ __ __ _ _ __ | |__  _  ___  | |  | | |__  _  ___  ___| |_ ___
S*     | | |_ | '__/ _` | '_ \| '_ \| |/ __| | |  | | '_ \| |/ _ \/ __| __/ __|
S*     | |__| | | | (_| | |_) | | | | | (__  | |__| | |_) | |  __/ (__| |_\__ \
S*      \_____|_|  \__,_| .__/|_| |_|_|\___|  \____/|_.__/| |\___|\___|\__|___/
X
S*                      | |                              _/ |
S*                      |_|                             |__/
S*/
S
S#define eGFX_OBJECT_TEXTF												0x0000
S#define eGFX_OBJECT_SHADED_TEXTF										0x0001
S#define eGFX_OBJECT_LINEF												0x0002
S#define eGFX_OBJECT_SPRITEF												0x0003
S#define eGFX_OBJECT_SCALED_SPRITEF										0x0004
S#define eGFX_OBJECT_BOXF												0x0005
S#define eGFX_OBJECT_CIRCLEF												0x0006
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	
S} eGFX_Obj_TextF;
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	char *String;
S	eGFX_Font *Font;
S	float Shading;
S
S} eGFX_Obj_ShadedTextF;
S
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Start;
S	eGFX_PointF End;
S	eGFX_PixelState PixelState; 
S} eGFX_Obj_LineF;
S
S#define eGFX_CIRCLEF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_CIRCLEF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	float Radius;
S	eGFX_PixelState PixelState; 
S	uint8_t RenderOption;
S} eGFX_Obj_CircleF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S	
S} eGFX_Obj_SpriteF;
S
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S	
S	eGFX_PointF Position;
S	eGFX_ImagePlane * Sprite;
S
S	float Scale;
S
S} eGFX_Obj_ScaledSpriteF;
S
S
S#define eGFX_BOXF_RENDER_OPTION_OUTLINE	0x00
S#define eGFX_BOXF_RENDER_OPTION_FILLED	0x01
S
Stypedef struct
S{
S	uint32_t Type;
S	uint32_t State;
S
S	eGFX_PointF P1;
S	eGFX_PointF P2;
S
S	eGFX_PixelState PixelState;
S
S	uint8_t BoxF_RenderOption;
S
S} eGFX_Obj_BoxF;
S
S
N#endif
L 10 ".\SRC\eGFX\eGFX.h" 2
N
N
N#ifndef _eGFX_H__
S#define _eGFX_H__
S
S#define eGFX_MAX_ANIMATORS										  32
S#define eGFX_MAX_OBJECTS										  64
S
S#define eGFX_SPACES_PER_TAB                                        4
S#define eGFX_MAX_STRING_LEN                                        64
S#define eGFX_MAX_PRINTF_BUF_LENGTH                                 64
S
S#define eGFX_API_LEVEL											   1
S#define eGFX_REVISION											   2
S
S
S#define eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+7)>>3) //We add 8 to round up to the next even byte boundary
S#define eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)			 ((x+1)>>1) //We add 1 to round up to the next even byte boundary
S#define eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)			 (x)
S#define eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)		 (x*2)
S#define eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*3)
S#define	eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	 	 (x*4)
S
S#define eGFX_CALCULATE_1BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_1BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_3BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (((x * y * 3))/8) //This is a special type  for sharp 8 color memory LCDs.   Packing is done in the data buffer so the dump to the screen is simple
S#define eGFX_CALCULATE_4BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_4BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_8BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)    (eGFX_CALCULATE_8BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_16BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_16BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_24BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_24BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S#define eGFX_CALCULATE_32BPP_IMAGE_STORAGE_SPACE_SIZE(x,y)   (eGFX_CALCULATE_32BPP_BUFFER_ROW_BYTE_SIZE(x)	* y)
S
S#define ROUND_TO_INT16_T(x)	((int16_t)(x + 0.5f))
S
Sextern const FIXED_1_14 eGFX_Fixed_1_14_SineTable [256];
Sextern const FIXED_7_8 eGFX_Fixed_7_8_SineTable[256];
S
S#define eGFX_GET_INT_FROM_FIXED_7_8(A)				(int16_t)(A>>8)
S#define eGFX_INT_TO_FIXED_7_8(A)					((FIXED_7_8)(A)<<8)
S#define eGFX_GET_FRAC_FROM_FIXED_7_8(A)				(FIXED_7_8)(A&0xFF)
S
S#define eGFX_GET_INT_FROM_FIXED_9_6_(A)				(int16_t)(A>>6)
S#define eGFX_INT_TO_FIXED_9_6(A)					((FIXED_9_6)(A)<<6)
S#define eGFX_GET_FRAC_FROM_FIXED_6_9(A)				(FIXED_9_6)(A&0x3F)
S
SFIXED_7_8 eGFX_GET_INT_FROM_FIXED_7_8_ROUND_TO_NEAREST(FIXED_7_8 A);
SFIXED_7_8 eGFX_FLOAT_TO_FIXED_7_8(float A);
Sint16_t eGFX_FMul_15_0to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_7_8to0_15(int16_t A, int16_t B);
Sint16_t eGFX_FMul_15_0to7_8(int16_t A,int16_t B);
Sint16_t eGFX_FMul_15_0to1_14(int16_t A,int16_t B);
Sint16_t eGFX_ABS(int16_t A);
S
S
S#define eGFX_RGB888_TO_RGB565(R,G,B)	 ( ((R>>2)<<11) | ((G>>2)<<5) | (B>>3))
S
S
S#ifndef TRUE
S	#define TRUE 1
S#endif
S
S#ifndef FALSE
S	#define FALSE 0
S#endif
S
S
S/***
S *      _____ _          _    ____                       _   _
S *     |  __ (_)        | |  / __ \                     | | (_)
S *     | |__) |__  _____| | | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ \ \/ / _ \ | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |>  <  __/ | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_/_/\_\___|_|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                 | |
S *                                 |_|
S */
Svoid eGFX_PutPixel(const eGFX_ImagePlane *Image,
S                   int16_t x,
S                   int16_t y,
S                   eGFX_PixelState PS);
S
SeGFX_PixelState eGFX_GetPixel(const eGFX_ImagePlane *Image,
S                         int16_t x,
S                         int16_t y);
S
S
S
S
S/***
S *      _____      _           _ _   _              ____                       _   _
S *     |  __ \    (_)         (_) | (_)            / __ \                     | | (_)
S *     | |__) | __ _ _ __ ___  _| |_ ___   _____  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *     |  ___/ '__| | '_ ` _ \| | __| \ \ / / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *     | |   | |  | | | | | | | | |_| |\ V /  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                                                       | |
S *                                                       |_|
S */
S
S 
Svoid eGFX_DrawHline(eGFX_ImagePlane *Image,
S                    int16_t XStart,
S                    int16_t XStop,
S                    int16_t Y,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledBox(eGFX_ImagePlane *Image,
S                        eGFX_Box *Box,
S                        eGFX_PixelState PS);
S
Svoid eGFX_DrawBox(eGFX_ImagePlane *Image,
S                  eGFX_Box *Box,
S                  eGFX_PixelState PS);
S
Svoid eGFX_DrawVline(eGFX_ImagePlane *Image,
S                    int16_t YStart,
S                    int16_t YStop,
S                    int16_t X,
S                    eGFX_PixelState PS);
S
Svoid eGFX_DrawLine(eGFX_ImagePlane *Image,
S                   int16_t X1,
S                   int16_t Y1,
S                   int16_t X2,
S                   int16_t Y2,
S                   eGFX_PixelState PS);
S
Svoid eGFX_DrawListPrimitive(eGFX_ImagePlane *Image,
S                            eGFX_ListPrimitive *LP ,
S                            eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledListPrimitive(eGFX_ImagePlane *Image,
S                                  eGFX_ListPrimitive *LP ,
S                                  FIXED_7_8 Scale,
S                                  eGFX_PixelState PS);
S
Svoid eGFX_DrawRotatedListPrimitive(eGFX_ImagePlane *Image,
S                                   eGFX_ListPrimitive *LP ,
S                                   uint8_t Angle,
S                                   eGFX_PixelState PS);
S
Svoid eGFX_DrawScaledRotatedListPrimitive(eGFX_ImagePlane *Image,
S        eGFX_ListPrimitive *LP ,
S        uint8_t Angle,
S        FIXED_7_8 Scale,
S        eGFX_PixelState PS);
S
Svoid eGFX_DrawCircle(eGFX_ImagePlane *RC,
S                     int16_t x0,
S                     int16_t y0,
S                     int16_t radius,
S                     eGFX_PixelState PS);
S
Svoid eGFX_DrawFilledCircle(eGFX_ImagePlane *RC,
S	int16_t x0,
S	int16_t y0,
S	int16_t radius,
S	eGFX_PixelState PS);
S
S
S
S/***
S *       _____ _        _                ____                       _   _
S *      / ____| |      (_)              / __ \                     | | (_)
S *     | (___ | |_ _ __ _ _ __   __ _  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S *      \___ \| __| '__| | '_ \ / _` | | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S *      ____) | |_| |  | | | | | (_| | | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S *     |_____/ \__|_|  |_|_| |_|\__, |  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S *                               __/ |        | |
S *                              |___/         |_|
S */
S
Sint16_t eGFX_ScaledDrawCharacter(eGFX_ImagePlane *Image,
S                                 int16_t StartX,
S                                 int16_t StartY,
S                                 uint8_t Character,
S                                 const eGFX_Font *MyFont,
S                                 float ScaleFactor);
S
Sint16_t eGFX_DrawCharacter(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawCharacterFaded(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           uint8_t Character,
S                           const eGFX_Font *MyFont,
S                           eGFX_PixelState PS);
S
Sint16_t eGFX_DrawCharacterShaded(eGFX_ImagePlane *Image,
S									int16_t StartX,
S									int16_t StartY,
S									uint8_t Character,
S									const eGFX_Font *MyFont,
S									float Shading);
S
S
Sint16_t eGFX_GetStringWidth(char *String,
S                            const eGFX_Font *MyFont);
S
Sint16_t eGFX_GetStringWidth_CustomSpacing(char *String,
S											const eGFX_Font *MyFont,
S											uint16_t Spacing);
S
S
Svoid eGFX_DrawHorizontalCenteredString(eGFX_ImagePlane *Image,
S                                       int16_t StartY,
S                                       char *String,
S                                       const eGFX_Font *MyFont);
S
Sint16_t eGFX_DrawRightAlignedCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t CustomCharacterSpacing,
S        int16_t RightSideBuffer);
S
Svoid eGFX_DrawHorizontalCenteredString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        uint16_t Spacing);
S
Svoid eGFX_ScaledDrawString(eGFX_ImagePlane *Image,
S                           int16_t StartX,
S                           int16_t StartY,
S                           char *String,
S                           const eGFX_Font *MyFont,
S                           float ScaleFactor);
S
Sint16_t  eGFX_DrawStringFaded(eGFX_ImagePlane *Image,
S						 char *String,
S                         int16_t StartX,
S                         int16_t StartY,
S                         const eGFX_Font *MyFont,
S						eGFX_PixelState PS
S                         );
S
S
Sint16_t  eGFX_DrawStringShaded(eGFX_ImagePlane *Image,
S								char *String,
S								int16_t StartX,
S								int16_t StartY,
S								const eGFX_Font *MyFont,
S								float Shading
S								);
S
Svoid eGFX_ScaledDrawString_CustomSpacing(eGFX_ImagePlane *Image,
S        int16_t StartX,
S        int16_t StartY,
S        char *String,
S        const eGFX_Font *MyFont,
S        float ScaleFactor ,
S        uint16_t Spacing);
S
Sint16_t  eGFX_DrawString(eGFX_ImagePlane *Image,
S						char * String,
S                         int16_t StartX,
S                         int16_t StartY,
S
S                         const eGFX_Font *MyFont
S                         );
S
Sint16_t  eGFX_printf(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S                     
S                     char *FormatString,...);
S
Sint16_t eGFX_DrawString_CustomSpacing(eGFX_ImagePlane *Image,
S                                      int16_t StartX,
S                                      int16_t StartY,
S                                      char *String,
S                                      const eGFX_Font *MyFont,uint16_t Spacing);
S                                      
Sint16_t  eGFX_printf_Colored(eGFX_ImagePlane *Image,
S                     int16_t StartX,
S                     int16_t StartY,
S                     const eGFX_Font *MyFont,
S											uint32_t Color,
S                     char *FormatString,...);
S
Sint16_t  eGFX_printf_HorizontalCentered_Colored(eGFX_ImagePlane *Image,
S                                         int16_t StartY,
S                                        const eGFX_Font *MyFont,
S                                        uint32_t Color,
S                                        char *FormatString,...);
S/***
S*      _____  _                     ____                       _   _
S*     |  __ \| |                   / __ \                     | | (_)
S*     | |__) | | __ _ _ __   ___  | |  | |_ __   ___ _ __ __ _| |_ _  ___  _ __  ___
S*     |  ___/| |/ _` | '_ \ / _ \ | |  | | '_ \ / _ \ '__/ _` | __| |/ _ \| '_ \/ __|
S*     | |    | | (_| | | | |  __/ | |__| | |_) |  __/ | | (_| | |_| | (_) | | | \__ \
S*     |_|    |_|\__,_|_| |_|\___|  \____/| .__/ \___|_|  \__,_|\__|_|\___/|_| |_|___/
X
S*                                        | |
S*                                        |_|
S*/
S
Svoid eGFX_Blit(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_CenteredBlit(eGFX_ImagePlane *Destination,
S			int16_t x,
S			int16_t y,
S			const eGFX_ImagePlane *Sprite);
S
Svoid eGFX_BlitFaded(eGFX_ImagePlane *Destination,
S               int16_t x,
S               int16_t y,
S               const eGFX_ImagePlane *Sprite,
S               eGFX_PixelState PS);
S
Svoid eGFX_BlitShaded(eGFX_ImagePlane *Destination,
S					int16_t x,
S					int16_t y,
S					const eGFX_ImagePlane *Sprite,
S					float Shading);
S                    
Svoid eGFX_BlitColored(eGFX_ImagePlane *Destination,
S                    int16_t x,
S                    int16_t y,
S                    const eGFX_ImagePlane *Sprite,
S                    uint32_t Color);
S
Svoid eGFX_ScaledBlit(eGFX_ImagePlane *Destination,
S                     int16_t x,
S                     int16_t y,
S                     const eGFX_ImagePlane *Sprite,
S                     float ScaleFactor);
S
Suint8_t eGFX_GetBitFromArray(uint8_t *DataArray,uint16_t Bit);
S
S
Suint8_t eGFX_ImagePlane_GetByte(eGFX_ImagePlane   *Image,
S                                uint16_t X,
S                                uint16_t Y);
S
S
Svoid eGFX_ImagePlaneInit(eGFX_ImagePlane   *Image, uint8_t * Store, int16_t SizeX, int16_t SizeY, uint8_t Type);
S
Svoid eGFX_ImagePlane_Clear(eGFX_ImagePlane   *Image);
S
S
S
S/***
S*                     _                 _                        _____ _____
S*         /\         (_)               | |                 /\   |  __ \_   _|
S*        /  \   _ __  _ _ __ ___   __ _| |_ ___  _ __     /  \  | |__) || |
S*       / /\ \ | '_ \| | '_ ` _ \ / _` | __/ _ \| '__|   / /\ \ |  ___/ | |
S*      / ____ \| | | | | | | | | | (_| | || (_) | |     / ____ \| |    _| |_
S*     /_/    \_\_| |_|_|_| |_| |_|\__,_|\__\___/|_|    /_/    \_\_|   |_____|
S*
S*
S*/
S
S//Call this in the main loop.   Animators will be stepped at the rate that this is called!
Svoid eGFX_ProcessAnimators(void);
S
S//Adds an animator object to the list.  returns TRUE if successful.
Suint32_t eGFX_AddAnimator(void * Animator);
S
S//Clears all animators from the list
Svoid eGFX_ClearAnimators(void);
S
S//Gets the number of animator objects in the list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Returns True if the animator is complete
Suint32_t eGFX_AnimatorIsComplete(void * A);
S
S//returns TRUE if all of the animators are complete
Suint32_t eGFX_AnimatorsAreComplete(void);
S
S//Pauses all the animators (sets the state to inactive)
Svoid eGFX_PauseAnimators(void);
S
S//Starts all the Animators in the list.  (Sets the State to Active)
Svoid eGFX_StartAnimators(void);
S
S//Resets and Animator to step 0 and starts it again.
Svoid eGFX_ResetAnimator(void * A);
S
S//Resets and restarts all animators
Svoid eGFX_ResetAnimators(void);
S
S/***
S*      ___     _     _   ___   ___ _            _
S*     | _ \___(_)_ _| |_| __| | _ |_)___ ___ __| |_
S*     |  _/ _ \ | ' \  _| _|  | _ \ (_-</ -_) _|  _|
S*     |_| \___/_|_||_\__|_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes  a point bisect animator.  It does not add it to the list
S//returns true if successful, false if not
Suint32_t eGFX_InitPointF_BisectAnimator(  eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect		//The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S);
S
S//Initializes and adds a point bisect animator to the list.
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_BisectAnimator(   eGFX_PointF_BisectAnimator *P,
S										eGFX_PointF Target,
S										eGFX_PointF *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float FractionalBisect //The amount of percentage of the distance the point should move each step.   Range is 0 to 1.0.    values of 0 or less will map to 0.5.   Value of 1 or greater will map to 0.5
S										);
S
Svoid eGFX_ProcessPointF_BisectAnimator(eGFX_PointF_BisectAnimator *P);
S
S
S/***
S*      ___          _          ___   ___ _            _
S*     / __| __ __ _| |__ _ _ _| __| | _ |_)___ ___ __| |_
S*     \__ \/ _/ _` | / _` | '_| _|  | _ \ (_-</ -_) _|  _|
S*     |___/\__\__,_|_\__,_|_| |_|   |___/_/__/\___\__|\__|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
Suint32_t eGFX_AddScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P,
S	float Target,
S	float *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float FractionalBisect);
S
S
Svoid eGFX_ProcessScalarF_BisectAnimator(eGFX_ScalarF_BisectAnimator *P);
S
S
S
S
S/***
S*      ___          _            _    _
S*     / __| __ __ _| |__ _ _ _  | |  (_)_ _  ___ __ _ _ _
S*     \__ \/ _/ _` | / _` | '_| | |__| | ' \/ -_) _` | '_|
S*     |___/\__\__,_|_\__,_|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P,
S										float Target,
S										float *Current,
S										uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S										float Increment
S										);
S
S										
Svoid eGFX_ProcessScalarF_LinearAnimator(eGFX_ScalarF_LinearAnimator *P);
S
S
S/***
S*      ___     _     _   ___   _    _
S*     | _ \___(_)_ _| |_| __| | |  (_)_ _  ___ __ _ _ _
S*     |  _/ _ \ | ' \  _| _|  | |__| | ' \/ -_) _` | '_|
S*     |_| \___/_|_||_\__|_|   |____|_|_||_\___\__,_|_|
S*
S*/
S
S//Initializes the data struct
Suint32_t eGFX_InitPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
S
S//Initializes and adds a scalarf linear animator and adds it to the list
S//returns true if successful, false if not
Suint32_t eGFX_AddPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P,
S	eGFX_PointF Target,
S	eGFX_PointF *Current,
S	uint32_t LastStep,			//Maximum Allow Steps before forced convergence
S	float IncrementX,
S	float IncrementY
S	);
S
S
Svoid eGFX_ProcessPointF_LinearAnimator(eGFX_PointF_LinearAnimator *P);
S
S
S
S
S
S										
S/***
S *       ____  ____       _ ______ _____ _______            _____ _____ 
S *      / __ \|  _ \     | |  ____/ ____|__   __|     /\   |  __ \_   _|
S *     | |  | | |_) |    | | |__ | |       | |       /  \  | |__) || |  
S *     | |  | |  _ < _   | |  __|| |       | |      / /\ \ |  ___/ | |  
S *     | |__| | |_) | |__| | |___| |____   | |     / ____ \| |    _| |_ 
S *      \____/|____/ \____/|______\_____|  |_|    /_/    \_\_|   |_____|
S *                                                                      
S *                                                                      
S */
S		
S//Call this when you are ready to draw all the objects on the list
Svoid eGFX_DrawObjects(eGFX_ImagePlane * Image);
S
S//Adds a eGFX object to the list
Suint32_t eGFX_AddObject(void * Object);
S
S//Clears all objects from the list
Svoid eGFX_ClearObjects(void);
S
S//Gets the number of objects in the object list
Suint32_t eGFX_GetAnimatorCount(void);
S
S//Disables rendering/processing of the object
Svoid eGFX_DisableObject(void * Object);
S
S//enable rendering/processing of the object
Svoid eGFX_EnableObject(void * Object);
S
S/***
S*      _____        _   ___
S*     |_   _|____ _| |_| __|
S*       | |/ -_) \ /  _| _|
S*       |_|\___/_\_\\__|_|
S*
S*/
S
S//Draws a TextF object onto an image Plane
Svoid eGFX_DrawObject_TextF(eGFX_ImagePlane * Image, eGFX_Obj_TextF *TextF_Object);
S
S//Initializes a TextF object
Svoid eGFX_InitObjectTextF(eGFX_Obj_TextF * TF,
S							eGFX_PointF Position,
S							eGFX_Font *Font,
S							char * String
S							);	
S
S//Initializes a TextF object and also adds it to the current draw list
Svoid eGFX_AddObjectTextF(eGFX_Obj_TextF * TF,
S						eGFX_PointF Position,
S						eGFX_Font *Font,
S						char * String
S						);
S
S/***
S*      ___ _            _        _   _____        _   ___
S*     / __| |_  __ _ __| |___ __| | |_   _|____ _| |_| __|
S*     \__ \ ' \/ _` / _` / -_) _` |   | |/ -_) \ /  _| _|
S*     |___/_||_\__,_\__,_\___\__,_|   |_|\___/_\_\\__|_|
S*
S*/
S
Svoid eGFX_InitObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
S
Svoid eGFX_AddObjectShadedTextF(eGFX_Obj_ShadedTextF * TF,
S	eGFX_PointF Position,
S	eGFX_Font *Font,
S	char * String,
S	float Shading
S	);
S
Svoid	eGFX_DrawObject_ShadedTextF(eGFX_ImagePlane * Image, eGFX_Obj_ShadedTextF *ShadedTextF_Object);
S
S						
S/***
S*      _    _          ___
S*     | |  (_)_ _  ___| __|
S*     | |__| | ' \/ -_) _|
S*     |____|_|_||_\___|_|
S*
S*/
S
S//Initializes a LineF object
Svoid eGFX_InitObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Initializes a LineF object and also adds it to the current draw list
Svoid eGFX_AddObjectLineF(eGFX_Obj_LineF * LF,
S	eGFX_PointF Start,
S	eGFX_PointF End,
S	eGFX_PixelState PS
S	);
S
S
S//Draws a LineF object onto an image Plane
Svoid	eGFX_DrawObject_LineF(eGFX_ImagePlane * Image, eGFX_Obj_LineF *LineF_Object);
S
S/***
S*      ___          _ _       ___
S*     / __|_ __ _ _(_) |_ ___| __|
S*     \__ \ '_ \ '_| |  _/ -_) _|
S*     |___/ .__/_| |_|\__\___|_|
S*         |_|
S*/
S
S//Initializes a SpriteF object
Svoid eGFX_InitObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//Initializes a SpriteF object and adds it to the object list
Svoid eGFX_AddObjectSpriteF(eGFX_Obj_SpriteF * S,
S							eGFX_PointF Position,
S							eGFX_ImagePlane *	Sprite
S							);
S
S//draws a spritef onto an image plane
Svoid	eGFX_DrawObject_SpriteF(eGFX_ImagePlane * Image, eGFX_Obj_SpriteF *SpriteF_Object);
S
S/***
S*      ___          _ _       ___   ___          _        _
S*     / __|_ __ _ _(_) |_ ___| __| / __| __ __ _| |___ __| |
S*     \__ \ '_ \ '_| |  _/ -_) _|  \__ \/ _/ _` | / -_) _` |
S*     |___/ .__/_| |_|\__\___|_|   |___/\__\__,_|_\___\__,_|
S*         |_|
S*/
S
S//Initializes a scaled sprited object
Svoid eGFX_InitObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S
S//Initializes a scaled sprited object and adds it to the object list
Svoid eGFX_AddObjectScaledSpriteF(eGFX_Obj_ScaledSpriteF * S,
S	eGFX_PointF Position,
S	eGFX_ImagePlane *	Sprite,
S	float Scale
S	);
S
S//draws a scaled spritef onto an image plane
Svoid	eGFX_DrawObject_ScaledSpriteF(eGFX_ImagePlane * Image, eGFX_Obj_ScaledSpriteF *SpriteF_Object);
S
S
S/***
S*       ___          ___
S*      | _ ) _____ _| __|
S*      | _ \/ _ \ \ / _|
S*      |___/\___/_\_\_|
S*
S*/
S
S
Svoid eGFX_InitObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectBoxF(eGFX_Obj_BoxF * BF,
S	eGFX_PointF P1,
S	eGFX_PointF P2,
S	eGFX_PixelState PS,
S	uint8_t BoxF_RenderOption
S	);
S
S
Svoid	eGFX_DrawObject_BoxF(eGFX_ImagePlane * Image, eGFX_Obj_BoxF *BoxF_Object);
S
S
S/***
S*       ___ _        _     ___
S*      / __(_)_ _ __| |___| __|
S*     | (__| | '_/ _| / -_) _|
S*      \___|_|_| \__|_\___|_|
S*
S*/
S
S
Svoid eGFX_InitObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
S
Svoid eGFX_AddObjectCircleF(eGFX_Obj_CircleF * CF,
S	eGFX_PointF Position,
S	float Radius,
S	eGFX_PixelState PS,
S	uint8_t CircleF_RenderOption
S	);
S
Svoid	eGFX_DrawObject_CircleF(eGFX_ImagePlane * Image, eGFX_Obj_CircleF *CircleF_Object);
S
S
N#endif
N
N
N#ifdef __cplusplus
S }
N#endif
N
L 2 ".\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565.h" 2
N
N#ifndef _MAGNETO__26PX__REGULAR__ANTIALIASGRIDFIT_16BPP_565_H
N#define _MAGNETO__26PX__REGULAR__ANTIALIASGRIDFIT_16BPP_565_H
N
N__attribute__ ((section ("ExtFlashSection"))) extern const eGFX_Font Magneto__26px__Regular__AntiAliasGridFit_16BPP_565;
N
N#endif
N
L 35 "SRC\main.c" 2
N 
N#define SLIDER_REGION_START_X	 85
N#define SLIDER_REGION_STOP_X	 SLIDER_REGION_START_X+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeX
N#define SLIDER_REGION_START_Y  50
N#define SLIDER_REGION_STOP_Y	 (eGFX_PHYSICAL_SCREEN_SIZE_Y - 75)
N
N#define SLIDER2_REGION_START_X	 160
N#define SLIDER2_REGION_STOP_X	 SLIDER2_REGION_START_X+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeX
N#define SLIDER2_REGION_START_Y  50
N#define SLIDER2_REGION_STOP_Y	 (eGFX_PHYSICAL_SCREEN_SIZE_Y - 75)
N
N#define SLIDER3_REGION_START_X	 235
N#define SLIDER3_REGION_STOP_X	 SLIDER3_REGION_START_X+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeX
N#define SLIDER3_REGION_START_Y  50
N#define SLIDER3_REGION_STOP_Y	 (eGFX_PHYSICAL_SCREEN_SIZE_Y - 75)
N
N#define SLIDER4_REGION_START_X	 335
N#define SLIDER4_REGION_STOP_X	 SLIDER4_REGION_START_X+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeX
N#define SLIDER4_REGION_START_Y  50
N#define SLIDER4_REGION_STOP_Y	 (eGFX_PHYSICAL_SCREEN_SIZE_Y - 75)
N
N#define BUTTON_REGION_START_X 	0
N#define BUTTON_REGION_STOP_X		75
N#define BUTTON_REGION_START_Y		0
N#define BUTTON_REGION_STOP_Y		75
N
N#define BUTTON2_REGION_START_X 	(eGFX_PHYSICAL_SCREEN_SIZE_X - 100)
N#define BUTTON2_REGION_STOP_X		eGFX_PHYSICAL_SCREEN_SIZE_X
N#define BUTTON2_REGION_START_Y	0
N#define BUTTON2_REGION_STOP_Y		100
N
N#define BUTTON3_REGION_START_X 	(eGFX_PHYSICAL_SCREEN_SIZE_X - 75)
N#define BUTTON3_REGION_STOP_X		eGFX_PHYSICAL_SCREEN_SIZE_X
N#define BUTTON3_REGION_START_Y	(eGFX_PHYSICAL_SCREEN_SIZE_Y - 75)
N#define BUTTON3_REGION_STOP_Y		eGFX_PHYSICAL_SCREEN_SIZE_Y
N
N#define BUTTON4_REGION_START_X 	0
N#define BUTTON4_REGION_STOP_X		75
N#define BUTTON4_REGION_START_Y	(eGFX_PHYSICAL_SCREEN_SIZE_Y - 75)
N#define BUTTON4_REGION_STOP_Y		eGFX_PHYSICAL_SCREEN_SIZE_Y
N
N#define  BUFFER_SIZE  									 1024
N
Nvolatile float * MicBuffer;					
Nvolatile float * BackgroundMicBuffer; 
N
Nuint32_t BackgroundBufferIdx = 0;     
N
Nvolatile float MicBuffer1[BUFFER_SIZE];  
Xvolatile float MicBuffer1[1024];  
Nvolatile float MicBuffer2[BUFFER_SIZE];
Xvolatile float MicBuffer2[1024];
Nvolatile uint32_t NextBufferReady = 0;
N
Nuint32_t BuffersCaptured = 0;
N
Nint32_t x=10,y=10;
Nint32_t x2=10,y2=10;
Nint32_t x3=10,y3=10;
Nint32_t x4=10,y4=10;
N
Nvoid DMIC0_IRQHandler()
N{
N	int16_t NextSampleIn;
N	
N	if(DMIC0->CHANNEL[1].FIFO_STATUS & DMIC_CHANNEL_FIFO_STATUS_INT_MASK)
X	if(((DMIC_Type *)(0x40090000u))->CHANNEL[1].FIFO_STATUS & (0x1U))
N	{
N		DMIC0->CHANNEL[1].FIFO_STATUS |= DMIC_CHANNEL_FIFO_STATUS_INT_MASK;
X		((DMIC_Type *)(0x40090000u))->CHANNEL[1].FIFO_STATUS |= (0x1U);
N
N		
N		NextSampleIn = (int16_t)(DMIC0->CHANNEL[1].FIFO_DATA);
X		NextSampleIn = (int16_t)(((DMIC_Type *)(0x40090000u))->CHANNEL[1].FIFO_DATA);
N	
N    BackgroundMicBuffer[BackgroundBufferIdx] =  (float)((NextSampleIn))  / 
N((float)(1<<15));
N		
N		BackgroundBufferIdx++;
N
N		if(BackgroundBufferIdx == BUFFER_SIZE)
X		if(BackgroundBufferIdx == 1024)
N		{
N			  
N
N/* Swap Buffers */
N			if(BackgroundMicBuffer == MicBuffer1)
N				{
N					BackgroundMicBuffer = MicBuffer2;
N					MicBuffer = MicBuffer1;
N				}
N				else
N				{
N					BackgroundMicBuffer = MicBuffer1;
N					MicBuffer = MicBuffer2;
N				}
N
N				if(NextBufferReady == 0)
N					NextBufferReady = 1;
N				
N	  		BackgroundBufferIdx=0;
N	  }
N  }
N}
N
Nvoid InitMicBuffers()
N{
N	for (int i=0;i<BUFFER_SIZE;i++)
X	for (int i=0;i<1024;i++)
N	{
N		MicBuffer1[i] = 0;
N		MicBuffer2[i] = 0;
N	}
N
N	MicBuffer = MicBuffer1;
N
N	BackgroundMicBuffer = MicBuffer2;
N
N	NextBufferReady = 0;
N}
N
Narm_rfft_fast_instance_f32 MyFFT;
N
Nfloat	 FFT_RawDataOut[BUFFER_SIZE];
Xfloat	 FFT_RawDataOut[1024];
N
Nfloat  FFT_PowerSpectrum[BUFFER_SIZE];
Xfloat  FFT_PowerSpectrum[1024];
N
N#define TEST1_PORT 4
N#define TEST1_PIN  6
N
N#define TEST2_PORT 3
N#define TEST2_PIN  21
N
Nft5406_handle_t touch_handle;
N   
Ntouch_event_t touch_event;
N
Nenum states {
N	Home,
N	Circles,
N	Shattered,
N	Lines,
N	Equalizer
N} state;
Ntypedef enum states states;
Nstates state;
N
Nint32_t BassSliderPosition = (SLIDER_REGION_STOP_Y + SLIDER_REGION_START_Y)/2;
Xint32_t BassSliderPosition = ((((uint16_t) 272) - 75) + 50)/2;
Nint32_t MidSliderPosition = (SLIDER2_REGION_STOP_Y + SLIDER2_REGION_START_Y)/2;
Xint32_t MidSliderPosition = ((((uint16_t) 272) - 75) + 50)/2;
Nint32_t TrebleSliderPosition = (SLIDER3_REGION_STOP_Y + SLIDER3_REGION_START_Y)/2;
Xint32_t TrebleSliderPosition = ((((uint16_t) 272) - 75) + 50)/2;
Nint32_t VolumeSliderPosition = (SLIDER4_REGION_STOP_Y + SLIDER4_REGION_START_Y)/2;
Xint32_t VolumeSliderPosition = ((((uint16_t) 272) - 75) + 50)/2;
N
Nfloat BassSliderValue;
Nfloat MidSliderValue;
Nfloat TrebleSliderValue;
Nfloat	VolumeSliderValue;
N
N
Nvoid SysTick_Handler()
N{
N	GPIO->NOT[TEST1_PORT] = 1<<TEST1_PIN;
X	((GPIO_Type *)(0x4008C000u))->NOT[4] = 1<<6;
N}
Nvoid HomeScreen()
N{
N		eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
N	
N		eGFX_printf_HorizontalCentered_Colored(&eGFX_BackBuffer,
N											eGFX_PHYSICAL_SCREEN_SIZE_Y/2 - 15, 
X											((uint16_t) 272)/2 - 15, 
N											&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,   
N											eGFX_RGB888_TO_RGB565(255,255,0),
X											( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3)),
N											"fast      ");
N	
N		eGFX_printf_HorizontalCentered_Colored(&eGFX_BackBuffer,
N											eGFX_PHYSICAL_SCREEN_SIZE_Y/2 - 15, 
X											((uint16_t) 272)/2 - 15, 
N											&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,   
N											eGFX_RGB888_TO_RGB565(0,128,0),
X											( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3)),
N											"      Visual");
N
N		eGFX_printf_HorizontalCentered_Colored(&eGFX_BackBuffer,
N											eGFX_PHYSICAL_SCREEN_SIZE_Y/2 + 10, 
X											((uint16_t) 272)/2 + 10, 
N											&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,   
N											eGFX_RGB888_TO_RGB565(255,255,255),
X											( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)),
N											"An Audio Visualizer By The Globetrotters");
N	
N		eGFX_printf_HorizontalCentered_Colored(&eGFX_BackBuffer,
N											10, 
N											&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,   
N											eGFX_RGB888_TO_RGB565(255,255,255),
X											( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)),
N											"Welcome to Home");
N	
N		eGFX_printf_HorizontalCentered_Colored(&eGFX_BackBuffer,
N											(eGFX_PHYSICAL_SCREEN_SIZE_Y-45), 
X											(((uint16_t) 272)-45), 
N											&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,   
N											eGFX_RGB888_TO_RGB565(255,0,0),
X											( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3)),
N											"<-- Click Here For Visualizers -->");
N		// Home Button
N		eGFX_Blit(&eGFX_BackBuffer,
N								eGFX_PHYSICAL_SCREEN_SIZE_X - 60, //x coordinate
X								((uint16_t) 480) - 60, 
N								0,			//y coordinate 
N								&Sprite_16BPP_565_home_icon);
N								
N		// Equalizer Button
N		eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								0,			//y coordinate 
N								&Sprite_16BPP_565_equalizer);
N								
N		// Shattered Button						
N		eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								eGFX_PHYSICAL_SCREEN_SIZE_Y - 60,			//y coordinate 
X								((uint16_t) 272) - 60,			
N								&Sprite_16BPP_565_piramid_silver);
N								
N		// Circles Button
N		eGFX_Blit(&eGFX_BackBuffer,
N								eGFX_PHYSICAL_SCREEN_SIZE_X - 60, //x coordinate
X								((uint16_t) 480) - 60, 
N								eGFX_PHYSICAL_SCREEN_SIZE_Y - 60,			//y coordinate 
X								((uint16_t) 272) - 60,			
N								&Sprite_16BPP_565_whirl_silver);
N								
N							
N	
N		eGFX_Dump(&eGFX_BackBuffer);
N}
N
Nvoid CirclesVisual()
N{			
N	if(NextBufferReady == 1)
N			{
N				
N				GPIO->SET[TEST2_PORT]=1<<TEST2_PIN;
X				((GPIO_Type *)(0x4008C000u))->SET[3]=1<<21;
N	
N				arm_rfft_fast_f32(&MyFFT,
N													  (float *)MicBuffer,
N													  FFT_RawDataOut,0);
N				
N				GPIO->CLR[TEST2_PORT]=1<<TEST2_PIN;
X				((GPIO_Type *)(0x4008C000u))->CLR[3]=1<<21;
N														
N				 arm_cmplx_mag_squared_f32(FFT_RawDataOut,
N																	 FFT_PowerSpectrum,
N																	 BUFFER_SIZE/2
X																	 1024/2
N																	);
N										
N				eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
N														
N/*				// Shattered Button						
N				eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								eGFX_PHYSICAL_SCREEN_SIZE_Y - 60,			//y coordinate 
N								&Sprite_16BPP_565_piramid_silver);
N*/
N				// Equalizer Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								0,			//y coordinate 
N								&Sprite_16BPP_565_equalizer);
N				
N				for(int i=0;i<eGFX_PHYSICAL_SCREEN_SIZE_X;i++)
X				for(int i=0;i<((uint16_t) 480);i++)
N				{
N								float Point1 = (VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/2));
X								float Point1 = (VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/2));
N
N								float Point2 = (VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
X								float Point2 = (VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/2));
N								
N								float Point3 = (VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/1.5));
X								float Point3 = (VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/1.5));
N
N								float Point4 = -(VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5));
X								float Point4 = -(VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/1.5));
N								
N								float Point5 = -(VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/3));
X								float Point5 = -(VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/3));
N
N								float Point6 = (VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/3));
X								float Point6 = (VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/3));
N					
N					if (i < (200/BassSliderValue) && i < (300*BassSliderValue))
N								{eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,      
X												Point1+((uint16_t) 480)/2.0,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.3,      
X												Point1+((uint16_t) 480)/4.3,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/4.3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point2+((uint16_t) 272)/4.3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);			
N								eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.2,      
X												Point1+((uint16_t) 480)/1.2,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.2 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point2+((uint16_t) 272)/1.2 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);			
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point3+eGFX_PHYSICAL_SCREEN_SIZE_X/1.5,
X												Point3+((uint16_t) 480)/1.5,
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point4+((uint16_t) 272)/1.5 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point3+eGFX_PHYSICAL_SCREEN_SIZE_X/3,
X												Point3+((uint16_t) 480)/3,
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point4+((uint16_t) 272)/3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/3,
X												Point5+((uint16_t) 480)/3,
N												Point6+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point6+((uint16_t) 272)/1.5 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/1.5,
X												Point5+((uint16_t) 480)/1.5,
N												Point6+eGFX_PHYSICAL_SCREEN_SIZE_Y/3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point6+((uint16_t) 272)/3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N							eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.3,
X												Point1+((uint16_t) 480)/4.3,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.2 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point2+((uint16_t) 272)/1.2 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.2,
X												Point1+((uint16_t) 480)/1.2,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/4.3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
X												Point2+((uint16_t) 272)/4.3 - FFT_PowerSpectrum[i]/12*BassSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);}
N				else if (i >= (200/MidSliderValue) && i < (400/MidSliderValue))
N								{eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,      
X												Point1+((uint16_t) 480)/2.0,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.3,      
X												Point1+((uint16_t) 480)/4.3,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/4.3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point2+((uint16_t) 272)/4.3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);			
N								eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.2,      
X												Point1+((uint16_t) 480)/1.2,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.2 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point2+((uint16_t) 272)/1.2 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);			
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point3+eGFX_PHYSICAL_SCREEN_SIZE_X/1.5,
X												Point3+((uint16_t) 480)/1.5,
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point4+((uint16_t) 272)/1.5 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point3+eGFX_PHYSICAL_SCREEN_SIZE_X/3,
X												Point3+((uint16_t) 480)/3,
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point4+((uint16_t) 272)/3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/3,
X												Point5+((uint16_t) 480)/3,
N												Point6+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point6+((uint16_t) 272)/1.5 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/1.5,
X												Point5+((uint16_t) 480)/1.5,
N												Point6+eGFX_PHYSICAL_SCREEN_SIZE_Y/3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point6+((uint16_t) 272)/3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N							eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.3,
X												Point1+((uint16_t) 480)/4.3,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.2 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point2+((uint16_t) 272)/1.2 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.2,
X												Point1+((uint16_t) 480)/1.2,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/4.3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
X												Point2+((uint16_t) 272)/4.3 - FFT_PowerSpectrum[i]/12*MidSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);}
N							else if(i >= (400/TrebleSliderValue))
N								{eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,      
X												Point1+((uint16_t) 480)/2.0,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.3,      
X												Point1+((uint16_t) 480)/4.3,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/4.3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point2+((uint16_t) 272)/4.3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);			
N								eGFX_DrawCircle(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.2,      
X												Point1+((uint16_t) 480)/1.2,      
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.2 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point2+((uint16_t) 272)/1.2 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);			
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point3+eGFX_PHYSICAL_SCREEN_SIZE_X/1.5,
X												Point3+((uint16_t) 480)/1.5,
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point4+((uint16_t) 272)/1.5 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point3+eGFX_PHYSICAL_SCREEN_SIZE_X/3,
X												Point3+((uint16_t) 480)/3,
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point4+((uint16_t) 272)/3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/3,
X												Point5+((uint16_t) 480)/3,
N												Point6+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.5 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point6+((uint16_t) 272)/1.5 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/1.5,
X												Point5+((uint16_t) 480)/1.5,
N												Point6+eGFX_PHYSICAL_SCREEN_SIZE_Y/3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point6+((uint16_t) 272)/3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N							eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.3,
X												Point1+((uint16_t) 480)/4.3,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/1.2 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point2+((uint16_t) 272)/1.2 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N								eGFX_DrawCircle(&eGFX_BackBuffer,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.2,
X												Point1+((uint16_t) 480)/1.2,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/4.3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
X												Point2+((uint16_t) 272)/4.3 - FFT_PowerSpectrum[i]/12*TrebleSliderValue,
N												3,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);}
N				}	
N				
N				
N														
N				eGFX_Dump(&eGFX_BackBuffer);
N					
N				NextBufferReady = 0;
N		}
N	}
N
Nvoid ShatteredVisual()
N{
N
N	if(NextBufferReady == 1)
N			{
N				GPIO->SET[TEST2_PORT]=1<<TEST2_PIN;
X				((GPIO_Type *)(0x4008C000u))->SET[3]=1<<21;
N				
N				arm_rfft_fast_f32(&MyFFT,
N													  (float *)MicBuffer,
N													  FFT_RawDataOut,0);
N				
N				GPIO->CLR[TEST2_PORT]=1<<TEST2_PIN;
X				((GPIO_Type *)(0x4008C000u))->CLR[3]=1<<21;
N														
N				 arm_cmplx_mag_squared_f32(FFT_RawDataOut,
N																	 FFT_PowerSpectrum,
N																	 BUFFER_SIZE/2
X																	 1024/2
N																	);
N										
N				 eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
N				
N	/*			// Circles Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								eGFX_PHYSICAL_SCREEN_SIZE_X - 60, //x coordinate
N								eGFX_PHYSICAL_SCREEN_SIZE_Y - 60,			//y coordinate 
N								&Sprite_16BPP_565_whirl_silver);
N											*/			
N				// Equalizer Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								0,			//y coordinate 
N								&Sprite_16BPP_565_equalizer);
N														
N				for(int i=0;i<eGFX_PHYSICAL_SCREEN_SIZE_X;i++)
X				for(int i=0;i<((uint16_t) 480);i++)
N				{
N								float Point1 = (VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/2));
X								float Point1 = (VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/2));
N
N								float Point2 = (VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
X								float Point2 = (VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/2));
N								
N								float Point3 = (VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/1.5));
X								float Point3 = (VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/1.5));
N
N								float Point4 = -(VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
X								float Point4 = -(VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/2));
N								
N								float Point5 = -(VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/2));
X								float Point5 = -(VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/2));
N
N								float Point6 = (VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/3));
X								float Point6 = (VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/3));
N					
N					if (i < (200/BassSliderValue) && i < (300*BassSliderValue))
N								{
N									eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point1+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
X												Point1+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
X												Point1+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*BassSliderValue,																					
N												eGFX_RGB888_TO_RGB565(0,128,0)  												
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))  												
N												);	
N							}		
N					else if (i >= (200/MidSliderValue) && i < (400/MidSliderValue))
N								{
N									
N									eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point1+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,
X												Point2+((uint16_t) 480)/1.33,
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,									
X												Point1+((uint16_t) 480)/1.33,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,
X												Point4+((uint16_t) 480)/1.33,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,									
X												Point5+((uint16_t) 480)/1.33,									
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
X												Point4+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,
X												Point4+((uint16_t) 480)/4.0,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,									
X												Point5+((uint16_t) 480)/4.0,									
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
X												Point4+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,
X												Point4+((uint16_t) 480)/4.0,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,									
X												Point5+((uint16_t) 480)/4.0,									
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
X												Point4+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/12*MidSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,255,0)  												
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))  												
N												);	
N											}
N							else if( i >= (400/TrebleSliderValue))
N								{
N									eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,
X												Point1+((uint16_t) 480)/2.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/2.0,									
X												Point2+((uint16_t) 480)/2.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,
X												Point1+((uint16_t) 480)/1.33,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,									
X												Point2+((uint16_t) 480)/1.33,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,
X												Point4+((uint16_t) 480)/1.33,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/1.33,									
X												Point5+((uint16_t) 480)/1.33,									
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
X												Point5+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);				
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point1+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,
X												Point1+((uint16_t) 480)/4.0,
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,									
X												Point2+((uint16_t) 480)/4.0,									
N												Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
X												Point2+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);	
N								eGFX_DrawHline(&eGFX_BackBuffer,                       
N												Point4+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,
X												Point4+((uint16_t) 480)/4.0,
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_X/4.0,									
X												Point5+((uint16_t) 480)/4.0,									
N												Point5+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
X												Point5+((uint16_t) 272)/2.0 - FFT_PowerSpectrum[i]/15*TrebleSliderValue,																					
N												eGFX_RGB888_TO_RGB565(255,0,0)  												
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))  												
N												);	
N											}
N				}	
N				
N				
N														
N				eGFX_Dump(&eGFX_BackBuffer);
N					
N				NextBufferReady = 0;
N		}
N	}
N
Nvoid LinesVisual()
N{
N	if(NextBufferReady == 1)
N			{
N				GPIO->SET[TEST2_PORT]=1<<TEST2_PIN;
X				((GPIO_Type *)(0x4008C000u))->SET[3]=1<<21;
N				
N				arm_rfft_fast_f32(&MyFFT,
N													  (float *)MicBuffer,
N													  FFT_RawDataOut,0);
N				
N				GPIO->CLR[TEST2_PORT]=1<<TEST2_PIN;
X				((GPIO_Type *)(0x4008C000u))->CLR[3]=1<<21;
N														
N				 arm_cmplx_mag_squared_f32(FFT_RawDataOut,
N																	 FFT_PowerSpectrum,
N																	 BUFFER_SIZE/2
X																	 1024/2
N																	);
N										
N				 eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
N
N				// Equalizer Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								0,			//y coordinate 
N								&Sprite_16BPP_565_equalizer);
N														
N				for(int i=0;i<eGFX_PHYSICAL_SCREEN_SIZE_X;i++)
X				for(int i=0;i<((uint16_t) 480);i++)
N				{
N								float Point1 = (VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/2));
X								float Point1 = (VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/2));
N
N								float Point2 = (VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
X								float Point2 = (VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/2));
N								
N								float Point3 = (VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/1.5));
X								float Point3 = (VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/1.5));
N
N								float Point4 = -(VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
X								float Point4 = -(VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/2));
N								
N								float Point5 = -(VolumeSliderValue*MicBuffer[i-1]*(eGFX_PHYSICAL_SCREEN_SIZE_X/2));
X								float Point5 = -(VolumeSliderValue*MicBuffer[i-1]*(((uint16_t) 480)/2));
N
N								float Point6 = (VolumeSliderValue*MicBuffer[i]*(eGFX_PHYSICAL_SCREEN_SIZE_Y/3));
X								float Point6 = (VolumeSliderValue*MicBuffer[i]*(((uint16_t) 272)/3));
N					
N					if (i < (200/BassSliderValue) && i < (300*BassSliderValue))   			
N
N								{eGFX_DrawLine(&eGFX_BackBuffer, 
N												i-1, Point1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2, 
X												i-1, Point1+((uint16_t) 272)/2, 
N												i,   Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2,
X												i,   Point2+((uint16_t) 272)/2,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N									eGFX_DrawLine(&eGFX_BackBuffer, 
N												i-1, Point3+eGFX_PHYSICAL_SCREEN_SIZE_Y/2, 
X												i-1, Point3+((uint16_t) 272)/2, 
N												i,   Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/2,
X												i,   Point4+((uint16_t) 272)/2,
N												eGFX_RGB888_TO_RGB565(0,128,0)
X												( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))
N												);
N								}
N				else if (i >= (200/MidSliderValue) && i < (400/MidSliderValue)) 
N
N								{eGFX_DrawLine(&eGFX_BackBuffer, 
N												i-1, Point1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2, 
X												i-1, Point1+((uint16_t) 272)/2, 
N												i,   Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2,
X												i,   Point2+((uint16_t) 272)/2,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N									eGFX_DrawLine(&eGFX_BackBuffer, 
N												i-1, Point3+eGFX_PHYSICAL_SCREEN_SIZE_Y/2, 
X												i-1, Point3+((uint16_t) 272)/2, 
N												i,   Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/2,
X												i,   Point4+((uint16_t) 272)/2,
N												eGFX_RGB888_TO_RGB565(255,255,0)
X												( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3))
N												);
N								}
N							else if (i >= (400/TrebleSliderValue))
N								{eGFX_DrawLine(&eGFX_BackBuffer, 
N												i-1, Point1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2, 
X												i-1, Point1+((uint16_t) 272)/2, 
N												i,   Point2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2,
X												i,   Point2+((uint16_t) 272)/2,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N									eGFX_DrawLine(&eGFX_BackBuffer, 
N												i-1, Point3+eGFX_PHYSICAL_SCREEN_SIZE_Y/2, 
X												i-1, Point3+((uint16_t) 272)/2, 
N												i,   Point4+eGFX_PHYSICAL_SCREEN_SIZE_Y/2,
X												i,   Point4+((uint16_t) 272)/2,
N												eGFX_RGB888_TO_RGB565(255,0,0)
X												( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3))
N												);
N								
N								}
N
N											}
N				}	
N				
N				
N														
N				eGFX_Dump(&eGFX_BackBuffer);
N					
N				NextBufferReady = 0;
N		}
N
N
Nvoid EqualizerScreen()
N{
N
N	  eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
N				
N     if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y, &x))
N        {
N         if (touch_event == kTouch_Contact)
N            {
N							  if(	 x>=SLIDER_REGION_START_X && x<=SLIDER_REGION_STOP_X 
X							  if(	 x>=85 && x<=85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX 
N									&& y>SLIDER_REGION_START_Y && y<= SLIDER_REGION_STOP_Y)
X									&& y>50 && y<= (((uint16_t) 272) - 75))
N								{
N										BassSliderPosition = y;
N								}
N            }
N        }
N				
N			if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y2, &x2))
N        {
N            if (touch_event == kTouch_Contact)
N            {
N							if(	 x2>=SLIDER2_REGION_START_X && x2<=SLIDER2_REGION_STOP_X 
X							if(	 x2>=160 && x2<=160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX 
N									&& y2>SLIDER2_REGION_START_Y && y2<= SLIDER2_REGION_STOP_Y)
X									&& y2>50 && y2<= (((uint16_t) 272) - 75))
N								{
N										MidSliderPosition = y2;
N								}
N            }
N        }
N				
N			if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y3, &x3))
N        {
N            if (touch_event == kTouch_Contact)
N            {
N							  if(	 x3>=SLIDER3_REGION_START_X && x3<=SLIDER3_REGION_STOP_X 
X							  if(	 x3>=235 && x3<=235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX 
N									&& y3>SLIDER3_REGION_START_Y && y3<= SLIDER3_REGION_STOP_Y)
X									&& y3>50 && y3<= (((uint16_t) 272) - 75))
N								{
N										TrebleSliderPosition = y3;
N								}
N            }
N        }
N				
N			if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y4, &x4))
N        {
N            if (touch_event == kTouch_Contact)
N            {
N							  if(	 x4>=SLIDER4_REGION_START_X && x4<=SLIDER4_REGION_STOP_X 
X							  if(	 x4>=335 && x4<=335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX 
N									&& y4>SLIDER4_REGION_START_Y && y4<= SLIDER4_REGION_STOP_Y)
X									&& y4>50 && y4<= (((uint16_t) 272) - 75))
N								{
N										VolumeSliderPosition = y4;
N								}
N            }
N        }
N				
N				eGFX_printf_HorizontalCentered_Colored(&eGFX_BackBuffer,
N											eGFX_PHYSICAL_SCREEN_SIZE_Y-20, 
X											((uint16_t) 272)-20, 
N											&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,   
N											eGFX_RGB888_TO_RGB565(255,255,255),
X											( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)),
N											"Equalizer");
N				
N				// Home Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								eGFX_PHYSICAL_SCREEN_SIZE_X-60, // x coordinate
X								((uint16_t) 480)-60, 
N								0,			//y coordinate 
N								&Sprite_16BPP_565_home_icon);
N				
N				// Shattered Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								10, //x coordinate
N								eGFX_PHYSICAL_SCREEN_SIZE_Y - 60,			//y coordinate 
X								((uint16_t) 272) - 60,			
N								&Sprite_16BPP_565_piramid_silver);
N				
N				// Circles Button
N				eGFX_Blit(&eGFX_BackBuffer,
N								eGFX_PHYSICAL_SCREEN_SIZE_X - 60, //x coordinate
X								((uint16_t) 480) - 60, 
N								eGFX_PHYSICAL_SCREEN_SIZE_Y - 60,			//y coordinate 
X								((uint16_t) 272) - 60,			
N								&Sprite_16BPP_565_whirl_silver);
N
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER_REGION_STOP_X/2 - 12),(SLIDER_REGION_START_Y - 40), 
X				eGFX_printf(&eGFX_BackBuffer,(85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),(50 - 40), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", BassSliderValue,eGFX_RGB888_TO_RGB565(0,128,0)); 
X				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", BassSliderValue,( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3))); 
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER2_REGION_STOP_X/2 - 12),(SLIDER2_REGION_START_Y - 40), 
X				eGFX_printf(&eGFX_BackBuffer,(160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),(50 - 40), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", MidSliderValue,eGFX_RGB888_TO_RGB565(255,255,0));
X				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", MidSliderValue,( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3)));
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER3_REGION_STOP_X/2 - 12),(SLIDER3_REGION_START_Y - 40), 
X				eGFX_printf(&eGFX_BackBuffer,(235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),(50 - 40), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", TrebleSliderValue,eGFX_RGB888_TO_RGB565(255,0,0));
X				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", TrebleSliderValue,( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3)));
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER4_REGION_STOP_X/2 - 12),(SLIDER4_REGION_START_Y - 40), 
X				eGFX_printf(&eGFX_BackBuffer,(335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),(50 - 40), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", VolumeSliderValue,eGFX_RGB888_TO_RGB565(0,0,255));
X				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"%.2f", VolumeSliderValue,( ((0>>2)<<11) | ((0>>2)<<5) | (255>>3)));
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER_REGION_STOP_X/2 - 12),(SLIDER_REGION_STOP_Y + 30), 
X				eGFX_printf(&eGFX_BackBuffer,(85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),((((uint16_t) 272) - 75) + 30), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"Low", BassSliderValue); 
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER2_REGION_STOP_X/2 - 12),(SLIDER2_REGION_STOP_Y + 30), 
X				eGFX_printf(&eGFX_BackBuffer,(160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),((((uint16_t) 272) - 75) + 30), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"Mid", MidSliderValue);
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER3_REGION_STOP_X/2 - 12),(SLIDER3_REGION_STOP_Y + 30), 
X				eGFX_printf(&eGFX_BackBuffer,(235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),((((uint16_t) 272) - 75) + 30), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"High", TrebleSliderValue);
N				
N				eGFX_printf(&eGFX_BackBuffer,(SLIDER4_REGION_STOP_X/2 - 12),(SLIDER4_REGION_STOP_Y + 30), 
X				eGFX_printf(&eGFX_BackBuffer,(335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX/2 - 12),((((uint16_t) 272) - 75) + 30), 
N				&OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP,"Vol");
N				
N				BassSliderValue =  (float)(SLIDER_REGION_STOP_Y - BassSliderPosition)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);
X				BassSliderValue =  (float)((((uint16_t) 272) - 75) - BassSliderPosition)/(float)((((uint16_t) 272) - 75)-50);
N				MidSliderValue =  (float)(SLIDER2_REGION_STOP_Y - MidSliderPosition)/(float)(SLIDER2_REGION_STOP_Y-SLIDER2_REGION_START_Y);
X				MidSliderValue =  (float)((((uint16_t) 272) - 75) - MidSliderPosition)/(float)((((uint16_t) 272) - 75)-50);
N				TrebleSliderValue =  (float)(SLIDER3_REGION_STOP_Y - TrebleSliderPosition)/(float)(SLIDER3_REGION_STOP_Y-SLIDER3_REGION_START_Y);
X				TrebleSliderValue =  (float)((((uint16_t) 272) - 75) - TrebleSliderPosition)/(float)((((uint16_t) 272) - 75)-50);
N				VolumeSliderValue =  (float)(SLIDER4_REGION_STOP_Y - VolumeSliderPosition)/(float)(SLIDER4_REGION_STOP_Y-SLIDER4_REGION_START_Y);
X				VolumeSliderValue =  (float)((((uint16_t) 272) - 75) - VolumeSliderPosition)/(float)((((uint16_t) 272) - 75)-50);
N	
N				eGFX_Box SliderFillBox;
N
N				SliderFillBox.P1.Y = BassSliderPosition;  
N				SliderFillBox.P1.X = (SLIDER_REGION_STOP_X+SLIDER_REGION_START_X)/2 - 5;
X				SliderFillBox.P1.X = (85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+85)/2 - 5;
N				SliderFillBox.P2.Y = SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
X				SliderFillBox.P2.Y = (((uint16_t) 272) - 75) + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
N				SliderFillBox.P2.X = (SLIDER_REGION_STOP_X+SLIDER_REGION_START_X)/2 + 5;
X				SliderFillBox.P2.X = (85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+85)/2 + 5;
N				
N				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox,eGFX_RGB888_TO_RGB565(0,128,0));
X				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox,( ((0>>2)<<11) | ((128>>2)<<5) | (0>>3)));
N								
N				eGFX_Blit(&eGFX_BackBuffer,
N								SLIDER_REGION_START_X,
X								85,
N								BassSliderPosition - Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2 + 1,																			 //y coordinate 
N								&Sprite_16BPP_565_Mushroom_Super_icon_red);																								
N			
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER_REGION_START_Y,SLIDER_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,85-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,SLIDER_REGION_START_Y,SLIDER_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,50,85-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER_REGION_START_Y,SLIDER_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,SLIDER_REGION_START_Y,SLIDER_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,50,85+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				
N				// Band 2 - Yellow
N				
N				eGFX_Box SliderFillBox2;
N
N				SliderFillBox2.P1.Y = MidSliderPosition;   
N				SliderFillBox2.P1.X = (SLIDER2_REGION_STOP_X+SLIDER2_REGION_START_X)/2 - 5;
X				SliderFillBox2.P1.X = (160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+160)/2 - 5;
N				SliderFillBox2.P2.Y = SLIDER2_REGION_STOP_Y + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
X				SliderFillBox2.P2.Y = (((uint16_t) 272) - 75) + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
N				SliderFillBox2.P2.X = (SLIDER2_REGION_STOP_X+SLIDER2_REGION_START_X)/2 + 5;
X				SliderFillBox2.P2.X = (160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+160)/2 + 5;
N				
N				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox2,eGFX_RGB888_TO_RGB565(255,255,0));
X				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox2,( ((255>>2)<<11) | ((255>>2)<<5) | (0>>3)));
N								
N				eGFX_Blit(&eGFX_BackBuffer,
N								SLIDER2_REGION_START_X,
X								160,
N								MidSliderPosition - Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2 + 1,																			 //y coordinate of where to put the monkey head
N								&Sprite_16BPP_565_Mushroom_Super_icon_red);																								
N			
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER2_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER2_REGION_START_Y,SLIDER2_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,160-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER2_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,SLIDER2_REGION_START_Y,SLIDER2_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,50,160-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER2_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER2_REGION_START_Y,SLIDER2_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER2_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,SLIDER2_REGION_START_Y,SLIDER2_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,50,160+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				
N				// Band 3 - Red				
N				eGFX_Box SliderFillBox3;
N
N				SliderFillBox3.P1.Y = TrebleSliderPosition;   
N				SliderFillBox3.P1.X = (SLIDER3_REGION_STOP_X+SLIDER3_REGION_START_X)/2 - 5;
X				SliderFillBox3.P1.X = (235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+235)/2 - 5;
N				SliderFillBox3.P2.Y = SLIDER3_REGION_STOP_Y + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
X				SliderFillBox3.P2.Y = (((uint16_t) 272) - 75) + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
N				SliderFillBox3.P2.X = (SLIDER3_REGION_STOP_X+SLIDER3_REGION_START_X)/2 + 5;
X				SliderFillBox3.P2.X = (235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+235)/2 + 5;
N				
N				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox3,eGFX_RGB888_TO_RGB565(255,0,0));
X				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox3,( ((255>>2)<<11) | ((0>>2)<<5) | (0>>3)));
N								
N				eGFX_Blit(&eGFX_BackBuffer,
N								SLIDER3_REGION_START_X,
X								235,
N								TrebleSliderPosition - Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2 + 1,																			 //y coordinate of where to put the monkey head
N								&Sprite_16BPP_565_Mushroom_Super_icon_red);																								
N			
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER3_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER3_REGION_START_Y,SLIDER3_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,235-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER3_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,SLIDER3_REGION_START_Y,SLIDER3_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,50,235-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER3_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER3_REGION_START_Y,SLIDER3_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER3_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,SLIDER3_REGION_START_Y,SLIDER3_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,50,235+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N			  
N				// Band 4 - Volume - Blue
N				
N				eGFX_Box SliderFillBox4;
N
N				SliderFillBox4.P1.Y = VolumeSliderPosition;   
N				SliderFillBox4.P1.X = (SLIDER4_REGION_STOP_X+SLIDER4_REGION_START_X)/2 - 5;
X				SliderFillBox4.P1.X = (335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+335)/2 - 5;
N				SliderFillBox4.P2.Y = SLIDER4_REGION_STOP_Y + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
X				SliderFillBox4.P2.Y = (((uint16_t) 272) - 75) + Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2;
N				SliderFillBox4.P2.X = (SLIDER4_REGION_STOP_X+SLIDER4_REGION_START_X)/2 + 5;
X				SliderFillBox4.P2.X = (335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+335)/2 + 5;
N				
N				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox4,eGFX_RGB888_TO_RGB565(0,0,255));
X				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox4,( ((0>>2)<<11) | ((0>>2)<<5) | (255>>3)));
N								
N				eGFX_Blit(&eGFX_BackBuffer,
N								SLIDER4_REGION_START_X,
X								335,
N								VolumeSliderPosition - Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2 + 1,																			 //y coordinate of where to put the monkey head
N								&Sprite_16BPP_565_Mushroom_Super_icon_red);																								
N			
N			
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER4_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER4_REGION_START_Y,SLIDER4_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,335-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER4_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,SLIDER4_REGION_START_Y,SLIDER4_REGION_START_X-5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2+1,50,335-5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER4_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,SLIDER4_REGION_START_Y,SLIDER4_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2,50,335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER4_REGION_STOP_Y+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,SLIDER4_REGION_START_Y,SLIDER4_REGION_STOP_X+5,eGFX_RGB888_TO_RGB565(255,255,255));
X				eGFX_DrawVline(&eGFX_BackBuffer,(((uint16_t) 272) - 75)+Sprite_16BPP_565_Mushroom_Super_icon_red.SizeY/2-1,50,335+Sprite_16BPP_565_Mushroom_Super_icon_red . SizeX+5,( ((255>>2)<<11) | ((255>>2)<<5) | (255>>3)));
N				eGFX_Dump(&eGFX_BackBuffer);
N	}
Nint main(void)
N{
N		CLOCK_EnableClock(kCLOCK_InputMux);
N		
N    CLOCK_EnableClock(kCLOCK_Iocon);
N	
N    CLOCK_EnableClock(kCLOCK_Gpio0);
N  
N    CLOCK_EnableClock(kCLOCK_Gpio1);
N		
N    CLOCK_EnableClock(kCLOCK_Gpio2);
N  
N    CLOCK_EnableClock(kCLOCK_Gpio3);
N			
N    CLOCK_EnableClock(kCLOCK_Gpio4);
N
N    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);
X    CLOCK_AttachClk(kFRO12M_to_FLEXCOMM0);
N
N    BOARD_InitPins();
N	
N    BOARD_BootClock_PLL_RUN();
N  
N    BOARD_InitDebugConsole();
N		
N		BOARD_InitSPIFI_ExternalFlash();
N
N		BOARD_InitSDRAM();
N
N		eGFX_InitDriver();
N
N    InitMicBuffers();
N
N   	Init_DMIC();
N	
N	  IOCON_PinMuxSet(IOCON, TEST1_PORT, TEST1_PIN, IOCON_FUNC0 |
X	  IOCON_PinMuxSet(((IOCON_Type *)(0x40001000u)), 4, 6, 0x0 |
N		IOCON_MODE_INACT| IOCON_DIGITAL_EN);
X		(0x0 << 4)| (0x1 << 8));
N
N    IOCON_PinMuxSet(IOCON, TEST2_PORT, TEST2_PIN, IOCON_FUNC0 |
X    IOCON_PinMuxSet(((IOCON_Type *)(0x40001000u)), 3, 21, 0x0 |
N		IOCON_MODE_INACT| IOCON_DIGITAL_EN);
X		(0x0 << 4)| (0x1 << 8));
N		
N    GPIO->DIR[TEST1_PORT] |= 1<<TEST1_PIN;
X    ((GPIO_Type *)(0x4008C000u))->DIR[4] |= 1<<6;
N	 
N	  GPIO->DIR[TEST2_PORT] |= 1<<TEST2_PIN;
X	  ((GPIO_Type *)(0x4008C000u))->DIR[3] |= 1<<21;
N	 
N	  SysTick_Config(SystemCoreClock/1000);
N
N	  arm_rfft_fast_init_f32(&MyFFT,1024);
N		
N		FT5406_Init(&touch_handle,I2C2);
X		FT5406_Init(&touch_handle,((I2C_Type *)(0x40088000u)));
N		
N		int32_t x5=10,y5=10;
N		int32_t x6=10,y6=10;
N		int32_t x7=10,y7=10;
N		int32_t x8=10,y8=10;
N
N	while(1)
N	{
N		
N		// Top Left Button
N		if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y5, &x5))
N						{
N							if (touch_event == kTouch_Down || touch_event == kTouch_Up)
N											{
N										if(	 x5>=BUTTON_REGION_START_X && x5<=BUTTON_REGION_STOP_X
X										if(	 x5>=0 && x5<=75
N														&& y5>BUTTON_REGION_START_Y && y5<=BUTTON_REGION_STOP_Y) // Top Left Corner
X														&& y5>0 && y5<=75) 
N														{
N																state = Equalizer;
N														
N														}
N											}
N							}
N						
N	// Top Right Button
N		if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y6, &x6))
N						{
N							if (touch_event == kTouch_Down || touch_event == kTouch_Up)
N											{
N										if(	 x6>=BUTTON2_REGION_START_X && x6<=BUTTON2_REGION_STOP_X
X										if(	 x6>=(((uint16_t) 480) - 100) && x6<=((uint16_t) 480)
N														&& y6>BUTTON2_REGION_START_Y && y6<=BUTTON2_REGION_STOP_Y)
X														&& y6>0 && y6<=100)
N														{
N																state = Home;
N														}
N											}
N							}
N						
N		// Bottom Right Button		
N		if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y7, &x7))
N						{
N							if (touch_event == kTouch_Down || touch_event == kTouch_Up)
N											{
N										if(	 x7>=BUTTON3_REGION_START_X && x7<=BUTTON3_REGION_STOP_X
X										if(	 x7>=(((uint16_t) 480) - 75) && x7<=((uint16_t) 480)
N														&& y7>BUTTON3_REGION_START_Y && y7<=BUTTON3_REGION_STOP_Y)
X														&& y7>(((uint16_t) 272) - 75) && y7<=((uint16_t) 272))
N														{
N																state = Circles;
N														}
N											}
N							}
N						
N		// Bottom Left Button
N		if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y8, &x8))
N						{
N							if (touch_event == kTouch_Down || touch_event == kTouch_Up)
N											{
N										if(	 x8>=BUTTON4_REGION_START_X && x8<=BUTTON4_REGION_STOP_X
X										if(	 x8>=0 && x8<=75
N														&& y8>BUTTON4_REGION_START_Y && y8<=BUTTON4_REGION_STOP_Y)
X														&& y8>(((uint16_t) 272) - 75) && y8<=((uint16_t) 272))
N														{
N																state = Shattered;
N														}
N											}
N							}
N						
N		if(state == Home){
N			HomeScreen();
N		}
N		if(state == Circles){
N			CirclesVisual();
N		}
N		if(state == Shattered){
N			ShatteredVisual();
N		}
N		if(state == Lines){
N			LinesVisual();
N		}
N		if(state == Equalizer){
N			EqualizerScreen();
N		} 
N		
N		}
N
N}
N
