; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_spifi_dma.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_spifi_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_spifi_dma.crf SRC\Drivers\fsl_spifi_dma.c]
                          THUMB

                          AREA ||i.SPIFI_EnableDMA||, CODE, READONLY, ALIGN=1

                  SPIFI_EnableDMA PROC
;;;318     */
;;;319    static inline void SPIFI_EnableDMA(SPIFI_Type *base, bool enable)
000000  b121              CBZ      r1,|L1.12|
;;;320    {
;;;321        if (enable)
;;;322        {
;;;323            base->CTRL |= SPIFI_CTRL_DMAEN_MASK;
000002  6802              LDR      r2,[r0,#0]
000004  f0424200          ORR      r2,r2,#0x80000000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L1.20|
                  |L1.12|
;;;324        }
;;;325        else
;;;326        {
;;;327            base->CTRL &= ~SPIFI_CTRL_DMAEN_MASK;
00000c  6802              LDR      r2,[r0,#0]
00000e  f0224200          BIC      r2,r2,#0x80000000
000012  6002              STR      r2,[r0,#0]
                  |L1.20|
;;;328        }
;;;329    }
000014  4770              BX       lr
;;;330    
                          ENDP


                          AREA ||i.SPIFI_ReceiveDMACallback||, CODE, READONLY, ALIGN=1

                  SPIFI_ReceiveDMACallback PROC
;;;115    
;;;116    static void SPIFI_ReceiveDMACallback(dma_handle_t *handle, void *param, bool transferDone, uint32_t intmode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;117    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;118        spifi_dma_private_handle_t *spifiPrivateHandle = (spifi_dma_private_handle_t *)param;
00000c  4634              MOV      r4,r6
;;;119    
;;;120        /* Avoid warning for unused parameters. */
;;;121        handle = handle;
00000e  bf00              NOP      
;;;122        intmode = intmode;
000010  bf00              NOP      
;;;123    
;;;124        if (transferDone)
000012  b17f              CBZ      r7,|L2.52|
;;;125        {
;;;126            /* Disable transfer. */
;;;127            SPIFI_TransferAbortReceiveDMA(spifiPrivateHandle->base, spifiPrivateHandle->handle);
000014  e9d40100          LDRD     r0,r1,[r4,#0]
000018  f7fffffe          BL       SPIFI_TransferAbortReceiveDMA
;;;128    
;;;129            if (spifiPrivateHandle->handle->callback)
00001c  6860              LDR      r0,[r4,#4]
00001e  68c0              LDR      r0,[r0,#0xc]
000020  b140              CBZ      r0,|L2.52|
;;;130            {
;;;131                spifiPrivateHandle->handle->callback(spifiPrivateHandle->base, spifiPrivateHandle->handle,
000022  6862              LDR      r2,[r4,#4]
000024  4611              MOV      r1,r2
000026  6913              LDR      r3,[r2,#0x10]
000028  6820              LDR      r0,[r4,#0]
00002a  f8d2c00c          LDR      r12,[r2,#0xc]
00002e  f2417270          MOV      r2,#0x1770
000032  47e0              BLX      r12
                  |L2.52|
;;;132                                                     kStatus_SPIFI_Idle, spifiPrivateHandle->handle->userData);
;;;133            }
;;;134        }
;;;135    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP


                          AREA ||i.SPIFI_SendDMACallback||, CODE, READONLY, ALIGN=1

                  SPIFI_SendDMACallback PROC
;;;95     
;;;96     static void SPIFI_SendDMACallback(dma_handle_t *handle, void *param, bool transferDone, uint32_t intmode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;97     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;98         spifi_dma_private_handle_t *spifiPrivateHandle = (spifi_dma_private_handle_t *)param;
00000c  4634              MOV      r4,r6
;;;99     
;;;100        /* Avoid the warning for unused variables. */
;;;101        handle = handle;
00000e  bf00              NOP      
;;;102        intmode = intmode;
000010  bf00              NOP      
;;;103    
;;;104        if (transferDone)
000012  b17f              CBZ      r7,|L3.52|
;;;105        {
;;;106            SPIFI_TransferAbortSendDMA(spifiPrivateHandle->base, spifiPrivateHandle->handle);
000014  e9d40100          LDRD     r0,r1,[r4,#0]
000018  f7fffffe          BL       SPIFI_TransferAbortSendDMA
;;;107    
;;;108            if (spifiPrivateHandle->handle->callback)
00001c  6860              LDR      r0,[r4,#4]
00001e  68c0              LDR      r0,[r0,#0xc]
000020  b140              CBZ      r0,|L3.52|
;;;109            {
;;;110                spifiPrivateHandle->handle->callback(spifiPrivateHandle->base, spifiPrivateHandle->handle,
000022  6862              LDR      r2,[r4,#4]
000024  4611              MOV      r1,r2
000026  6913              LDR      r3,[r2,#0x10]
000028  6820              LDR      r0,[r4,#0]
00002a  f8d2c00c          LDR      r12,[r2,#0xc]
00002e  f2417270          MOV      r2,#0x1770
000032  47e0              BLX      r12
                  |L3.52|
;;;111                                                     kStatus_SPIFI_Idle, spifiPrivateHandle->handle->userData);
;;;112            }
;;;113        }
;;;114    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;115    
                          ENDP


                          AREA ||i.SPIFI_TransferAbortReceiveDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferAbortReceiveDMA PROC
;;;265    
;;;266    void SPIFI_TransferAbortReceiveDMA(SPIFI_Type *base, spifi_dma_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;268        assert(handle && (handle->dmaHandle));
000006  b114              CBZ      r4,|L4.14|
000008  6820              LDR      r0,[r4,#0]
00000a  b100              CBZ      r0,|L4.14|
00000c  e005              B        |L4.26|
                  |L4.14|
00000e  f44f7286          MOV      r2,#0x10c
000012  a107              ADR      r1,|L4.48|
000014  a00d              ADR      r0,|L4.76|
000016  f7fffffe          BL       __aeabi_assert
                  |L4.26|
;;;269    
;;;270        /* Disable SPIFI RX DMA. */
;;;271        SPIFI_EnableDMA(base, false);
00001a  2100              MOVS     r1,#0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       SPIFI_EnableDMA
;;;272    
;;;273        /* Stop transfer. */
;;;274        DMA_AbortTransfer(handle->dmaHandle);
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       DMA_AbortTransfer
;;;275    
;;;276        handle->state = kSPIFI_Idle;
000028  2000              MOVS     r0,#0
00002a  60a0              STR      r0,[r4,#8]
;;;277    }
00002c  bd70              POP      {r4-r6,pc}
;;;278    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
000030  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000034  44726976
000038  6572735c
00003c  66736c5f
000040  73706966
000044  695f646d
000048  612e6300
                  |L4.76|
00004c  68616e64          DCB      "handle && (handle->dmaHandle)",0
000050  6c652026
000054  26202868
000058  616e646c
00005c  652d3e64
000060  6d614861
000064  6e646c65
000068  2900    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.SPIFI_TransferAbortSendDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferAbortSendDMA PROC
;;;252    
;;;253    void SPIFI_TransferAbortSendDMA(SPIFI_Type *base, spifi_dma_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;255        assert(handle && (handle->dmaHandle));
000006  b114              CBZ      r4,|L5.14|
000008  6820              LDR      r0,[r4,#0]
00000a  b100              CBZ      r0,|L5.14|
00000c  e004              B        |L5.24|
                  |L5.14|
00000e  22ff              MOVS     r2,#0xff
000010  a106              ADR      r1,|L5.44|
000012  a00d              ADR      r0,|L5.72|
000014  f7fffffe          BL       __aeabi_assert
                  |L5.24|
;;;256    
;;;257        /* Disable SPIFI TX DMA. */
;;;258        SPIFI_EnableDMA(base, false);
000018  2100              MOVS     r1,#0
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       SPIFI_EnableDMA
;;;259    
;;;260        /* Stop transfer. */
;;;261        DMA_AbortTransfer(handle->dmaHandle);
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       DMA_AbortTransfer
;;;262    
;;;263        handle->state = kSPIFI_Idle;
000026  2000              MOVS     r0,#0
000028  60a0              STR      r0,[r4,#8]
;;;264    }
00002a  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

                  |L5.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  73706966
000040  695f646d
000044  612e6300
                  |L5.72|
000048  68616e64          DCB      "handle && (handle->dmaHandle)",0
00004c  6c652026
000050  26202868
000054  616e646c
000058  652d3e64
00005c  6d614861
000060  6e646c65
000064  2900    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.SPIFI_TransferGetReceiveCountDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferGetReceiveCountDMA PROC
;;;296    
;;;297    status_t SPIFI_TransferGetReceiveCountDMA(SPIFI_Type *base, spifi_dma_handle_t *handle, size_t *count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;298    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;299        assert(handle);
00000a  b104              CBZ      r4,|L6.14|
00000c  e005              B        |L6.26|
                  |L6.14|
00000e  f240122b          MOV      r2,#0x12b
000012  a10a              ADR      r1,|L6.60|
000014  a010              ADR      r0,|L6.88|
000016  f7fffffe          BL       __aeabi_assert
                  |L6.26|
;;;300    
;;;301        status_t status = kStatus_Success;
00001a  2600              MOVS     r6,#0
;;;302    
;;;303        if (handle->state != kSPIFI_BusBusy)
00001c  68a0              LDR      r0,[r4,#8]
00001e  2801              CMP      r0,#1
000020  d001              BEQ      |L6.38|
;;;304        {
;;;305            status = kStatus_NoTransferInProgress;
000022  2606              MOVS     r6,#6
000024  e007              B        |L6.54|
                  |L6.38|
;;;306        }
;;;307        else
;;;308        {
;;;309            *count = handle->transferSize - DMA_GetRemainingBytes(handle->dmaHandle->base, handle->dmaHandle->channel);
000026  6822              LDR      r2,[r4,#0]
000028  7b11              LDRB     r1,[r2,#0xc]
00002a  6890              LDR      r0,[r2,#8]
00002c  f7fffffe          BL       DMA_GetRemainingBytes
000030  6861              LDR      r1,[r4,#4]
000032  1a08              SUBS     r0,r1,r0
000034  6028              STR      r0,[r5,#0]
                  |L6.54|
;;;310        }
;;;311    
;;;312        return status;
000036  4630              MOV      r0,r6
;;;313    }
000038  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L6.60|
00003c  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000040  44726976
000044  6572735c
000048  66736c5f
00004c  73706966
000050  695f646d
000054  612e6300
                  |L6.88|
000058  68616e64          DCB      "handle",0
00005c  6c6500  
00005f  00                DCB      0

                          AREA ||i.SPIFI_TransferGetSendCountDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferGetSendCountDMA PROC
;;;278    
;;;279    status_t SPIFI_TransferGetSendCountDMA(SPIFI_Type *base, spifi_dma_handle_t *handle, size_t *count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;280    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;281        assert(handle);
00000a  b104              CBZ      r4,|L7.14|
00000c  e005              B        |L7.26|
                  |L7.14|
00000e  f2401219          MOV      r2,#0x119
000012  a10a              ADR      r1,|L7.60|
000014  a010              ADR      r0,|L7.88|
000016  f7fffffe          BL       __aeabi_assert
                  |L7.26|
;;;282    
;;;283        status_t status = kStatus_Success;
00001a  2600              MOVS     r6,#0
;;;284    
;;;285        if (handle->state != kSPIFI_BusBusy)
00001c  68a0              LDR      r0,[r4,#8]
00001e  2801              CMP      r0,#1
000020  d001              BEQ      |L7.38|
;;;286        {
;;;287            status = kStatus_NoTransferInProgress;
000022  2606              MOVS     r6,#6
000024  e007              B        |L7.54|
                  |L7.38|
;;;288        }
;;;289        else
;;;290        {
;;;291            *count = handle->transferSize - DMA_GetRemainingBytes(handle->dmaHandle->base, handle->dmaHandle->channel);
000026  6822              LDR      r2,[r4,#0]
000028  7b11              LDRB     r1,[r2,#0xc]
00002a  6890              LDR      r0,[r2,#8]
00002c  f7fffffe          BL       DMA_GetRemainingBytes
000030  6861              LDR      r1,[r4,#4]
000032  1a08              SUBS     r0,r1,r0
000034  6028              STR      r0,[r5,#0]
                  |L7.54|
;;;292        }
;;;293    
;;;294        return status;
000036  4630              MOV      r0,r6
;;;295    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;296    
                          ENDP

                  |L7.60|
00003c  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000040  44726976
000044  6572735c
000048  66736c5f
00004c  73706966
000050  695f646d
000054  612e6300
                  |L7.88|
000058  68616e64          DCB      "handle",0
00005c  6c6500  
00005f  00                DCB      0

                          AREA ||i.SPIFI_TransferReceiveDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferReceiveDMA PROC
;;;219    
;;;220    status_t SPIFI_TransferReceiveDMA(SPIFI_Type *base, spifi_dma_handle_t *handle, spifi_transfer_t *xfer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
000004  b08a              SUB      sp,sp,#0x28
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
;;;222        assert(handle && (handle->dmaHandle));
00000c  b114              CBZ      r4,|L8.20|
00000e  6820              LDR      r0,[r4,#0]
000010  b100              CBZ      r0,|L8.20|
000012  e004              B        |L8.30|
                  |L8.20|
000014  22de              MOVS     r2,#0xde
000016  a116              ADR      r1,|L8.112|
000018  a01c              ADR      r0,|L8.140|
00001a  f7fffffe          BL       __aeabi_assert
                  |L8.30|
;;;223    
;;;224        dma_transfer_config_t xferConfig;
;;;225        status_t status;
;;;226    
;;;227        /* If previous TX not finished. */
;;;228        if (kSPIFI_BusBusy == handle->state)
00001e  68a0              LDR      r0,[r4,#8]
000020  2801              CMP      r0,#1
000022  d102              BNE      |L8.42|
;;;229        {
;;;230            status = kStatus_SPIFI_Busy;
000024  f2417771          MOV      r7,#0x1771
000028  e01d              B        |L8.102|
                  |L8.42|
;;;231        }
;;;232        else
;;;233        {
;;;234            handle->state = kSPIFI_BusBusy;
00002a  2001              MOVS     r0,#1
00002c  60a0              STR      r0,[r4,#8]
;;;235    
;;;236            /* Prepare transfer. */
;;;237            DMA_PrepareTransfer(&xferConfig, (void *)SPIFI_GetDataRegisterAddress(base), xfer->data, sizeof(uint32_t),
00002e  bf00              NOP      
000030  f1050014          ADD      r0,r5,#0x14
000034  4680              MOV      r8,r0
000036  2100              MOVS     r1,#0
000038  2201              MOVS     r2,#1
00003a  6870              LDR      r0,[r6,#4]
00003c  e9cd2101          STRD     r2,r1,[sp,#4]
000040  9000              STR      r0,[sp,#0]
000042  2304              MOVS     r3,#4
000044  4641              MOV      r1,r8
000046  a803              ADD      r0,sp,#0xc
000048  6832              LDR      r2,[r6,#0]
00004a  f7fffffe          BL       DMA_PrepareTransfer
;;;238                                xfer->dataSize, kDMA_PeripheralToMemory, NULL);
;;;239    
;;;240            /* Submit transfer. */
;;;241            DMA_SubmitTransfer(handle->dmaHandle, &xferConfig);
00004e  a903              ADD      r1,sp,#0xc
000050  6820              LDR      r0,[r4,#0]
000052  f7fffffe          BL       DMA_SubmitTransfer
;;;242            DMA_StartTransfer(handle->dmaHandle);
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       DMA_StartTransfer
;;;243    
;;;244            /* Enable SPIFI TX DMA. */
;;;245            SPIFI_EnableDMA(base, true);
00005c  2101              MOVS     r1,#1
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       SPIFI_EnableDMA
;;;246    
;;;247            status = kStatus_Success;
000064  2700              MOVS     r7,#0
                  |L8.102|
;;;248        }
;;;249    
;;;250        return status;
000066  4638              MOV      r0,r7
;;;251    }
000068  b00a              ADD      sp,sp,#0x28
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;252    
                          ENDP

00006e  0000              DCW      0x0000
                  |L8.112|
000070  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000074  44726976
000078  6572735c
00007c  66736c5f
000080  73706966
000084  695f646d
000088  612e6300
                  |L8.140|
00008c  68616e64          DCB      "handle && (handle->dmaHandle)",0
000090  6c652026
000094  26202868
000098  616e646c
00009c  652d3e64
0000a0  6d614861
0000a4  6e646c65
0000a8  2900    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.SPIFI_TransferRxCreateHandleDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferRxCreateHandleDMA PROC
;;;161    
;;;162    void SPIFI_TransferRxCreateHandleDMA(SPIFI_Type *base,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;163                                         spifi_dma_handle_t *handle,
;;;164                                         spifi_dma_callback_t callback,
;;;165                                         void *userData,
;;;166                                         dma_handle_t *dmaHandle)
;;;167    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;168        assert(handle);
000010  b104              CBZ      r4,|L9.20|
000012  e004              B        |L9.30|
                  |L9.20|
000014  22a8              MOVS     r2,#0xa8
000016  a113              ADR      r1,|L9.100|
000018  a019              ADR      r0,|L9.128|
00001a  f7fffffe          BL       __aeabi_assert
                  |L9.30|
;;;169    
;;;170        uint32_t instance = SPIFI_GetInstance(base);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIFI_GetInstance
000024  4605              MOV      r5,r0
;;;171    
;;;172        s_dmaPrivateHandle[instance][1].base = base;
000026  4818              LDR      r0,|L9.136|
000028  eb001005          ADD      r0,r0,r5,LSL #4
00002c  6086              STR      r6,[r0,#8]
;;;173        s_dmaPrivateHandle[instance][1].handle = handle;
00002e  4816              LDR      r0,|L9.136|
000030  eb001005          ADD      r0,r0,r5,LSL #4
000034  60c4              STR      r4,[r0,#0xc]
;;;174    
;;;175        memset(handle, 0, sizeof(*handle));
000036  2114              MOVS     r1,#0x14
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       __aeabi_memclr4
;;;176    
;;;177        handle->state = kSPIFI_Idle;
00003e  2000              MOVS     r0,#0
000040  60a0              STR      r0,[r4,#8]
;;;178        handle->dmaHandle = dmaHandle;
000042  f8c49000          STR      r9,[r4,#0]
;;;179    
;;;180        handle->callback = callback;
000046  60e7              STR      r7,[r4,#0xc]
;;;181        handle->userData = userData;
000048  f8c48010          STR      r8,[r4,#0x10]
;;;182    
;;;183        /* Configure RX dma callback */
;;;184        DMA_SetCallback(handle->dmaHandle, SPIFI_ReceiveDMACallback, &s_dmaPrivateHandle[instance][1]);
00004c  490e              LDR      r1,|L9.136|
00004e  eb011105          ADD      r1,r1,r5,LSL #4
000052  f1010208          ADD      r2,r1,#8
000056  490d              LDR      r1,|L9.140|
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       DMA_SetCallback
;;;185    }
00005e  e8bd87f0          POP      {r4-r10,pc}
;;;186    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
000064  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000068  44726976
00006c  6572735c
000070  66736c5f
000074  73706966
000078  695f646d
00007c  612e6300
                  |L9.128|
000080  68616e64          DCB      "handle",0
000084  6c6500  
000087  00                DCB      0
                  |L9.136|
                          DCD      s_dmaPrivateHandle
                  |L9.140|
                          DCD      SPIFI_ReceiveDMACallback

                          AREA ||i.SPIFI_TransferSendDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferSendDMA PROC
;;;186    
;;;187    status_t SPIFI_TransferSendDMA(SPIFI_Type *base, spifi_dma_handle_t *handle, spifi_transfer_t *xfer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;188    {
000004  b08a              SUB      sp,sp,#0x28
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
;;;189        assert(handle && (handle->dmaHandle));
00000c  b114              CBZ      r4,|L10.20|
00000e  6820              LDR      r0,[r4,#0]
000010  b100              CBZ      r0,|L10.20|
000012  e004              B        |L10.30|
                  |L10.20|
000014  22bd              MOVS     r2,#0xbd
000016  a116              ADR      r1,|L10.112|
000018  a01c              ADR      r0,|L10.140|
00001a  f7fffffe          BL       __aeabi_assert
                  |L10.30|
;;;190    
;;;191        dma_transfer_config_t xferConfig;
;;;192        status_t status;
;;;193    
;;;194        /* If previous TX not finished. */
;;;195        if (kSPIFI_BusBusy == handle->state)
00001e  68a0              LDR      r0,[r4,#8]
000020  2801              CMP      r0,#1
000022  d102              BNE      |L10.42|
;;;196        {
;;;197            status = kStatus_SPIFI_Busy;
000024  f2417771          MOV      r7,#0x1771
000028  e01d              B        |L10.102|
                  |L10.42|
;;;198        }
;;;199        else
;;;200        {
;;;201            handle->state = kSPIFI_BusBusy;
00002a  2001              MOVS     r0,#1
00002c  60a0              STR      r0,[r4,#8]
;;;202    
;;;203            /* Prepare transfer. */
;;;204            DMA_PrepareTransfer(&xferConfig, xfer->data, (void *)SPIFI_GetDataRegisterAddress(base), sizeof(uint32_t),
00002e  bf00              NOP      
000030  f1050014          ADD      r0,r5,#0x14
000034  4680              MOV      r8,r0
000036  2100              MOVS     r1,#0
000038  2202              MOVS     r2,#2
00003a  6870              LDR      r0,[r6,#4]
00003c  e9cd2101          STRD     r2,r1,[sp,#4]
000040  9000              STR      r0,[sp,#0]
000042  2304              MOVS     r3,#4
000044  4642              MOV      r2,r8
000046  a803              ADD      r0,sp,#0xc
000048  6831              LDR      r1,[r6,#0]
00004a  f7fffffe          BL       DMA_PrepareTransfer
;;;205                                xfer->dataSize, kDMA_MemoryToPeripheral, NULL);
;;;206    
;;;207            /* Submit transfer. */
;;;208            DMA_SubmitTransfer(handle->dmaHandle, &xferConfig);
00004e  a903              ADD      r1,sp,#0xc
000050  6820              LDR      r0,[r4,#0]
000052  f7fffffe          BL       DMA_SubmitTransfer
;;;209            DMA_StartTransfer(handle->dmaHandle);
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       DMA_StartTransfer
;;;210    
;;;211            /* Enable SPIFI TX DMA. */
;;;212            SPIFI_EnableDMA(base, true);
00005c  2101              MOVS     r1,#1
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       SPIFI_EnableDMA
;;;213    
;;;214            status = kStatus_Success;
000064  2700              MOVS     r7,#0
                  |L10.102|
;;;215        }
;;;216    
;;;217        return status;
000066  4638              MOV      r0,r7
;;;218    }
000068  b00a              ADD      sp,sp,#0x28
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;219    
                          ENDP

00006e  0000              DCW      0x0000
                  |L10.112|
000070  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000074  44726976
000078  6572735c
00007c  66736c5f
000080  73706966
000084  695f646d
000088  612e6300
                  |L10.140|
00008c  68616e64          DCB      "handle && (handle->dmaHandle)",0
000090  6c652026
000094  26202868
000098  616e646c
00009c  652d3e64
0000a0  6d614861
0000a4  6e646c65
0000a8  2900    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.SPIFI_TransferTxCreateHandleDMA||, CODE, READONLY, ALIGN=2

                  SPIFI_TransferTxCreateHandleDMA PROC
;;;136    
;;;137    void SPIFI_TransferTxCreateHandleDMA(SPIFI_Type *base,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;138                                         spifi_dma_handle_t *handle,
;;;139                                         spifi_dma_callback_t callback,
;;;140                                         void *userData,
;;;141                                         dma_handle_t *dmaHandle)
;;;142    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;143        assert(handle);
000010  b104              CBZ      r4,|L11.20|
000012  e004              B        |L11.30|
                  |L11.20|
000014  228f              MOVS     r2,#0x8f
000016  a112              ADR      r1,|L11.96|
000018  a018              ADR      r0,|L11.124|
00001a  f7fffffe          BL       __aeabi_assert
                  |L11.30|
;;;144    
;;;145        uint32_t instance = SPIFI_GetInstance(base);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIFI_GetInstance
000024  4605              MOV      r5,r0
;;;146    
;;;147        s_dmaPrivateHandle[instance][0].base = base;
000026  4817              LDR      r0,|L11.132|
000028  eb001005          ADD      r0,r0,r5,LSL #4
00002c  6006              STR      r6,[r0,#0]
;;;148        s_dmaPrivateHandle[instance][0].handle = handle;
00002e  4815              LDR      r0,|L11.132|
000030  eb001005          ADD      r0,r0,r5,LSL #4
000034  6044              STR      r4,[r0,#4]
;;;149    
;;;150        memset(handle, 0, sizeof(*handle));
000036  2114              MOVS     r1,#0x14
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       __aeabi_memclr4
;;;151    
;;;152        handle->state = kSPIFI_Idle;
00003e  2000              MOVS     r0,#0
000040  60a0              STR      r0,[r4,#8]
;;;153        handle->dmaHandle = dmaHandle;
000042  f8c49000          STR      r9,[r4,#0]
;;;154    
;;;155        handle->callback = callback;
000046  60e7              STR      r7,[r4,#0xc]
;;;156        handle->userData = userData;
000048  f8c48010          STR      r8,[r4,#0x10]
;;;157    
;;;158        /* Configure TX dma callback */
;;;159        DMA_SetCallback(handle->dmaHandle, SPIFI_SendDMACallback, &s_dmaPrivateHandle[instance][0]);
00004c  490d              LDR      r1,|L11.132|
00004e  eb011205          ADD      r2,r1,r5,LSL #4
000052  490d              LDR      r1,|L11.136|
000054  6820              LDR      r0,[r4,#0]
000056  f7fffffe          BL       DMA_SetCallback
;;;160    }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;161    
                          ENDP

00005e  0000              DCW      0x0000
                  |L11.96|
000060  5352435c          DCB      "SRC\\Drivers\\fsl_spifi_dma.c",0
000064  44726976
000068  6572735c
00006c  66736c5f
000070  73706966
000074  695f646d
000078  612e6300
                  |L11.124|
00007c  68616e64          DCB      "handle",0
000080  6c6500  
000083  00                DCB      0
                  |L11.132|
                          DCD      s_dmaPrivateHandle
                  |L11.136|
                          DCD      SPIFI_SendDMACallback

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_dmaPrivateHandle
                          %        16

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_spifi_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_fsl_spifi_dma_c_111136a2____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_fsl_spifi_dma_c_111136a2____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_fsl_spifi_dma_c_111136a2____REVSH|
#line 402
|__asm___15_fsl_spifi_dma_c_111136a2____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_fsl_spifi_dma_c_111136a2____RRX|
#line 587
|__asm___15_fsl_spifi_dma_c_111136a2____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
