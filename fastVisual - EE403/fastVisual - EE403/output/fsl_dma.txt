; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_dma.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_dma.crf SRC\Drivers\fsl_dma.c]
                          THUMB

                          AREA ||i.DMA0_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_DriverIRQHandler PROC
;;;381    
;;;382    void DMA0_DriverIRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;383    {
;;;384        dma_handle_t *handle;
;;;385        int32_t channel_group;
;;;386        int32_t channel_index;
;;;387    
;;;388        /* Find channels that have completed transfer */
;;;389        for (int i = 0; i < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS; i++)
000004  2700              MOVS     r7,#0
000006  e04b              B        |L1.160|
                  |L1.8|
;;;390        {
;;;391            handle = s_DMAHandle[i];
000008  4827              LDR      r0,|L1.168|
00000a  f8504027          LDR      r4,[r0,r7,LSL #2]
;;;392            /* Handle is not present */
;;;393            if (NULL == handle)
00000e  b904              CBNZ     r4,|L1.18|
;;;394            {
;;;395                continue;
000010  e045              B        |L1.158|
                  |L1.18|
;;;396            }
;;;397            channel_group = DMA_CHANNEL_GROUP(handle->channel);
000012  7b20              LDRB     r0,[r4,#0xc]
000014  1145              ASRS     r5,r0,#5
;;;398            channel_index = DMA_CHANNEL_INDEX(handle->channel);
000016  7b20              LDRB     r0,[r4,#0xc]
000018  f000061f          AND      r6,r0,#0x1f
;;;399            /* Channel uses INTA flag */
;;;400            if (handle->base->COMMON[channel_group].INTA & (1U << channel_index))
00001c  68a0              LDR      r0,[r4,#8]
00001e  3020              ADDS     r0,r0,#0x20
000020  ebc501c5          RSB      r1,r5,r5,LSL #3
000024  eb011105          ADD      r1,r1,r5,LSL #4
000028  eb000081          ADD      r0,r0,r1,LSL #2
00002c  6b80              LDR      r0,[r0,#0x38]
00002e  2101              MOVS     r1,#1
000030  40b1              LSLS     r1,r1,r6
000032  4008              ANDS     r0,r0,r1
000034  b190              CBZ      r0,|L1.92|
;;;401            {
;;;402                /* Clear INTA flag */
;;;403                handle->base->COMMON[channel_group].INTA = 1U << channel_index;
000036  2001              MOVS     r0,#1
000038  40b0              LSLS     r0,r0,r6
00003a  68a1              LDR      r1,[r4,#8]
00003c  3120              ADDS     r1,r1,#0x20
00003e  ebc502c5          RSB      r2,r5,r5,LSL #3
000042  eb021205          ADD      r2,r2,r5,LSL #4
000046  eb010182          ADD      r1,r1,r2,LSL #2
00004a  6388              STR      r0,[r1,#0x38]
;;;404                if (handle->callback)
00004c  6820              LDR      r0,[r4,#0]
00004e  b128              CBZ      r0,|L1.92|
;;;405                {
;;;406                    (handle->callback)(handle, handle->userData, true, kDMA_IntA);
000050  2300              MOVS     r3,#0
000052  2201              MOVS     r2,#1
000054  4620              MOV      r0,r4
000056  e9d4c100          LDRD     r12,r1,[r4,#0]
00005a  47e0              BLX      r12
                  |L1.92|
;;;407                }
;;;408            }
;;;409            /* Channel uses INTB flag */
;;;410            if (handle->base->COMMON[channel_group].INTB & (1U << channel_index))
00005c  68a0              LDR      r0,[r4,#8]
00005e  3020              ADDS     r0,r0,#0x20
000060  ebc501c5          RSB      r1,r5,r5,LSL #3
000064  eb011105          ADD      r1,r1,r5,LSL #4
000068  eb000081          ADD      r0,r0,r1,LSL #2
00006c  6c00              LDR      r0,[r0,#0x40]
00006e  2101              MOVS     r1,#1
000070  40b1              LSLS     r1,r1,r6
000072  4008              ANDS     r0,r0,r1
000074  b190              CBZ      r0,|L1.156|
;;;411            {
;;;412                /* Clear INTB flag */
;;;413                handle->base->COMMON[channel_group].INTB = 1U << channel_index;
000076  2101              MOVS     r1,#1
000078  40b1              LSLS     r1,r1,r6
00007a  68a0              LDR      r0,[r4,#8]
00007c  3020              ADDS     r0,r0,#0x20
00007e  ebc502c5          RSB      r2,r5,r5,LSL #3
000082  eb021205          ADD      r2,r2,r5,LSL #4
000086  eb000082          ADD      r0,r0,r2,LSL #2
00008a  6401              STR      r1,[r0,#0x40]
;;;414                if (handle->callback)
00008c  6820              LDR      r0,[r4,#0]
00008e  b128              CBZ      r0,|L1.156|
;;;415                {
;;;416                    (handle->callback)(handle, handle->userData, true, kDMA_IntB);
000090  2301              MOVS     r3,#1
000092  461a              MOV      r2,r3
000094  4620              MOV      r0,r4
000096  e9d4c100          LDRD     r12,r1,[r4,#0]
00009a  47e0              BLX      r12
                  |L1.156|
00009c  bf00              NOP                            ;395
                  |L1.158|
00009e  1c7f              ADDS     r7,r7,#1              ;389
                  |L1.160|
0000a0  2f1e              CMP      r7,#0x1e              ;389
0000a2  dbb1              BLT      |L1.8|
;;;417                }
;;;418            }
;;;419        }
;;;420    }
0000a4  e8bd81f0          POP      {r4-r8,pc}
;;;421    
                          ENDP

                  |L1.168|
                          DCD      s_DMAHandle

                          AREA ||i.DMA_AbortTransfer||, CODE, READONLY, ALIGN=2

                  DMA_AbortTransfer PROC
;;;238    
;;;239    void DMA_AbortTransfer(dma_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;240    {
000002  4604              MOV      r4,r0
;;;241        assert(NULL != handle);
000004  b104              CBZ      r4,|L2.8|
000006  e004              B        |L2.18|
                  |L2.8|
000008  22f1              MOVS     r2,#0xf1
00000a  a140              ADR      r1,|L2.268|
00000c  a045              ADR      r0,|L2.292|
00000e  f7fffffe          BL       __aeabi_assert
                  |L2.18|
;;;242    
;;;243        DMA_DisableChannel(handle->base, handle->channel);
000012  7b25              LDRB     r5,[r4,#0xc]
000014  68a6              LDR      r6,[r4,#8]
000016  2d1e              CMP      r5,#0x1e
000018  d200              BCS      |L2.28|
00001a  e005              B        |L2.40|
                  |L2.28|
00001c  f2401217          MOV      r2,#0x117
000020  a144              ADR      r1,|L2.308|
000022  a04a              ADR      r0,|L2.332|
000024  f7fffffe          BL       __aeabi_assert
                  |L2.40|
000028  f3c51042          UBFX     r0,r5,#5,#3
00002c  ebc001c0          RSB      r1,r0,r0,LSL #3
000030  eb011100          ADD      r1,r1,r0,LSL #4
000034  f1060020          ADD      r0,r6,#0x20
000038  eb000081          ADD      r0,r0,r1,LSL #2
00003c  6880              LDR      r0,[r0,#8]
00003e  f005021f          AND      r2,r5,#0x1f
000042  2101              MOVS     r1,#1
000044  4091              LSLS     r1,r1,r2
000046  4308              ORRS     r0,r0,r1
000048  f3c51142          UBFX     r1,r5,#5,#3
00004c  ebc102c1          RSB      r2,r1,r1,LSL #3
000050  eb021201          ADD      r2,r2,r1,LSL #4
000054  f1060120          ADD      r1,r6,#0x20
000058  eb010182          ADD      r1,r1,r2,LSL #2
00005c  6088              STR      r0,[r1,#8]
00005e  bf00              NOP      
;;;244        while (handle->base->COMMON[DMA_CHANNEL_GROUP(handle->channel)].BUSY & (1U << DMA_CHANNEL_INDEX(handle->channel)))
000060  bf00              NOP      
                  |L2.98|
000062  68a0              LDR      r0,[r4,#8]
000064  3020              ADDS     r0,r0,#0x20
000066  7b21              LDRB     r1,[r4,#0xc]
000068  1149              ASRS     r1,r1,#5
00006a  ebc102c1          RSB      r2,r1,r1,LSL #3
00006e  eb021101          ADD      r1,r2,r1,LSL #4
000072  eb000081          ADD      r0,r0,r1,LSL #2
000076  6981              LDR      r1,[r0,#0x18]
000078  7b20              LDRB     r0,[r4,#0xc]
00007a  f000021f          AND      r2,r0,#0x1f
00007e  2001              MOVS     r0,#1
000080  4090              LSLS     r0,r0,r2
000082  4001              ANDS     r1,r1,r0
000084  2900              CMP      r1,#0
000086  d1ec              BNE      |L2.98|
;;;245        { }
;;;246        handle->base->COMMON[DMA_CHANNEL_GROUP(handle->channel)].ABORT |= 1U << DMA_CHANNEL_INDEX(handle->channel);
000088  68a0              LDR      r0,[r4,#8]
00008a  3020              ADDS     r0,r0,#0x20
00008c  7b21              LDRB     r1,[r4,#0xc]
00008e  1149              ASRS     r1,r1,#5
000090  ebc102c1          RSB      r2,r1,r1,LSL #3
000094  eb021101          ADD      r1,r2,r1,LSL #4
000098  eb000081          ADD      r0,r0,r1,LSL #2
00009c  6d80              LDR      r0,[r0,#0x58]
00009e  7b21              LDRB     r1,[r4,#0xc]
0000a0  f001021f          AND      r2,r1,#0x1f
0000a4  2101              MOVS     r1,#1
0000a6  4091              LSLS     r1,r1,r2
0000a8  4308              ORRS     r0,r0,r1
0000aa  68a1              LDR      r1,[r4,#8]
0000ac  3120              ADDS     r1,r1,#0x20
0000ae  7b22              LDRB     r2,[r4,#0xc]
0000b0  1152              ASRS     r2,r2,#5
0000b2  ebc203c2          RSB      r3,r2,r2,LSL #3
0000b6  eb031202          ADD      r2,r3,r2,LSL #4
0000ba  eb010182          ADD      r1,r1,r2,LSL #2
0000be  6588              STR      r0,[r1,#0x58]
;;;247        DMA_EnableChannel(handle->base, handle->channel);
0000c0  7b25              LDRB     r5,[r4,#0xc]
0000c2  68a6              LDR      r6,[r4,#8]
0000c4  2d1e              CMP      r5,#0x1e
0000c6  d200              BCS      |L2.202|
0000c8  e005              B        |L2.214|
                  |L2.202|
0000ca  f240120b          MOV      r2,#0x10b
0000ce  a119              ADR      r1,|L2.308|
0000d0  a01e              ADR      r0,|L2.332|
0000d2  f7fffffe          BL       __aeabi_assert
                  |L2.214|
0000d6  f3c51042          UBFX     r0,r5,#5,#3
0000da  ebc001c0          RSB      r1,r0,r0,LSL #3
0000de  eb011100          ADD      r1,r1,r0,LSL #4
0000e2  f1060020          ADD      r0,r6,#0x20
0000e6  f8500021          LDR      r0,[r0,r1,LSL #2]
0000ea  f005021f          AND      r2,r5,#0x1f
0000ee  2101              MOVS     r1,#1
0000f0  4091              LSLS     r1,r1,r2
0000f2  4308              ORRS     r0,r0,r1
0000f4  f3c51142          UBFX     r1,r5,#5,#3
0000f8  ebc102c1          RSB      r2,r1,r1,LSL #3
0000fc  eb021201          ADD      r2,r2,r1,LSL #4
000100  f1060120          ADD      r1,r6,#0x20
000104  f8410022          STR      r0,[r1,r2,LSL #2]
000108  bf00              NOP      
;;;248    }
00010a  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

                  |L2.268|
00010c  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
000110  44726976
000114  6572735c
000118  66736c5f
00011c  646d612e
000120  6300    
000122  00                DCB      0
000123  00                DCB      0
                  |L2.292|
000124  4e554c4c          DCB      "NULL != handle",0
000128  20213d20
00012c  68616e64
000130  6c6500  
000133  00                DCB      0
                  |L2.308|
000134  5352435c          DCB      "SRC\\Drivers\\fsl_dma.h",0
000138  44726976
00013c  6572735c
000140  66736c5f
000144  646d612e
000148  6800    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L2.332|
00014c  6368616e          DCB      "channel < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS",0
000150  6e656c20
000154  3c204653
000158  4c5f4645
00015c  41545552
000160  455f444d
000164  415f4e55
000168  4d424552
00016c  5f4f465f
000170  4348414e
000174  4e454c53
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0

                          AREA ||i.DMA_ConfigureChannelTrigger||, CODE, READONLY, ALIGN=2

                  DMA_ConfigureChannelTrigger PROC
;;;109    
;;;110    void DMA_ConfigureChannelTrigger(DMA_Type *base, uint32_t channel, dma_channel_trigger_t *trigger)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;111    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;112        assert((channel < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS) && (NULL != trigger));
00000a  2d1e              CMP      r5,#0x1e
00000c  d201              BCS      |L3.18|
00000e  b104              CBZ      r4,|L3.18|
000010  e004              B        |L3.28|
                  |L3.18|
000012  2270              MOVS     r2,#0x70
000014  a10c              ADR      r1,|L3.72|
000016  4812              LDR      r0,|L3.96|
000018  f7fffffe          BL       __aeabi_assert
                  |L3.28|
;;;113    
;;;114        uint32_t tmp = (
00001c  f64c7772          MOV      r7,#0xcf72
;;;115            DMA_CHANNEL_CFG_HWTRIGEN_MASK | DMA_CHANNEL_CFG_TRIGPOL_MASK | DMA_CHANNEL_CFG_TRIGTYPE_MASK |
;;;116            DMA_CHANNEL_CFG_TRIGBURST_MASK | DMA_CHANNEL_CFG_BURSTPOWER_MASK | DMA_CHANNEL_CFG_SRCBURSTWRAP_MASK |
;;;117            DMA_CHANNEL_CFG_DSTBURSTWRAP_MASK
;;;118        );
;;;119        tmp = base->CHANNEL[channel].CFG & (~tmp);
000020  f5066080          ADD      r0,r6,#0x400
000024  eb001005          ADD      r0,r0,r5,LSL #4
000028  6800              LDR      r0,[r0,#0]
00002a  ea200707          BIC      r7,r0,r7
;;;120        tmp |= (uint32_t)(trigger->type) | (uint32_t)(trigger->burst) | (uint32_t)(trigger->wrap);
00002e  7820              LDRB     r0,[r4,#0]
000030  8861              LDRH     r1,[r4,#2]
000032  4308              ORRS     r0,r0,r1
000034  88a1              LDRH     r1,[r4,#4]
000036  4308              ORRS     r0,r0,r1
000038  4307              ORRS     r7,r7,r0
;;;121        base->CHANNEL[channel].CFG = tmp;
00003a  f5066080          ADD      r0,r6,#0x400
00003e  eb001005          ADD      r0,r0,r5,LSL #4
000042  6007              STR      r7,[r0,#0]
;;;122    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;123    
                          ENDP

                  |L3.72|
000048  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
00004c  44726976
000050  6572735c
000054  66736c5f
000058  646d612e
00005c  6300    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L3.96|
                          DCD      ||.conststring||

                          AREA ||i.DMA_CreateDescriptor||, CODE, READONLY, ALIGN=2

                  DMA_CreateDescriptor PROC
;;;212    
;;;213    void DMA_CreateDescriptor(
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;214        dma_descriptor_t    *desc,
;;;215        dma_xfercfg_t       *xfercfg,
;;;216        void                *srcAddr,
;;;217        void                *dstAddr,
;;;218        void                *nextDesc
;;;219    )
;;;220    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;221        uint32_t xfercfg_reg = 0;
000010  2000              MOVS     r0,#0
000012  9001              STR      r0,[sp,#4]
;;;222    
;;;223        assert((NULL != desc) && (0 == (uint32_t)desc % 16) && (NULL != xfercfg));
000014  b127              CBZ      r7,|L4.32|
000016  f007000f          AND      r0,r7,#0xf
00001a  b908              CBNZ     r0,|L4.32|
00001c  b104              CBZ      r4,|L4.32|
00001e  e004              B        |L4.42|
                  |L4.32|
000020  22df              MOVS     r2,#0xdf
000022  a123              ADR      r1,|L4.176|
000024  4828              LDR      r0,|L4.200|
000026  f7fffffe          BL       __aeabi_assert
                  |L4.42|
;;;224        assert((NULL != srcAddr) && (0 == (uint32_t)srcAddr % xfercfg->byteWidth));
00002a  b135              CBZ      r5,|L4.58|
00002c  79a0              LDRB     r0,[r4,#6]
00002e  fbb5f1f0          UDIV     r1,r5,r0
000032  fb005011          MLS      r0,r0,r1,r5
000036  b900              CBNZ     r0,|L4.58|
000038  e004              B        |L4.68|
                  |L4.58|
00003a  22e0              MOVS     r2,#0xe0
00003c  a11c              ADR      r1,|L4.176|
00003e  4823              LDR      r0,|L4.204|
000040  f7fffffe          BL       __aeabi_assert
                  |L4.68|
;;;225        assert((NULL != dstAddr) && (0 == (uint32_t)dstAddr % xfercfg->byteWidth));
000044  b136              CBZ      r6,|L4.84|
000046  79a0              LDRB     r0,[r4,#6]
000048  fbb6f1f0          UDIV     r1,r6,r0
00004c  fb006011          MLS      r0,r0,r1,r6
000050  b900              CBNZ     r0,|L4.84|
000052  e004              B        |L4.94|
                  |L4.84|
000054  22e1              MOVS     r2,#0xe1
000056  a116              ADR      r1,|L4.176|
000058  481d              LDR      r0,|L4.208|
00005a  f7fffffe          BL       __aeabi_assert
                  |L4.94|
;;;226        assert((NULL == nextDesc) || (0 == (uint32_t)nextDesc % 16));
00005e  f1b80f00          CMP      r8,#0
000062  d002              BEQ      |L4.106|
000064  f008000f          AND      r0,r8,#0xf
000068  b900              CBNZ     r0,|L4.108|
                  |L4.106|
00006a  e004              B        |L4.118|
                  |L4.108|
00006c  22e2              MOVS     r2,#0xe2
00006e  a110              ADR      r1,|L4.176|
000070  a018              ADR      r0,|L4.212|
000072  f7fffffe          BL       __aeabi_assert
                  |L4.118|
;;;227    
;;;228        /* Setup channel configuration */
;;;229        DMA_SetupXferCFG(xfercfg, &xfercfg_reg);
000076  a901              ADD      r1,sp,#4
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       DMA_SetupXferCFG
;;;230    
;;;231        /* Set descriptor structure */
;;;232        DMA_SetupDescriptor(desc, xfercfg_reg,
00007e  f8cd8000          STR      r8,[sp,#0]
000082  7a20              LDRB     r0,[r4,#8]
000084  79a1              LDRB     r1,[r4,#6]
000086  fb10f101          SMULBB   r1,r0,r1
00008a  8960              LDRH     r0,[r4,#0xa]
00008c  1e40              SUBS     r0,r0,#1
00008e  fb016300          MLA      r3,r1,r0,r6
000092  79e0              LDRB     r0,[r4,#7]
000094  79a1              LDRB     r1,[r4,#6]
000096  fb10f101          SMULBB   r1,r0,r1
00009a  8960              LDRH     r0,[r4,#0xa]
00009c  1e40              SUBS     r0,r0,#1
00009e  fb015200          MLA      r2,r1,r0,r5
0000a2  4638              MOV      r0,r7
0000a4  9901              LDR      r1,[sp,#4]
0000a6  f7fffffe          BL       DMA_SetupDescriptor
;;;233            (uint8_t*)srcAddr + (xfercfg->srcInc * xfercfg->byteWidth * (xfercfg->transferCount - 1)),
;;;234            (uint8_t*)dstAddr + (xfercfg->dstInc * xfercfg->byteWidth * (xfercfg->transferCount - 1)),
;;;235            nextDesc
;;;236        );
;;;237    }
0000aa  e8bd81fc          POP      {r2-r8,pc}
;;;238    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L4.176|
0000b0  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
0000b4  44726976
0000b8  6572735c
0000bc  66736c5f
0000c0  646d612e
0000c4  6300    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L4.200|
                          DCD      ||.conststring||+0x168
                  |L4.204|
                          DCD      ||.conststring||+0x1ac
                  |L4.208|
                          DCD      ||.conststring||+0x1f0
                  |L4.212|
0000d4  284e554c          DCB      "(NULL == nextDesc) || (0 == (uint32_t)nextDesc % 16)",0
0000d8  4c203d3d
0000dc  206e6578
0000e0  74446573
0000e4  6329207c
0000e8  7c202830
0000ec  203d3d20
0000f0  2875696e
0000f4  7433325f
0000f8  74296e65
0000fc  78744465
000100  73632025
000104  20313629
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.DMA_CreateHandle||, CODE, READONLY, ALIGN=2

                  DMA_CreateHandle PROC
;;;249    
;;;250    void DMA_CreateHandle(dma_handle_t *handle, DMA_Type *base, uint32_t channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;251    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;252        int32_t dmaInstance;
;;;253        assert((NULL != handle) && (channel < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS));
00000a  b114              CBZ      r4,|L5.18|
00000c  2d1e              CMP      r5,#0x1e
00000e  d200              BCS      |L5.18|
000010  e004              B        |L5.28|
                  |L5.18|
000012  22fd              MOVS     r2,#0xfd
000014  a113              ADR      r1,|L5.100|
000016  4819              LDR      r0,|L5.124|
000018  f7fffffe          BL       __aeabi_assert
                  |L5.28|
;;;254    
;;;255        /* base address is invalid DMA instance */
;;;256        dmaInstance = DMA_GetInstance(base);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       DMA_GetInstance
000022  4607              MOV      r7,r0
;;;257    
;;;258        memset(handle, 0, sizeof(*handle));
000024  2000              MOVS     r0,#0
000026  6020              STR      r0,[r4,#0]
000028  6060              STR      r0,[r4,#4]
00002a  60a0              STR      r0,[r4,#8]
00002c  60e0              STR      r0,[r4,#0xc]
;;;259        handle->base = base;
00002e  60a6              STR      r6,[r4,#8]
;;;260        handle->channel = channel;
000030  7325              STRB     r5,[r4,#0xc]
;;;261        s_DMAHandle[channel] = handle;
000032  4813              LDR      r0,|L5.128|
000034  f8404025          STR      r4,[r0,r5,LSL #2]
;;;262        /* Enable NVIC interrupt */
;;;263        EnableIRQ(s_dmaIRQNumber[dmaInstance]);
000038  4912              LDR      r1,|L5.132|
00003a  57c8              LDRSB    r0,[r1,r7]
00003c  f1100f80          CMN      r0,#0x80
000040  d100              BNE      |L5.68|
000042  e00c              B        |L5.94|
                  |L5.68|
000044  bf00              NOP      
000046  f000021f          AND      r2,r0,#0x1f
00004a  2101              MOVS     r1,#1
00004c  4091              LSLS     r1,r1,r2
00004e  0942              LSRS     r2,r0,#5
000050  0092              LSLS     r2,r2,#2
000052  f10222e0          ADD      r2,r2,#0xe000e000
000056  f8c21100          STR      r1,[r2,#0x100]
00005a  bf00              NOP      
00005c  bf00              NOP      
                  |L5.94|
;;;264    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;265    
                          ENDP

000062  0000              DCW      0x0000
                  |L5.100|
000064  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
000068  44726976
00006c  6572735c
000070  66736c5f
000074  646d612e
000078  6300    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L5.124|
                          DCD      ||.conststring||+0x234
                  |L5.128|
                          DCD      s_DMAHandle
                  |L5.132|
                          DCD      s_dmaIRQNumber

                          AREA ||i.DMA_Deinit||, CODE, READONLY, ALIGN=1

                  DMA_Deinit PROC
;;;101    
;;;102    void DMA_Deinit(DMA_Type *base)
000000  6801              LDR      r1,[r0,#0]
;;;103    {
;;;104    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;105        /* Disable DMA peripheral */
;;;106        base->CTRL &= ~(DMA_CTRL_ENABLE_MASK);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;107    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;108    }
000008  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.DMA_GetInstance||, CODE, READONLY, ALIGN=2

                  DMA_GetInstance PROC
;;;74     
;;;75     static int32_t DMA_GetInstance(DMA_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
000002  4605              MOV      r5,r0
;;;77         int32_t instance;
;;;78         /* Find the instance index from base address mappings. */
;;;79         for (instance = 0; instance < FSL_FEATURE_SOC_DMA_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L7.22|
                  |L7.8|
;;;80         {
;;;81             if (s_dmaBases[instance] == base)
000008  480c              LDR      r0,|L7.60|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L7.20|
;;;82             {
;;;83                 break;
000012  e002              B        |L7.26|
                  |L7.20|
000014  1c64              ADDS     r4,r4,#1              ;79
                  |L7.22|
000016  2c01              CMP      r4,#1                 ;79
000018  dbf6              BLT      |L7.8|
                  |L7.26|
00001a  bf00              NOP      
;;;84             }
;;;85         }
;;;86         assert(instance < FSL_FEATURE_SOC_DMA_COUNT);
00001c  2c01              CMP      r4,#1
00001e  da00              BGE      |L7.34|
000020  e004              B        |L7.44|
                  |L7.34|
000022  2256              MOVS     r2,#0x56
000024  a106              ADR      r1,|L7.64|
000026  a00c              ADR      r0,|L7.88|
000028  f7fffffe          BL       __aeabi_assert
                  |L7.44|
;;;87         return instance < FSL_FEATURE_SOC_DMA_COUNT ? instance : -1;
00002c  2c01              CMP      r4,#1
00002e  da01              BGE      |L7.52|
000030  4620              MOV      r0,r4
                  |L7.50|
;;;88     }
000032  bd70              POP      {r4-r6,pc}
                  |L7.52|
000034  f04f30ff          MOV      r0,#0xffffffff        ;87
000038  e7fb              B        |L7.50|
;;;89     
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      s_dmaBases
                  |L7.64|
000040  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
000044  44726976
000048  6572735c
00004c  66736c5f
000050  646d612e
000054  6300    
000056  00                DCB      0
000057  00                DCB      0
                  |L7.88|
000058  696e7374          DCB      "instance < FSL_FEATURE_SOC_DMA_COUNT",0
00005c  616e6365
000060  203c2046
000064  534c5f46
000068  45415455
00006c  52455f53
000070  4f435f44
000074  4d415f43
000078  4f554e54
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.DMA_GetRemainingBytes||, CODE, READONLY, ALIGN=2

                  DMA_GetRemainingBytes PROC
;;;130     */
;;;131    uint32_t DMA_GetRemainingBytes(DMA_Type *base, uint32_t channel)
000000  b570              PUSH     {r4-r6,lr}
;;;132    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;133        assert(channel < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS);
000006  2c1e              CMP      r4,#0x1e
000008  d200              BCS      |L8.12|
00000a  e004              B        |L8.22|
                  |L8.12|
00000c  2285              MOVS     r2,#0x85
00000e  a114              ADR      r1,|L8.96|
000010  a019              ADR      r0,|L8.120|
000012  f7fffffe          BL       __aeabi_assert
                  |L8.22|
;;;134    
;;;135        /* NOTE: when descriptors are chained, ACTIVE bit is set for whole chain. It makes 
;;;136         * impossible to distinguish between:
;;;137         * - transfer finishes (represented by value '0x3FF')
;;;138         * - and remaining 1024 bytes to transfer (value 0x3FF)
;;;139         * for all descriptor in chain, except the last one.
;;;140         * If you decide to use this function, please use 1023 transfers as maximal value */
;;;141    
;;;142        /* Channel not active (transfer finished) and value is 0x3FF - nothing to transfer */
;;;143        if (
000016  f3c41042          UBFX     r0,r4,#5,#3
00001a  ebc001c0          RSB      r1,r0,r0,LSL #3
00001e  eb011100          ADD      r1,r1,r0,LSL #4
000022  f1050020          ADD      r0,r5,#0x20
000026  eb000081          ADD      r0,r0,r1,LSL #2
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f004021f          AND      r2,r4,#0x1f
000030  2101              MOVS     r1,#1
000032  4091              LSLS     r1,r1,r2
000034  4008              ANDS     r0,r0,r1
000036  b960              CBNZ     r0,|L8.82|
;;;144            (!(base->COMMON[DMA_CHANNEL_GROUP(channel)].ACTIVE & (1U << (DMA_CHANNEL_INDEX(channel))))) && 
;;;145            (0x3FF == ((base->CHANNEL[channel].XFERCFG & DMA_CHANNEL_XFERCFG_XFERCOUNT_MASK) >> DMA_CHANNEL_XFERCFG_XFERCOUNT_SHIFT))
000038  f5056080          ADD      r0,r5,#0x400
00003c  eb001004          ADD      r0,r0,r4,LSL #4
000040  6880              LDR      r0,[r0,#8]
000042  f3c04009          UBFX     r0,r0,#16,#10
000046  f24031ff          MOV      r1,#0x3ff
00004a  4288              CMP      r0,r1
00004c  d101              BNE      |L8.82|
;;;146        )
;;;147        {
;;;148            return 0;
00004e  2000              MOVS     r0,#0
                  |L8.80|
;;;149        }
;;;150    
;;;151        return base->CHANNEL[channel].XFERCFG + 1;
;;;152    }
000050  bd70              POP      {r4-r6,pc}
                  |L8.82|
000052  f5056080          ADD      r0,r5,#0x400          ;151
000056  eb001004          ADD      r0,r0,r4,LSL #4       ;151
00005a  6880              LDR      r0,[r0,#8]            ;151
00005c  1c40              ADDS     r0,r0,#1              ;151
00005e  e7f7              B        |L8.80|
;;;153    
                          ENDP

                  |L8.96|
000060  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
000064  44726976
000068  6572735c
00006c  66736c5f
000070  646d612e
000074  6300    
000076  00                DCB      0
000077  00                DCB      0
                  |L8.120|
000078  6368616e          DCB      "channel < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS",0
00007c  6e656c20
000080  3c204653
000084  4c5f4645
000088  41545552
00008c  455f444d
000090  415f4e55
000094  4d424552
000098  5f4f465f
00009c  4348414e
0000a0  4e454c53
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.DMA_Init||, CODE, READONLY, ALIGN=2

                  DMA_Init PROC
;;;89     
;;;90     void DMA_Init(DMA_Type *base)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92     #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;93         /* enable dma clock gate */
;;;94         CLOCK_EnableClock(kCLOCK_Dma);
000002  2114              MOVS     r1,#0x14
000004  0a0a              LSRS     r2,r1,#8
000006  2a03              CMP      r2,#3
000008  d205              BCS      |L9.22|
00000a  2301              MOVS     r3,#1
00000c  408b              LSLS     r3,r3,r1
00000e  4c09              LDR      r4,|L9.52|
000010  f8443022          STR      r3,[r4,r2,LSL #2]
000014  e005              B        |L9.34|
                  |L9.22|
000016  2301              MOVS     r3,#1
000018  079c              LSLS     r4,r3,#30
00001a  64e3              STR      r3,[r4,#0x4c]
00001c  408b              LSLS     r3,r3,r1
00001e  4c06              LDR      r4,|L9.56|
000020  6163              STR      r3,[r4,#0x14]
                  |L9.34|
000022  bf00              NOP      
;;;95     #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;96         /* set descriptor table */
;;;97         base->SRAMBASE = (uint32_t)s_dma_descriptor_table;
000024  4905              LDR      r1,|L9.60|
000026  6081              STR      r1,[r0,#8]
;;;98         /* enable dma peripheral */
;;;99         base->CTRL |= DMA_CTRL_ENABLE_MASK;
000028  6801              LDR      r1,[r0,#0]
00002a  f0410101          ORR      r1,r1,#1
00002e  6001              STR      r1,[r0,#0]
;;;100    }
000030  bd10              POP      {r4,pc}
;;;101    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      0x40000220
                  |L9.56|
                          DCD      0x40040000
                  |L9.60|
                          DCD      s_dma_descriptor_table

                          AREA ||i.DMA_PrepareTransfer||, CODE, READONLY, ALIGN=2

                  DMA_PrepareTransfer PROC
;;;273    
;;;274    void DMA_PrepareTransfer(dma_transfer_config_t *config,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;275                              void *srcAddr,
;;;276                              void *dstAddr,
;;;277                              uint32_t byteWidth,
;;;278                              uint32_t transferBytes,
;;;279                              dma_transfer_type_t type,
;;;280                              void *nextDesc)
;;;281    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  e9ddba0b          LDRD     r11,r10,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
;;;282        uint32_t xfer_count;
;;;283        assert((NULL != config) && (NULL != srcAddr) && (NULL != dstAddr));
000014  b114              CBZ      r4,|L10.28|
000016  b10e              CBZ      r6,|L10.28|
000018  b107              CBZ      r7,|L10.28|
00001a  e005              B        |L10.40|
                  |L10.28|
00001c  f240121b          MOV      r2,#0x11b
000020  a131              ADR      r1,|L10.232|
000022  a037              ADR      r0,|L10.256|
000024  f7fffffe          BL       __aeabi_assert
                  |L10.40|
;;;284        assert((byteWidth == 1) || (byteWidth == 2) || (byteWidth == 4));
000028  2d01              CMP      r5,#1
00002a  d003              BEQ      |L10.52|
00002c  2d02              CMP      r5,#2
00002e  d001              BEQ      |L10.52|
000030  2d04              CMP      r5,#4
000032  d100              BNE      |L10.54|
                  |L10.52|
000034  e005              B        |L10.66|
                  |L10.54|
000036  f44f728e          MOV      r2,#0x11c
00003a  a12b              ADR      r1,|L10.232|
00003c  a03f              ADR      r0,|L10.316|
00003e  f7fffffe          BL       __aeabi_assert
                  |L10.66|
;;;285    
;;;286        /* check max */
;;;287        xfer_count = transferBytes / byteWidth;
000042  fbb9f8f5          UDIV     r8,r9,r5
;;;288        assert((xfer_count <= DMA_MAX_TRANSFER_COUNT) && (0 == transferBytes % byteWidth));
000046  f5b86f80          CMP      r8,#0x400
00004a  d805              BHI      |L10.88|
00004c  fbb9f0f5          UDIV     r0,r9,r5
000050  fb059010          MLS      r0,r5,r0,r9
000054  b900              CBNZ     r0,|L10.88|
000056  e005              B        |L10.100|
                  |L10.88|
000058  f44f7290          MOV      r2,#0x120
00005c  a122              ADR      r1,|L10.232|
00005e  4846              LDR      r0,|L10.376|
000060  f7fffffe          BL       __aeabi_assert
                  |L10.100|
;;;289    
;;;290        memset(config, 0, sizeof(*config));
000064  211c              MOVS     r1,#0x1c
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       __aeabi_memclr4
;;;291        switch (type)
00006c  f1bb0f00          CMP      r11,#0
000070  d009              BEQ      |L10.134|
000072  f1bb0f01          CMP      r11,#1
000076  d00c              BEQ      |L10.146|
000078  f1bb0f02          CMP      r11,#2
00007c  d010              BEQ      |L10.160|
00007e  f1bb0f03          CMP      r11,#3
000082  d11a              BNE      |L10.186|
000084  e013              B        |L10.174|
                  |L10.134|
;;;292        {
;;;293        case kDMA_MemoryToMemory:
;;;294            config->xfercfg.srcInc = 1;
000086  2101              MOVS     r1,#1
000088  74e1              STRB     r1,[r4,#0x13]
;;;295            config->xfercfg.dstInc = 1;
00008a  7521              STRB     r1,[r4,#0x14]
;;;296            config->isPeriph = false;
00008c  2000              MOVS     r0,#0
00008e  7620              STRB     r0,[r4,#0x18]
;;;297            break;
000090  e015              B        |L10.190|
                  |L10.146|
;;;298        case kDMA_PeripheralToMemory:
;;;299            /* Peripheral register - source doesn't increment */
;;;300            config->xfercfg.srcInc = 0;
000092  2100              MOVS     r1,#0
000094  74e1              STRB     r1,[r4,#0x13]
;;;301            config->xfercfg.dstInc = 1;
000096  2101              MOVS     r1,#1
000098  7521              STRB     r1,[r4,#0x14]
;;;302            config->isPeriph = true;
00009a  2001              MOVS     r0,#1
00009c  7620              STRB     r0,[r4,#0x18]
;;;303            break;
00009e  e00e              B        |L10.190|
                  |L10.160|
;;;304        case kDMA_MemoryToPeripheral:
;;;305            /* Peripheral register - destination doesn't increment */
;;;306            config->xfercfg.srcInc = 1;
0000a0  2101              MOVS     r1,#1
0000a2  74e1              STRB     r1,[r4,#0x13]
;;;307            config->xfercfg.dstInc = 0;
0000a4  2100              MOVS     r1,#0
0000a6  7521              STRB     r1,[r4,#0x14]
;;;308            config->isPeriph = true;
0000a8  2001              MOVS     r0,#1
0000aa  7620              STRB     r0,[r4,#0x18]
;;;309            break;
0000ac  e007              B        |L10.190|
                  |L10.174|
;;;310        case kDMA_StaticToStatic:
;;;311            config->xfercfg.srcInc = 0;
0000ae  2100              MOVS     r1,#0
0000b0  74e1              STRB     r1,[r4,#0x13]
;;;312            config->xfercfg.dstInc = 0;
0000b2  7521              STRB     r1,[r4,#0x14]
;;;313            config->isPeriph = true;
0000b4  2001              MOVS     r0,#1
0000b6  7620              STRB     r0,[r4,#0x18]
;;;314            break;
0000b8  e001              B        |L10.190|
                  |L10.186|
;;;315        default:
;;;316            return;
;;;317        }
;;;318    
;;;319        config->dstAddr = (uint8_t*)dstAddr;
;;;320        config->srcAddr = (uint8_t*)srcAddr;
;;;321        config->nextDesc = (uint8_t*)nextDesc;
;;;322        config->xfercfg.transferCount = xfer_count;
;;;323        config->xfercfg.byteWidth = byteWidth;
;;;324        config->xfercfg.intA = true;
;;;325        config->xfercfg.reload = nextDesc != NULL;
;;;326        config->xfercfg.valid = true;
;;;327    }
0000ba  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.190|
0000be  bf00              NOP                            ;297
0000c0  6067              STR      r7,[r4,#4]            ;319
0000c2  6026              STR      r6,[r4,#0]            ;320
0000c4  f8c4a008          STR      r10,[r4,#8]           ;321
0000c8  f8a48016          STRH     r8,[r4,#0x16]         ;322
0000cc  74a5              STRB     r5,[r4,#0x12]         ;323
0000ce  2101              MOVS     r1,#1                 ;324
0000d0  7421              STRB     r1,[r4,#0x10]         ;324
0000d2  f1ba0f00          CMP      r10,#0                ;325
0000d6  d000              BEQ      |L10.218|
0000d8  e000              B        |L10.220|
                  |L10.218|
0000da  2100              MOVS     r1,#0                 ;325
                  |L10.220|
0000dc  7361              STRB     r1,[r4,#0xd]          ;325
0000de  2001              MOVS     r0,#1                 ;326
0000e0  7320              STRB     r0,[r4,#0xc]          ;326
0000e2  bf00              NOP      
0000e4  e7e9              B        |L10.186|
;;;328    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L10.232|
0000e8  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
0000ec  44726976
0000f0  6572735c
0000f4  66736c5f
0000f8  646d612e
0000fc  6300    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L10.256|
000100  284e554c          DCB      "(NULL != config) && (NULL != srcAddr) && (NULL != dstAd"
000104  4c20213d
000108  20636f6e
00010c  66696729
000110  20262620
000114  284e554c
000118  4c20213d
00011c  20737263
000120  41646472
000124  29202626
000128  20284e55
00012c  4c4c2021
000130  3d206473
000134  744164  
000137  64722900          DCB      "dr)",0
00013b  00                DCB      0
                  |L10.316|
00013c  28627974          DCB      "(byteWidth == 1) || (byteWidth == 2) || (byteWidth == 4"
000140  65576964
000144  7468203d
000148  3d203129
00014c  207c7c20
000150  28627974
000154  65576964
000158  7468203d
00015c  3d203229
000160  207c7c20
000164  28627974
000168  65576964
00016c  7468203d
000170  3d2034  
000173  2900              DCB      ")",0
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L10.376|
                          DCD      ||.conststring||+0x278

                          AREA ||i.DMA_SetCallback||, CODE, READONLY, ALIGN=2

                  DMA_SetCallback PROC
;;;265    
;;;266    void DMA_SetCallback(dma_handle_t *handle, dma_callback callback, void *userData)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;268        assert(handle != NULL);
000008  b104              CBZ      r4,|L11.12|
00000a  e005              B        |L11.24|
                  |L11.12|
00000c  f44f7286          MOV      r2,#0x10c
000010  a103              ADR      r1,|L11.32|
000012  a009              ADR      r0,|L11.56|
000014  f7fffffe          BL       __aeabi_assert
                  |L11.24|
;;;269    
;;;270        handle->callback = callback;
000018  6026              STR      r6,[r4,#0]
;;;271        handle->userData = userData;
00001a  6065              STR      r5,[r4,#4]
;;;272    }
00001c  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
000020  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
000024  44726976
000028  6572735c
00002c  66736c5f
000030  646d612e
000034  6300    
000036  00                DCB      0
000037  00                DCB      0
                  |L11.56|
000038  68616e64          DCB      "handle != NULL",0
00003c  6c652021
000040  3d204e55
000044  4c4c00  
000047  00                DCB      0

                          AREA ||i.DMA_SetupDescriptor||, CODE, READONLY, ALIGN=1

                  DMA_SetupDescriptor PROC
;;;153    
;;;154    static void DMA_SetupDescriptor(
000000  b510              PUSH     {r4,lr}
;;;155        dma_descriptor_t    *desc,
;;;156        uint32_t            xfercfg,
;;;157        void                *srcEndAddr,
;;;158        void                *dstEndAddr,
;;;159        void                *nextDesc
;;;160    )
;;;161    {
000002  9c02              LDR      r4,[sp,#8]
;;;162        desc->xfercfg = xfercfg;
000004  6001              STR      r1,[r0,#0]
;;;163        desc->srcEndAddr = srcEndAddr;
000006  6042              STR      r2,[r0,#4]
;;;164        desc->dstEndAddr = dstEndAddr;
000008  6083              STR      r3,[r0,#8]
;;;165        desc->linkToNextDesc = nextDesc;
00000a  60c4              STR      r4,[r0,#0xc]
;;;166    }
00000c  bd10              POP      {r4,pc}
;;;167    
                          ENDP


                          AREA ||i.DMA_SetupXferCFG||, CODE, READONLY, ALIGN=2

                  DMA_SetupXferCFG PROC
;;;168    /* Verify and convert dma_xfercfg_t to XFERCFG register */
;;;169    static void DMA_SetupXferCFG(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;170        dma_xfercfg_t *xfercfg,
;;;171        uint32_t *xfercfg_addr
;;;172    )
;;;173    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;174        assert(xfercfg != NULL);
000008  b104              CBZ      r4,|L13.12|
00000a  e004              B        |L13.22|
                  |L13.12|
00000c  22ae              MOVS     r2,#0xae
00000e  a151              ADR      r1,|L13.340|
000010  a056              ADR      r0,|L13.364|
000012  f7fffffe          BL       __aeabi_assert
                  |L13.22|
;;;175        /* check source increment */
;;;176        assert((xfercfg->srcInc == 0) || (xfercfg->srcInc == 1) || (xfercfg->srcInc == 2) || (xfercfg->srcInc == 4));
000016  79e0              LDRB     r0,[r4,#7]
000018  b140              CBZ      r0,|L13.44|
00001a  79e0              LDRB     r0,[r4,#7]
00001c  2801              CMP      r0,#1
00001e  d005              BEQ      |L13.44|
000020  79e0              LDRB     r0,[r4,#7]
000022  2802              CMP      r0,#2
000024  d002              BEQ      |L13.44|
000026  79e0              LDRB     r0,[r4,#7]
000028  2804              CMP      r0,#4
00002a  d100              BNE      |L13.46|
                  |L13.44|
00002c  e004              B        |L13.56|
                  |L13.46|
00002e  22b0              MOVS     r2,#0xb0
000030  a148              ADR      r1,|L13.340|
000032  4852              LDR      r0,|L13.380|
000034  f7fffffe          BL       __aeabi_assert
                  |L13.56|
;;;177        /* check destination increment */
;;;178        assert((xfercfg->dstInc == 0) || (xfercfg->dstInc == 1) || (xfercfg->dstInc == 2) || (xfercfg->dstInc == 4));
000038  7a20              LDRB     r0,[r4,#8]
00003a  b140              CBZ      r0,|L13.78|
00003c  7a20              LDRB     r0,[r4,#8]
00003e  2801              CMP      r0,#1
000040  d005              BEQ      |L13.78|
000042  7a20              LDRB     r0,[r4,#8]
000044  2802              CMP      r0,#2
000046  d002              BEQ      |L13.78|
000048  7a20              LDRB     r0,[r4,#8]
00004a  2804              CMP      r0,#4
00004c  d100              BNE      |L13.80|
                  |L13.78|
00004e  e004              B        |L13.90|
                  |L13.80|
000050  22b2              MOVS     r2,#0xb2
000052  a140              ADR      r1,|L13.340|
000054  484a              LDR      r0,|L13.384|
000056  f7fffffe          BL       __aeabi_assert
                  |L13.90|
;;;179        /* check data width */
;;;180        assert((xfercfg->byteWidth == 1) || (xfercfg->byteWidth == 2) || (xfercfg->byteWidth == 4));
00005a  79a0              LDRB     r0,[r4,#6]
00005c  2801              CMP      r0,#1
00005e  d005              BEQ      |L13.108|
000060  79a0              LDRB     r0,[r4,#6]
000062  2802              CMP      r0,#2
000064  d002              BEQ      |L13.108|
000066  79a0              LDRB     r0,[r4,#6]
000068  2804              CMP      r0,#4
00006a  d100              BNE      |L13.110|
                  |L13.108|
00006c  e004              B        |L13.120|
                  |L13.110|
00006e  22b4              MOVS     r2,#0xb4
000070  a138              ADR      r1,|L13.340|
000072  4844              LDR      r0,|L13.388|
000074  f7fffffe          BL       __aeabi_assert
                  |L13.120|
;;;181        /* check transfer count */
;;;182        assert(xfercfg->transferCount <= DMA_MAX_TRANSFER_COUNT);
000078  8960              LDRH     r0,[r4,#0xa]
00007a  f5b06f80          CMP      r0,#0x400
00007e  dc00              BGT      |L13.130|
000080  e004              B        |L13.140|
                  |L13.130|
000082  22b6              MOVS     r2,#0xb6
000084  a133              ADR      r1,|L13.340|
000086  a040              ADR      r0,|L13.392|
000088  f7fffffe          BL       __aeabi_assert
                  |L13.140|
;;;183    
;;;184        uint32_t xfer = 0, tmp;
00008c  2500              MOVS     r5,#0
;;;185        /* set valid flag - descriptor is ready now */
;;;186        xfer |= DMA_CHANNEL_XFERCFG_CFGVALID(xfercfg->valid ? 1 : 0);
00008e  7820              LDRB     r0,[r4,#0]
000090  b108              CBZ      r0,|L13.150|
000092  2001              MOVS     r0,#1
000094  e000              B        |L13.152|
                  |L13.150|
000096  2000              MOVS     r0,#0
                  |L13.152|
000098  f0000001          AND      r0,r0,#1
00009c  4305              ORRS     r5,r5,r0
;;;187        /* set reload - allow link to next descriptor */
;;;188        xfer |= DMA_CHANNEL_XFERCFG_RELOAD(xfercfg->reload ? 1 : 0);
00009e  7860              LDRB     r0,[r4,#1]
0000a0  b108              CBZ      r0,|L13.166|
0000a2  2001              MOVS     r0,#1
0000a4  e000              B        |L13.168|
                  |L13.166|
0000a6  2000              MOVS     r0,#0
                  |L13.168|
0000a8  2102              MOVS     r1,#2
0000aa  ea010040          AND      r0,r1,r0,LSL #1
0000ae  4305              ORRS     r5,r5,r0
;;;189        /* set swtrig flag - start transfer */
;;;190        xfer |= DMA_CHANNEL_XFERCFG_SWTRIG(xfercfg->swtrig? 1 : 0);
0000b0  78a0              LDRB     r0,[r4,#2]
0000b2  b108              CBZ      r0,|L13.184|
0000b4  2001              MOVS     r0,#1
0000b6  e000              B        |L13.186|
                  |L13.184|
0000b8  2000              MOVS     r0,#0
                  |L13.186|
0000ba  2104              MOVS     r1,#4
0000bc  ea010080          AND      r0,r1,r0,LSL #2
0000c0  4305              ORRS     r5,r5,r0
;;;191        /* set transfer count */
;;;192        xfer |= DMA_CHANNEL_XFERCFG_CLRTRIG(xfercfg->clrtrig? 1 : 0);
0000c2  78e0              LDRB     r0,[r4,#3]
0000c4  b108              CBZ      r0,|L13.202|
0000c6  2001              MOVS     r0,#1
0000c8  e000              B        |L13.204|
                  |L13.202|
0000ca  2000              MOVS     r0,#0
                  |L13.204|
0000cc  2108              MOVS     r1,#8
0000ce  ea0100c0          AND      r0,r1,r0,LSL #3
0000d2  4305              ORRS     r5,r5,r0
;;;193        /* set INTA */
;;;194        xfer |= DMA_CHANNEL_XFERCFG_SETINTA(xfercfg->intA ? 1 : 0);
0000d4  7920              LDRB     r0,[r4,#4]
0000d6  b108              CBZ      r0,|L13.220|
0000d8  2001              MOVS     r0,#1
0000da  e000              B        |L13.222|
                  |L13.220|
0000dc  2000              MOVS     r0,#0
                  |L13.222|
0000de  2110              MOVS     r1,#0x10
0000e0  ea011000          AND      r0,r1,r0,LSL #4
0000e4  4305              ORRS     r5,r5,r0
;;;195        /* set INTB */
;;;196        xfer |= DMA_CHANNEL_XFERCFG_SETINTB(xfercfg->intB ? 1 : 0);
0000e6  7960              LDRB     r0,[r4,#5]
0000e8  b108              CBZ      r0,|L13.238|
0000ea  2001              MOVS     r0,#1
0000ec  e000              B        |L13.240|
                  |L13.238|
0000ee  2000              MOVS     r0,#0
                  |L13.240|
0000f0  2120              MOVS     r1,#0x20
0000f2  ea011040          AND      r0,r1,r0,LSL #5
0000f6  4305              ORRS     r5,r5,r0
;;;197        /* set data width */
;;;198        tmp = xfercfg->byteWidth == 4 ? 2 : xfercfg->byteWidth - 1;
0000f8  79a0              LDRB     r0,[r4,#6]
0000fa  2804              CMP      r0,#4
0000fc  d101              BNE      |L13.258|
0000fe  2002              MOVS     r0,#2
000100  e001              B        |L13.262|
                  |L13.258|
000102  79a0              LDRB     r0,[r4,#6]
000104  1e40              SUBS     r0,r0,#1
                  |L13.262|
000106  4606              MOV      r6,r0
;;;199        xfer |= DMA_CHANNEL_XFERCFG_WIDTH(tmp);
000108  f44f7040          MOV      r0,#0x300
00010c  ea002006          AND      r0,r0,r6,LSL #8
000110  4305              ORRS     r5,r5,r0
;;;200        /* set source increment value */
;;;201        tmp = xfercfg->srcInc == 4 ? 3 : xfercfg->srcInc;
000112  79e0              LDRB     r0,[r4,#7]
000114  2804              CMP      r0,#4
000116  d101              BNE      |L13.284|
000118  2003              MOVS     r0,#3
00011a  e000              B        |L13.286|
                  |L13.284|
00011c  79e0              LDRB     r0,[r4,#7]
                  |L13.286|
00011e  4606              MOV      r6,r0
;;;202        xfer |= DMA_CHANNEL_XFERCFG_SRCINC(tmp);
000120  f44f5040          MOV      r0,#0x3000
000124  ea003006          AND      r0,r0,r6,LSL #12
000128  4305              ORRS     r5,r5,r0
;;;203        /* set destination increment value */
;;;204        tmp = xfercfg->dstInc == 4 ? 3 : xfercfg->dstInc;
00012a  7a20              LDRB     r0,[r4,#8]
00012c  2804              CMP      r0,#4
00012e  d101              BNE      |L13.308|
000130  2003              MOVS     r0,#3
000132  e000              B        |L13.310|
                  |L13.308|
000134  7a20              LDRB     r0,[r4,#8]
                  |L13.310|
000136  4606              MOV      r6,r0
;;;205        xfer |= DMA_CHANNEL_XFERCFG_DSTINC(tmp);
000138  f44f4040          MOV      r0,#0xc000
00013c  ea003086          AND      r0,r0,r6,LSL #14
000140  4305              ORRS     r5,r5,r0
;;;206        /* set transfer count */
;;;207        xfer |= DMA_CHANNEL_XFERCFG_XFERCOUNT(xfercfg->transferCount - 1);
000142  8960              LDRH     r0,[r4,#0xa]
000144  1e40              SUBS     r0,r0,#1
000146  491d              LDR      r1,|L13.444|
000148  ea014000          AND      r0,r1,r0,LSL #16
00014c  4305              ORRS     r5,r5,r0
;;;208    
;;;209        /* store xferCFG */
;;;210        *xfercfg_addr = xfer;
00014e  603d              STR      r5,[r7,#0]
;;;211    }
000150  e8bd81f0          POP      {r4-r8,pc}
;;;212    
                          ENDP

                  |L13.340|
000154  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
000158  44726976
00015c  6572735c
000160  66736c5f
000164  646d612e
000168  6300    
00016a  00                DCB      0
00016b  00                DCB      0
                  |L13.364|
00016c  78666572          DCB      "xfercfg != NULL",0
000170  63666720
000174  213d204e
000178  554c4c00
                  |L13.380|
                          DCD      ||.conststring||+0x44
                  |L13.384|
                          DCD      ||.conststring||+0xac
                  |L13.388|
                          DCD      ||.conststring||+0x114
                  |L13.392|
000188  78666572          DCB      "xfercfg->transferCount <= DMA_MAX_TRANSFER_COUNT",0
00018c  6366672d
000190  3e747261
000194  6e736665
000198  72436f75
00019c  6e74203c
0001a0  3d20444d
0001a4  415f4d41
0001a8  585f5452
0001ac  414e5346
0001b0  45525f43
0001b4  4f554e54
0001b8  00      
0001b9  00                DCB      0
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L13.444|
                          DCD      0x03ff0000

                          AREA ||i.DMA_StartTransfer||, CODE, READONLY, ALIGN=2

                  DMA_StartTransfer PROC
;;;356    
;;;357    void DMA_StartTransfer(dma_handle_t *handle)
000000  b510              PUSH     {r4,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359        assert(NULL != handle);
000004  b104              CBZ      r4,|L14.8|
000006  e005              B        |L14.20|
                  |L14.8|
000008  f2401267          MOV      r2,#0x167
00000c  a127              ADR      r1,|L14.172|
00000e  a02d              ADR      r0,|L14.196|
000010  f7fffffe          BL       __aeabi_assert
                  |L14.20|
;;;360    
;;;361        /* Enable channel interrupt */
;;;362        handle->base->COMMON[DMA_CHANNEL_GROUP(handle->channel)].INTENSET |= 1U << DMA_CHANNEL_INDEX(handle->channel);
000014  68a0              LDR      r0,[r4,#8]
000016  3020              ADDS     r0,r0,#0x20
000018  7b21              LDRB     r1,[r4,#0xc]
00001a  1149              ASRS     r1,r1,#5
00001c  ebc102c1          RSB      r2,r1,r1,LSL #3
000020  eb021101          ADD      r1,r2,r1,LSL #4
000024  eb000081          ADD      r0,r0,r1,LSL #2
000028  6a80              LDR      r0,[r0,#0x28]
00002a  7b21              LDRB     r1,[r4,#0xc]
00002c  f001021f          AND      r2,r1,#0x1f
000030  2101              MOVS     r1,#1
000032  4091              LSLS     r1,r1,r2
000034  4308              ORRS     r0,r0,r1
000036  68a1              LDR      r1,[r4,#8]
000038  3120              ADDS     r1,r1,#0x20
00003a  7b22              LDRB     r2,[r4,#0xc]
00003c  1152              ASRS     r2,r2,#5
00003e  ebc203c2          RSB      r3,r2,r2,LSL #3
000042  eb031202          ADD      r2,r3,r2,LSL #4
000046  eb010182          ADD      r1,r1,r2,LSL #2
00004a  6288              STR      r0,[r1,#0x28]
;;;363    
;;;364        /* If HW trigger is enabled - disable SW trigger */
;;;365        if (handle->base->CHANNEL[handle->channel].CFG & DMA_CHANNEL_CFG_HWTRIGEN_MASK)
00004c  68a0              LDR      r0,[r4,#8]
00004e  f5006080          ADD      r0,r0,#0x400
000052  7b21              LDRB     r1,[r4,#0xc]
000054  eb001001          ADD      r0,r0,r1,LSL #4
000058  6800              LDR      r0,[r0,#0]
00005a  f0000002          AND      r0,r0,#2
00005e  b160              CBZ      r0,|L14.122|
;;;366        {
;;;367            s_dma_descriptor_table[ handle->channel ].xfercfg &= ~(DMA_CHANNEL_XFERCFG_SWTRIG_MASK);
000060  7b20              LDRB     r0,[r4,#0xc]
000062  491c              LDR      r1,|L14.212|
000064  eb011000          ADD      r0,r1,r0,LSL #4
000068  6800              LDR      r0,[r0,#0]
00006a  f0200004          BIC      r0,r0,#4
00006e  7b21              LDRB     r1,[r4,#0xc]
000070  4a18              LDR      r2,|L14.212|
000072  eb021101          ADD      r1,r2,r1,LSL #4
000076  6008              STR      r0,[r1,#0]
000078  e00b              B        |L14.146|
                  |L14.122|
;;;368        }
;;;369        /* Otherwise enable SW trigger */
;;;370        else
;;;371        {
;;;372            s_dma_descriptor_table[ handle->channel ].xfercfg |= DMA_CHANNEL_XFERCFG_SWTRIG_MASK;
00007a  7b20              LDRB     r0,[r4,#0xc]
00007c  4915              LDR      r1,|L14.212|
00007e  eb011000          ADD      r0,r1,r0,LSL #4
000082  6800              LDR      r0,[r0,#0]
000084  f0400004          ORR      r0,r0,#4
000088  7b21              LDRB     r1,[r4,#0xc]
00008a  4a12              LDR      r2,|L14.212|
00008c  eb021101          ADD      r1,r2,r1,LSL #4
000090  6008              STR      r0,[r1,#0]
                  |L14.146|
;;;373        }
;;;374    
;;;375        /* Set channel XFERCFG register according first channel descriptor. */
;;;376        handle->base->CHANNEL[handle->channel].XFERCFG = s_dma_descriptor_table[ handle->channel ].xfercfg;
000092  7b20              LDRB     r0,[r4,#0xc]
000094  490f              LDR      r1,|L14.212|
000096  eb011000          ADD      r0,r1,r0,LSL #4
00009a  6801              LDR      r1,[r0,#0]
00009c  68a0              LDR      r0,[r4,#8]
00009e  f5006080          ADD      r0,r0,#0x400
0000a2  7b22              LDRB     r2,[r4,#0xc]
0000a4  eb001002          ADD      r0,r0,r2,LSL #4
0000a8  6081              STR      r1,[r0,#8]
;;;377        /* At this moment, the channel ACTIVE bit is set and application cannot modify 
;;;378         * or start another transfer using this channel. Channel ACTIVE bit is cleared by 
;;;379        * 'AbortTransfer' function or when the transfer finishes */
;;;380    }
0000aa  bd10              POP      {r4,pc}
;;;381    
                          ENDP

                  |L14.172|
0000ac  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
0000b0  44726976
0000b4  6572735c
0000b8  66736c5f
0000bc  646d612e
0000c0  6300    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L14.196|
0000c4  4e554c4c          DCB      "NULL != handle",0
0000c8  20213d20
0000cc  68616e64
0000d0  6c6500  
0000d3  00                DCB      0
                  |L14.212|
                          DCD      s_dma_descriptor_table

                          AREA ||i.DMA_SubmitTransfer||, CODE, READONLY, ALIGN=2

                  DMA_SubmitTransfer PROC
;;;328    
;;;329    status_t DMA_SubmitTransfer(dma_handle_t *handle, dma_transfer_config_t *config)
000000  b5f8              PUSH     {r3-r7,lr}
;;;330    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;331        assert((NULL != handle) && (NULL != config));
000006  b10c              CBZ      r4,|L15.12|
000008  b105              CBZ      r5,|L15.12|
00000a  e005              B        |L15.24|
                  |L15.12|
00000c  f240124b          MOV      r2,#0x14b
000010  a135              ADR      r1,|L15.232|
000012  a03b              ADR      r0,|L15.256|
000014  f7fffffe          BL       __aeabi_assert
                  |L15.24|
;;;332    
;;;333        /* Previous transfer has not finished */
;;;334        if (DMA_ChannelIsActive(handle->base, handle->channel))
000018  7b26              LDRB     r6,[r4,#0xc]
00001a  68a7              LDR      r7,[r4,#8]
00001c  2e1e              CMP      r6,#0x1e
00001e  d200              BCS      |L15.34|
000020  e005              B        |L15.46|
                  |L15.34|
000022  22e7              MOVS     r2,#0xe7
000024  4940              LDR      r1,|L15.296|
000026  f1010018          ADD      r0,r1,#0x18
00002a  f7fffffe          BL       __aeabi_assert
                  |L15.46|
00002e  f3c61042          UBFX     r0,r6,#5,#3
000032  ebc001c0          RSB      r1,r0,r0,LSL #3
000036  eb011100          ADD      r1,r1,r0,LSL #4
00003a  f1070020          ADD      r0,r7,#0x20
00003e  eb000081          ADD      r0,r0,r1,LSL #2
000042  6900              LDR      r0,[r0,#0x10]
000044  f006021f          AND      r2,r6,#0x1f
000048  2101              MOVS     r1,#1
00004a  4091              LSLS     r1,r1,r2
00004c  4008              ANDS     r0,r0,r1
00004e  b108              CBZ      r0,|L15.84|
000050  2001              MOVS     r0,#1
000052  e000              B        |L15.86|
                  |L15.84|
000054  2000              MOVS     r0,#0
                  |L15.86|
000056  b110              CBZ      r0,|L15.94|
;;;335        {
;;;336             return kStatus_DMA_Busy;
000058  f2413088          MOV      r0,#0x1388
                  |L15.92|
;;;337        }
;;;338    
;;;339        /* enable/disable peripheral request */
;;;340        if (config->isPeriph)
;;;341        {
;;;342            DMA_EnableChannelPeriphRq(handle->base, handle->channel);
;;;343        }
;;;344        else
;;;345        {
;;;346            DMA_DisableChannelPeriphRq(handle->base, handle->channel);
;;;347        }
;;;348    
;;;349        DMA_CreateDescriptor(
;;;350            &s_dma_descriptor_table[ handle->channel ], &config->xfercfg,
;;;351            config->srcAddr, config->dstAddr, config->nextDesc
;;;352        );
;;;353    
;;;354        return kStatus_Success;
;;;355    }
00005c  bdf8              POP      {r3-r7,pc}
                  |L15.94|
00005e  7e28              LDRB     r0,[r5,#0x18]         ;340
000060  b1c8              CBZ      r0,|L15.150|
000062  7b26              LDRB     r6,[r4,#0xc]          ;342
000064  68a7              LDR      r7,[r4,#8]            ;342
000066  2e1e              CMP      r6,#0x1e              ;342
000068  d200              BCS      |L15.108|
00006a  e006              B        |L15.122|
                  |L15.108|
00006c  f2401223          MOV      r2,#0x123             ;342
000070  492d              LDR      r1,|L15.296|
000072  f1010018          ADD      r0,r1,#0x18           ;342
000076  f7fffffe          BL       __aeabi_assert
                  |L15.122|
00007a  f5076080          ADD      r0,r7,#0x400          ;342
00007e  eb001006          ADD      r0,r0,r6,LSL #4       ;342
000082  6800              LDR      r0,[r0,#0]            ;342
000084  f0400101          ORR      r1,r0,#1              ;342
000088  f5076080          ADD      r0,r7,#0x400          ;342
00008c  eb001006          ADD      r0,r0,r6,LSL #4       ;342
000090  6001              STR      r1,[r0,#0]            ;342
000092  bf00              NOP                            ;342
000094  e019              B        |L15.202|
                  |L15.150|
000096  7b26              LDRB     r6,[r4,#0xc]          ;346
000098  68a7              LDR      r7,[r4,#8]            ;346
00009a  2e1e              CMP      r6,#0x1e              ;346
00009c  d200              BCS      |L15.160|
00009e  e006              B        |L15.174|
                  |L15.160|
0000a0  f44f7298          MOV      r2,#0x130             ;346
0000a4  4920              LDR      r1,|L15.296|
0000a6  f1010018          ADD      r0,r1,#0x18           ;346
0000aa  f7fffffe          BL       __aeabi_assert
                  |L15.174|
0000ae  f5076080          ADD      r0,r7,#0x400          ;346
0000b2  eb001006          ADD      r0,r0,r6,LSL #4       ;346
0000b6  6800              LDR      r0,[r0,#0]            ;346
0000b8  f0200101          BIC      r1,r0,#1              ;346
0000bc  f5076080          ADD      r0,r7,#0x400          ;346
0000c0  eb001006          ADD      r0,r0,r6,LSL #4       ;346
0000c4  6001              STR      r1,[r0,#0]            ;346
0000c6  bf00              NOP                            ;346
0000c8  bf00              NOP                            ;346
                  |L15.202|
0000ca  68a8              LDR      r0,[r5,#8]            ;349
0000cc  9000              STR      r0,[sp,#0]            ;349
0000ce  7b21              LDRB     r1,[r4,#0xc]          ;349
0000d0  4e16              LDR      r6,|L15.300|
0000d2  eb061001          ADD      r0,r6,r1,LSL #4       ;349
0000d6  f105010c          ADD      r1,r5,#0xc            ;349
0000da  e9d52300          LDRD     r2,r3,[r5,#0]         ;349
0000de  f7fffffe          BL       DMA_CreateDescriptor
0000e2  2000              MOVS     r0,#0                 ;354
0000e4  e7ba              B        |L15.92|
;;;356    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L15.232|
0000e8  5352435c          DCB      "SRC\\Drivers\\fsl_dma.c",0
0000ec  44726976
0000f0  6572735c
0000f4  66736c5f
0000f8  646d612e
0000fc  6300    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L15.256|
000100  284e554c          DCB      "(NULL != handle) && (NULL != config)",0
000104  4c20213d
000108  2068616e
00010c  646c6529
000110  20262620
000114  284e554c
000118  4c20213d
00011c  20636f6e
000120  66696729
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L15.296|
                          DCD      ||i.DMA_AbortTransfer||+0x134
                  |L15.300|
                          DCD      s_dma_descriptor_table

                          AREA ||.bss||, DATA, NOINIT, ALIGN=9

                  s_DMAHandle
                          %        512
                  s_dma_descriptor_table
                          %        480

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_dmaBases
                          DCD      0x40082000
                  s_dmaIRQNumber
000004  01                DCB      0x01

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  28636861          DCB      "(channel < FSL_FEATURE_DMA_NUMBER_OF_CHANNELS) && (NULL"
000004  6e6e656c
000008  203c2046
00000c  534c5f46
000010  45415455
000014  52455f44
000018  4d415f4e
00001c  554d4245
000020  525f4f46
000024  5f434841
000028  4e4e454c
00002c  53292026
000030  2620284e
000034  554c4c  
000037  20213d20          DCB      " != trigger)",0
00003b  74726967
00003f  67657229
000043  00      
000044  28786665          DCB      "(xfercfg->srcInc == 0) || (xfercfg->srcInc == 1) || (xf"
000048  72636667
00004c  2d3e7372
000050  63496e63
000054  203d3d20
000058  3029207c
00005c  7c202878
000060  66657263
000064  66672d3e
000068  73726349
00006c  6e63203d
000070  3d203129
000074  207c7c20
000078  287866  
00007b  65726366          DCB      "ercfg->srcInc == 2) || (xfercfg->srcInc == 4)",0
00007f  672d3e73
000083  7263496e
000087  63203d3d
00008b  20322920
00008f  7c7c2028
000093  78666572
000097  6366672d
00009b  3e737263
00009f  496e6320
0000a3  3d3d2034
0000a7  2900    
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
0000ac  28786665          DCB      "(xfercfg->dstInc == 0) || (xfercfg->dstInc == 1) || (xf"
0000b0  72636667
0000b4  2d3e6473
0000b8  74496e63
0000bc  203d3d20
0000c0  3029207c
0000c4  7c202878
0000c8  66657263
0000cc  66672d3e
0000d0  64737449
0000d4  6e63203d
0000d8  3d203129
0000dc  207c7c20
0000e0  287866  
0000e3  65726366          DCB      "ercfg->dstInc == 2) || (xfercfg->dstInc == 4)",0
0000e7  672d3e64
0000eb  7374496e
0000ef  63203d3d
0000f3  20322920
0000f7  7c7c2028
0000fb  78666572
0000ff  6366672d
000103  3e647374
000107  496e6320
00010b  3d3d2034
00010f  2900    
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
000114  28786665          DCB      "(xfercfg->byteWidth == 1) || (xfercfg->byteWidth == 2) "
000118  72636667
00011c  2d3e6279
000120  74655769
000124  64746820
000128  3d3d2031
00012c  29207c7c
000130  20287866
000134  65726366
000138  672d3e62
00013c  79746557
000140  69647468
000144  203d3d20
000148  322920  
00014b  7c7c2028          DCB      "|| (xfercfg->byteWidth == 4)",0
00014f  78666572
000153  6366672d
000157  3e627974
00015b  65576964
00015f  7468203d
000163  3d203429
000167  00      
000168  284e554c          DCB      "(NULL != desc) && (0 == (uint32_t)desc % 16) && (NULL !"
00016c  4c20213d
000170  20646573
000174  63292026
000178  26202830
00017c  203d3d20
000180  2875696e
000184  7433325f
000188  74296465
00018c  73632025
000190  20313629
000194  20262620
000198  284e554c
00019c  4c2021  
00019f  3d207866          DCB      "= xfercfg)",0
0001a3  65726366
0001a7  672900  
0001aa  00                DCB      0
0001ab  00                DCB      0
0001ac  284e554c          DCB      "(NULL != srcAddr) && (0 == (uint32_t)srcAddr % xfercfg-"
0001b0  4c20213d
0001b4  20737263
0001b8  41646472
0001bc  29202626
0001c0  20283020
0001c4  3d3d2028
0001c8  75696e74
0001cc  33325f74
0001d0  29737263
0001d4  41646472
0001d8  20252078
0001dc  66657263
0001e0  66672d  
0001e3  3e627974          DCB      ">byteWidth)",0
0001e7  65576964
0001eb  74682900
0001ef  00                DCB      0
0001f0  284e554c          DCB      "(NULL != dstAddr) && (0 == (uint32_t)dstAddr % xfercfg-"
0001f4  4c20213d
0001f8  20647374
0001fc  41646472
000200  29202626
000204  20283020
000208  3d3d2028
00020c  75696e74
000210  33325f74
000214  29647374
000218  41646472
00021c  20252078
000220  66657263
000224  66672d  
000227  3e627974          DCB      ">byteWidth)",0
00022b  65576964
00022f  74682900
000233  00                DCB      0
000234  284e554c          DCB      "(NULL != handle) && (channel < FSL_FEATURE_DMA_NUMBER_O"
000238  4c20213d
00023c  2068616e
000240  646c6529
000244  20262620
000248  28636861
00024c  6e6e656c
000250  203c2046
000254  534c5f46
000258  45415455
00025c  52455f44
000260  4d415f4e
000264  554d4245
000268  525f4f  
00026b  465f4348          DCB      "F_CHANNELS)",0
00026f  414e4e45
000273  4c532900
000277  00                DCB      0
000278  28786665          DCB      "(xfer_count <= DMA_MAX_TRANSFER_COUNT) && (0 == transfe"
00027c  725f636f
000280  756e7420
000284  3c3d2044
000288  4d415f4d
00028c  41585f54
000290  52414e53
000294  4645525f
000298  434f554e
00029c  54292026
0002a0  26202830
0002a4  203d3d20
0002a8  7472616e
0002ac  736665  
0002af  72427974          DCB      "rBytes % byteWidth)",0
0002b3  65732025
0002b7  20627974
0002bb  65576964
0002bf  74682900

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_dma_c_8eda9ce1____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_dma_c_8eda9ce1____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_dma_c_8eda9ce1____REVSH|
#line 402
|__asm___9_fsl_dma_c_8eda9ce1____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_dma_c_8eda9ce1____RRX|
#line 587
|__asm___9_fsl_dma_c_8eda9ce1____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
