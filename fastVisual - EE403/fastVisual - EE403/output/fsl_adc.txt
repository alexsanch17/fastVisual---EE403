; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_adc.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_adc.crf SRC\Drivers\fsl_adc.c]
                          THUMB

                          AREA ||i.ADC_Deinit||, CODE, READONLY, ALIGN=2

                  ADC_Deinit PROC
;;;107    
;;;108    void ADC_Deinit(ADC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;109    {
000002  4605              MOV      r5,r0
;;;110    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;111        /* Disable the clock. */
;;;112        CLOCK_DisableClock(s_adcClocks[ADC_GetInstance(base)]);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       ADC_GetInstance
00000a  490a              LDR      r1,|L1.52|
00000c  f8314010          LDRH     r4,[r1,r0,LSL #1]
000010  0a20              LSRS     r0,r4,#8
000012  2803              CMP      r0,#3
000014  d205              BCS      |L1.34|
000016  2101              MOVS     r1,#1
000018  40a1              LSLS     r1,r1,r4
00001a  4a07              LDR      r2,|L1.56|
00001c  f8421020          STR      r1,[r2,r0,LSL #2]
000020  e006              B        |L1.48|
                  |L1.34|
000022  2101              MOVS     r1,#1
000024  40a1              LSLS     r1,r1,r4
000026  4a05              LDR      r2,|L1.60|
000028  6191              STR      r1,[r2,#0x18]
00002a  2100              MOVS     r1,#0
00002c  0312              LSLS     r2,r2,#12
00002e  64d1              STR      r1,[r2,#0x4c]
                  |L1.48|
000030  bf00              NOP      
;;;113    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;114    }
000032  bd70              POP      {r4-r6,pc}
;;;115    
                          ENDP

                  |L1.52|
                          DCD      s_adcClocks
                  |L1.56|
                          DCD      0x40000240
                  |L1.60|
                          DCD      0x40040000

                          AREA ||i.ADC_DoSelfCalibration||, CODE, READONLY, ALIGN=2

                  ADC_DoSelfCalibration PROC
;;;115    
;;;116    bool ADC_DoSelfCalibration(ADC_Type *base)
000000  4601              MOV      r1,r0
;;;117    {
;;;118        uint32_t i;
;;;119    
;;;120        /* Enable the converter. */
;;;121        /* This bit acn only be set 1 by software. It is cleared automatically whenever the ADC is powered down.
;;;122           This bit should be set after at least 10 ms after the ADC is powered on. */
;;;123        base->STARTUP = ADC_STARTUP_ADC_ENA_MASK;
000002  2001              MOVS     r0,#1
000004  66c8              STR      r0,[r1,#0x6c]
;;;124        for (i = 0U; i < 0x10; i++) /* Wait a few clocks to startup up. */
000006  2200              MOVS     r2,#0
000008  e001              B        |L2.14|
                  |L2.10|
;;;125        {
;;;126            __ASM("NOP");
00000a  bf00              NOP      
00000c  1c52              ADDS     r2,r2,#1              ;124
                  |L2.14|
00000e  2a10              CMP      r2,#0x10              ;124
000010  d3fb              BCC      |L2.10|
;;;127        }
;;;128        if (!(base->STARTUP & ADC_STARTUP_ADC_ENA_MASK))
000012  6ec8              LDR      r0,[r1,#0x6c]
000014  f0000001          AND      r0,r0,#1
000018  b908              CBNZ     r0,|L2.30|
;;;129        {
;;;130            return false; /* ADC is not powered up. */
00001a  2000              MOVS     r0,#0
                  |L2.28|
;;;131        }
;;;132    
;;;133        /* If not in by-pass mode, do the calibration. */
;;;134        if ((ADC_CALIB_CALREQD_MASK == (base->CALIB & ADC_CALIB_CALREQD_MASK)) &&
;;;135            (0U == (base->CTRL & ADC_CTRL_BYPASSCAL_MASK)))
;;;136        {
;;;137            /* Calibration is needed, do it now. */
;;;138            base->CALIB = ADC_CALIB_CALIB_MASK;
;;;139            i = 0xF0000;
;;;140            while ((ADC_CALIB_CALIB_MASK == (base->CALIB & ADC_CALIB_CALIB_MASK)) && (--i))
;;;141            {
;;;142            }
;;;143            if (i == 0U)
;;;144            {
;;;145                return false; /* Calibration timeout. */
;;;146            }
;;;147        }
;;;148    
;;;149        /* A dummy conversion cycle will be performed. */
;;;150        base->STARTUP |= ADC_STARTUP_ADC_INIT_MASK;
;;;151        i = 0x7FFFF;
;;;152        while ((ADC_STARTUP_ADC_INIT_MASK == (base->STARTUP & ADC_STARTUP_ADC_INIT_MASK)) && (--i))
;;;153        {
;;;154        }
;;;155        if (i == 0U)
;;;156        {
;;;157            return false;
;;;158        }
;;;159    
;;;160        return true;
;;;161    }
00001c  4770              BX       lr
                  |L2.30|
00001e  6f08              LDR      r0,[r1,#0x70]         ;134
000020  f0000002          AND      r0,r0,#2              ;134
000024  2802              CMP      r0,#2                 ;134
000026  d112              BNE      |L2.78|
000028  6808              LDR      r0,[r1,#0]            ;135
00002a  f4006000          AND      r0,r0,#0x800          ;135
00002e  b970              CBNZ     r0,|L2.78|
000030  2001              MOVS     r0,#1                 ;138
000032  6708              STR      r0,[r1,#0x70]         ;138
000034  f44f2270          MOV      r2,#0xf0000           ;139
000038  bf00              NOP                            ;140
                  |L2.58|
00003a  6f08              LDR      r0,[r1,#0x70]         ;140
00003c  f0000001          AND      r0,r0,#1              ;140
000040  b110              CBZ      r0,|L2.72|
000042  1e50              SUBS     r0,r2,#1              ;140
000044  1e02              SUBS     r2,r0,#0              ;140
000046  d1f8              BNE      |L2.58|
                  |L2.72|
000048  b90a              CBNZ     r2,|L2.78|
00004a  2000              MOVS     r0,#0                 ;145
00004c  e7e6              B        |L2.28|
                  |L2.78|
00004e  6ec8              LDR      r0,[r1,#0x6c]         ;150
000050  f0400002          ORR      r0,r0,#2              ;150
000054  66c8              STR      r0,[r1,#0x6c]         ;150
000056  4a07              LDR      r2,|L2.116|
000058  bf00              NOP                            ;152
                  |L2.90|
00005a  6ec8              LDR      r0,[r1,#0x6c]         ;152
00005c  f0000002          AND      r0,r0,#2              ;152
000060  2802              CMP      r0,#2                 ;152
000062  d102              BNE      |L2.106|
000064  1e50              SUBS     r0,r2,#1              ;152
000066  1e02              SUBS     r2,r0,#0              ;152
000068  d1f7              BNE      |L2.90|
                  |L2.106|
00006a  b90a              CBNZ     r2,|L2.112|
00006c  2000              MOVS     r0,#0                 ;157
00006e  e7d5              B        |L2.28|
                  |L2.112|
000070  2001              MOVS     r0,#1                 ;160
000072  e7d3              B        |L2.28|
;;;162    
                          ENDP

                  |L2.116|
                          DCD      0x0007ffff

                          AREA ||i.ADC_GetChannelConversionResult||, CODE, READONLY, ALIGN=2

                  ADC_GetChannelConversionResult PROC
;;;294    
;;;295    bool ADC_GetChannelConversionResult(ADC_Type *base, uint32_t channel, adc_result_info_t *info)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;296    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;297        assert(info != NULL);
00000a  b104              CBZ      r4,|L3.14|
00000c  e005              B        |L3.26|
                  |L3.14|
00000e  f2401229          MOV      r2,#0x129
000012  a114              ADR      r1,|L3.100|
000014  a019              ADR      r0,|L3.124|
000016  f7fffffe          BL       __aeabi_assert
                  |L3.26|
;;;298        assert(channel < ADC_DAT_COUNT);
00001a  2e0c              CMP      r6,#0xc
00001c  d200              BCS      |L3.32|
00001e  e005              B        |L3.44|
                  |L3.32|
000020  f44f7295          MOV      r2,#0x12a
000024  a10f              ADR      r1,|L3.100|
000026  a019              ADR      r0,|L3.140|
000028  f7fffffe          BL       __aeabi_assert
                  |L3.44|
;;;299    
;;;300        uint32_t tmp32 = base->DAT[channel]; /* Read to clear the status. */
00002c  f1070020          ADD      r0,r7,#0x20
000030  f8505026          LDR      r5,[r0,r6,LSL #2]
;;;301    
;;;302        if (0U == (ADC_DAT_DATAVALID_MASK & tmp32))
000034  f0054000          AND      r0,r5,#0x80000000
000038  b910              CBNZ     r0,|L3.64|
;;;303        {
;;;304            return false;
00003a  2000              MOVS     r0,#0
                  |L3.60|
;;;305        }
;;;306    
;;;307        info->result = (tmp32 & ADC_DAT_RESULT_MASK) >> ADC_DAT_RESULT_SHIFT;
;;;308        info->thresholdCompareStatus =
;;;309            (adc_threshold_compare_status_t)((tmp32 & ADC_DAT_THCMPRANGE_MASK) >> ADC_DAT_THCMPRANGE_SHIFT);
;;;310        info->thresholdCorssingStatus =
;;;311            (adc_threshold_crossing_status_t)((tmp32 & ADC_DAT_THCMPCROSS_MASK) >> ADC_DAT_THCMPCROSS_SHIFT);
;;;312        info->channelNumber = (tmp32 & ADC_DAT_CHANNEL_MASK) >> ADC_DAT_CHANNEL_SHIFT;
;;;313        info->overrunFlag = ((tmp32 & ADC_DAT_OVERRUN_MASK) == ADC_DAT_OVERRUN_MASK);
;;;314    
;;;315        return true;
;;;316    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.64|
000040  f3c5100b          UBFX     r0,r5,#4,#12          ;307
000044  6020              STR      r0,[r4,#0]            ;307
000046  f3c54001          UBFX     r0,r5,#16,#2          ;308
00004a  7120              STRB     r0,[r4,#4]            ;308
00004c  f3c54081          UBFX     r0,r5,#18,#2          ;310
000050  7160              STRB     r0,[r4,#5]            ;310
000052  f3c56083          UBFX     r0,r5,#26,#4          ;312
000056  60a0              STR      r0,[r4,#8]            ;312
000058  f3c57080          UBFX     r0,r5,#30,#1          ;313
00005c  7320              STRB     r0,[r4,#0xc]          ;313
00005e  2001              MOVS     r0,#1                 ;315
000060  e7ec              B        |L3.60|
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
000064  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000068  44726976
00006c  6572735c
000070  66736c5f
000074  6164632e
000078  6300    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L3.124|
00007c  696e666f          DCB      "info != NULL",0
000080  20213d20
000084  4e554c4c
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L3.140|
00008c  6368616e          DCB      "channel < ADC_DAT_COUNT",0
000090  6e656c20
000094  3c204144
000098  435f4441
00009c  545f434f
0000a0  554e5400

                          AREA ||i.ADC_GetConvSeqAGlobalConversionResult||, CODE, READONLY, ALIGN=2

                  ADC_GetConvSeqAGlobalConversionResult PROC
;;;250    
;;;251    bool ADC_GetConvSeqAGlobalConversionResult(ADC_Type *base, adc_result_info_t *info)
000000  b570              PUSH     {r4-r6,lr}
;;;252    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;253        assert(info != NULL);
000006  b104              CBZ      r4,|L4.10|
000008  e004              B        |L4.20|
                  |L4.10|
00000a  22fd              MOVS     r2,#0xfd
00000c  a10d              ADR      r1,|L4.68|
00000e  a013              ADR      r0,|L4.92|
000010  f7fffffe          BL       __aeabi_assert
                  |L4.20|
;;;254    
;;;255        uint32_t tmp32 = base->SEQ_GDAT[0]; /* Read to clear the status. */
000014  6935              LDR      r5,[r6,#0x10]
;;;256    
;;;257        if (0U == (ADC_SEQ_GDAT_DATAVALID_MASK & tmp32))
000016  f0054000          AND      r0,r5,#0x80000000
00001a  b908              CBNZ     r0,|L4.32|
;;;258        {
;;;259            return false;
00001c  2000              MOVS     r0,#0
                  |L4.30|
;;;260        }
;;;261    
;;;262        info->result = (tmp32 & ADC_SEQ_GDAT_RESULT_MASK) >> ADC_SEQ_GDAT_RESULT_SHIFT;
;;;263        info->thresholdCompareStatus =
;;;264            (adc_threshold_compare_status_t)((tmp32 & ADC_SEQ_GDAT_THCMPRANGE_MASK) >> ADC_SEQ_GDAT_THCMPRANGE_SHIFT);
;;;265        info->thresholdCorssingStatus =
;;;266            (adc_threshold_crossing_status_t)((tmp32 & ADC_SEQ_GDAT_THCMPCROSS_MASK) >> ADC_SEQ_GDAT_THCMPCROSS_SHIFT);
;;;267        info->channelNumber = (tmp32 & ADC_SEQ_GDAT_CHN_MASK) >> ADC_SEQ_GDAT_CHN_SHIFT;
;;;268        info->overrunFlag = ((tmp32 & ADC_SEQ_GDAT_OVERRUN_MASK) == ADC_SEQ_GDAT_OVERRUN_MASK);
;;;269    
;;;270        return true;
;;;271    }
00001e  bd70              POP      {r4-r6,pc}
                  |L4.32|
000020  f3c5100b          UBFX     r0,r5,#4,#12          ;262
000024  6020              STR      r0,[r4,#0]            ;262
000026  f3c54001          UBFX     r0,r5,#16,#2          ;263
00002a  7120              STRB     r0,[r4,#4]            ;263
00002c  f3c54081          UBFX     r0,r5,#18,#2          ;265
000030  7160              STRB     r0,[r4,#5]            ;265
000032  f3c56083          UBFX     r0,r5,#26,#4          ;267
000036  60a0              STR      r0,[r4,#8]            ;267
000038  f3c57080          UBFX     r0,r5,#30,#1          ;268
00003c  7320              STRB     r0,[r4,#0xc]          ;268
00003e  2001              MOVS     r0,#1                 ;270
000040  e7ed              B        |L4.30|
;;;272    
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  6164632e
000058  6300    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L4.92|
00005c  696e666f          DCB      "info != NULL",0
000060  20213d20
000064  4e554c4c
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.ADC_GetConvSeqBGlobalConversionResult||, CODE, READONLY, ALIGN=2

                  ADC_GetConvSeqBGlobalConversionResult PROC
;;;272    
;;;273    bool ADC_GetConvSeqBGlobalConversionResult(ADC_Type *base, adc_result_info_t *info)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;275        assert(info != NULL);
000006  b104              CBZ      r4,|L5.10|
000008  e005              B        |L5.22|
                  |L5.10|
00000a  f2401213          MOV      r2,#0x113
00000e  a10d              ADR      r1,|L5.68|
000010  a012              ADR      r0,|L5.92|
000012  f7fffffe          BL       __aeabi_assert
                  |L5.22|
;;;276    
;;;277        uint32_t tmp32 = base->SEQ_GDAT[1]; /* Read to clear the status. */
000016  6975              LDR      r5,[r6,#0x14]
;;;278    
;;;279        if (0U == (ADC_SEQ_GDAT_DATAVALID_MASK & tmp32))
000018  f0054000          AND      r0,r5,#0x80000000
00001c  b908              CBNZ     r0,|L5.34|
;;;280        {
;;;281            return false;
00001e  2000              MOVS     r0,#0
                  |L5.32|
;;;282        }
;;;283    
;;;284        info->result = (tmp32 & ADC_SEQ_GDAT_RESULT_MASK) >> ADC_SEQ_GDAT_RESULT_SHIFT;
;;;285        info->thresholdCompareStatus =
;;;286            (adc_threshold_compare_status_t)((tmp32 & ADC_SEQ_GDAT_THCMPRANGE_MASK) >> ADC_SEQ_GDAT_THCMPRANGE_SHIFT);
;;;287        info->thresholdCorssingStatus =
;;;288            (adc_threshold_crossing_status_t)((tmp32 & ADC_SEQ_GDAT_THCMPCROSS_MASK) >> ADC_SEQ_GDAT_THCMPCROSS_SHIFT);
;;;289        info->channelNumber = (tmp32 & ADC_SEQ_GDAT_CHN_MASK) >> ADC_SEQ_GDAT_CHN_SHIFT;
;;;290        info->overrunFlag = ((tmp32 & ADC_SEQ_GDAT_OVERRUN_MASK) == ADC_SEQ_GDAT_OVERRUN_MASK);
;;;291    
;;;292        return true;
;;;293    }
000020  bd70              POP      {r4-r6,pc}
                  |L5.34|
000022  f3c5100b          UBFX     r0,r5,#4,#12          ;284
000026  6020              STR      r0,[r4,#0]            ;284
000028  f3c54001          UBFX     r0,r5,#16,#2          ;285
00002c  7120              STRB     r0,[r4,#4]            ;285
00002e  f3c54081          UBFX     r0,r5,#18,#2          ;287
000032  7160              STRB     r0,[r4,#5]            ;287
000034  f3c56083          UBFX     r0,r5,#26,#4          ;289
000038  60a0              STR      r0,[r4,#8]            ;289
00003a  f3c57080          UBFX     r0,r5,#30,#1          ;290
00003e  7320              STRB     r0,[r4,#0xc]          ;290
000040  2001              MOVS     r0,#1                 ;292
000042  e7ed              B        |L5.32|
;;;294    
                          ENDP

                  |L5.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  6164632e
000058  6300    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L5.92|
00005c  696e666f          DCB      "info != NULL",0
000060  20213d20
000064  4e554c4c
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.ADC_GetDefaultConfig||, CODE, READONLY, ALIGN=1

                  ADC_GetDefaultConfig PROC
;;;98     
;;;99     void ADC_GetDefaultConfig(adc_config_t *config)
000000  2100              MOVS     r1,#0
;;;100    {
;;;101        config->clockMode = kADC_ClockSynchronousMode;
000002  7001              STRB     r1,[r0,#0]
;;;102        config->clockDividerNumber = 0U;
000004  6041              STR      r1,[r0,#4]
;;;103        config->resolution = kADC_Resolution12bit;
000006  2103              MOVS     r1,#3
000008  7201              STRB     r1,[r0,#8]
;;;104        config->enableBypassCalibration = false;
00000a  2100              MOVS     r1,#0
00000c  7241              STRB     r1,[r0,#9]
;;;105        config->sampleTimeNumber = 0U;
00000e  60c1              STR      r1,[r0,#0xc]
;;;106    }
000010  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.ADC_GetInstance||, CODE, READONLY, ALIGN=2

                  ADC_GetInstance PROC
;;;38     
;;;39     static uint32_t ADC_GetInstance(ADC_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;40     {
000002  4605              MOV      r5,r0
;;;41         uint32_t instance;
;;;42     
;;;43         /* Find the instance index from base address mappings. */
;;;44         for (instance = 0; instance < FSL_FEATURE_SOC_ADC_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L7.22|
                  |L7.8|
;;;45         {
;;;46             if (s_adcBases[instance] == base)
000008  4809              LDR      r0,|L7.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L7.20|
;;;47             {
;;;48                 break;
000012  e002              B        |L7.26|
                  |L7.20|
000014  1c64              ADDS     r4,r4,#1              ;44
                  |L7.22|
000016  2c00              CMP      r4,#0                 ;44
000018  d0f6              BEQ      |L7.8|
                  |L7.26|
00001a  bf00              NOP      
;;;49             }
;;;50         }
;;;51     
;;;52         assert(instance < FSL_FEATURE_SOC_ADC_COUNT);
00001c  b904              CBNZ     r4,|L7.32|
00001e  e004              B        |L7.42|
                  |L7.32|
000020  2234              MOVS     r2,#0x34
000022  a104              ADR      r1,|L7.52|
000024  a009              ADR      r0,|L7.76|
000026  f7fffffe          BL       __aeabi_assert
                  |L7.42|
;;;53     
;;;54         return instance;
00002a  4620              MOV      r0,r4
;;;55     }
00002c  bd70              POP      {r4-r6,pc}
;;;56     
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      s_adcBases
                  |L7.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  6164632e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L7.76|
00004c  696e7374          DCB      "instance < FSL_FEATURE_SOC_ADC_COUNT",0
000050  616e6365
000054  203c2046
000058  534c5f46
00005c  45415455
000060  52455f53
000064  4f435f41
000068  44435f43
00006c  4f554e54
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;56     
;;;57     void ADC_Init(ADC_Type *base, const adc_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;58     {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;59         assert(config != NULL);
000008  b104              CBZ      r4,|L8.12|
00000a  e004              B        |L8.22|
                  |L8.12|
00000c  223b              MOVS     r2,#0x3b
00000e  a11c              ADR      r1,|L8.128|
000010  a021              ADR      r0,|L8.152|
000012  f7fffffe          BL       __aeabi_assert
                  |L8.22|
;;;60     
;;;61         uint32_t tmp32 = 0U;
000016  2500              MOVS     r5,#0
;;;62     
;;;63     #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;64         /* Enable clock. */
;;;65         CLOCK_EnableClock(s_adcClocks[ADC_GetInstance(base)]);
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       ADC_GetInstance
00001e  4922              LDR      r1,|L8.168|
000020  f8316010          LDRH     r6,[r1,r0,LSL #1]
000024  0a30              LSRS     r0,r6,#8
000026  2803              CMP      r0,#3
000028  d205              BCS      |L8.54|
00002a  2101              MOVS     r1,#1
00002c  40b1              LSLS     r1,r1,r6
00002e  4a1f              LDR      r2,|L8.172|
000030  f8421020          STR      r1,[r2,r0,LSL #2]
000034  e005              B        |L8.66|
                  |L8.54|
000036  2101              MOVS     r1,#1
000038  078a              LSLS     r2,r1,#30
00003a  64d1              STR      r1,[r2,#0x4c]
00003c  40b1              LSLS     r1,r1,r6
00003e  4a1c              LDR      r2,|L8.176|
000040  6151              STR      r1,[r2,#0x14]
                  |L8.66|
000042  bf00              NOP      
;;;66     #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;67     
;;;68         /* Disable the interrupts. */
;;;69         base->INTEN = 0U; /* Quickly disable all the interrupts. */
000044  2000              MOVS     r0,#0
000046  6678              STR      r0,[r7,#0x64]
;;;70     
;;;71         /* Configure the ADC block. */
;;;72         tmp32 = ADC_CTRL_CLKDIV(config->clockDividerNumber);
000048  7925              LDRB     r5,[r4,#4]
;;;73     
;;;74         /* Async or Sync clock mode. */
;;;75         switch (config->clockMode)
00004a  7820              LDRB     r0,[r4,#0]
00004c  2801              CMP      r0,#1
00004e  d102              BNE      |L8.86|
;;;76         {
;;;77             case kADC_ClockAsynchronousMode:
;;;78                 tmp32 |= ADC_CTRL_ASYNMODE_MASK;
000050  f4457580          ORR      r5,r5,#0x100
;;;79                 break;
000054  e000              B        |L8.88|
                  |L8.86|
;;;80             default: /* kADC_ClockSynchronousMode */
;;;81                 break;
000056  bf00              NOP      
                  |L8.88|
000058  bf00              NOP                            ;79
;;;82         }
;;;83     
;;;84         /* Resolution. */
;;;85         tmp32 |= ADC_CTRL_RESOL(config->resolution);
00005a  7a20              LDRB     r0,[r4,#8]
00005c  f44f61c0          MOV      r1,#0x600
000060  ea012040          AND      r0,r1,r0,LSL #9
000064  4305              ORRS     r5,r5,r0
;;;86     
;;;87         /* Bypass calibration. */
;;;88         if (config->enableBypassCalibration)
000066  7a60              LDRB     r0,[r4,#9]
000068  b108              CBZ      r0,|L8.110|
;;;89         {
;;;90             tmp32 |= ADC_CTRL_BYPASSCAL_MASK;
00006a  f4456500          ORR      r5,r5,#0x800
                  |L8.110|
;;;91         }
;;;92     
;;;93         /* Sample time clock count. */
;;;94         tmp32 |= ADC_CTRL_TSAMP(config->sampleTimeNumber);
00006e  f44f41e0          MOV      r1,#0x7000
000072  68e0              LDR      r0,[r4,#0xc]
000074  ea013000          AND      r0,r1,r0,LSL #12
000078  4305              ORRS     r5,r5,r0
;;;95     
;;;96         base->CTRL = tmp32;
00007a  603d              STR      r5,[r7,#0]
;;;97     }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;98     
                          ENDP

                  |L8.128|
000080  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000084  44726976
000088  6572735c
00008c  66736c5f
000090  6164632e
000094  6300    
000096  00                DCB      0
000097  00                DCB      0
                  |L8.152|
000098  636f6e66          DCB      "config != NULL",0
00009c  69672021
0000a0  3d204e55
0000a4  4c4c00  
0000a7  00                DCB      0
                  |L8.168|
                          DCD      s_adcClocks
                  |L8.172|
                          DCD      0x40000220
                  |L8.176|
                          DCD      0x40040000

                          AREA ||i.ADC_SetConvSeqAConfig||, CODE, READONLY, ALIGN=2

                  ADC_SetConvSeqAConfig PROC
;;;162    
;;;163    void ADC_SetConvSeqAConfig(ADC_Type *base, const adc_conv_seq_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;164    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;165        assert(config != NULL);
000006  b104              CBZ      r4,|L9.10|
000008  e004              B        |L9.20|
                  |L9.10|
00000a  22a5              MOVS     r2,#0xa5
00000c  a113              ADR      r1,|L9.92|
00000e  a019              ADR      r0,|L9.116|
000010  f7fffffe          BL       __aeabi_assert
                  |L9.20|
;;;166    
;;;167        uint32_t tmp32;
;;;168    
;;;169        tmp32 = ADC_SEQ_CTRL_CHANNELS(config->channelMask)   /* Channel mask. */
000014  8820              LDRH     r0,[r4,#0]
000016  f3c0000b          UBFX     r0,r0,#0,#12
00001a  f44f327c          MOV      r2,#0x3f000
00001e  6861              LDR      r1,[r4,#4]
000020  ea023101          AND      r1,r2,r1,LSL #12
000024  ea400501          ORR      r5,r0,r1
;;;170                | ADC_SEQ_CTRL_TRIGGER(config->triggerMask); /* Trigger mask. */
;;;171    
;;;172        /* Polarity for tirgger signal. */
;;;173        switch (config->triggerPolarity)
000028  7a20              LDRB     r0,[r4,#8]
00002a  2801              CMP      r0,#1
00002c  d102              BNE      |L9.52|
;;;174        {
;;;175            case kADC_TriggerPolarityPositiveEdge:
;;;176                tmp32 |= ADC_SEQ_CTRL_TRIGPOL_MASK;
00002e  f4452580          ORR      r5,r5,#0x40000
;;;177                break;
000032  e000              B        |L9.54|
                  |L9.52|
;;;178            default: /* kADC_TriggerPolarityNegativeEdge */
;;;179                break;
000034  bf00              NOP      
                  |L9.54|
000036  bf00              NOP                            ;177
;;;180        }
;;;181    
;;;182        /* Bypass the clock Sync. */
;;;183        if (config->enableSyncBypass)
000038  7a60              LDRB     r0,[r4,#9]
00003a  b108              CBZ      r0,|L9.64|
;;;184        {
;;;185            tmp32 |= ADC_SEQ_CTRL_SYNCBYPASS_MASK;
00003c  f4452500          ORR      r5,r5,#0x80000
                  |L9.64|
;;;186        }
;;;187    
;;;188        /* Interrupt point. */
;;;189        switch (config->interruptMode)
000040  7ae0              LDRB     r0,[r4,#0xb]
000042  2801              CMP      r0,#1
000044  d102              BNE      |L9.76|
;;;190        {
;;;191            case kADC_InterruptForEachSequence:
;;;192                tmp32 |= ADC_SEQ_CTRL_MODE_MASK;
000046  f0454580          ORR      r5,r5,#0x40000000
;;;193                break;
00004a  e000              B        |L9.78|
                  |L9.76|
;;;194            default: /* kADC_InterruptForEachConversion */
;;;195                break;
00004c  bf00              NOP      
                  |L9.78|
00004e  bf00              NOP                            ;193
;;;196        }
;;;197    
;;;198        /* One trigger for a conversion, or for a sequence. */
;;;199        if (config->enableSingleStep)
000050  7aa0              LDRB     r0,[r4,#0xa]
000052  b108              CBZ      r0,|L9.88|
;;;200        {
;;;201            tmp32 |= ADC_SEQ_CTRL_SINGLESTEP_MASK;
000054  f0455580          ORR      r5,r5,#0x10000000
                  |L9.88|
;;;202        }
;;;203    
;;;204        base->SEQ_CTRL[0] = tmp32;
000058  60b5              STR      r5,[r6,#8]
;;;205    }
00005a  bd70              POP      {r4-r6,pc}
;;;206    
                          ENDP

                  |L9.92|
00005c  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000060  44726976
000064  6572735c
000068  66736c5f
00006c  6164632e
000070  6300    
000072  00                DCB      0
000073  00                DCB      0
                  |L9.116|
000074  636f6e66          DCB      "config != NULL",0
000078  69672021
00007c  3d204e55
000080  4c4c00  
000083  00                DCB      0

                          AREA ||i.ADC_SetConvSeqBConfig||, CODE, READONLY, ALIGN=2

                  ADC_SetConvSeqBConfig PROC
;;;206    
;;;207    void ADC_SetConvSeqBConfig(ADC_Type *base, const adc_conv_seq_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;208    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;209        assert(config != NULL);
000006  b104              CBZ      r4,|L10.10|
000008  e004              B        |L10.20|
                  |L10.10|
00000a  22d1              MOVS     r2,#0xd1
00000c  a113              ADR      r1,|L10.92|
00000e  a019              ADR      r0,|L10.116|
000010  f7fffffe          BL       __aeabi_assert
                  |L10.20|
;;;210    
;;;211        uint32_t tmp32;
;;;212    
;;;213        tmp32 = ADC_SEQ_CTRL_CHANNELS(config->channelMask)   /* Channel mask. */
000014  8820              LDRH     r0,[r4,#0]
000016  f3c0000b          UBFX     r0,r0,#0,#12
00001a  f44f327c          MOV      r2,#0x3f000
00001e  6861              LDR      r1,[r4,#4]
000020  ea023101          AND      r1,r2,r1,LSL #12
000024  ea400501          ORR      r5,r0,r1
;;;214                | ADC_SEQ_CTRL_TRIGGER(config->triggerMask); /* Trigger mask. */
;;;215    
;;;216        /* Polarity for tirgger signal. */
;;;217        switch (config->triggerPolarity)
000028  7a20              LDRB     r0,[r4,#8]
00002a  2801              CMP      r0,#1
00002c  d102              BNE      |L10.52|
;;;218        {
;;;219            case kADC_TriggerPolarityPositiveEdge:
;;;220                tmp32 |= ADC_SEQ_CTRL_TRIGPOL_MASK;
00002e  f4452580          ORR      r5,r5,#0x40000
;;;221                break;
000032  e000              B        |L10.54|
                  |L10.52|
;;;222            default: /* kADC_TriggerPolarityPositiveEdge */
;;;223                break;
000034  bf00              NOP      
                  |L10.54|
000036  bf00              NOP                            ;221
;;;224        }
;;;225    
;;;226        /* Bypass the clock Sync. */
;;;227        if (config->enableSyncBypass)
000038  7a60              LDRB     r0,[r4,#9]
00003a  b108              CBZ      r0,|L10.64|
;;;228        {
;;;229            tmp32 |= ADC_SEQ_CTRL_SYNCBYPASS_MASK;
00003c  f4452500          ORR      r5,r5,#0x80000
                  |L10.64|
;;;230        }
;;;231    
;;;232        /* Interrupt point. */
;;;233        switch (config->interruptMode)
000040  7ae0              LDRB     r0,[r4,#0xb]
000042  2801              CMP      r0,#1
000044  d102              BNE      |L10.76|
;;;234        {
;;;235            case kADC_InterruptForEachSequence:
;;;236                tmp32 |= ADC_SEQ_CTRL_MODE_MASK;
000046  f0454580          ORR      r5,r5,#0x40000000
;;;237                break;
00004a  e000              B        |L10.78|
                  |L10.76|
;;;238            default: /* kADC_InterruptForEachConversion */
;;;239                break;
00004c  bf00              NOP      
                  |L10.78|
00004e  bf00              NOP                            ;237
;;;240        }
;;;241    
;;;242        /* One trigger for a conversion, or for a sequence. */
;;;243        if (config->enableSingleStep)
000050  7aa0              LDRB     r0,[r4,#0xa]
000052  b108              CBZ      r0,|L10.88|
;;;244        {
;;;245            tmp32 |= ADC_SEQ_CTRL_SINGLESTEP_MASK;
000054  f0455580          ORR      r5,r5,#0x10000000
                  |L10.88|
;;;246        }
;;;247    
;;;248        base->SEQ_CTRL[1] = tmp32;
000058  60f5              STR      r5,[r6,#0xc]
;;;249    }
00005a  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

                  |L10.92|
00005c  5352435c          DCB      "SRC\\Drivers\\fsl_adc.c",0
000060  44726976
000064  6572735c
000068  66736c5f
00006c  6164632e
000070  6300    
000072  00                DCB      0
000073  00                DCB      0
                  |L10.116|
000074  636f6e66          DCB      "config != NULL",0
000078  69672021
00007c  3d204e55
000080  4c4c00  
000083  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_adcBases
                          DCD      0x400a0000
                  s_adcClocks
000004  001b              DCW      0x001b

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_adc_c_ADC_Init____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_adc_c_ADC_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_adc_c_ADC_Init____REVSH|
#line 402
|__asm___9_fsl_adc_c_ADC_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_adc_c_ADC_Init____RRX|
#line 587
|__asm___9_fsl_adc_c_ADC_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
