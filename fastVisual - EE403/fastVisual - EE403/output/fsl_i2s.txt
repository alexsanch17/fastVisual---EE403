; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_i2s.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_i2s.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_i2s.crf SRC\Drivers\fsl_i2s.c]
                          THUMB

                          AREA ||i.I2S_Config||, CODE, READONLY, ALIGN=2

                  I2S_Config PROC
;;;145    
;;;146    static void I2S_Config(I2S_Type *base, const i2s_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;148        assert(config);
000008  b104              CBZ      r4,|L1.12|
00000a  e004              B        |L1.22|
                  |L1.12|
00000c  2294              MOVS     r2,#0x94
00000e  a126              ADR      r1,|L1.168|
000010  a02b              ADR      r0,|L1.192|
000012  f7fffffe          BL       __aeabi_assert
                  |L1.22|
;;;149    
;;;150        uint32_t cfg1 = 0U;
000016  2500              MOVS     r5,#0
;;;151        uint32_t cfg2 = 0U;
000018  2700              MOVS     r7,#0
;;;152    
;;;153        /* set master/slave configuration */
;;;154        cfg1 |= I2S_CFG1_MSTSLVCFG(config->masterSlave);
00001a  7820              LDRB     r0,[r4,#0]
00001c  2130              MOVS     r1,#0x30
00001e  ea011000          AND      r0,r1,r0,LSL #4
000022  4305              ORRS     r5,r5,r0
;;;155    
;;;156        /* set I2S mode */
;;;157        cfg1 |= I2S_CFG1_MODE(config->mode);
000024  7860              LDRB     r0,[r4,#1]
000026  21c0              MOVS     r1,#0xc0
000028  ea011080          AND      r0,r1,r0,LSL #6
00002c  4305              ORRS     r5,r5,r0
;;;158    
;;;159        /* set right low (channel swap) */
;;;160        cfg1 |= I2S_CFG1_RIGHTLOW(config->rightLow);
00002e  78a0              LDRB     r0,[r4,#2]
000030  f44f7180          MOV      r1,#0x100
000034  ea012000          AND      r0,r1,r0,LSL #8
000038  4305              ORRS     r5,r5,r0
;;;161    
;;;162        /* set data justification */
;;;163        cfg1 |= I2S_CFG1_LEFTJUST(config->leftJust);
00003a  78e0              LDRB     r0,[r4,#3]
00003c  0049              LSLS     r1,r1,#1
00003e  ea012040          AND      r0,r1,r0,LSL #9
000042  4305              ORRS     r5,r5,r0
;;;164    
;;;165        /* set source to PDM dmic */
;;;166        cfg1 |= I2S_CFG1_PDMDATA(config->pdmData);
000044  7920              LDRB     r0,[r4,#4]
000046  0089              LSLS     r1,r1,#2
000048  ea0120c0          AND      r0,r1,r0,LSL #11
00004c  4305              ORRS     r5,r5,r0
;;;167    
;;;168        /* set SCLK polarity */
;;;169        cfg1 |= I2S_CFG1_SCK_POL(config->sckPol);
00004e  7960              LDRB     r0,[r4,#5]
000050  0049              LSLS     r1,r1,#1
000052  ea013000          AND      r0,r1,r0,LSL #12
000056  4305              ORRS     r5,r5,r0
;;;170    
;;;171        /* set WS polarity */
;;;172        cfg1 |= I2S_CFG1_WS_POL(config->wsPol);
000058  79a0              LDRB     r0,[r4,#6]
00005a  0049              LSLS     r1,r1,#1
00005c  ea013040          AND      r0,r1,r0,LSL #13
000060  4305              ORRS     r5,r5,r0
;;;173    
;;;174        /* set mono mode */
;;;175        cfg1 |= I2S_CFG1_ONECHANNEL(config->oneChannel);
000062  7aa0              LDRB     r0,[r4,#0xa]
000064  10c9              ASRS     r1,r1,#3
000066  ea012080          AND      r0,r1,r0,LSL #10
00006a  4305              ORRS     r5,r5,r0
;;;176    
;;;177        /* set data length */
;;;178        cfg1 |= I2S_CFG1_DATALEN(config->dataLength - 1U);
00006c  7ae0              LDRB     r0,[r4,#0xb]
00006e  1e40              SUBS     r0,r0,#1
000070  f44f11f8          MOV      r1,#0x1f0000
000074  ea014000          AND      r0,r1,r0,LSL #16
000078  4305              ORRS     r5,r5,r0
;;;179    
;;;180        /* set frame length */
;;;181        cfg2 |= I2S_CFG2_FRAMELEN(config->frameLength - 1U);
00007a  89a0              LDRH     r0,[r4,#0xc]
00007c  1e40              SUBS     r0,r0,#1
00007e  f3c00008          UBFX     r0,r0,#0,#9
000082  4307              ORRS     r7,r7,r0
;;;182    
;;;183        /* set data position of this channel pair within the frame */
;;;184        cfg2 |= I2S_CFG2_POSITION(config->position);
000084  89e0              LDRH     r0,[r4,#0xe]
000086  4910              LDR      r1,|L1.200|
000088  ea014000          AND      r0,r1,r0,LSL #16
00008c  4307              ORRS     r7,r7,r0
;;;185    
;;;186        /* write to registers */
;;;187        base->CFG1 = cfg1;
00008e  f8c65c00          STR      r5,[r6,#0xc00]
;;;188        base->CFG2 = cfg2;
000092  f8c67c04          STR      r7,[r6,#0xc04]
;;;189    
;;;190        /* set the clock divider */
;;;191        base->DIV = I2S_DIV_DIV(config->divider - 1U);
000096  8920              LDRH     r0,[r4,#8]
000098  1e40              SUBS     r0,r0,#1
00009a  f3c0000b          UBFX     r0,r0,#0,#12
00009e  f8c60c1c          STR      r0,[r6,#0xc1c]
;;;192    }
0000a2  e8bd81f0          POP      {r4-r8,pc}
;;;193    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
0000a8  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
0000ac  44726976
0000b0  6572735c
0000b4  66736c5f
0000b8  6932732e
0000bc  6300    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L1.192|
0000c0  636f6e66          DCB      "config",0
0000c4  696700  
0000c7  00                DCB      0
                  |L1.200|
                          DCD      0x01ff0000

                          AREA ||i.I2S_Deinit||, CODE, READONLY, ALIGN=1

                  I2S_Deinit PROC
;;;193    
;;;194    void I2S_Deinit(I2S_Type *base)
000000  4770              BX       lr
;;;195    {
;;;196        /* TODO gate FLEXCOMM clock via FLEXCOMM driver */
;;;197    }
;;;198    
                          ENDP


                          AREA ||i.I2S_Disable||, CODE, READONLY, ALIGN=1

                  I2S_Disable PROC
;;;409     */
;;;410    static inline void I2S_Disable(I2S_Type *base)
000000  f8d01c00          LDR      r1,[r0,#0xc00]
;;;411    {
;;;412        base->CFG1 &= (~I2S_CFG1_MAINENABLE(1U));
000004  f0210101          BIC      r1,r1,#1
000008  f8c01c00          STR      r1,[r0,#0xc00]
;;;413    }
00000c  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.I2S_DisableInterrupts||, CODE, READONLY, ALIGN=1

                  I2S_DisableInterrupts PROC
;;;440     */
;;;441    static inline void I2S_DisableInterrupts(I2S_Type *base, uint32_t interruptMask)
000000  f8c01e14          STR      r1,[r0,#0xe14]
;;;442    {
;;;443        base->FIFOINTENCLR = interruptMask;
;;;444    }
000004  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.I2S_Enable||, CODE, READONLY, ALIGN=1

                  I2S_Enable PROC
;;;399     */
;;;400    static inline void I2S_Enable(I2S_Type *base)
000000  f8d01c00          LDR      r1,[r0,#0xc00]
;;;401    {
;;;402        base->CFG1 |= I2S_CFG1_MAINENABLE(1U);
000004  f0410101          ORR      r1,r1,#1
000008  f8c01c00          STR      r1,[r0,#0xc00]
;;;403    }
00000c  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.I2S_EnableInterrupts||, CODE, READONLY, ALIGN=1

                  I2S_EnableInterrupts PROC
;;;428     */
;;;429    static inline void I2S_EnableInterrupts(I2S_Type *base, uint32_t interruptMask)
000000  f8c01e10          STR      r1,[r0,#0xe10]
;;;430    {
;;;431        base->FIFOINTENSET = interruptMask;
;;;432    }
000004  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.I2S_RxEnable||, CODE, READONLY, ALIGN=1

                  I2S_RxEnable PROC
;;;213    
;;;214    void I2S_RxEnable(I2S_Type *base, bool enable)
000000  b570              PUSH     {r4-r6,lr}
;;;215    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;216        if (enable)
000006  b13d              CBZ      r5,|L7.24|
;;;217        {
;;;218            I2S_EnableInterrupts(base, kI2S_RxErrorFlag | kI2S_RxLevelFlag);
000008  210a              MOVS     r1,#0xa
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2S_EnableInterrupts
;;;219            I2S_Enable(base);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2S_Enable
000016  e00c              B        |L7.50|
                  |L7.24|
;;;220        }
;;;221        else
;;;222        {
;;;223            I2S_DisableInterrupts(base, kI2S_RxErrorFlag | kI2S_RxLevelFlag);
000018  210a              MOVS     r1,#0xa
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       I2S_DisableInterrupts
;;;224            I2S_Disable(base);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2S_Disable
;;;225            base->FIFOCFG |= I2S_FIFOCFG_EMPTYRX_MASK;
000026  f8d40e00          LDR      r0,[r4,#0xe00]
00002a  f4403000          ORR      r0,r0,#0x20000
00002e  f8c40e00          STR      r0,[r4,#0xe00]
                  |L7.50|
;;;226        }
;;;227    }
000032  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP


                          AREA ||i.I2S_RxGetDefaultConfig||, CODE, READONLY, ALIGN=1

                  I2S_RxGetDefaultConfig PROC
;;;126    
;;;127    void I2S_RxGetDefaultConfig(i2s_config_t *config)
000000  2100              MOVS     r1,#0
;;;128    {
;;;129        config->masterSlave = kI2S_MasterSlaveNormalSlave;
000002  7001              STRB     r1,[r0,#0]
;;;130        config->mode = kI2S_ModeI2sClassic;
000004  7041              STRB     r1,[r0,#1]
;;;131        config->rightLow = false;
000006  7081              STRB     r1,[r0,#2]
;;;132        config->leftJust = false;
000008  70c1              STRB     r1,[r0,#3]
;;;133        config->pdmData = false;
00000a  7101              STRB     r1,[r0,#4]
;;;134        config->sckPol = false;
00000c  7141              STRB     r1,[r0,#5]
;;;135        config->wsPol = false;
00000e  7181              STRB     r1,[r0,#6]
;;;136        config->divider = 1U;
000010  2101              MOVS     r1,#1
000012  8101              STRH     r1,[r0,#8]
;;;137        config->oneChannel = false;
000014  2100              MOVS     r1,#0
000016  7281              STRB     r1,[r0,#0xa]
;;;138        config->dataLength = 16U;
000018  2110              MOVS     r1,#0x10
00001a  72c1              STRB     r1,[r0,#0xb]
;;;139        config->frameLength = 32U;
00001c  2120              MOVS     r1,#0x20
00001e  8181              STRH     r1,[r0,#0xc]
;;;140        config->position = 0U;
000020  2100              MOVS     r1,#0
000022  81c1              STRH     r1,[r0,#0xe]
;;;141        config->watermark = 4U;
000024  2104              MOVS     r1,#4
000026  7401              STRB     r1,[r0,#0x10]
;;;142        config->txEmptyZero = false;
000028  2100              MOVS     r1,#0
00002a  7441              STRB     r1,[r0,#0x11]
;;;143        config->pack48 = false;
00002c  7481              STRB     r1,[r0,#0x12]
;;;144    }
00002e  4770              BX       lr
;;;145    
                          ENDP


                          AREA ||i.I2S_RxHandleIRQ||, CODE, READONLY, ALIGN=1

                  I2S_RxHandleIRQ PROC
;;;687    
;;;688    void I2S_RxHandleIRQ(I2S_Type *base, i2s_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;689    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;690        uint32_t intstat = base->FIFOINTSTAT;
000008  f8d57e18          LDR      r7,[r5,#0xe18]
;;;691        uint32_t data;
;;;692    
;;;693        if (intstat & I2S_FIFOINTSTAT_RXERR_MASK)
00000c  f0070002          AND      r0,r7,#2
000010  b128              CBZ      r0,|L9.30|
;;;694        {
;;;695            handle->errorCount++;
000012  6b60              LDR      r0,[r4,#0x34]
000014  1c40              ADDS     r0,r0,#1
000016  6360              STR      r0,[r4,#0x34]
;;;696    
;;;697            /* Clear RX error interrupt flag */
;;;698            base->FIFOSTAT = I2S_FIFOSTAT_RXERR(1U);
000018  2002              MOVS     r0,#2
00001a  f8c50e04          STR      r0,[r5,#0xe04]
                  |L9.30|
;;;699        }
;;;700    
;;;701        if (intstat & I2S_FIFOINTSTAT_RXLVL_MASK)
00001e  f0070008          AND      r0,r7,#8
000022  2800              CMP      r0,#0
000024  d075              BEQ      |L9.274|
;;;702        {
;;;703            while ((base->FIFOSTAT & I2S_FIFOSTAT_RXNOTEMPTY_MASK) && (handle->i2sQueue[handle->queueDriver].dataSize > 0U))
000026  e15b              B        |L9.736|
                  |L9.40|
;;;704            {
;;;705                /* Read input data */
;;;706                if (handle->dataLength == 4U)
000028  7b60              LDRB     r0,[r4,#0xd]
00002a  2804              CMP      r0,#4
00002c  d125              BNE      |L9.122|
;;;707                {
;;;708                    data = base->FIFORD;
00002e  f8d56e30          LDR      r6,[r5,#0xe30]
;;;709                    *(handle->i2sQueue[handle->queueDriver].data) = ((data & 0x000F0000U) >> 12U) | (data & 0x0000000FU);
000032  f006000f          AND      r0,r6,#0xf
000036  f4062170          AND      r1,r6,#0xf0000
00003a  ea403111          ORR      r1,r0,r1,LSR #12
00003e  f8942031          LDRB     r2,[r4,#0x31]
000042  f1040010          ADD      r0,r4,#0x10
000046  f8500032          LDR      r0,[r0,r2,LSL #3]
00004a  7001              STRB     r1,[r0,#0]
;;;710                    handle->i2sQueue[handle->queueDriver].data++;
00004c  f8942031          LDRB     r2,[r4,#0x31]
000050  f1040110          ADD      r1,r4,#0x10
000054  eb0100c2          ADD      r0,r1,r2,LSL #3
000058  6801              LDR      r1,[r0,#0]
00005a  1c49              ADDS     r1,r1,#1
00005c  6001              STR      r1,[r0,#0]
;;;711                    handle->transferCount++;
00005e  6ba0              LDR      r0,[r4,#0x38]
000060  1c40              ADDS     r0,r0,#1
000062  63a0              STR      r0,[r4,#0x38]
;;;712                    handle->i2sQueue[handle->queueDriver].dataSize--;
000064  f8942031          LDRB     r2,[r4,#0x31]
000068  f1040110          ADD      r1,r4,#0x10
00006c  eb0101c2          ADD      r1,r1,r2,LSL #3
000070  1d08              ADDS     r0,r1,#4
000072  6849              LDR      r1,[r1,#4]
000074  1e49              SUBS     r1,r1,#1
000076  6001              STR      r1,[r0,#0]
000078  e0f3              B        |L9.610|
                  |L9.122|
;;;713                }
;;;714                else if (handle->dataLength <= 8U)
00007a  7b60              LDRB     r0,[r4,#0xd]
00007c  2808              CMP      r0,#8
00007e  d825              BHI      |L9.204|
;;;715                {
;;;716                    data = base->FIFORD;
000080  f8d56e30          LDR      r6,[r5,#0xe30]
;;;717                    *((uint16_t *)handle->i2sQueue[handle->queueDriver].data) = ((data >> 8U) & 0xFF00U) | (data & 0xFFU);
000084  f44f407f          MOV      r0,#0xff00
000088  ea002016          AND      r0,r0,r6,LSR #8
00008c  b2f1              UXTB     r1,r6
00008e  4308              ORRS     r0,r0,r1
000090  f8942031          LDRB     r2,[r4,#0x31]
000094  f1040110          ADD      r1,r4,#0x10
000098  f8511032          LDR      r1,[r1,r2,LSL #3]
00009c  8008              STRH     r0,[r1,#0]
;;;718                    handle->i2sQueue[handle->queueDriver].data += sizeof(uint16_t);
00009e  f8942031          LDRB     r2,[r4,#0x31]
0000a2  f1040110          ADD      r1,r4,#0x10
0000a6  eb0100c2          ADD      r0,r1,r2,LSL #3
0000aa  6801              LDR      r1,[r0,#0]
0000ac  1c89              ADDS     r1,r1,#2
0000ae  6001              STR      r1,[r0,#0]
;;;719                    handle->transferCount += sizeof(uint16_t);
0000b0  6ba0              LDR      r0,[r4,#0x38]
0000b2  1c80              ADDS     r0,r0,#2
0000b4  63a0              STR      r0,[r4,#0x38]
;;;720                    handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint16_t);
0000b6  f8942031          LDRB     r2,[r4,#0x31]
0000ba  f1040110          ADD      r1,r4,#0x10
0000be  eb0101c2          ADD      r1,r1,r2,LSL #3
0000c2  1d08              ADDS     r0,r1,#4
0000c4  6849              LDR      r1,[r1,#4]
0000c6  1e89              SUBS     r1,r1,#2
0000c8  6001              STR      r1,[r0,#0]
0000ca  e0ca              B        |L9.610|
                  |L9.204|
;;;721                }
;;;722                else if (handle->dataLength <= 16U)
0000cc  7b60              LDRB     r0,[r4,#0xd]
0000ce  2810              CMP      r0,#0x10
0000d0  d820              BHI      |L9.276|
;;;723                {
;;;724                    data = base->FIFORD;
0000d2  f8d56e30          LDR      r6,[r5,#0xe30]
;;;725                    *((uint32_t *)handle->i2sQueue[handle->queueDriver].data) = data;
0000d6  f8941031          LDRB     r1,[r4,#0x31]
0000da  f1040010          ADD      r0,r4,#0x10
0000de  f8500031          LDR      r0,[r0,r1,LSL #3]
0000e2  6006              STR      r6,[r0,#0]
;;;726                    handle->i2sQueue[handle->queueDriver].data += sizeof(uint32_t);
0000e4  f8942031          LDRB     r2,[r4,#0x31]
0000e8  f1040110          ADD      r1,r4,#0x10
0000ec  eb0100c2          ADD      r0,r1,r2,LSL #3
0000f0  6801              LDR      r1,[r0,#0]
0000f2  1d09              ADDS     r1,r1,#4
0000f4  6001              STR      r1,[r0,#0]
;;;727                    handle->transferCount += sizeof(uint32_t);
0000f6  6ba0              LDR      r0,[r4,#0x38]
0000f8  1d00              ADDS     r0,r0,#4
0000fa  63a0              STR      r0,[r4,#0x38]
;;;728                    handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint32_t);
0000fc  f8942031          LDRB     r2,[r4,#0x31]
000100  f1040110          ADD      r1,r4,#0x10
000104  eb0101c2          ADD      r1,r1,r2,LSL #3
000108  1d08              ADDS     r0,r1,#4
00010a  6849              LDR      r1,[r1,#4]
00010c  1f09              SUBS     r1,r1,#4
00010e  6001              STR      r1,[r0,#0]
000110  e0a7              B        |L9.610|
                  |L9.274|
000112  e0f8              B        |L9.774|
                  |L9.276|
;;;729                }
;;;730                else if (handle->dataLength <= 24U)
000114  7b60              LDRB     r0,[r4,#0xd]
000116  2818              CMP      r0,#0x18
000118  d87e              BHI      |L9.536|
;;;731                {
;;;732                    if (handle->pack48)
00011a  7ba0              LDRB     r0,[r4,#0xe]
00011c  b3e8              CBZ      r0,|L9.410|
;;;733                    {
;;;734                        if (handle->useFifo48H)
00011e  7be0              LDRB     r0,[r4,#0xf]
000120  b308              CBZ      r0,|L9.358|
;;;735                        {
;;;736                            data = base->FIFORD48H;
000122  f8d56e34          LDR      r6,[r5,#0xe34]
;;;737                            handle->useFifo48H = false;
000126  2000              MOVS     r0,#0
000128  73e0              STRB     r0,[r4,#0xf]
;;;738    
;;;739                            *((uint16_t *)handle->i2sQueue[handle->queueDriver].data) = data;
00012a  f8942031          LDRB     r2,[r4,#0x31]
00012e  f1040010          ADD      r0,r4,#0x10
000132  f8500032          LDR      r0,[r0,r2,LSL #3]
000136  8006              STRH     r6,[r0,#0]
;;;740                            handle->i2sQueue[handle->queueDriver].data += sizeof(uint16_t);
000138  f8942031          LDRB     r2,[r4,#0x31]
00013c  f1040110          ADD      r1,r4,#0x10
000140  eb0100c2          ADD      r0,r1,r2,LSL #3
000144  6801              LDR      r1,[r0,#0]
000146  1c89              ADDS     r1,r1,#2
000148  6001              STR      r1,[r0,#0]
;;;741                            handle->transferCount += sizeof(uint16_t);
00014a  6ba0              LDR      r0,[r4,#0x38]
00014c  1c80              ADDS     r0,r0,#2
00014e  63a0              STR      r0,[r4,#0x38]
;;;742                            handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint16_t);
000150  f8942031          LDRB     r2,[r4,#0x31]
000154  f1040110          ADD      r1,r4,#0x10
000158  eb0101c2          ADD      r1,r1,r2,LSL #3
00015c  1d08              ADDS     r0,r1,#4
00015e  6849              LDR      r1,[r1,#4]
000160  1e89              SUBS     r1,r1,#2
000162  6001              STR      r1,[r0,#0]
000164  e07d              B        |L9.610|
                  |L9.358|
;;;743                        }
;;;744                        else
;;;745                        {
;;;746                            data = base->FIFORD;
000166  f8d56e30          LDR      r6,[r5,#0xe30]
;;;747                            handle->useFifo48H = true;
00016a  2001              MOVS     r0,#1
00016c  73e0              STRB     r0,[r4,#0xf]
;;;748    
;;;749                            *((uint32_t *)handle->i2sQueue[handle->queueDriver].data) = data;
00016e  f8941031          LDRB     r1,[r4,#0x31]
000172  f1040010          ADD      r0,r4,#0x10
000176  f8500031          LDR      r0,[r0,r1,LSL #3]
00017a  6006              STR      r6,[r0,#0]
;;;750                            handle->i2sQueue[handle->queueDriver].data += sizeof(uint32_t);
00017c  f8942031          LDRB     r2,[r4,#0x31]
000180  f1040110          ADD      r1,r4,#0x10
000184  eb0100c2          ADD      r0,r1,r2,LSL #3
000188  6801              LDR      r1,[r0,#0]
00018a  1d09              ADDS     r1,r1,#4
00018c  6001              STR      r1,[r0,#0]
;;;751                            handle->transferCount += sizeof(uint32_t);
00018e  6ba0              LDR      r0,[r4,#0x38]
000190  1d00              ADDS     r0,r0,#4
000192  63a0              STR      r0,[r4,#0x38]
;;;752                            handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint32_t);
000194  f8942031          LDRB     r2,[r4,#0x31]
000198  e000              B        |L9.412|
                  |L9.410|
00019a  e008              B        |L9.430|
                  |L9.412|
00019c  f1040110          ADD      r1,r4,#0x10
0001a0  eb0101c2          ADD      r1,r1,r2,LSL #3
0001a4  1d08              ADDS     r0,r1,#4
0001a6  6849              LDR      r1,[r1,#4]
0001a8  1f09              SUBS     r1,r1,#4
0001aa  6001              STR      r1,[r0,#0]
0001ac  e059              B        |L9.610|
                  |L9.430|
;;;753                        }
;;;754                    }
;;;755                    else
;;;756                    {
;;;757                        if (handle->useFifo48H)
0001ae  7be0              LDRB     r0,[r4,#0xf]
0001b0  b120              CBZ      r0,|L9.444|
;;;758                        {
;;;759                            data = base->FIFORD48H;
0001b2  f8d56e34          LDR      r6,[r5,#0xe34]
;;;760                            handle->useFifo48H = false;
0001b6  2000              MOVS     r0,#0
0001b8  73e0              STRB     r0,[r4,#0xf]
0001ba  e003              B        |L9.452|
                  |L9.444|
;;;761                        }
;;;762                        else
;;;763                        {
;;;764                            data = base->FIFORD;
0001bc  f8d56e30          LDR      r6,[r5,#0xe30]
;;;765                            handle->useFifo48H = true;
0001c0  2001              MOVS     r0,#1
0001c2  73e0              STRB     r0,[r4,#0xf]
                  |L9.452|
;;;766                        }
;;;767    
;;;768                        *(handle->i2sQueue[handle->queueDriver].data++) = data & 0xFFU;
0001c4  f894c031          LDRB     r12,[r4,#0x31]
0001c8  f1040210          ADD      r2,r4,#0x10
0001cc  eb0201cc          ADD      r1,r2,r12,LSL #3
0001d0  6808              LDR      r0,[r1,#0]
0001d2  1c42              ADDS     r2,r0,#1
0001d4  600a              STR      r2,[r1,#0]
0001d6  7006              STRB     r6,[r0,#0]
;;;769                        *(handle->i2sQueue[handle->queueDriver].data++) = (data >> 8U) & 0xFFU;
0001d8  0a33              LSRS     r3,r6,#8
0001da  f894c031          LDRB     r12,[r4,#0x31]
0001de  f1040210          ADD      r2,r4,#0x10
0001e2  eb0201cc          ADD      r1,r2,r12,LSL #3
0001e6  6808              LDR      r0,[r1,#0]
0001e8  1c42              ADDS     r2,r0,#1
0001ea  600a              STR      r2,[r1,#0]
0001ec  7003              STRB     r3,[r0,#0]
;;;770                        *(handle->i2sQueue[handle->queueDriver].data++) = (data >> 16U) & 0xFFU;
0001ee  0c33              LSRS     r3,r6,#16
0001f0  f894c031          LDRB     r12,[r4,#0x31]
0001f4  f1040210          ADD      r2,r4,#0x10
0001f8  eb0201cc          ADD      r1,r2,r12,LSL #3
0001fc  6808              LDR      r0,[r1,#0]
0001fe  1c42              ADDS     r2,r0,#1
000200  600a              STR      r2,[r1,#0]
000202  7003              STRB     r3,[r0,#0]
;;;771                        handle->transferCount += 3U;
000204  6ba0              LDR      r0,[r4,#0x38]
000206  1cc0              ADDS     r0,r0,#3
000208  63a0              STR      r0,[r4,#0x38]
;;;772                        handle->i2sQueue[handle->queueDriver].dataSize -= 3U;
00020a  f8942031          LDRB     r2,[r4,#0x31]
00020e  f1040110          ADD      r1,r4,#0x10
000212  eb0101c2          ADD      r1,r1,r2,LSL #3
000216  e000              B        |L9.538|
                  |L9.536|
000218  e004              B        |L9.548|
                  |L9.538|
00021a  1d08              ADDS     r0,r1,#4
00021c  6849              LDR      r1,[r1,#4]
00021e  1ec9              SUBS     r1,r1,#3
000220  6001              STR      r1,[r0,#0]
000222  e01e              B        |L9.610|
                  |L9.548|
;;;773                    }
;;;774                }
;;;775                else /* if (handle->dataLength <= 32U) */
;;;776                {
;;;777                    data = base->FIFORD;
000224  f8d56e30          LDR      r6,[r5,#0xe30]
;;;778                    *((uint32_t *)handle->i2sQueue[handle->queueDriver].data) = data;
000228  f8941031          LDRB     r1,[r4,#0x31]
00022c  f1040010          ADD      r0,r4,#0x10
000230  f8500031          LDR      r0,[r0,r1,LSL #3]
000234  6006              STR      r6,[r0,#0]
;;;779                    handle->i2sQueue[handle->queueDriver].data += sizeof(uint32_t);
000236  f8942031          LDRB     r2,[r4,#0x31]
00023a  f1040110          ADD      r1,r4,#0x10
00023e  eb0100c2          ADD      r0,r1,r2,LSL #3
000242  6801              LDR      r1,[r0,#0]
000244  1d09              ADDS     r1,r1,#4
000246  6001              STR      r1,[r0,#0]
;;;780                    handle->transferCount += sizeof(uint32_t);
000248  6ba0              LDR      r0,[r4,#0x38]
00024a  1d00              ADDS     r0,r0,#4
00024c  63a0              STR      r0,[r4,#0x38]
;;;781                    handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint32_t);
00024e  f8942031          LDRB     r2,[r4,#0x31]
000252  f1040110          ADD      r1,r4,#0x10
000256  eb0101c2          ADD      r1,r1,r2,LSL #3
00025a  1d08              ADDS     r0,r1,#4
00025c  6849              LDR      r1,[r1,#4]
00025e  1f09              SUBS     r1,r1,#4
000260  6001              STR      r1,[r0,#0]
                  |L9.610|
;;;782                }
;;;783    
;;;784                if (handle->i2sQueue[handle->queueDriver].dataSize == 0U)
000262  f8941031          LDRB     r1,[r4,#0x31]
000266  f1040010          ADD      r0,r4,#0x10
00026a  eb0000c1          ADD      r0,r0,r1,LSL #3
00026e  6840              LDR      r0,[r0,#4]
000270  bba8              CBNZ     r0,|L9.734|
;;;785                {
;;;786                    /* Actual data buffer filled with input data, switch to a next one */
;;;787                    handle->queueDriver = (handle->queueDriver + 1U) % I2S_NUM_BUFFERS;
000272  f8940031          LDRB     r0,[r4,#0x31]
000276  1c40              ADDS     r0,r0,#1
000278  f0000003          AND      r0,r0,#3
00027c  f8840031          STRB     r0,[r4,#0x31]
;;;788    
;;;789                    /* Notify user */
;;;790                    if (handle->completionCallback)
000280  6860              LDR      r0,[r4,#4]
000282  b130              CBZ      r0,|L9.658|
;;;791                    {
;;;792                        handle->completionCallback(base, handle, kStatus_I2S_BufferComplete, handle->userData);
000284  f640228c          MOV      r2,#0xa8c
000288  4621              MOV      r1,r4
00028a  4628              MOV      r0,r5
00028c  e9d4c301          LDRD     r12,r3,[r4,#4]
000290  47e0              BLX      r12
                  |L9.658|
;;;793                    }
;;;794    
;;;795                    if (handle->i2sQueue[handle->queueDriver].dataSize == 0U)
000292  f8941031          LDRB     r1,[r4,#0x31]
000296  f1040010          ADD      r0,r4,#0x10
00029a  eb0000c1          ADD      r0,r0,r1,LSL #3
00029e  6840              LDR      r0,[r0,#4]
0002a0  b9e8              CBNZ     r0,|L9.734|
;;;796                    {
;;;797                        /* No other buffer prepared to receive data into */
;;;798    
;;;799                        /* Disable I2S operation and interrupts */
;;;800                        I2S_Disable(base);
0002a2  4628              MOV      r0,r5
0002a4  f7fffffe          BL       I2S_Disable
;;;801                        I2S_DisableInterrupts(base, kI2S_RxErrorFlag | kI2S_RxLevelFlag);
0002a8  210a              MOVS     r1,#0xa
0002aa  4628              MOV      r0,r5
0002ac  f7fffffe          BL       I2S_DisableInterrupts
;;;802                        base->FIFOCFG |= I2S_FIFOCFG_EMPTYRX_MASK;
0002b0  f8d50e00          LDR      r0,[r5,#0xe00]
0002b4  f4403000          ORR      r0,r0,#0x20000
0002b8  f8c50e00          STR      r0,[r5,#0xe00]
;;;803    
;;;804                        /* Reset state */
;;;805                        handle->state = kI2S_StateIdle;
0002bc  2000              MOVS     r0,#0
0002be  6020              STR      r0,[r4,#0]
;;;806    
;;;807                        /* Notify user */
;;;808                        if (handle->completionCallback)
0002c0  6860              LDR      r0,[r4,#4]
0002c2  b130              CBZ      r0,|L9.722|
;;;809                        {
;;;810                            handle->completionCallback(base, handle, kStatus_I2S_Done, handle->userData);
0002c4  f640228d          MOV      r2,#0xa8d
0002c8  4621              MOV      r1,r4
0002ca  4628              MOV      r0,r5
0002cc  e9d4c301          LDRD     r12,r3,[r4,#4]
0002d0  47e0              BLX      r12
                  |L9.722|
;;;811                        }
;;;812    
;;;813                        /* Clear RX level interrupt flag */
;;;814                        base->FIFOSTAT = I2S_FIFOSTAT_RXLVL(1U);
0002d2  f44f3080          MOV      r0,#0x10000
0002d6  f8c50e04          STR      r0,[r5,#0xe04]
                  |L9.730|
;;;815    
;;;816                        return;
;;;817                    }
;;;818                }
;;;819            }
;;;820    
;;;821            /* Clear RX level interrupt flag */
;;;822            base->FIFOSTAT = I2S_FIFOSTAT_RXLVL(1U);
;;;823        }
;;;824    }
0002da  e8bd81f0          POP      {r4-r8,pc}
                  |L9.734|
0002de  e7ff              B        |L9.736|
                  |L9.736|
0002e0  f8d50e04          LDR      r0,[r5,#0xe04]        ;703
0002e4  f0000040          AND      r0,r0,#0x40           ;703
0002e8  b148              CBZ      r0,|L9.766|
0002ea  f8941031          LDRB     r1,[r4,#0x31]         ;703
0002ee  f1040010          ADD      r0,r4,#0x10           ;703
0002f2  eb0000c1          ADD      r0,r0,r1,LSL #3       ;703
0002f6  6840              LDR      r0,[r0,#4]            ;703
0002f8  2800              CMP      r0,#0                 ;703
0002fa  f47fae95          BNE      |L9.40|
                  |L9.766|
0002fe  f44f3080          MOV      r0,#0x10000           ;822
000302  f8c50e04          STR      r0,[r5,#0xe04]        ;822
                  |L9.774|
000306  bf00              NOP      
000308  e7e7              B        |L9.730|
                          ENDP


                          AREA ||i.I2S_RxInit||, CODE, READONLY, ALIGN=1

                  I2S_RxInit PROC
;;;87     
;;;88     void I2S_RxInit(I2S_Type *base, const i2s_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;90         uint32_t cfg = 0U;
000008  2400              MOVS     r4,#0
;;;91         uint32_t trig = 0U;
00000a  2700              MOVS     r7,#0
;;;92     
;;;93         FLEXCOMM_Init(base, FLEXCOMM_PERIPH_I2S_RX);
00000c  2105              MOVS     r1,#5
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       FLEXCOMM_Init
;;;94         I2S_Config(base, config);
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       I2S_Config
;;;95     
;;;96         /* Configure FIFO */
;;;97     
;;;98         cfg |= I2S_FIFOCFG_ENABLERX(1U);               /* enable RX FIFO */
00001c  f0440402          ORR      r4,r4,#2
;;;99         cfg |= I2S_FIFOCFG_EMPTYRX(1U);                /* empty RX FIFO */
000020  f4443400          ORR      r4,r4,#0x20000
;;;100        cfg |= I2S_FIFOCFG_PACK48(config->pack48);     /* set pack 48-bit format or not */
000024  7cb0              LDRB     r0,[r6,#0x12]
000026  2108              MOVS     r1,#8
000028  ea0100c0          AND      r0,r1,r0,LSL #3
00002c  4304              ORRS     r4,r4,r0
;;;101        trig |= I2S_FIFOTRIG_RXLVLENA(1U);             /* enable RX FIFO trigger */
00002e  f0470702          ORR      r7,r7,#2
;;;102        trig |= I2S_FIFOTRIG_RXLVL(config->watermark); /* set RX FIFO trigger level */
000032  7c30              LDRB     r0,[r6,#0x10]
000034  f44f2170          MOV      r1,#0xf0000
000038  ea014000          AND      r0,r1,r0,LSL #16
00003c  4307              ORRS     r7,r7,r0
;;;103    
;;;104        base->FIFOCFG = cfg;
00003e  f8c54e00          STR      r4,[r5,#0xe00]
;;;105        base->FIFOTRIG = trig;
000042  f8c57e08          STR      r7,[r5,#0xe08]
;;;106    }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;107    
                          ENDP


                          AREA ||i.I2S_RxTransferAbort||, CODE, READONLY, ALIGN=2

                  I2S_RxTransferAbort PROC
;;;454    
;;;455    void I2S_RxTransferAbort(I2S_Type *base, i2s_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;457        assert(handle);
000006  b104              CBZ      r4,|L11.10|
000008  e005              B        |L11.22|
                  |L11.10|
00000a  f24012c9          MOV      r2,#0x1c9
00000e  a10a              ADR      r1,|L11.56|
000010  a00f              ADR      r0,|L11.80|
000012  f7fffffe          BL       __aeabi_assert
                  |L11.22|
;;;458    
;;;459        /* Disable I2S operation and interrupts */
;;;460        I2S_RxEnable(base, false);
000016  2100              MOVS     r1,#0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       I2S_RxEnable
;;;461    
;;;462        /* Reset state */
;;;463        handle->state = kI2S_StateIdle;
00001e  2000              MOVS     r0,#0
000020  6020              STR      r0,[r4,#0]
;;;464    
;;;465        /* Clear transfer queue */
;;;466        memset((void *)&handle->i2sQueue, 0U, sizeof(i2s_transfer_t) * I2S_NUM_BUFFERS);
000022  2120              MOVS     r1,#0x20
000024  f1040010          ADD      r0,r4,#0x10
000028  f7fffffe          BL       __aeabi_memclr4
;;;467        handle->queueDriver = 0U;
00002c  2000              MOVS     r0,#0
00002e  f8840031          STRB     r0,[r4,#0x31]
;;;468        handle->queueUser = 0U;
000032  f8840030          STRB     r0,[r4,#0x30]
;;;469    }
000036  bd70              POP      {r4-r6,pc}
;;;470    
                          ENDP

                  |L11.56|
000038  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
00003c  44726976
000040  6572735c
000044  66736c5f
000048  6932732e
00004c  6300    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L11.80|
000050  68616e64          DCB      "handle",0
000054  6c6500  
000057  00                DCB      0

                          AREA ||i.I2S_RxTransferCreateHandle||, CODE, READONLY, ALIGN=2

                  I2S_RxTransferCreateHandle PROC
;;;398    
;;;399    void I2S_RxTransferCreateHandle(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_callback_t callback, void *userData)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;400    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;401        assert(handle);
00000c  b104              CBZ      r4,|L12.16|
00000e  e005              B        |L12.28|
                  |L12.16|
000010  f2401291          MOV      r2,#0x191
000014  a114              ADR      r1,|L12.104|
000016  a01a              ADR      r0,|L12.128|
000018  f7fffffe          BL       __aeabi_assert
                  |L12.28|
;;;402    
;;;403        /* Clear out the handle */
;;;404        memset(handle, 0U, sizeof(*handle));
00001c  2140              MOVS     r1,#0x40
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memclr4
;;;405    
;;;406        /* Save callback and user data */
;;;407        handle->completionCallback = callback;
000024  6067              STR      r7,[r4,#4]
;;;408        handle->userData = userData;
000026  60a6              STR      r6,[r4,#8]
;;;409    
;;;410        /* Remember some items set previously by configuration */
;;;411        handle->watermark = ((base->FIFOTRIG & I2S_FIFOTRIG_RXLVL_MASK) >> I2S_FIFOTRIG_RXLVL_SHIFT);
000028  f8d50e08          LDR      r0,[r5,#0xe08]
00002c  f3c04003          UBFX     r0,r0,#16,#4
000030  f884003c          STRB     r0,[r4,#0x3c]
;;;412        handle->oneChannel = ((base->CFG1 & I2S_CFG1_ONECHANNEL_MASK) >> I2S_CFG1_ONECHANNEL_SHIFT);
000034  f8d50c00          LDR      r0,[r5,#0xc00]
000038  f3c02080          UBFX     r0,r0,#10,#1
00003c  7320              STRB     r0,[r4,#0xc]
;;;413        handle->dataLength = ((base->CFG1 & I2S_CFG1_DATALEN_MASK) >> I2S_CFG1_DATALEN_SHIFT) + 1U;
00003e  f8d50c00          LDR      r0,[r5,#0xc00]
000042  f3c04004          UBFX     r0,r0,#16,#5
000046  1c40              ADDS     r0,r0,#1
000048  7360              STRB     r0,[r4,#0xd]
;;;414        handle->pack48 = ((base->FIFOCFG & I2S_FIFOCFG_PACK48_MASK) >> I2S_FIFOCFG_PACK48_SHIFT);
00004a  f8d50e00          LDR      r0,[r5,#0xe00]
00004e  f3c000c0          UBFX     r0,r0,#3,#1
000052  73a0              STRB     r0,[r4,#0xe]
;;;415    
;;;416        handle->useFifo48H = false;
000054  2000              MOVS     r0,#0
000056  73e0              STRB     r0,[r4,#0xf]
;;;417    
;;;418        /* Register IRQ handling */
;;;419        FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)I2S_RxHandleIRQ, handle);
000058  4622              MOV      r2,r4
00005a  490b              LDR      r1,|L12.136|
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       FLEXCOMM_SetIRQHandler
;;;420    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;421    
                          ENDP

000066  0000              DCW      0x0000
                  |L12.104|
000068  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
00006c  44726976
000070  6572735c
000074  66736c5f
000078  6932732e
00007c  6300    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L12.128|
000080  68616e64          DCB      "handle",0
000084  6c6500  
000087  00                DCB      0
                  |L12.136|
                          DCD      I2S_RxHandleIRQ

                          AREA ||i.I2S_RxTransferNonBlocking||, CODE, READONLY, ALIGN=2

                  I2S_RxTransferNonBlocking PROC
;;;421    
;;;422    status_t I2S_RxTransferNonBlocking(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_t transfer)
000000  b57f              PUSH     {r0-r6,lr}
;;;423    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;424        assert(handle);
000006  b104              CBZ      r4,|L13.10|
000008  e005              B        |L13.22|
                  |L13.10|
00000a  f44f72d4          MOV      r2,#0x1a8
00000e  a11f              ADR      r1,|L13.140|
000010  a024              ADR      r0,|L13.164|
000012  f7fffffe          BL       __aeabi_assert
                  |L13.22|
;;;425        if (!handle)
000016  b914              CBNZ     r4,|L13.30|
;;;426        {
;;;427            return kStatus_InvalidArgument;
000018  2004              MOVS     r0,#4
                  |L13.26|
;;;428        }
;;;429    
;;;430        status_t result;
;;;431    
;;;432        result = I2S_ValidateBuffer(handle, &transfer);
;;;433        if (result != kStatus_Success)
;;;434        {
;;;435            return result;
;;;436        }
;;;437    
;;;438        if (handle->i2sQueue[handle->queueUser].dataSize)
;;;439        {
;;;440            /* Previously prepared buffers not processed yet */
;;;441            return kStatus_I2S_Busy;
;;;442        }
;;;443    
;;;444        handle->state = kI2S_StateRx;
;;;445        handle->i2sQueue[handle->queueUser].data = transfer.data;
;;;446        handle->i2sQueue[handle->queueUser].dataSize = transfer.dataSize;
;;;447        handle->queueUser = (handle->queueUser + 1U) % I2S_NUM_BUFFERS;
;;;448    
;;;449        base->FIFOTRIG = (base->FIFOTRIG & (~I2S_FIFOTRIG_RXLVL_MASK)) | I2S_FIFOTRIG_RXLVL(handle->watermark);
;;;450        I2S_RxEnable(base, true);
;;;451    
;;;452        return kStatus_Success;
;;;453    }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  a902              ADD      r1,sp,#8              ;432
000020  4620              MOV      r0,r4                 ;432
000022  f7fffffe          BL       I2S_ValidateBuffer
000026  4606              MOV      r6,r0                 ;432
000028  b10e              CBZ      r6,|L13.46|
00002a  4630              MOV      r0,r6                 ;435
00002c  e7f5              B        |L13.26|
                  |L13.46|
00002e  f8941030          LDRB     r1,[r4,#0x30]         ;438
000032  f1040010          ADD      r0,r4,#0x10           ;438
000036  eb0000c1          ADD      r0,r0,r1,LSL #3       ;438
00003a  6840              LDR      r0,[r0,#4]            ;438
00003c  b110              CBZ      r0,|L13.68|
00003e  f640208e          MOV      r0,#0xa8e             ;441
000042  e7ea              B        |L13.26|
                  |L13.68|
000044  2004              MOVS     r0,#4                 ;444
000046  6020              STR      r0,[r4,#0]            ;444
000048  f8942030          LDRB     r2,[r4,#0x30]         ;445
00004c  9902              LDR      r1,[sp,#8]            ;445
00004e  f1040010          ADD      r0,r4,#0x10           ;445
000052  f8401032          STR      r1,[r0,r2,LSL #3]     ;445
000056  9903              LDR      r1,[sp,#0xc]          ;446
000058  f8942030          LDRB     r2,[r4,#0x30]         ;446
00005c  eb0000c2          ADD      r0,r0,r2,LSL #3       ;446
000060  6041              STR      r1,[r0,#4]            ;446
000062  f8140f30          LDRB     r0,[r4,#0x30]!        ;447
000066  1c40              ADDS     r0,r0,#1              ;447
000068  f0000003          AND      r0,r0,#3              ;447
00006c  7020              STRB     r0,[r4,#0]            ;447
00006e  7b21              LDRB     r1,[r4,#0xc]          ;449
000070  3c30              SUBS     r4,r4,#0x30           ;449
000072  f8d50e08          LDR      r0,[r5,#0xe08]        ;449
000076  f3614013          BFI      r0,r1,#16,#4          ;449
00007a  f8c50e08          STR      r0,[r5,#0xe08]        ;449
00007e  2101              MOVS     r1,#1                 ;450
000080  4628              MOV      r0,r5                 ;450
000082  f7fffffe          BL       I2S_RxEnable
000086  2000              MOVS     r0,#0                 ;452
000088  e7c7              B        |L13.26|
;;;454    
                          ENDP

00008a  0000              DCW      0x0000
                  |L13.140|
00008c  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
000090  44726976
000094  6572735c
000098  66736c5f
00009c  6932732e
0000a0  6300    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L13.164|
0000a4  68616e64          DCB      "handle",0
0000a8  6c6500  
0000ab  00                DCB      0

                          AREA ||i.I2S_TransferGetCount||, CODE, READONLY, ALIGN=2

                  I2S_TransferGetCount PROC
;;;470    
;;;471    status_t I2S_TransferGetCount(I2S_Type *base, i2s_handle_t *handle, size_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;472    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;473        assert(handle);
000008  b104              CBZ      r4,|L14.12|
00000a  e005              B        |L14.24|
                  |L14.12|
00000c  f24012d9          MOV      r2,#0x1d9
000010  a10c              ADR      r1,|L14.68|
000012  a012              ADR      r0,|L14.92|
000014  f7fffffe          BL       __aeabi_assert
                  |L14.24|
;;;474        if (!handle)
000018  b90c              CBNZ     r4,|L14.30|
;;;475        {
;;;476            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L14.28|
;;;477        }
;;;478    
;;;479        assert(count);
;;;480        if (!count)
;;;481        {
;;;482            return kStatus_InvalidArgument;
;;;483        }
;;;484    
;;;485        if (handle->state == kI2S_StateIdle)
;;;486        {
;;;487            return kStatus_NoTransferInProgress;
;;;488        }
;;;489    
;;;490        *count = handle->transferCount;
;;;491    
;;;492        return kStatus_Success;
;;;493    }
00001c  bd70              POP      {r4-r6,pc}
                  |L14.30|
00001e  b105              CBZ      r5,|L14.34|
000020  e005              B        |L14.46|
                  |L14.34|
000022  f24012df          MOV      r2,#0x1df             ;479
000026  a107              ADR      r1,|L14.68|
000028  a00e              ADR      r0,|L14.100|
00002a  f7fffffe          BL       __aeabi_assert
                  |L14.46|
00002e  b90d              CBNZ     r5,|L14.52|
000030  2004              MOVS     r0,#4                 ;482
000032  e7f3              B        |L14.28|
                  |L14.52|
000034  6820              LDR      r0,[r4,#0]            ;485
000036  b908              CBNZ     r0,|L14.60|
000038  2006              MOVS     r0,#6                 ;487
00003a  e7ef              B        |L14.28|
                  |L14.60|
00003c  6ba0              LDR      r0,[r4,#0x38]         ;490
00003e  6028              STR      r0,[r5,#0]            ;490
000040  2000              MOVS     r0,#0                 ;492
000042  e7eb              B        |L14.28|
;;;494    
                          ENDP

                  |L14.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  6932732e
000058  6300    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L14.92|
00005c  68616e64          DCB      "handle",0
000060  6c6500  
000063  00                DCB      0
                  |L14.100|
000064  636f756e          DCB      "count",0
000068  7400    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.I2S_TransferGetErrorCount||, CODE, READONLY, ALIGN=2

                  I2S_TransferGetErrorCount PROC
;;;494    
;;;495    status_t I2S_TransferGetErrorCount(I2S_Type *base, i2s_handle_t *handle, size_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;496    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;497        assert(handle);
000008  b104              CBZ      r4,|L15.12|
00000a  e005              B        |L15.24|
                  |L15.12|
00000c  f24012f1          MOV      r2,#0x1f1
000010  a10c              ADR      r1,|L15.68|
000012  a012              ADR      r0,|L15.92|
000014  f7fffffe          BL       __aeabi_assert
                  |L15.24|
;;;498        if (!handle)
000018  b90c              CBNZ     r4,|L15.30|
;;;499        {
;;;500            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L15.28|
;;;501        }
;;;502    
;;;503        assert(count);
;;;504        if (!count)
;;;505        {
;;;506            return kStatus_InvalidArgument;
;;;507        }
;;;508    
;;;509        if (handle->state == kI2S_StateIdle)
;;;510        {
;;;511            return kStatus_NoTransferInProgress;
;;;512        }
;;;513    
;;;514        *count = handle->errorCount;
;;;515    
;;;516        return kStatus_Success;
;;;517    }
00001c  bd70              POP      {r4-r6,pc}
                  |L15.30|
00001e  b105              CBZ      r5,|L15.34|
000020  e005              B        |L15.46|
                  |L15.34|
000022  f24012f7          MOV      r2,#0x1f7             ;503
000026  a107              ADR      r1,|L15.68|
000028  a00e              ADR      r0,|L15.100|
00002a  f7fffffe          BL       __aeabi_assert
                  |L15.46|
00002e  b90d              CBNZ     r5,|L15.52|
000030  2004              MOVS     r0,#4                 ;506
000032  e7f3              B        |L15.28|
                  |L15.52|
000034  6820              LDR      r0,[r4,#0]            ;509
000036  b908              CBNZ     r0,|L15.60|
000038  2006              MOVS     r0,#6                 ;511
00003a  e7ef              B        |L15.28|
                  |L15.60|
00003c  6b60              LDR      r0,[r4,#0x34]         ;514
00003e  6028              STR      r0,[r5,#0]            ;514
000040  2000              MOVS     r0,#0                 ;516
000042  e7eb              B        |L15.28|
;;;518    
                          ENDP

                  |L15.68|
000044  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
000048  44726976
00004c  6572735c
000050  66736c5f
000054  6932732e
000058  6300    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L15.92|
00005c  68616e64          DCB      "handle",0
000060  6c6500  
000063  00                DCB      0
                  |L15.100|
000064  636f756e          DCB      "count",0
000068  7400    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.I2S_TxEnable||, CODE, READONLY, ALIGN=1

                  I2S_TxEnable PROC
;;;198    
;;;199    void I2S_TxEnable(I2S_Type *base, bool enable)
000000  b570              PUSH     {r4-r6,lr}
;;;200    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;201        if (enable)
000006  b13d              CBZ      r5,|L16.24|
;;;202        {
;;;203            I2S_EnableInterrupts(base, kI2S_TxErrorFlag | kI2S_TxLevelFlag);
000008  2105              MOVS     r1,#5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2S_EnableInterrupts
;;;204            I2S_Enable(base);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2S_Enable
000016  e00c              B        |L16.50|
                  |L16.24|
;;;205        }
;;;206        else
;;;207        {
;;;208            I2S_DisableInterrupts(base, kI2S_TxErrorFlag | kI2S_TxLevelFlag);
000018  2105              MOVS     r1,#5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       I2S_DisableInterrupts
;;;209            I2S_Disable(base);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2S_Disable
;;;210            base->FIFOCFG |= I2S_FIFOCFG_EMPTYTX_MASK;
000026  f8d40e00          LDR      r0,[r4,#0xe00]
00002a  f4403080          ORR      r0,r0,#0x10000
00002e  f8c40e00          STR      r0,[r4,#0xe00]
                  |L16.50|
;;;211        }
;;;212    }
000032  bd70              POP      {r4-r6,pc}
;;;213    
                          ENDP


                          AREA ||i.I2S_TxGetDefaultConfig||, CODE, READONLY, ALIGN=1

                  I2S_TxGetDefaultConfig PROC
;;;107    
;;;108    void I2S_TxGetDefaultConfig(i2s_config_t *config)
000000  2103              MOVS     r1,#3
;;;109    {
;;;110        config->masterSlave = kI2S_MasterSlaveNormalMaster;
000002  7001              STRB     r1,[r0,#0]
;;;111        config->mode = kI2S_ModeI2sClassic;
000004  2100              MOVS     r1,#0
000006  7041              STRB     r1,[r0,#1]
;;;112        config->rightLow = false;
000008  7081              STRB     r1,[r0,#2]
;;;113        config->leftJust = false;
00000a  70c1              STRB     r1,[r0,#3]
;;;114        config->pdmData = false;
00000c  7101              STRB     r1,[r0,#4]
;;;115        config->sckPol = false;
00000e  7141              STRB     r1,[r0,#5]
;;;116        config->wsPol = false;
000010  7181              STRB     r1,[r0,#6]
;;;117        config->divider = 1U;
000012  2101              MOVS     r1,#1
000014  8101              STRH     r1,[r0,#8]
;;;118        config->oneChannel = false;
000016  2100              MOVS     r1,#0
000018  7281              STRB     r1,[r0,#0xa]
;;;119        config->dataLength = 16U;
00001a  2110              MOVS     r1,#0x10
00001c  72c1              STRB     r1,[r0,#0xb]
;;;120        config->frameLength = 32U;
00001e  2120              MOVS     r1,#0x20
000020  8181              STRH     r1,[r0,#0xc]
;;;121        config->position = 0U;
000022  2100              MOVS     r1,#0
000024  81c1              STRH     r1,[r0,#0xe]
;;;122        config->watermark = 4U;
000026  2104              MOVS     r1,#4
000028  7401              STRB     r1,[r0,#0x10]
;;;123        config->txEmptyZero = true;
00002a  2101              MOVS     r1,#1
00002c  7441              STRB     r1,[r0,#0x11]
;;;124        config->pack48 = false;
00002e  2100              MOVS     r1,#0
000030  7481              STRB     r1,[r0,#0x12]
;;;125    }
000032  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.I2S_TxHandleIRQ||, CODE, READONLY, ALIGN=1

                  I2S_TxHandleIRQ PROC
;;;518    
;;;519    void I2S_TxHandleIRQ(I2S_Type *base, i2s_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;520    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;521        uint32_t intstat = base->FIFOINTSTAT;
000008  f8d57e18          LDR      r7,[r5,#0xe18]
;;;522        uint32_t data;
;;;523    
;;;524        if (intstat & I2S_FIFOINTSTAT_TXERR_MASK)
00000c  f0070001          AND      r0,r7,#1
000010  b128              CBZ      r0,|L18.30|
;;;525        {
;;;526            handle->errorCount++;
000012  6b60              LDR      r0,[r4,#0x34]
000014  1c40              ADDS     r0,r0,#1
000016  6360              STR      r0,[r4,#0x34]
;;;527    
;;;528            /* Clear TX error interrupt flag */
;;;529            base->FIFOSTAT = I2S_FIFOSTAT_TXERR(1U);
000018  2001              MOVS     r0,#1
00001a  f8c50e04          STR      r0,[r5,#0xe04]
                  |L18.30|
;;;530        }
;;;531    
;;;532        if (intstat & I2S_FIFOINTSTAT_TXLVL_MASK)
00001e  f0070004          AND      r0,r7,#4
000022  2800              CMP      r0,#0
000024  d077              BEQ      |L18.278|
;;;533        {
;;;534            if (handle->state == kI2S_StateTx)
000026  6820              LDR      r0,[r4,#0]
000028  2801              CMP      r0,#1
00002a  d175              BNE      |L18.280|
;;;535            {
;;;536                /* Send data */
;;;537    
;;;538                while ((base->FIFOSTAT & I2S_FIFOSTAT_TXNOTFULL_MASK) &&
00002c  e140              B        |L18.688|
                  |L18.46|
;;;539                       (handle->i2sQueue[handle->queueDriver].dataSize > 0U))
;;;540                {
;;;541                    /* Write output data */
;;;542                    if (handle->dataLength == 4U)
00002e  7b60              LDRB     r0,[r4,#0xd]
000030  2804              CMP      r0,#4
000032  d125              BNE      |L18.128|
;;;543                    {
;;;544                        data = *(handle->i2sQueue[handle->queueDriver].data);
000034  f8941031          LDRB     r1,[r4,#0x31]
000038  f1040010          ADD      r0,r4,#0x10
00003c  f8500031          LDR      r0,[r0,r1,LSL #3]
000040  7806              LDRB     r6,[r0,#0]
;;;545                        base->FIFOWR = ((data & 0xF0U) << 12U) | (data & 0xFU);
000042  f006000f          AND      r0,r6,#0xf
000046  f00601f0          AND      r1,r6,#0xf0
00004a  ea403001          ORR      r0,r0,r1,LSL #12
00004e  f8c50e20          STR      r0,[r5,#0xe20]
;;;546                        handle->i2sQueue[handle->queueDriver].data++;
000052  f8942031          LDRB     r2,[r4,#0x31]
000056  f1040110          ADD      r1,r4,#0x10
00005a  eb0100c2          ADD      r0,r1,r2,LSL #3
00005e  6801              LDR      r1,[r0,#0]
000060  1c49              ADDS     r1,r1,#1
000062  6001              STR      r1,[r0,#0]
;;;547                        handle->transferCount++;
000064  6ba0              LDR      r0,[r4,#0x38]
000066  1c40              ADDS     r0,r0,#1
000068  63a0              STR      r0,[r4,#0x38]
;;;548                        handle->i2sQueue[handle->queueDriver].dataSize--;
00006a  f8942031          LDRB     r2,[r4,#0x31]
00006e  f1040110          ADD      r1,r4,#0x10
000072  eb0101c2          ADD      r1,r1,r2,LSL #3
000076  1d08              ADDS     r0,r1,#4
000078  6849              LDR      r1,[r1,#4]
00007a  1e49              SUBS     r1,r1,#1
00007c  6001              STR      r1,[r0,#0]
00007e  e0f4              B        |L18.618|
                  |L18.128|
;;;549                    }
;;;550                    else if (handle->dataLength <= 8U)
000080  7b60              LDRB     r0,[r4,#0xd]
000082  2808              CMP      r0,#8
000084  d824              BHI      |L18.208|
;;;551                    {
;;;552                        data = *((uint16_t *)handle->i2sQueue[handle->queueDriver].data);
000086  f8941031          LDRB     r1,[r4,#0x31]
00008a  f1040010          ADD      r0,r4,#0x10
00008e  f8500031          LDR      r0,[r0,r1,LSL #3]
000092  8806              LDRH     r6,[r0,#0]
;;;553                        base->FIFOWR = ((data & 0xFF00U) << 8U) | (data & 0xFFU);
000094  f406417f          AND      r1,r6,#0xff00
000098  4630              MOV      r0,r6
00009a  f361201f          BFI      r0,r1,#8,#24
00009e  f8c50e20          STR      r0,[r5,#0xe20]
;;;554                        handle->i2sQueue[handle->queueDriver].data += sizeof(uint16_t);
0000a2  f8942031          LDRB     r2,[r4,#0x31]
0000a6  f1040110          ADD      r1,r4,#0x10
0000aa  eb0100c2          ADD      r0,r1,r2,LSL #3
0000ae  6801              LDR      r1,[r0,#0]
0000b0  1c89              ADDS     r1,r1,#2
0000b2  6001              STR      r1,[r0,#0]
;;;555                        handle->transferCount += sizeof(uint16_t);
0000b4  6ba0              LDR      r0,[r4,#0x38]
0000b6  1c80              ADDS     r0,r0,#2
0000b8  63a0              STR      r0,[r4,#0x38]
;;;556                        handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint16_t);
0000ba  f8942031          LDRB     r2,[r4,#0x31]
0000be  f1040110          ADD      r1,r4,#0x10
0000c2  eb0101c2          ADD      r1,r1,r2,LSL #3
0000c6  1d08              ADDS     r0,r1,#4
0000c8  6849              LDR      r1,[r1,#4]
0000ca  1e89              SUBS     r1,r1,#2
0000cc  6001              STR      r1,[r0,#0]
0000ce  e0cc              B        |L18.618|
                  |L18.208|
;;;557                    }
;;;558                    else if (handle->dataLength <= 16U)
0000d0  7b60              LDRB     r0,[r4,#0xd]
0000d2  2810              CMP      r0,#0x10
0000d4  d821              BHI      |L18.282|
;;;559                    {
;;;560                        base->FIFOWR = *((uint32_t *)(handle->i2sQueue[handle->queueDriver].data));
0000d6  f8941031          LDRB     r1,[r4,#0x31]
0000da  f1040010          ADD      r0,r4,#0x10
0000de  f8500031          LDR      r0,[r0,r1,LSL #3]
0000e2  6800              LDR      r0,[r0,#0]
0000e4  f8c50e20          STR      r0,[r5,#0xe20]
;;;561                        handle->i2sQueue[handle->queueDriver].data += sizeof(uint32_t);
0000e8  f8942031          LDRB     r2,[r4,#0x31]
0000ec  f1040110          ADD      r1,r4,#0x10
0000f0  eb0100c2          ADD      r0,r1,r2,LSL #3
0000f4  6801              LDR      r1,[r0,#0]
0000f6  1d09              ADDS     r1,r1,#4
0000f8  6001              STR      r1,[r0,#0]
;;;562                        handle->transferCount += sizeof(uint32_t);
0000fa  6ba0              LDR      r0,[r4,#0x38]
0000fc  1d00              ADDS     r0,r0,#4
0000fe  63a0              STR      r0,[r4,#0x38]
;;;563                        handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint32_t);
000100  f8942031          LDRB     r2,[r4,#0x31]
000104  f1040110          ADD      r1,r4,#0x10
000108  eb0101c2          ADD      r1,r1,r2,LSL #3
00010c  1d08              ADDS     r0,r1,#4
00010e  6849              LDR      r1,[r1,#4]
000110  1f09              SUBS     r1,r1,#4
000112  6001              STR      r1,[r0,#0]
000114  e0a9              B        |L18.618|
                  |L18.278|
000116  e11c              B        |L18.850|
                  |L18.280|
000118  e0da              B        |L18.720|
                  |L18.282|
;;;564                    }
;;;565                    else if (handle->dataLength <= 24U)
00011a  7b60              LDRB     r0,[r4,#0xd]
00011c  2818              CMP      r0,#0x18
00011e  d872              BHI      |L18.518|
;;;566                    {
;;;567                        if (handle->pack48)
000120  7ba0              LDRB     r0,[r4,#0xe]
000122  b3e8              CBZ      r0,|L18.416|
;;;568                        {
;;;569                            if (handle->useFifo48H)
000124  7be0              LDRB     r0,[r4,#0xf]
000126  b308              CBZ      r0,|L18.364|
;;;570                            {
;;;571                                base->FIFOWR48H = *((uint16_t *)(handle->i2sQueue[handle->queueDriver].data));
000128  f8941031          LDRB     r1,[r4,#0x31]
00012c  f1040010          ADD      r0,r4,#0x10
000130  f8500031          LDR      r0,[r0,r1,LSL #3]
000134  8800              LDRH     r0,[r0,#0]
000136  f8c50e24          STR      r0,[r5,#0xe24]
;;;572                                handle->i2sQueue[handle->queueDriver].data += sizeof(uint16_t);
00013a  f8942031          LDRB     r2,[r4,#0x31]
00013e  f1040110          ADD      r1,r4,#0x10
000142  eb0100c2          ADD      r0,r1,r2,LSL #3
000146  6801              LDR      r1,[r0,#0]
000148  1c89              ADDS     r1,r1,#2
00014a  6001              STR      r1,[r0,#0]
;;;573                                handle->transferCount += sizeof(uint16_t);
00014c  6ba0              LDR      r0,[r4,#0x38]
00014e  1c80              ADDS     r0,r0,#2
000150  63a0              STR      r0,[r4,#0x38]
;;;574                                handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint16_t);
000152  f8942031          LDRB     r2,[r4,#0x31]
000156  f1040110          ADD      r1,r4,#0x10
00015a  eb0101c2          ADD      r1,r1,r2,LSL #3
00015e  1d08              ADDS     r0,r1,#4
000160  6849              LDR      r1,[r1,#4]
000162  1e89              SUBS     r1,r1,#2
000164  6001              STR      r1,[r0,#0]
;;;575                                handle->useFifo48H = false;
000166  2000              MOVS     r0,#0
000168  73e0              STRB     r0,[r4,#0xf]
00016a  e07e              B        |L18.618|
                  |L18.364|
;;;576                            }
;;;577                            else
;;;578                            {
;;;579                                base->FIFOWR = *((uint32_t *)(handle->i2sQueue[handle->queueDriver].data));
00016c  f8941031          LDRB     r1,[r4,#0x31]
000170  f1040010          ADD      r0,r4,#0x10
000174  f8500031          LDR      r0,[r0,r1,LSL #3]
000178  6800              LDR      r0,[r0,#0]
00017a  f8c50e20          STR      r0,[r5,#0xe20]
;;;580                                handle->i2sQueue[handle->queueDriver].data += sizeof(uint32_t);
00017e  f8942031          LDRB     r2,[r4,#0x31]
000182  f1040110          ADD      r1,r4,#0x10
000186  eb0100c2          ADD      r0,r1,r2,LSL #3
00018a  6801              LDR      r1,[r0,#0]
00018c  1d09              ADDS     r1,r1,#4
00018e  6001              STR      r1,[r0,#0]
;;;581                                handle->transferCount += sizeof(uint32_t);
000190  6ba0              LDR      r0,[r4,#0x38]
000192  1d00              ADDS     r0,r0,#4
000194  63a0              STR      r0,[r4,#0x38]
;;;582                                handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint32_t);
000196  f8942031          LDRB     r2,[r4,#0x31]
00019a  f1040110          ADD      r1,r4,#0x10
00019e  e000              B        |L18.418|
                  |L18.416|
0001a0  e008              B        |L18.436|
                  |L18.418|
0001a2  eb0101c2          ADD      r1,r1,r2,LSL #3
0001a6  1d08              ADDS     r0,r1,#4
0001a8  6849              LDR      r1,[r1,#4]
0001aa  1f09              SUBS     r1,r1,#4
0001ac  6001              STR      r1,[r0,#0]
;;;583                                handle->useFifo48H = true;
0001ae  2001              MOVS     r0,#1
0001b0  73e0              STRB     r0,[r4,#0xf]
0001b2  e05a              B        |L18.618|
                  |L18.436|
;;;584                            }
;;;585                        }
;;;586                        else
;;;587                        {
;;;588                            data = (uint32_t)(*(handle->i2sQueue[handle->queueDriver].data++));
0001b4  f8943031          LDRB     r3,[r4,#0x31]
0001b8  f1040210          ADD      r2,r4,#0x10
0001bc  eb0201c3          ADD      r1,r2,r3,LSL #3
0001c0  6808              LDR      r0,[r1,#0]
0001c2  1c42              ADDS     r2,r0,#1
0001c4  600a              STR      r2,[r1,#0]
0001c6  7806              LDRB     r6,[r0,#0]
;;;589                            data |= ((uint32_t)(*(handle->i2sQueue[handle->queueDriver].data++))) << 8U;
0001c8  f8943031          LDRB     r3,[r4,#0x31]
0001cc  f1040210          ADD      r2,r4,#0x10
0001d0  eb0201c3          ADD      r1,r2,r3,LSL #3
0001d4  6808              LDR      r0,[r1,#0]
0001d6  1c42              ADDS     r2,r0,#1
0001d8  600a              STR      r2,[r1,#0]
0001da  7802              LDRB     r2,[r0,#0]
0001dc  ea462602          ORR      r6,r6,r2,LSL #8
;;;590                            data |= ((uint32_t)(*(handle->i2sQueue[handle->queueDriver].data++))) << 16U;
0001e0  f8943031          LDRB     r3,[r4,#0x31]
0001e4  f1040210          ADD      r2,r4,#0x10
0001e8  eb0201c3          ADD      r1,r2,r3,LSL #3
0001ec  6808              LDR      r0,[r1,#0]
0001ee  1c42              ADDS     r2,r0,#1
0001f0  600a              STR      r2,[r1,#0]
0001f2  7802              LDRB     r2,[r0,#0]
0001f4  ea464602          ORR      r6,r6,r2,LSL #16
;;;591                            if (handle->useFifo48H)
0001f8  7be0              LDRB     r0,[r4,#0xf]
0001fa  b128              CBZ      r0,|L18.520|
;;;592                            {
;;;593                                base->FIFOWR48H = data;
0001fc  f8c56e24          STR      r6,[r5,#0xe24]
;;;594                                handle->useFifo48H = false;
000200  2000              MOVS     r0,#0
000202  73e0              STRB     r0,[r4,#0xf]
000204  e004              B        |L18.528|
                  |L18.518|
000206  e011              B        |L18.556|
                  |L18.520|
;;;595                            }
;;;596                            else
;;;597                            {
;;;598                                base->FIFOWR = data;
000208  f8c56e20          STR      r6,[r5,#0xe20]
;;;599                                handle->useFifo48H = true;
00020c  2001              MOVS     r0,#1
00020e  73e0              STRB     r0,[r4,#0xf]
                  |L18.528|
;;;600                            }
;;;601                            handle->transferCount += 3U;
000210  6ba0              LDR      r0,[r4,#0x38]
000212  1cc0              ADDS     r0,r0,#3
000214  63a0              STR      r0,[r4,#0x38]
;;;602                            handle->i2sQueue[handle->queueDriver].dataSize -= 3U;
000216  f8942031          LDRB     r2,[r4,#0x31]
00021a  f1040110          ADD      r1,r4,#0x10
00021e  eb0101c2          ADD      r1,r1,r2,LSL #3
000222  1d08              ADDS     r0,r1,#4
000224  6849              LDR      r1,[r1,#4]
000226  1ec9              SUBS     r1,r1,#3
000228  6001              STR      r1,[r0,#0]
00022a  e01e              B        |L18.618|
                  |L18.556|
;;;603                        }
;;;604                    }
;;;605                    else /* if (handle->dataLength <= 32U) */
;;;606                    {
;;;607                        base->FIFOWR = *((uint32_t *)(handle->i2sQueue[handle->queueDriver].data));
00022c  f8941031          LDRB     r1,[r4,#0x31]
000230  f1040010          ADD      r0,r4,#0x10
000234  f8500031          LDR      r0,[r0,r1,LSL #3]
000238  6800              LDR      r0,[r0,#0]
00023a  f8c50e20          STR      r0,[r5,#0xe20]
;;;608                        handle->i2sQueue[handle->queueDriver].data += sizeof(uint32_t);
00023e  f8942031          LDRB     r2,[r4,#0x31]
000242  f1040110          ADD      r1,r4,#0x10
000246  eb0100c2          ADD      r0,r1,r2,LSL #3
00024a  6801              LDR      r1,[r0,#0]
00024c  1d09              ADDS     r1,r1,#4
00024e  6001              STR      r1,[r0,#0]
;;;609                        handle->transferCount += sizeof(uint32_t);
000250  6ba0              LDR      r0,[r4,#0x38]
000252  1d00              ADDS     r0,r0,#4
000254  63a0              STR      r0,[r4,#0x38]
;;;610                        handle->i2sQueue[handle->queueDriver].dataSize -= sizeof(uint32_t);
000256  f8942031          LDRB     r2,[r4,#0x31]
00025a  f1040110          ADD      r1,r4,#0x10
00025e  eb0101c2          ADD      r1,r1,r2,LSL #3
000262  1d08              ADDS     r0,r1,#4
000264  6849              LDR      r1,[r1,#4]
000266  1f09              SUBS     r1,r1,#4
000268  6001              STR      r1,[r0,#0]
                  |L18.618|
;;;611                    }
;;;612    
;;;613                    if (handle->i2sQueue[handle->queueDriver].dataSize == 0U)
00026a  f8941031          LDRB     r1,[r4,#0x31]
00026e  f1040010          ADD      r0,r4,#0x10
000272  eb0000c1          ADD      r0,r0,r1,LSL #3
000276  6840              LDR      r0,[r0,#4]
000278  b9d0              CBNZ     r0,|L18.688|
;;;614                    {
;;;615                        /* Actual data buffer sent out, switch to a next one */
;;;616                        handle->queueDriver = (handle->queueDriver + 1U) % I2S_NUM_BUFFERS;
00027a  f8940031          LDRB     r0,[r4,#0x31]
00027e  1c40              ADDS     r0,r0,#1
000280  f0000003          AND      r0,r0,#3
000284  f8840031          STRB     r0,[r4,#0x31]
;;;617    
;;;618                        /* Notify user */
;;;619                        if (handle->completionCallback)
000288  6860              LDR      r0,[r4,#4]
00028a  b130              CBZ      r0,|L18.666|
;;;620                        {
;;;621                            handle->completionCallback(base, handle, kStatus_I2S_BufferComplete, handle->userData);
00028c  f640228c          MOV      r2,#0xa8c
000290  4621              MOV      r1,r4
000292  4628              MOV      r0,r5
000294  e9d4c301          LDRD     r12,r3,[r4,#4]
000298  47e0              BLX      r12
                  |L18.666|
;;;622                        }
;;;623    
;;;624                        /* Check if the next buffer contains anything to send */
;;;625                        if (handle->i2sQueue[handle->queueDriver].dataSize == 0U)
00029a  f8941031          LDRB     r1,[r4,#0x31]
00029e  f1040010          ADD      r0,r4,#0x10
0002a2  eb0000c1          ADD      r0,r0,r1,LSL #3
0002a6  6840              LDR      r0,[r0,#4]
0002a8  b910              CBNZ     r0,|L18.688|
;;;626                        {
;;;627                            /* Everything has been written to FIFO */
;;;628                            handle->state = kI2S_StateTxWaitToWriteDummyData;
0002aa  2002              MOVS     r0,#2
0002ac  6020              STR      r0,[r4,#0]
;;;629                            break;
0002ae  e00e              B        |L18.718|
                  |L18.688|
0002b0  f8d50e04          LDR      r0,[r5,#0xe04]        ;538
0002b4  f0000020          AND      r0,r0,#0x20           ;538
0002b8  b148              CBZ      r0,|L18.718|
0002ba  f8941031          LDRB     r1,[r4,#0x31]         ;539
0002be  f1040010          ADD      r0,r4,#0x10           ;539
0002c2  eb0000c1          ADD      r0,r0,r1,LSL #3       ;539
0002c6  6840              LDR      r0,[r0,#4]            ;539
0002c8  2800              CMP      r0,#0                 ;539
0002ca  f47faeb0          BNE      |L18.46|
                  |L18.718|
0002ce  e03c              B        |L18.842|
                  |L18.720|
;;;630                        }
;;;631                    }
;;;632                }
;;;633            }
;;;634            else if (handle->state == kI2S_StateTxWaitToWriteDummyData)
0002d0  6820              LDR      r0,[r4,#0]
0002d2  2802              CMP      r0,#2
0002d4  d11e              BNE      |L18.788|
;;;635            {
;;;636                /* Write dummy data */
;;;637                if ((handle->dataLength > 16U) && (handle->dataLength < 25U))
0002d6  7b60              LDRB     r0,[r4,#0xd]
0002d8  2810              CMP      r0,#0x10
0002da  d90f              BLS      |L18.764|
0002dc  7b60              LDRB     r0,[r4,#0xd]
0002de  2819              CMP      r0,#0x19
0002e0  d20c              BCS      |L18.764|
;;;638                {
;;;639                    if (handle->useFifo48H)
0002e2  7be0              LDRB     r0,[r4,#0xf]
0002e4  b120              CBZ      r0,|L18.752|
;;;640                    {
;;;641                        base->FIFOWR48H = 0U;
0002e6  2000              MOVS     r0,#0
0002e8  f8c50e24          STR      r0,[r5,#0xe24]
;;;642                        handle->useFifo48H = false;
0002ec  73e0              STRB     r0,[r4,#0xf]
0002ee  e008              B        |L18.770|
                  |L18.752|
;;;643                    }
;;;644                    else
;;;645                    {
;;;646                        base->FIFOWR = 0U;
0002f0  2000              MOVS     r0,#0
0002f2  f8c50e20          STR      r0,[r5,#0xe20]
;;;647                        base->FIFOWR48H = 0U;
0002f6  f8c50e24          STR      r0,[r5,#0xe24]
0002fa  e002              B        |L18.770|
                  |L18.764|
;;;648                    }
;;;649                }
;;;650                else
;;;651                {
;;;652                    base->FIFOWR = 0U;
0002fc  2000              MOVS     r0,#0
0002fe  f8c50e20          STR      r0,[r5,#0xe20]
                  |L18.770|
;;;653                }
;;;654    
;;;655                /* Next time invoke this handler when FIFO becomes empty (TX level 0) */
;;;656                base->FIFOTRIG &= ~I2S_FIFOTRIG_TXLVL_MASK;
000302  f8d50e08          LDR      r0,[r5,#0xe08]
000306  f4206070          BIC      r0,r0,#0xf00
00030a  f8c50e08          STR      r0,[r5,#0xe08]
;;;657                handle->state = kI2S_StateTxWaitForEmptyFifo;
00030e  2003              MOVS     r0,#3
000310  6020              STR      r0,[r4,#0]
000312  e01a              B        |L18.842|
                  |L18.788|
;;;658            }
;;;659            else if (handle->state == kI2S_StateTxWaitForEmptyFifo)
000314  6820              LDR      r0,[r4,#0]
000316  2803              CMP      r0,#3
000318  d117              BNE      |L18.842|
;;;660            {
;;;661                /* FIFO, including additional dummy data, has been emptied now,
;;;662                 * all relevant data should have been output from peripheral */
;;;663    
;;;664                /* Stop transfer */
;;;665                I2S_Disable(base);
00031a  4628              MOV      r0,r5
00031c  f7fffffe          BL       I2S_Disable
;;;666                I2S_DisableInterrupts(base, kI2S_TxErrorFlag | kI2S_TxLevelFlag);
000320  2105              MOVS     r1,#5
000322  4628              MOV      r0,r5
000324  f7fffffe          BL       I2S_DisableInterrupts
;;;667                base->FIFOCFG |= I2S_FIFOCFG_EMPTYTX_MASK;
000328  f8d50e00          LDR      r0,[r5,#0xe00]
00032c  f4403080          ORR      r0,r0,#0x10000
000330  f8c50e00          STR      r0,[r5,#0xe00]
;;;668    
;;;669                /* Reset state */
;;;670                handle->state = kI2S_StateIdle;
000334  2000              MOVS     r0,#0
000336  6020              STR      r0,[r4,#0]
;;;671    
;;;672                /* Notify user */
;;;673                if (handle->completionCallback)
000338  6860              LDR      r0,[r4,#4]
00033a  b130              CBZ      r0,|L18.842|
;;;674                {
;;;675                    handle->completionCallback(base, handle, kStatus_I2S_Done, handle->userData);
00033c  f640228d          MOV      r2,#0xa8d
000340  4621              MOV      r1,r4
000342  4628              MOV      r0,r5
000344  e9d4c301          LDRD     r12,r3,[r4,#4]
000348  47e0              BLX      r12
                  |L18.842|
;;;676                }
;;;677            }
;;;678            else
;;;679            {
;;;680                /* Do nothing */
;;;681            }
;;;682    
;;;683            /* Clear TX level interrupt flag */
;;;684            base->FIFOSTAT = I2S_FIFOSTAT_TXLVL(1U);
00034a  f44f7080          MOV      r0,#0x100
00034e  f8c50e04          STR      r0,[r5,#0xe04]
                  |L18.850|
;;;685        }
;;;686    }
000352  e8bd81f0          POP      {r4-r8,pc}
;;;687    
                          ENDP


                          AREA ||i.I2S_TxInit||, CODE, READONLY, ALIGN=1

                  I2S_TxInit PROC
;;;66     
;;;67     void I2S_TxInit(I2S_Type *base, const i2s_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;68     {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;69         uint32_t cfg = 0U;
000008  2400              MOVS     r4,#0
;;;70         uint32_t trig = 0U;
00000a  2700              MOVS     r7,#0
;;;71     
;;;72         FLEXCOMM_Init(base, FLEXCOMM_PERIPH_I2S_TX);
00000c  2104              MOVS     r1,#4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       FLEXCOMM_Init
;;;73         I2S_Config(base, config);
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       I2S_Config
;;;74     
;;;75         /* Configure FIFO */
;;;76     
;;;77         cfg |= I2S_FIFOCFG_ENABLETX(1U);                 /* enable TX FIFO */
00001c  f0440401          ORR      r4,r4,#1
;;;78         cfg |= I2S_FIFOCFG_EMPTYTX(1U);                  /* empty TX FIFO */
000020  f4443480          ORR      r4,r4,#0x10000
;;;79         cfg |= I2S_FIFOCFG_TXI2SE0(config->txEmptyZero); /* transmit zero when buffer becomes empty or last item */
000024  7c68              LDRB     r0,[r5,#0x11]
000026  2104              MOVS     r1,#4
000028  ea010080          AND      r0,r1,r0,LSL #2
00002c  4304              ORRS     r4,r4,r0
;;;80         cfg |= I2S_FIFOCFG_PACK48(config->pack48);       /* set pack 48-bit format or not */
00002e  7ca8              LDRB     r0,[r5,#0x12]
000030  2108              MOVS     r1,#8
000032  ea0100c0          AND      r0,r1,r0,LSL #3
000036  4304              ORRS     r4,r4,r0
;;;81         trig |= I2S_FIFOTRIG_TXLVLENA(1U);               /* enable TX FIFO trigger */
000038  f0470701          ORR      r7,r7,#1
;;;82         trig |= I2S_FIFOTRIG_TXLVL(config->watermark);   /* set TX FIFO trigger level */
00003c  7c28              LDRB     r0,[r5,#0x10]
00003e  f44f6170          MOV      r1,#0xf00
000042  ea012000          AND      r0,r1,r0,LSL #8
000046  4307              ORRS     r7,r7,r0
;;;83     
;;;84         base->FIFOCFG = cfg;
000048  f8c64e00          STR      r4,[r6,#0xe00]
;;;85         base->FIFOTRIG = trig;
00004c  f8c67e08          STR      r7,[r6,#0xe08]
;;;86     }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;87     
                          ENDP


                          AREA ||i.I2S_TxTransferAbort||, CODE, READONLY, ALIGN=2

                  I2S_TxTransferAbort PROC
;;;382    
;;;383    void I2S_TxTransferAbort(I2S_Type *base, i2s_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;385        assert(handle);
000006  b104              CBZ      r4,|L20.10|
000008  e005              B        |L20.22|
                  |L20.10|
00000a  f2401281          MOV      r2,#0x181
00000e  a10a              ADR      r1,|L20.56|
000010  a00f              ADR      r0,|L20.80|
000012  f7fffffe          BL       __aeabi_assert
                  |L20.22|
;;;386    
;;;387        /* Disable I2S operation and interrupts */
;;;388        I2S_TxEnable(base, false);
000016  2100              MOVS     r1,#0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       I2S_TxEnable
;;;389    
;;;390        /* Reset state */
;;;391        handle->state = kI2S_StateIdle;
00001e  2000              MOVS     r0,#0
000020  6020              STR      r0,[r4,#0]
;;;392    
;;;393        /* Clear transfer queue */
;;;394        memset((void *)&handle->i2sQueue, 0U, sizeof(i2s_transfer_t) * I2S_NUM_BUFFERS);
000022  2120              MOVS     r1,#0x20
000024  f1040010          ADD      r0,r4,#0x10
000028  f7fffffe          BL       __aeabi_memclr4
;;;395        handle->queueDriver = 0U;
00002c  2000              MOVS     r0,#0
00002e  f8840031          STRB     r0,[r4,#0x31]
;;;396        handle->queueUser = 0U;
000032  f8840030          STRB     r0,[r4,#0x30]
;;;397    }
000036  bd70              POP      {r4-r6,pc}
;;;398    
                          ENDP

                  |L20.56|
000038  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
00003c  44726976
000040  6572735c
000044  66736c5f
000048  6932732e
00004c  6300    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L20.80|
000050  68616e64          DCB      "handle",0
000054  6c6500  
000057  00                DCB      0

                          AREA ||i.I2S_TxTransferCreateHandle||, CODE, READONLY, ALIGN=2

                  I2S_TxTransferCreateHandle PROC
;;;326    
;;;327    void I2S_TxTransferCreateHandle(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_callback_t callback, void *userData)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;328    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;329        assert(handle);
00000c  b104              CBZ      r4,|L21.16|
00000e  e005              B        |L21.28|
                  |L21.16|
000010  f2401249          MOV      r2,#0x149
000014  a114              ADR      r1,|L21.104|
000016  a01a              ADR      r0,|L21.128|
000018  f7fffffe          BL       __aeabi_assert
                  |L21.28|
;;;330    
;;;331        /* Clear out the handle */
;;;332        memset(handle, 0U, sizeof(*handle));
00001c  2140              MOVS     r1,#0x40
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memclr4
;;;333    
;;;334        /* Save callback and user data */
;;;335        handle->completionCallback = callback;
000024  6067              STR      r7,[r4,#4]
;;;336        handle->userData = userData;
000026  60a6              STR      r6,[r4,#8]
;;;337    
;;;338        /* Remember some items set previously by configuration */
;;;339        handle->watermark = ((base->FIFOTRIG & I2S_FIFOTRIG_TXLVL_MASK) >> I2S_FIFOTRIG_TXLVL_SHIFT);
000028  f8d50e08          LDR      r0,[r5,#0xe08]
00002c  f3c02003          UBFX     r0,r0,#8,#4
000030  f884003c          STRB     r0,[r4,#0x3c]
;;;340        handle->oneChannel = ((base->CFG1 & I2S_CFG1_ONECHANNEL_MASK) >> I2S_CFG1_ONECHANNEL_SHIFT);
000034  f8d50c00          LDR      r0,[r5,#0xc00]
000038  f3c02080          UBFX     r0,r0,#10,#1
00003c  7320              STRB     r0,[r4,#0xc]
;;;341        handle->dataLength = ((base->CFG1 & I2S_CFG1_DATALEN_MASK) >> I2S_CFG1_DATALEN_SHIFT) + 1U;
00003e  f8d50c00          LDR      r0,[r5,#0xc00]
000042  f3c04004          UBFX     r0,r0,#16,#5
000046  1c40              ADDS     r0,r0,#1
000048  7360              STRB     r0,[r4,#0xd]
;;;342        handle->pack48 = ((base->FIFOCFG & I2S_FIFOCFG_PACK48_MASK) >> I2S_FIFOCFG_PACK48_SHIFT);
00004a  f8d50e00          LDR      r0,[r5,#0xe00]
00004e  f3c000c0          UBFX     r0,r0,#3,#1
000052  73a0              STRB     r0,[r4,#0xe]
;;;343    
;;;344        handle->useFifo48H = false;
000054  2000              MOVS     r0,#0
000056  73e0              STRB     r0,[r4,#0xf]
;;;345    
;;;346        /* Register IRQ handling */
;;;347        FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)I2S_TxHandleIRQ, handle);
000058  4622              MOV      r2,r4
00005a  490b              LDR      r1,|L21.136|
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       FLEXCOMM_SetIRQHandler
;;;348    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;349    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
000068  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
00006c  44726976
000070  6572735c
000074  66736c5f
000078  6932732e
00007c  6300    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L21.128|
000080  68616e64          DCB      "handle",0
000084  6c6500  
000087  00                DCB      0
                  |L21.136|
                          DCD      I2S_TxHandleIRQ

                          AREA ||i.I2S_TxTransferNonBlocking||, CODE, READONLY, ALIGN=2

                  I2S_TxTransferNonBlocking PROC
;;;349    
;;;350    status_t I2S_TxTransferNonBlocking(I2S_Type *base, i2s_handle_t *handle, i2s_transfer_t transfer)
000000  b57f              PUSH     {r0-r6,lr}
;;;351    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;352        assert(handle);
000006  b104              CBZ      r4,|L22.10|
000008  e005              B        |L22.22|
                  |L22.10|
00000a  f44f72b0          MOV      r2,#0x160
00000e  a11f              ADR      r1,|L22.140|
000010  a024              ADR      r0,|L22.164|
000012  f7fffffe          BL       __aeabi_assert
                  |L22.22|
;;;353        if (!handle)
000016  b914              CBNZ     r4,|L22.30|
;;;354        {
;;;355            return kStatus_InvalidArgument;
000018  2004              MOVS     r0,#4
                  |L22.26|
;;;356        }
;;;357    
;;;358        status_t result;
;;;359    
;;;360        result = I2S_ValidateBuffer(handle, &transfer);
;;;361        if (result != kStatus_Success)
;;;362        {
;;;363            return result;
;;;364        }
;;;365    
;;;366        if (handle->i2sQueue[handle->queueUser].dataSize)
;;;367        {
;;;368            /* Previously prepared buffers not processed yet */
;;;369            return kStatus_I2S_Busy;
;;;370        }
;;;371    
;;;372        handle->state = kI2S_StateTx;
;;;373        handle->i2sQueue[handle->queueUser].data = transfer.data;
;;;374        handle->i2sQueue[handle->queueUser].dataSize = transfer.dataSize;
;;;375        handle->queueUser = (handle->queueUser + 1U) % I2S_NUM_BUFFERS;
;;;376    
;;;377        base->FIFOTRIG = (base->FIFOTRIG & (~I2S_FIFOTRIG_TXLVL_MASK)) | I2S_FIFOTRIG_TXLVL(handle->watermark);
;;;378        I2S_TxEnable(base, true);
;;;379    
;;;380        return kStatus_Success;
;;;381    }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd70              POP      {r4-r6,pc}
                  |L22.30|
00001e  a902              ADD      r1,sp,#8              ;360
000020  4620              MOV      r0,r4                 ;360
000022  f7fffffe          BL       I2S_ValidateBuffer
000026  4606              MOV      r6,r0                 ;360
000028  b10e              CBZ      r6,|L22.46|
00002a  4630              MOV      r0,r6                 ;363
00002c  e7f5              B        |L22.26|
                  |L22.46|
00002e  f8941030          LDRB     r1,[r4,#0x30]         ;366
000032  f1040010          ADD      r0,r4,#0x10           ;366
000036  eb0000c1          ADD      r0,r0,r1,LSL #3       ;366
00003a  6840              LDR      r0,[r0,#4]            ;366
00003c  b110              CBZ      r0,|L22.68|
00003e  f640208e          MOV      r0,#0xa8e             ;369
000042  e7ea              B        |L22.26|
                  |L22.68|
000044  2001              MOVS     r0,#1                 ;372
000046  6020              STR      r0,[r4,#0]            ;372
000048  f8942030          LDRB     r2,[r4,#0x30]         ;373
00004c  9902              LDR      r1,[sp,#8]            ;373
00004e  f1040010          ADD      r0,r4,#0x10           ;373
000052  f8401032          STR      r1,[r0,r2,LSL #3]     ;373
000056  9903              LDR      r1,[sp,#0xc]          ;374
000058  f8942030          LDRB     r2,[r4,#0x30]         ;374
00005c  eb0000c2          ADD      r0,r0,r2,LSL #3       ;374
000060  6041              STR      r1,[r0,#4]            ;374
000062  f8140f30          LDRB     r0,[r4,#0x30]!        ;375
000066  1c40              ADDS     r0,r0,#1              ;375
000068  f0000003          AND      r0,r0,#3              ;375
00006c  7020              STRB     r0,[r4,#0]            ;375
00006e  7b21              LDRB     r1,[r4,#0xc]          ;377
000070  3c30              SUBS     r4,r4,#0x30           ;377
000072  f8d50e08          LDR      r0,[r5,#0xe08]        ;377
000076  f361200b          BFI      r0,r1,#8,#4           ;377
00007a  f8c50e08          STR      r0,[r5,#0xe08]        ;377
00007e  2101              MOVS     r1,#1                 ;378
000080  4628              MOV      r0,r5                 ;378
000082  f7fffffe          BL       I2S_TxEnable
000086  2000              MOVS     r0,#0                 ;380
000088  e7c7              B        |L22.26|
;;;382    
                          ENDP

00008a  0000              DCW      0x0000
                  |L22.140|
00008c  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
000090  44726976
000094  6572735c
000098  66736c5f
00009c  6932732e
0000a0  6300    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L22.164|
0000a4  68616e64          DCB      "handle",0
0000a8  6c6500  
0000ab  00                DCB      0

                          AREA ||i.I2S_ValidateBuffer||, CODE, READONLY, ALIGN=2

                  I2S_ValidateBuffer PROC
;;;228    
;;;229    static status_t I2S_ValidateBuffer(i2s_handle_t *handle, i2s_transfer_t *transfer)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;231        assert(transfer->data);
000006  6820              LDR      r0,[r4,#0]
000008  b100              CBZ      r0,|L23.12|
00000a  e004              B        |L23.22|
                  |L23.12|
00000c  22e7              MOVS     r2,#0xe7
00000e  a16a              ADR      r1,|L23.440|
000010  a06f              ADR      r0,|L23.464|
000012  f7fffffe          BL       __aeabi_assert
                  |L23.22|
;;;232        if (!transfer->data)
000016  6820              LDR      r0,[r4,#0]
000018  b908              CBNZ     r0,|L23.30|
;;;233        {
;;;234            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L23.28|
;;;235        }
;;;236    
;;;237        assert(transfer->dataSize > 0U);
;;;238        if (transfer->dataSize <= 0U)
;;;239        {
;;;240            return kStatus_InvalidArgument;
;;;241        }
;;;242    
;;;243        if (handle->dataLength == 4U)
;;;244        {
;;;245            /* No alignment and data length requirements */
;;;246        }
;;;247        else if ((handle->dataLength >= 5U) && (handle->dataLength <= 8U))
;;;248        {
;;;249            assert((((uint32_t)transfer->data) % 2U) == 0U);
;;;250            if ((((uint32_t)transfer->data) % 2U) != 0U)
;;;251            {
;;;252                /* Data not 2-bytes aligned */
;;;253                return kStatus_InvalidArgument;
;;;254            }
;;;255    
;;;256            assert((transfer->dataSize % 2U) == 0U);
;;;257            if ((transfer->dataSize % 2U) != 0U)
;;;258            {
;;;259                /* Data not in pairs of left/right channel bytes */
;;;260                return kStatus_InvalidArgument;
;;;261            }
;;;262        }
;;;263        else if ((handle->dataLength >= 9U) && (handle->dataLength <= 16U))
;;;264        {
;;;265            assert((((uint32_t)transfer->data) % 4U) == 0U);
;;;266            if ((((uint32_t)transfer->data) % 4U) != 0U)
;;;267            {
;;;268                /* Data not 4-bytes aligned */
;;;269                return kStatus_InvalidArgument;
;;;270            }
;;;271    
;;;272            assert((transfer->dataSize % 4U) == 0U);
;;;273            if ((transfer->dataSize % 4U) != 0U)
;;;274            {
;;;275                /* Data lenght not multiply of 4 */
;;;276                return kStatus_InvalidArgument;
;;;277            }
;;;278        }
;;;279        else if ((handle->dataLength >= 17U) && (handle->dataLength <= 24U))
;;;280        {
;;;281            assert((transfer->dataSize % 6U) == 0U);
;;;282            if ((transfer->dataSize % 6U) != 0U)
;;;283            {
;;;284                /* Data lenght not multiply of 6 */
;;;285                return kStatus_InvalidArgument;
;;;286            }
;;;287    
;;;288            assert(!((handle->pack48) && ((((uint32_t)transfer->data) % 4U) != 0U)));
;;;289            if ((handle->pack48) && ((((uint32_t)transfer->data) % 4U) != 0U))
;;;290            {
;;;291                /* Data not 4-bytes aligned */
;;;292                return kStatus_InvalidArgument;
;;;293            }
;;;294        }
;;;295        else /* if (handle->dataLength >= 25U) */
;;;296        {
;;;297            assert((((uint32_t)transfer->data) % 4U) == 0U);
;;;298            if ((((uint32_t)transfer->data) % 4U) != 0U)
;;;299            {
;;;300                /* Data not 4-bytes aligned */
;;;301                return kStatus_InvalidArgument;
;;;302            }
;;;303    
;;;304            if (handle->oneChannel)
;;;305            {
;;;306                assert((transfer->dataSize % 4U) == 0U);
;;;307                if ((transfer->dataSize % 4U) != 0U)
;;;308                {
;;;309                    /* Data lenght not multiply of 4 */
;;;310                    return kStatus_InvalidArgument;
;;;311                }
;;;312            }
;;;313            else
;;;314            {
;;;315                assert((transfer->dataSize % 8U) == 0U);
;;;316                if ((transfer->dataSize % 8U) != 0U)
;;;317                {
;;;318                    /* Data lenght not multiply of 8 */
;;;319                    return kStatus_InvalidArgument;
;;;320                }
;;;321            }
;;;322        }
;;;323    
;;;324        return kStatus_Success;
;;;325    }
00001c  bd70              POP      {r4-r6,pc}
                  |L23.30|
00001e  6860              LDR      r0,[r4,#4]            ;237
000020  b100              CBZ      r0,|L23.36|
000022  e004              B        |L23.46|
                  |L23.36|
000024  22ed              MOVS     r2,#0xed              ;237
000026  a164              ADR      r1,|L23.440|
000028  a06d              ADR      r0,|L23.480|
00002a  f7fffffe          BL       __aeabi_assert
                  |L23.46|
00002e  6860              LDR      r0,[r4,#4]            ;238
000030  b908              CBNZ     r0,|L23.54|
000032  2004              MOVS     r0,#4                 ;240
000034  e7f2              B        |L23.28|
                  |L23.54|
000036  7b68              LDRB     r0,[r5,#0xd]          ;243
000038  2804              CMP      r0,#4                 ;243
                  |L23.58|
00003a  d074              BEQ      |L23.294|
00003c  7b68              LDRB     r0,[r5,#0xd]          ;247
00003e  2805              CMP      r0,#5                 ;247
000040  d324              BCC      |L23.140|
000042  7b68              LDRB     r0,[r5,#0xd]          ;247
000044  2808              CMP      r0,#8                 ;247
000046  d821              BHI      |L23.140|
000048  7820              LDRB     r0,[r4,#0]            ;249
00004a  f0000001          AND      r0,r0,#1              ;249
00004e  b900              CBNZ     r0,|L23.82|
000050  e004              B        |L23.92|
                  |L23.82|
000052  22f9              MOVS     r2,#0xf9              ;249
000054  a158              ADR      r1,|L23.440|
000056  a068              ADR      r0,|L23.504|
000058  f7fffffe          BL       __aeabi_assert
                  |L23.92|
00005c  7820              LDRB     r0,[r4,#0]            ;250
00005e  f0000001          AND      r0,r0,#1              ;250
000062  b108              CBZ      r0,|L23.104|
000064  2004              MOVS     r0,#4                 ;253
000066  e7d9              B        |L23.28|
                  |L23.104|
000068  6860              LDR      r0,[r4,#4]            ;256
00006a  f0000001          AND      r0,r0,#1              ;256
00006e  b900              CBNZ     r0,|L23.114|
000070  e005              B        |L23.126|
                  |L23.114|
000072  f44f7280          MOV      r2,#0x100             ;256
000076  a150              ADR      r1,|L23.440|
000078  a069              ADR      r0,|L23.544|
00007a  f7fffffe          BL       __aeabi_assert
                  |L23.126|
00007e  6860              LDR      r0,[r4,#4]            ;257
000080  f0000001          AND      r0,r0,#1              ;257
000084  2800              CMP      r0,#0                 ;257
000086  d0d8              BEQ      |L23.58|
000088  2004              MOVS     r0,#4                 ;260
00008a  e7c7              B        |L23.28|
                  |L23.140|
00008c  7b68              LDRB     r0,[r5,#0xd]          ;263
00008e  2809              CMP      r0,#9                 ;263
000090  d325              BCC      |L23.222|
000092  7b68              LDRB     r0,[r5,#0xd]          ;263
000094  2810              CMP      r0,#0x10              ;263
000096  d822              BHI      |L23.222|
000098  7820              LDRB     r0,[r4,#0]            ;265
00009a  f0000003          AND      r0,r0,#3              ;265
00009e  b900              CBNZ     r0,|L23.162|
0000a0  e005              B        |L23.174|
                  |L23.162|
0000a2  f2401209          MOV      r2,#0x109             ;265
0000a6  a144              ADR      r1,|L23.440|
0000a8  a065              ADR      r0,|L23.576|
0000aa  f7fffffe          BL       __aeabi_assert
                  |L23.174|
0000ae  7820              LDRB     r0,[r4,#0]            ;266
0000b0  f0000003          AND      r0,r0,#3              ;266
0000b4  b108              CBZ      r0,|L23.186|
0000b6  2004              MOVS     r0,#4                 ;269
0000b8  e7b0              B        |L23.28|
                  |L23.186|
0000ba  6860              LDR      r0,[r4,#4]            ;272
0000bc  f0000003          AND      r0,r0,#3              ;272
0000c0  b900              CBNZ     r0,|L23.196|
0000c2  e005              B        |L23.208|
                  |L23.196|
0000c4  f44f7288          MOV      r2,#0x110             ;272
0000c8  a13b              ADR      r1,|L23.440|
0000ca  a067              ADR      r0,|L23.616|
0000cc  f7fffffe          BL       __aeabi_assert
                  |L23.208|
0000d0  6860              LDR      r0,[r4,#4]            ;273
0000d2  f0000003          AND      r0,r0,#3              ;273
0000d6  2800              CMP      r0,#0                 ;273
0000d8  d06b              BEQ      |L23.434|
0000da  2004              MOVS     r0,#4                 ;276
0000dc  e79e              B        |L23.28|
                  |L23.222|
0000de  7b68              LDRB     r0,[r5,#0xd]          ;279
0000e0  2811              CMP      r0,#0x11              ;279
0000e2  d331              BCC      |L23.328|
0000e4  7b68              LDRB     r0,[r5,#0xd]          ;279
0000e6  2818              CMP      r0,#0x18              ;279
0000e8  d82e              BHI      |L23.328|
0000ea  6860              LDR      r0,[r4,#4]            ;281
0000ec  2106              MOVS     r1,#6                 ;281
0000ee  fbb0f2f1          UDIV     r2,r0,r1              ;281
0000f2  fb010012          MLS      r0,r1,r2,r0           ;281
0000f6  b900              CBNZ     r0,|L23.250|
0000f8  e005              B        |L23.262|
                  |L23.250|
0000fa  f2401219          MOV      r2,#0x119             ;281
0000fe  a12e              ADR      r1,|L23.440|
000100  a061              ADR      r0,|L23.648|
000102  f7fffffe          BL       __aeabi_assert
                  |L23.262|
000106  6860              LDR      r0,[r4,#4]            ;282
000108  2106              MOVS     r1,#6                 ;282
00010a  fbb0f2f1          UDIV     r2,r0,r1              ;282
00010e  fb010012          MLS      r0,r1,r2,r0           ;282
000112  b108              CBZ      r0,|L23.280|
000114  2004              MOVS     r0,#4                 ;285
000116  e781              B        |L23.28|
                  |L23.280|
000118  7ba8              LDRB     r0,[r5,#0xe]          ;288
00011a  b118              CBZ      r0,|L23.292|
00011c  7820              LDRB     r0,[r4,#0]            ;288
00011e  f0000003          AND      r0,r0,#3              ;288
000122  b908              CBNZ     r0,|L23.296|
                  |L23.292|
000124  e006              B        |L23.308|
                  |L23.294|
000126  e044              B        |L23.434|
                  |L23.296|
000128  f44f7290          MOV      r2,#0x120             ;288
00012c  a122              ADR      r1,|L23.440|
00012e  485e              LDR      r0,|L23.680|
000130  f7fffffe          BL       __aeabi_assert
                  |L23.308|
000134  7ba8              LDRB     r0,[r5,#0xe]          ;289
000136  2800              CMP      r0,#0                 ;289
000138  d03b              BEQ      |L23.434|
00013a  7820              LDRB     r0,[r4,#0]            ;289
00013c  f0000003          AND      r0,r0,#3              ;289
000140  2800              CMP      r0,#0                 ;289
000142  d036              BEQ      |L23.434|
000144  2004              MOVS     r0,#4                 ;292
000146  e769              B        |L23.28|
                  |L23.328|
000148  7820              LDRB     r0,[r4,#0]            ;297
00014a  f0000003          AND      r0,r0,#3              ;297
00014e  b900              CBNZ     r0,|L23.338|
000150  e005              B        |L23.350|
                  |L23.338|
000152  f2401229          MOV      r2,#0x129             ;297
000156  a118              ADR      r1,|L23.440|
000158  a039              ADR      r0,|L23.576|
00015a  f7fffffe          BL       __aeabi_assert
                  |L23.350|
00015e  7820              LDRB     r0,[r4,#0]            ;298
000160  f0000003          AND      r0,r0,#3              ;298
000164  b108              CBZ      r0,|L23.362|
000166  2004              MOVS     r0,#4                 ;301
000168  e758              B        |L23.28|
                  |L23.362|
00016a  7b28              LDRB     r0,[r5,#0xc]          ;304
00016c  b180              CBZ      r0,|L23.400|
00016e  6860              LDR      r0,[r4,#4]            ;306
000170  f0000003          AND      r0,r0,#3              ;306
000174  b900              CBNZ     r0,|L23.376|
000176  e005              B        |L23.388|
                  |L23.376|
000178  f44f7299          MOV      r2,#0x132             ;306
00017c  a10e              ADR      r1,|L23.440|
00017e  a03a              ADR      r0,|L23.616|
000180  f7fffffe          BL       __aeabi_assert
                  |L23.388|
000184  6860              LDR      r0,[r4,#4]            ;307
000186  f0000003          AND      r0,r0,#3              ;307
00018a  b190              CBZ      r0,|L23.434|
00018c  2004              MOVS     r0,#4                 ;310
00018e  e745              B        |L23.28|
                  |L23.400|
000190  6860              LDR      r0,[r4,#4]            ;315
000192  f0000007          AND      r0,r0,#7              ;315
000196  b900              CBNZ     r0,|L23.410|
000198  e005              B        |L23.422|
                  |L23.410|
00019a  f240123b          MOV      r2,#0x13b             ;315
00019e  a106              ADR      r1,|L23.440|
0001a0  a042              ADR      r0,|L23.684|
0001a2  f7fffffe          BL       __aeabi_assert
                  |L23.422|
0001a6  6860              LDR      r0,[r4,#4]            ;316
0001a8  f0000007          AND      r0,r0,#7              ;316
0001ac  b108              CBZ      r0,|L23.434|
0001ae  2004              MOVS     r0,#4                 ;319
0001b0  e734              B        |L23.28|
                  |L23.434|
0001b2  2000              MOVS     r0,#0                 ;324
0001b4  e732              B        |L23.28|
;;;326    
                          ENDP

0001b6  0000              DCW      0x0000
                  |L23.440|
0001b8  5352435c          DCB      "SRC\\Drivers\\fsl_i2s.c",0
0001bc  44726976
0001c0  6572735c
0001c4  66736c5f
0001c8  6932732e
0001cc  6300    
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L23.464|
0001d0  7472616e          DCB      "transfer->data",0
0001d4  73666572
0001d8  2d3e6461
0001dc  746100  
0001df  00                DCB      0
                  |L23.480|
0001e0  7472616e          DCB      "transfer->dataSize > 0U",0
0001e4  73666572
0001e8  2d3e6461
0001ec  74615369
0001f0  7a65203e
0001f4  20305500
                  |L23.504|
0001f8  28282875          DCB      "(((uint32_t)transfer->data) % 2U) == 0U",0
0001fc  696e7433
000200  325f7429
000204  7472616e
000208  73666572
00020c  2d3e6461
000210  74612920
000214  25203255
000218  29203d3d
00021c  20305500
                  |L23.544|
000220  28747261          DCB      "(transfer->dataSize % 2U) == 0U",0
000224  6e736665
000228  722d3e64
00022c  61746153
000230  697a6520
000234  25203255
000238  29203d3d
00023c  20305500
                  |L23.576|
000240  28282875          DCB      "(((uint32_t)transfer->data) % 4U) == 0U",0
000244  696e7433
000248  325f7429
00024c  7472616e
000250  73666572
000254  2d3e6461
000258  74612920
00025c  25203455
000260  29203d3d
000264  20305500
                  |L23.616|
000268  28747261          DCB      "(transfer->dataSize % 4U) == 0U",0
00026c  6e736665
000270  722d3e64
000274  61746153
000278  697a6520
00027c  25203455
000280  29203d3d
000284  20305500
                  |L23.648|
000288  28747261          DCB      "(transfer->dataSize % 6U) == 0U",0
00028c  6e736665
000290  722d3e64
000294  61746153
000298  697a6520
00029c  25203655
0002a0  29203d3d
0002a4  20305500
                  |L23.680|
                          DCD      ||.conststring||
                  |L23.684|
0002ac  28747261          DCB      "(transfer->dataSize % 8U) == 0U",0
0002b0  6e736665
0002b4  722d3e64
0002b8  61746153
0002bc  697a6520
0002c0  25203855
0002c4  29203d3d
0002c8  20305500

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  21282868          DCB      "!((handle->pack48) && ((((uint32_t)transfer->data) % 4U"
000004  616e646c
000008  652d3e70
00000c  61636b34
000010  38292026
000014  26202828
000018  28287569
00001c  6e743332
000020  5f742974
000024  72616e73
000028  6665722d
00002c  3e646174
000030  61292025
000034  203455  
000037  2920213d          DCB      ") != 0U))",0
00003b  20305529
00003f  2900    

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_i2s.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_i2s_c_9669b48a____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_i2s_c_9669b48a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_i2s_c_9669b48a____REVSH|
#line 402
|__asm___9_fsl_i2s_c_9669b48a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_i2s_c_9669b48a____RRX|
#line 587
|__asm___9_fsl_i2s_c_9669b48a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
