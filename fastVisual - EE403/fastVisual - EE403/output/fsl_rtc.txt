; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_rtc.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_rtc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_rtc.crf SRC\Drivers\fsl_rtc.c]
                          THUMB

                          AREA ||i.RTC_CheckDatetimeFormat||, CODE, READONLY, ALIGN=2

                  RTC_CheckDatetimeFormat PROC
;;;74      ******************************************************************************/
;;;75     static bool RTC_CheckDatetimeFormat(const rtc_datetime_t *datetime)
000000  b51f              PUSH     {r0-r4,lr}
;;;76     {
000002  4604              MOV      r4,r0
;;;77         assert(datetime);
000004  b104              CBZ      r4,|L1.8|
000006  e004              B        |L1.18|
                  |L1.8|
000008  224d              MOVS     r2,#0x4d
00000a  a122              ADR      r1,|L1.148|
00000c  a027              ADR      r0,|L1.172|
00000e  f7fffffe          BL       __aeabi_assert
                  |L1.18|
;;;78     
;;;79         /* Table of days in a month for a non leap year. First entry in the table is not used,
;;;80          * valid months start from 1
;;;81          */
;;;82         uint8_t daysPerMonth[] = {0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U};
000012  a329              ADR      r3,|L1.184|
000014  cb0f              LDM      r3,{r0-r3}
000016  e88d000f          STM      sp,{r0-r3}
;;;83     
;;;84         /* Check year, month, hour, minute, seconds */
;;;85         if ((datetime->year < YEAR_RANGE_START) || (datetime->year > YEAR_RANGE_END) || (datetime->month > 12U) ||
00001a  8820              LDRH     r0,[r4,#0]
00001c  f24071b2          MOV      r1,#0x7b2
000020  4288              CMP      r0,r1
000022  d312              BCC      |L1.74|
000024  8820              LDRH     r0,[r4,#0]
000026  f6400133          MOV      r1,#0x833
00002a  4288              CMP      r0,r1
00002c  d80d              BHI      |L1.74|
00002e  78a0              LDRB     r0,[r4,#2]
000030  280c              CMP      r0,#0xc
000032  d80a              BHI      |L1.74|
;;;86             (datetime->month < 1U) || (datetime->hour >= 24U) || (datetime->minute >= 60U) || (datetime->second >= 60U))
000034  78a0              LDRB     r0,[r4,#2]
000036  b140              CBZ      r0,|L1.74|
000038  7920              LDRB     r0,[r4,#4]
00003a  2818              CMP      r0,#0x18
00003c  d205              BCS      |L1.74|
00003e  7960              LDRB     r0,[r4,#5]
000040  283c              CMP      r0,#0x3c
000042  d202              BCS      |L1.74|
000044  79a0              LDRB     r0,[r4,#6]
000046  283c              CMP      r0,#0x3c
000048  d302              BCC      |L1.80|
                  |L1.74|
;;;87         {
;;;88             /* If not correct then error*/
;;;89             return false;
00004a  2000              MOVS     r0,#0
                  |L1.76|
;;;90         }
;;;91     
;;;92         /* Adjust the days in February for a leap year */
;;;93         if ((((datetime->year & 3U) == 0) && (datetime->year % 100 != 0)) || (datetime->year % 400 == 0))
;;;94         {
;;;95             daysPerMonth[2] = 29U;
;;;96         }
;;;97     
;;;98         /* Check the validity of the day */
;;;99         if ((datetime->day > daysPerMonth[datetime->month]) || (datetime->day < 1U))
;;;100        {
;;;101            return false;
;;;102        }
;;;103    
;;;104        return true;
;;;105    }
00004c  b004              ADD      sp,sp,#0x10
00004e  bd10              POP      {r4,pc}
                  |L1.80|
000050  7820              LDRB     r0,[r4,#0]            ;93
000052  f0000003          AND      r0,r0,#3              ;93
000056  b930              CBNZ     r0,|L1.102|
000058  8820              LDRH     r0,[r4,#0]            ;93
00005a  2164              MOVS     r1,#0x64              ;93
00005c  fb90f2f1          SDIV     r2,r0,r1              ;93
000060  fb010012          MLS      r0,r1,r2,r0           ;93
000064  b938              CBNZ     r0,|L1.118|
                  |L1.102|
000066  8820              LDRH     r0,[r4,#0]            ;93
000068  f44f71c8          MOV      r1,#0x190             ;93
00006c  fb90f2f1          SDIV     r2,r0,r1              ;93
000070  fb010012          MLS      r0,r1,r2,r0           ;93
000074  b910              CBNZ     r0,|L1.124|
                  |L1.118|
000076  201d              MOVS     r0,#0x1d              ;95
000078  f88d0002          STRB     r0,[sp,#2]            ;95
                  |L1.124|
00007c  78e0              LDRB     r0,[r4,#3]            ;99
00007e  78a1              LDRB     r1,[r4,#2]            ;99
000080  f81d1001          LDRB     r1,[sp,r1]            ;99
000084  4288              CMP      r0,r1                 ;99
000086  dc01              BGT      |L1.140|
000088  78e0              LDRB     r0,[r4,#3]            ;99
00008a  b908              CBNZ     r0,|L1.144|
                  |L1.140|
00008c  2000              MOVS     r0,#0                 ;101
00008e  e7dd              B        |L1.76|
                  |L1.144|
000090  2001              MOVS     r0,#1                 ;104
000092  e7db              B        |L1.76|
;;;106    
                          ENDP

                  |L1.148|
000094  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
000098  44726976
00009c  6572735c
0000a0  66736c5f
0000a4  7274632e
0000a8  6300    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L1.172|
0000ac  64617465          DCB      "datetime",0
0000b0  74696d65
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L1.184|
0000b8  00                DCB      0
0000b9  1f1c1f1e          DCB      31,28,31,30,31,30,31,31,30,31,30,31,0
0000bd  1f1e1f1f
0000c1  1e1f1e1f
0000c5  00      
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.RTC_ConvertDatetimeToSeconds||, CODE, READONLY, ALIGN=2

                  RTC_ConvertDatetimeToSeconds PROC
;;;106    
;;;107    static uint32_t RTC_ConvertDatetimeToSeconds(const rtc_datetime_t *datetime)
000000  b530              PUSH     {r4,r5,lr}
;;;108    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;109        assert(datetime);
000006  b104              CBZ      r4,|L2.10|
000008  e004              B        |L2.20|
                  |L2.10|
00000a  226d              MOVS     r2,#0x6d
00000c  a11c              ADR      r1,|L2.128|
00000e  a022              ADR      r0,|L2.152|
000010  f7fffffe          BL       __aeabi_assert
                  |L2.20|
;;;110    
;;;111        /* Number of days from begin of the non Leap-year*/
;;;112        /* Number of days from begin of the non Leap-year*/
;;;113        uint16_t monthDays[] = {0U, 0U, 31U, 59U, 90U, 120U, 151U, 181U, 212U, 243U, 273U, 304U, 334U};
000014  221c              MOVS     r2,#0x1c
000016  4923              LDR      r1,|L2.164|
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       __aeabi_memcpy4
;;;114        uint32_t seconds;
;;;115    
;;;116        /* Compute number of days from 1970 till given year*/
;;;117        seconds = (datetime->year - 1970U) * DAYS_IN_A_YEAR;
00001e  8820              LDRH     r0,[r4,#0]
000020  f2a070b2          SUB      r0,r0,#0x7b2
000024  f240116d          MOV      r1,#0x16d
000028  fb00f501          MUL      r5,r0,r1
;;;118        /* Add leap year days */
;;;119        seconds += ((datetime->year / 4) - (1970U / 4));
00002c  8820              LDRH     r0,[r4,#0]
00002e  17c1              ASRS     r1,r0,#31
000030  eb007191          ADD      r1,r0,r1,LSR #30
000034  1089              ASRS     r1,r1,#2
000036  f5a171f6          SUB      r1,r1,#0x1ec
00003a  440d              ADD      r5,r5,r1
;;;120        /* Add number of days till given month*/
;;;121        seconds += monthDays[datetime->month];
00003c  78a0              LDRB     r0,[r4,#2]
00003e  f83d0010          LDRH     r0,[sp,r0,LSL #1]
000042  4405              ADD      r5,r5,r0
;;;122        /* Add days in given month. We subtract the current day as it is
;;;123         * represented in the hours, minutes and seconds field*/
;;;124        seconds += (datetime->day - 1);
000044  78e0              LDRB     r0,[r4,#3]
000046  1e40              SUBS     r0,r0,#1
000048  4405              ADD      r5,r5,r0
;;;125        /* For leap year if month less than or equal to Febraury, decrement day counter*/
;;;126        if ((!(datetime->year & 3U)) && (datetime->month <= 2U))
00004a  7820              LDRB     r0,[r4,#0]
00004c  f0000003          AND      r0,r0,#3
000050  b918              CBNZ     r0,|L2.90|
000052  78a0              LDRB     r0,[r4,#2]
000054  2802              CMP      r0,#2
000056  d800              BHI      |L2.90|
;;;127        {
;;;128            seconds--;
000058  1e6d              SUBS     r5,r5,#1
                  |L2.90|
;;;129        }
;;;130    
;;;131        seconds = (seconds * SECONDS_IN_A_DAY) + (datetime->hour * SECONDS_IN_A_HOUR) +
00005a  4813              LDR      r0,|L2.168|
00005c  4368              MULS     r0,r5,r0
00005e  7921              LDRB     r1,[r4,#4]
000060  ebc11241          RSB      r2,r1,r1,LSL #5
000064  ebc22101          RSB      r1,r2,r1,LSL #8
000068  eb001001          ADD      r0,r0,r1,LSL #4
00006c  7961              LDRB     r1,[r4,#5]
00006e  ebc11101          RSB      r1,r1,r1,LSL #4
000072  eb000081          ADD      r0,r0,r1,LSL #2
000076  79a1              LDRB     r1,[r4,#6]
000078  1845              ADDS     r5,r0,r1
;;;132                  (datetime->minute * SECONDS_IN_A_MINUTE) + datetime->second;
;;;133    
;;;134        return seconds;
00007a  4628              MOV      r0,r5
;;;135    }
00007c  b007              ADD      sp,sp,#0x1c
00007e  bd30              POP      {r4,r5,pc}
;;;136    
                          ENDP

                  |L2.128|
000080  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
000084  44726976
000088  6572735c
00008c  66736c5f
000090  7274632e
000094  6300    
000096  00                DCB      0
000097  00                DCB      0
                  |L2.152|
000098  64617465          DCB      "datetime",0
00009c  74696d65
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L2.164|
                          DCD      ||.constdata||
                  |L2.168|
                          DCD      0x00015180

                          AREA ||i.RTC_ConvertSecondsToDatetime||, CODE, READONLY, ALIGN=2

                  RTC_ConvertSecondsToDatetime PROC
;;;136    
;;;137    static void RTC_ConvertSecondsToDatetime(uint32_t seconds, rtc_datetime_t *datetime)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;138    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
;;;139        assert(datetime);
000008  b104              CBZ      r4,|L3.12|
00000a  e004              B        |L3.22|
                  |L3.12|
00000c  228b              MOVS     r2,#0x8b
00000e  a12b              ADR      r1,|L3.188|
000010  a030              ADR      r0,|L3.212|
000012  f7fffffe          BL       __aeabi_assert
                  |L3.22|
;;;140    
;;;141        uint32_t x;
;;;142        uint32_t secondsRemaining, days;
;;;143        uint16_t daysInYear;
;;;144        /* Table of days in a month for a non leap year. First entry in the table is not used,
;;;145         * valid months start from 1
;;;146         */
;;;147        uint8_t daysPerMonth[] = {0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U};
000016  a332              ADR      r3,|L3.224|
000018  cb0f              LDM      r3,{r0-r3}
00001a  e88d000f          STM      sp,{r0-r3}
;;;148    
;;;149        /* Start with the seconds value that is passed in to be converted to date time format */
;;;150        secondsRemaining = seconds;
00001e  4646              MOV      r6,r8
;;;151    
;;;152        /* Calcuate the number of days, we add 1 for the current day which is represented in the
;;;153         * hours and seconds field
;;;154         */
;;;155        days = secondsRemaining / SECONDS_IN_A_DAY + 1;
000020  4833              LDR      r0,|L3.240|
000022  fbb6f0f0          UDIV     r0,r6,r0
000026  1c47              ADDS     r7,r0,#1
;;;156    
;;;157        /* Update seconds left*/
;;;158        secondsRemaining = secondsRemaining % SECONDS_IN_A_DAY;
000028  4831              LDR      r0,|L3.240|
00002a  fbb6f1f0          UDIV     r1,r6,r0
00002e  fb006611          MLS      r6,r0,r1,r6
;;;159    
;;;160        /* Calculate the datetime hour, minute and second fields */
;;;161        datetime->hour = secondsRemaining / SECONDS_IN_A_HOUR;
000032  f44f6061          MOV      r0,#0xe10
000036  fbb6f0f0          UDIV     r0,r6,r0
00003a  7120              STRB     r0,[r4,#4]
;;;162        secondsRemaining = secondsRemaining % SECONDS_IN_A_HOUR;
00003c  f44f6061          MOV      r0,#0xe10
000040  fbb6f1f0          UDIV     r1,r6,r0
000044  fb006611          MLS      r6,r0,r1,r6
;;;163        datetime->minute = secondsRemaining / 60U;
000048  203c              MOVS     r0,#0x3c
00004a  fbb6f0f0          UDIV     r0,r6,r0
00004e  7160              STRB     r0,[r4,#5]
;;;164        datetime->second = secondsRemaining % SECONDS_IN_A_MINUTE;
000050  203c              MOVS     r0,#0x3c
000052  fbb6f1f0          UDIV     r1,r6,r0
000056  fb006011          MLS      r0,r0,r1,r6
00005a  71a0              STRB     r0,[r4,#6]
;;;165    
;;;166        /* Calculate year */
;;;167        daysInYear = DAYS_IN_A_YEAR;
00005c  f240196d          MOV      r9,#0x16d
;;;168        datetime->year = YEAR_RANGE_START;
000060  f24070b2          MOV      r0,#0x7b2
000064  8020              STRH     r0,[r4,#0]
;;;169        while (days > daysInYear)
000066  e00d              B        |L3.132|
                  |L3.104|
;;;170        {
;;;171            /* Decrease day count by a year and increment year by 1 */
;;;172            days -= daysInYear;
000068  eba70709          SUB      r7,r7,r9
;;;173            datetime->year++;
00006c  8820              LDRH     r0,[r4,#0]
00006e  1c40              ADDS     r0,r0,#1
000070  8020              STRH     r0,[r4,#0]
;;;174    
;;;175            /* Adjust the number of days for a leap year */
;;;176            if (datetime->year & 3U)
000072  7820              LDRB     r0,[r4,#0]
000074  f0000003          AND      r0,r0,#3
000078  b110              CBZ      r0,|L3.128|
;;;177            {
;;;178                daysInYear = DAYS_IN_A_YEAR;
00007a  f240196d          MOV      r9,#0x16d
00007e  e001              B        |L3.132|
                  |L3.128|
;;;179            }
;;;180            else
;;;181            {
;;;182                daysInYear = DAYS_IN_A_YEAR + 1;
000080  f44f79b7          MOV      r9,#0x16e
                  |L3.132|
000084  454f              CMP      r7,r9                 ;169
000086  d8ef              BHI      |L3.104|
;;;183            }
;;;184        }
;;;185    
;;;186        /* Adjust the days in February for a leap year */
;;;187        if (!(datetime->year & 3U))
000088  7820              LDRB     r0,[r4,#0]
00008a  f0000003          AND      r0,r0,#3
00008e  b910              CBNZ     r0,|L3.150|
;;;188        {
;;;189            daysPerMonth[2] = 29U;
000090  201d              MOVS     r0,#0x1d
000092  f88d0002          STRB     r0,[sp,#2]
                  |L3.150|
;;;190        }
;;;191    
;;;192        for (x = 1U; x <= 12U; x++)
000096  2501              MOVS     r5,#1
000098  e009              B        |L3.174|
                  |L3.154|
;;;193        {
;;;194            if (days <= daysPerMonth[x])
00009a  f81d0005          LDRB     r0,[sp,r5]
00009e  42b8              CMP      r0,r7
0000a0  d301              BCC      |L3.166|
;;;195            {
;;;196                datetime->month = x;
0000a2  70a5              STRB     r5,[r4,#2]
;;;197                break;
0000a4  e005              B        |L3.178|
                  |L3.166|
;;;198            }
;;;199            else
;;;200            {
;;;201                days -= daysPerMonth[x];
0000a6  f81d0005          LDRB     r0,[sp,r5]
0000aa  1a3f              SUBS     r7,r7,r0
0000ac  1c6d              ADDS     r5,r5,#1              ;192
                  |L3.174|
0000ae  2d0c              CMP      r5,#0xc               ;192
0000b0  d9f3              BLS      |L3.154|
                  |L3.178|
0000b2  bf00              NOP                            ;197
;;;202            }
;;;203        }
;;;204    
;;;205        datetime->day = days;
0000b4  70e7              STRB     r7,[r4,#3]
;;;206    }
0000b6  e8bd87ff          POP      {r0-r10,pc}
;;;207    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L3.188|
0000bc  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
0000c0  44726976
0000c4  6572735c
0000c8  66736c5f
0000cc  7274632e
0000d0  6300    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L3.212|
0000d4  64617465          DCB      "datetime",0
0000d8  74696d65
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
0000e0  00                DCB      0
0000e1  1f1c1f1e          DCB      31,28,31,30,31,30,31,31,30,31,30,31,0
0000e5  1f1e1f1f
0000e9  1e1f1e1f
0000ed  00      
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L3.240|
                          DCD      0x00015180

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;277    
;;;278    void RTC_GetAlarm(RTC_Type *base, rtc_datetime_t *datetime)
000000  b570              PUSH     {r4-r6,lr}
;;;279    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;280        assert(datetime);
000006  b105              CBZ      r5,|L4.10|
000008  e005              B        |L4.22|
                  |L4.10|
00000a  f44f728c          MOV      r2,#0x118
00000e  a105              ADR      r1,|L4.36|
000010  a00a              ADR      r0,|L4.60|
000012  f7fffffe          BL       __aeabi_assert
                  |L4.22|
;;;281    
;;;282        uint32_t alarmSeconds = 0;
000016  2600              MOVS     r6,#0
;;;283    
;;;284        /* Get alarm in seconds  */
;;;285        alarmSeconds = base->MATCH;
000018  6866              LDR      r6,[r4,#4]
;;;286    
;;;287        RTC_ConvertSecondsToDatetime(alarmSeconds, datetime);
00001a  4629              MOV      r1,r5
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       RTC_ConvertSecondsToDatetime
;;;288    }
000022  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L4.36|
000024  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
000028  44726976
00002c  6572735c
000030  66736c5f
000034  7274632e
000038  6300    
00003a  00                DCB      0
00003b  00                DCB      0
                  |L4.60|
00003c  64617465          DCB      "datetime",0
000040  74696d65
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.RTC_GetDatetime||, CODE, READONLY, ALIGN=2

                  RTC_GetDatetime PROC
;;;237    
;;;238    void RTC_GetDatetime(RTC_Type *base, rtc_datetime_t *datetime)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;240        assert(datetime);
000006  b105              CBZ      r5,|L5.10|
000008  e004              B        |L5.20|
                  |L5.10|
00000a  22f0              MOVS     r2,#0xf0
00000c  a105              ADR      r1,|L5.36|
00000e  a00b              ADR      r0,|L5.60|
000010  f7fffffe          BL       __aeabi_assert
                  |L5.20|
;;;241    
;;;242        uint32_t seconds = 0;
000014  2600              MOVS     r6,#0
;;;243    
;;;244        seconds = base->COUNT;
000016  68a6              LDR      r6,[r4,#8]
;;;245        RTC_ConvertSecondsToDatetime(seconds, datetime);
000018  4629              MOV      r1,r5
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       RTC_ConvertSecondsToDatetime
;;;246    }
000020  bd70              POP      {r4-r6,pc}
;;;247    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
000024  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
000028  44726976
00002c  6572735c
000030  66736c5f
000034  7274632e
000038  6300    
00003a  00                DCB      0
00003b  00                DCB      0
                  |L5.60|
00003c  64617465          DCB      "datetime",0
000040  74696d65
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;207    
;;;208    void RTC_Init(RTC_Type *base)
000000  b510              PUSH     {r4,lr}
;;;209    {
;;;210    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;211        /* Enable the RTC peripheral clock */
;;;212        CLOCK_EnableClock(kCLOCK_Rtc);
000002  2117              MOVS     r1,#0x17
000004  0a0a              LSRS     r2,r1,#8
000006  2a03              CMP      r2,#3
000008  d205              BCS      |L6.22|
00000a  2301              MOVS     r3,#1
00000c  408b              LSLS     r3,r3,r1
00000e  4c0a              LDR      r4,|L6.56|
000010  f8443022          STR      r3,[r4,r2,LSL #2]
000014  e005              B        |L6.34|
                  |L6.22|
000016  2301              MOVS     r3,#1
000018  079c              LSLS     r4,r3,#30
00001a  64e3              STR      r3,[r4,#0x4c]
00001c  408b              LSLS     r3,r3,r1
00001e  4c07              LDR      r4,|L6.60|
000020  6163              STR      r3,[r4,#0x14]
                  |L6.34|
000022  bf00              NOP      
;;;213    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;214    
;;;215        /* Make sure the reset bit is cleared */
;;;216        base->CTRL &= ~RTC_CTRL_SWRESET_MASK;
000024  6801              LDR      r1,[r0,#0]
000026  f0210101          BIC      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
;;;217    
;;;218        /* Make sure the RTC OSC is powered up */
;;;219        base->CTRL &= ~RTC_CTRL_RTC_OSC_PD_MASK;
00002c  6801              LDR      r1,[r0,#0]
00002e  f4217180          BIC      r1,r1,#0x100
000032  6001              STR      r1,[r0,#0]
;;;220    }
000034  bd10              POP      {r4,pc}
;;;221    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40000220
                  |L6.60|
                          DCD      0x40040000

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;247    
;;;248    status_t RTC_SetAlarm(RTC_Type *base, const rtc_datetime_t *alarmTime)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;249    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;250        assert(alarmTime);
000008  b105              CBZ      r5,|L7.12|
00000a  e004              B        |L7.22|
                  |L7.12|
00000c  22fa              MOVS     r2,#0xfa
00000e  a10c              ADR      r1,|L7.64|
000010  a011              ADR      r0,|L7.88|
000012  f7fffffe          BL       __aeabi_assert
                  |L7.22|
;;;251    
;;;252        uint32_t alarmSeconds = 0;
000016  2600              MOVS     r6,#0
;;;253        uint32_t currSeconds = 0;
000018  2700              MOVS     r7,#0
;;;254    
;;;255        /* Return error if the alarm time provided is not valid */
;;;256        if (!(RTC_CheckDatetimeFormat(alarmTime)))
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       RTC_CheckDatetimeFormat
000020  b910              CBNZ     r0,|L7.40|
;;;257        {
;;;258            return kStatus_InvalidArgument;
000022  2004              MOVS     r0,#4
                  |L7.36|
;;;259        }
;;;260    
;;;261        alarmSeconds = RTC_ConvertDatetimeToSeconds(alarmTime);
;;;262    
;;;263        /* Get the current time */
;;;264        currSeconds = base->COUNT;
;;;265    
;;;266        /* Return error if the alarm time has passed */
;;;267        if (alarmSeconds < currSeconds)
;;;268        {
;;;269            return kStatus_Fail;
;;;270        }
;;;271    
;;;272        /* Set alarm in seconds*/
;;;273        base->MATCH = alarmSeconds;
;;;274    
;;;275        return kStatus_Success;
;;;276    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L7.40|
000028  4628              MOV      r0,r5                 ;261
00002a  f7fffffe          BL       RTC_ConvertDatetimeToSeconds
00002e  4606              MOV      r6,r0                 ;261
000030  68a7              LDR      r7,[r4,#8]            ;264
000032  42be              CMP      r6,r7                 ;267
000034  d201              BCS      |L7.58|
000036  2001              MOVS     r0,#1                 ;269
000038  e7f4              B        |L7.36|
                  |L7.58|
00003a  6066              STR      r6,[r4,#4]            ;273
00003c  2000              MOVS     r0,#0                 ;275
00003e  e7f1              B        |L7.36|
;;;277    
                          ENDP

                  |L7.64|
000040  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
000044  44726976
000048  6572735c
00004c  66736c5f
000050  7274632e
000054  6300    
000056  00                DCB      0
000057  00                DCB      0
                  |L7.88|
000058  616c6172          DCB      "alarmTime",0
00005c  6d54696d
000060  6500    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.RTC_SetDatetime||, CODE, READONLY, ALIGN=2

                  RTC_SetDatetime PROC
;;;221    
;;;222    status_t RTC_SetDatetime(RTC_Type *base, const rtc_datetime_t *datetime)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;224        assert(datetime);
000006  b104              CBZ      r4,|L8.10|
000008  e004              B        |L8.20|
                  |L8.10|
00000a  22e0              MOVS     r2,#0xe0
00000c  a107              ADR      r1,|L8.44|
00000e  a00d              ADR      r0,|L8.68|
000010  f7fffffe          BL       __aeabi_assert
                  |L8.20|
;;;225    
;;;226        /* Return error if the time provided is not valid */
;;;227        if (!(RTC_CheckDatetimeFormat(datetime)))
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RTC_CheckDatetimeFormat
00001a  b908              CBNZ     r0,|L8.32|
;;;228        {
;;;229            return kStatus_InvalidArgument;
00001c  2004              MOVS     r0,#4
                  |L8.30|
;;;230        }
;;;231    
;;;232        /* Set time in seconds */
;;;233        base->COUNT = RTC_ConvertDatetimeToSeconds(datetime);
;;;234    
;;;235        return kStatus_Success;
;;;236    }
00001e  bd70              POP      {r4-r6,pc}
                  |L8.32|
000020  4620              MOV      r0,r4                 ;233
000022  f7fffffe          BL       RTC_ConvertDatetimeToSeconds
000026  60a8              STR      r0,[r5,#8]            ;233
000028  2000              MOVS     r0,#0                 ;235
00002a  e7f8              B        |L8.30|
;;;237    
                          ENDP

                  |L8.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_rtc.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  7274632e
000040  6300    
000042  00                DCB      0
000043  00                DCB      0
                  |L8.68|
000044  64617465          DCB      "datetime",0
000048  74696d65
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00000000          DCW      0x0000,0x0000
000004  001f003b          DCW      0x001f,0x003b
000008  005a0078          DCW      0x005a,0x0078
00000c  009700b5          DCW      0x0097,0x00b5
000010  00d400f3          DCW      0x00d4,0x00f3
000014  01110130          DCW      0x0111,0x0130
000018  014e              DCW      0x014e

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_rtc_c_RTC_Init____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_rtc_c_RTC_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_rtc_c_RTC_Init____REVSH|
#line 402
|__asm___9_fsl_rtc_c_RTC_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_rtc_c_RTC_Init____RRX|
#line 587
|__asm___9_fsl_rtc_c_RTC_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
