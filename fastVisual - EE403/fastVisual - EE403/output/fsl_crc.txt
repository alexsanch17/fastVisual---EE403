; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_crc.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_crc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_crc.crf SRC\Drivers\fsl_crc.c]
                          THUMB

                          AREA ||i.CRC_GetConfig||, CODE, READONLY, ALIGN=1

                  CRC_GetConfig PROC
;;;90     
;;;91     void CRC_GetConfig(CRC_Type *base, crc_config_t *config)
000000  4602              MOV      r2,r0
;;;92     {
;;;93         /* extract CRC mode settings */
;;;94         uint32_t mode = base->MODE;
000002  6810              LDR      r0,[r2,#0]
;;;95         config->polynomial = (crc_polynomial_t)((mode & CRC_MODE_CRC_POLY_MASK) >> CRC_MODE_CRC_POLY_SHIFT);
000004  f0000303          AND      r3,r0,#3
000008  700b              STRB     r3,[r1,#0]
;;;96         config->reverseIn = (bool)(mode & CRC_MODE_BIT_RVS_WR_MASK);
00000a  f3c00380          UBFX     r3,r0,#2,#1
00000e  704b              STRB     r3,[r1,#1]
;;;97         config->complementIn = (bool)(mode & CRC_MODE_CMPL_WR_MASK);
000010  f3c003c0          UBFX     r3,r0,#3,#1
000014  708b              STRB     r3,[r1,#2]
;;;98         config->reverseOut = (bool)(mode & CRC_MODE_BIT_RVS_SUM_MASK);
000016  f3c01300          UBFX     r3,r0,#4,#1
00001a  70cb              STRB     r3,[r1,#3]
;;;99         config->complementOut = (bool)(mode & CRC_MODE_CMPL_SUM_MASK);
00001c  f3c01340          UBFX     r3,r0,#5,#1
000020  710b              STRB     r3,[r1,#4]
;;;100    
;;;101        /* reset CRC sum bit reverse and 1's complement setting, so its value can be used as a seed */
;;;102        base->MODE = mode & ~((1U << CRC_MODE_BIT_RVS_SUM_SHIFT) | (1U << CRC_MODE_CMPL_SUM_SHIFT));
000022  f0200330          BIC      r3,r0,#0x30
000026  6013              STR      r3,[r2,#0]
;;;103    
;;;104        /* now we can obtain intermediate raw CRC sum value */
;;;105        config->seed = base->SUM;
000028  6893              LDR      r3,[r2,#8]
00002a  608b              STR      r3,[r1,#8]
;;;106    
;;;107        /* restore original CRC sum bit reverse and 1's complement setting */
;;;108        base->MODE = mode;
00002c  6010              STR      r0,[r2,#0]
;;;109    }
00002e  4770              BX       lr
;;;110    
                          ENDP


                          AREA ||i.CRC_GetDefaultConfig||, CODE, READONLY, ALIGN=2

                  CRC_GetDefaultConfig PROC
;;;69     
;;;70     void CRC_GetDefaultConfig(crc_config_t *config)
000000  4b02              LDR      r3,|L2.12|
;;;71     {
;;;72         static const crc_config_t default_config = {CRC_DRIVER_DEFAULT_POLYNOMIAL,     CRC_DRIVER_DEFAULT_REVERSE_IN,
;;;73                                                     CRC_DRIVER_DEFAULT_COMPLEMENT_IN,  CRC_DRIVER_DEFAULT_REVERSE_OUT,
;;;74                                                     CRC_DRIVER_DEFAULT_COMPLEMENT_OUT, CRC_DRIVER_DEFAULT_SEED};
;;;75     
;;;76         *config = default_config;
000002  cb0e              LDM      r3,{r1-r3}
000004  e880000e          STM      r0,{r1-r3}
;;;77     }
000008  4770              BX       lr
;;;78     
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      default_config

                          AREA ||i.CRC_Init||, CODE, READONLY, ALIGN=2

                  CRC_Init PROC
;;;55     
;;;56     void CRC_Init(CRC_Type *base, const crc_config_t *config)
000000  b530              PUSH     {r4,r5,lr}
;;;57     {
000002  4602              MOV      r2,r0
;;;58     #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;59         /* enable clock to CRC */
;;;60         CLOCK_EnableClock(kCLOCK_Crc);
000004  2015              MOVS     r0,#0x15
000006  0a03              LSRS     r3,r0,#8
000008  2b03              CMP      r3,#3
00000a  d205              BCS      |L3.24|
00000c  2401              MOVS     r4,#1
00000e  4084              LSLS     r4,r4,r0
000010  4d12              LDR      r5,|L3.92|
000012  f8454023          STR      r4,[r5,r3,LSL #2]
000016  e005              B        |L3.36|
                  |L3.24|
000018  2401              MOVS     r4,#1
00001a  07a5              LSLS     r5,r4,#30
00001c  64ec              STR      r4,[r5,#0x4c]
00001e  4084              LSLS     r4,r4,r0
000020  4d0f              LDR      r5,|L3.96|
000022  616c              STR      r4,[r5,#0x14]
                  |L3.36|
000024  bf00              NOP      
;;;61     #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;62     
;;;63         /* configure CRC module and write the seed */
;;;64         base->MODE = 0 | CRC_MODE_CRC_POLY(config->polynomial) | CRC_MODE_BIT_RVS_WR(config->reverseIn) |
000026  7808              LDRB     r0,[r1,#0]
000028  f0000003          AND      r0,r0,#3
00002c  784b              LDRB     r3,[r1,#1]
00002e  2404              MOVS     r4,#4
000030  ea040383          AND      r3,r4,r3,LSL #2
000034  4318              ORRS     r0,r0,r3
000036  788b              LDRB     r3,[r1,#2]
000038  2408              MOVS     r4,#8
00003a  ea0403c3          AND      r3,r4,r3,LSL #3
00003e  4318              ORRS     r0,r0,r3
000040  78cb              LDRB     r3,[r1,#3]
000042  2410              MOVS     r4,#0x10
000044  ea041303          AND      r3,r4,r3,LSL #4
000048  4318              ORRS     r0,r0,r3
00004a  790b              LDRB     r3,[r1,#4]
00004c  2420              MOVS     r4,#0x20
00004e  ea041343          AND      r3,r4,r3,LSL #5
000052  4318              ORRS     r0,r0,r3
000054  6010              STR      r0,[r2,#0]
;;;65                      CRC_MODE_CMPL_WR(config->complementIn) | CRC_MODE_BIT_RVS_SUM(config->reverseOut) |
;;;66                      CRC_MODE_CMPL_SUM(config->complementOut);
;;;67         base->SEED = config->seed;
000056  6888              LDR      r0,[r1,#8]
000058  6050              STR      r0,[r2,#4]
;;;68     }
00005a  bd30              POP      {r4,r5,pc}
;;;69     
                          ENDP

                  |L3.92|
                          DCD      0x40000220
                  |L3.96|
                          DCD      0x40040000

                          AREA ||i.CRC_Reset||, CODE, READONLY, ALIGN=1

                  CRC_Reset PROC
;;;78     
;;;79     void CRC_Reset(CRC_Type *base)
000000  b51e              PUSH     {r1-r4,lr}
;;;80     {
000002  4604              MOV      r4,r0
;;;81         /* TODO - HW reset currently not exposed in API and they don't want
;;;82          * dependencies to other modules anyway, so use SW reset temporarily. */
;;;83     
;;;84         /* SYSCON_PeriphReset(RESET_CRC); */
;;;85     
;;;86         crc_config_t config;
;;;87         CRC_GetDefaultConfig(&config);
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       CRC_GetDefaultConfig
;;;88         CRC_Init(base, &config);
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       CRC_Init
;;;89     }
000012  bd1e              POP      {r1-r4,pc}
;;;90     
                          ENDP


                          AREA ||i.CRC_WriteData||, CODE, READONLY, ALIGN=1

                  CRC_WriteData PROC
;;;110    
;;;111    void CRC_WriteData(CRC_Type *base, const uint8_t *data, size_t dataSize)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113        const uint32_t *data32;
;;;114    
;;;115        /* 8-bit reads and writes till source address is aligned 4 bytes */
;;;116        while ((dataSize) && ((uint32_t)data & 3U))
000002  e003              B        |L5.12|
                  |L5.4|
;;;117        {
;;;118            *((__O uint8_t *)&(base->WR_DATA)) = *data;
000004  780c              LDRB     r4,[r1,#0]
000006  7204              STRB     r4,[r0,#8]
;;;119            data++;
000008  1c49              ADDS     r1,r1,#1
;;;120            dataSize--;
00000a  1e52              SUBS     r2,r2,#1
                  |L5.12|
00000c  b11a              CBZ      r2,|L5.22|
00000e  f0010403          AND      r4,r1,#3              ;116
000012  2c00              CMP      r4,#0                 ;116
000014  d1f6              BNE      |L5.4|
                  |L5.22|
;;;121        }
;;;122    
;;;123        /* use 32-bit reads and writes as long as possible */
;;;124        data32 = (const uint32_t *)data;
000016  460b              MOV      r3,r1
;;;125        while (dataSize >= sizeof(uint32_t))
000018  e003              B        |L5.34|
                  |L5.26|
;;;126        {
;;;127            base->WR_DATA = *data32;
00001a  681c              LDR      r4,[r3,#0]
00001c  6084              STR      r4,[r0,#8]
;;;128            data32++;
00001e  1d1b              ADDS     r3,r3,#4
;;;129            dataSize -= sizeof(uint32_t);
000020  1f12              SUBS     r2,r2,#4
                  |L5.34|
000022  2a04              CMP      r2,#4                 ;125
000024  d2f9              BCS      |L5.26|
;;;130        }
;;;131    
;;;132        data = (const uint8_t *)data32;
000026  4619              MOV      r1,r3
;;;133    
;;;134        /* 8-bit reads and writes till end of data buffer */
;;;135        while (dataSize)
000028  e003              B        |L5.50|
                  |L5.42|
;;;136        {
;;;137            *((__O uint8_t *)&(base->WR_DATA)) = *data;
00002a  780c              LDRB     r4,[r1,#0]
00002c  7204              STRB     r4,[r0,#8]
;;;138            data++;
00002e  1c49              ADDS     r1,r1,#1
;;;139            dataSize--;
000030  1e52              SUBS     r2,r2,#1
                  |L5.50|
000032  2a00              CMP      r2,#0                 ;135
000034  d1f9              BNE      |L5.42|
;;;140        }
;;;141    }
000036  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  default_config
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000ffff

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_crc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_crc_c_CRC_Init____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_crc_c_CRC_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_crc_c_CRC_Init____REVSH|
#line 402
|__asm___9_fsl_crc_c_CRC_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_crc_c_CRC_Init____RRX|
#line 587
|__asm___9_fsl_crc_c_CRC_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
