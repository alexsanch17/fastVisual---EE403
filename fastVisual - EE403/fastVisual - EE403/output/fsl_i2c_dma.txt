; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_i2c_dma.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_i2c_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_i2c_dma.crf SRC\Drivers\fsl_i2c_dma.c]
                          THUMB

                          AREA ||i.I2C_DisableInterrupts||, CODE, READONLY, ALIGN=1

                  I2C_DisableInterrupts PROC
;;;527     */
;;;528    static inline void I2C_DisableInterrupts(I2C_Type *base, uint32_t interruptMask)
000000  f8c0180c          STR      r1,[r0,#0x80c]
;;;529    {
;;;530        base->INTENCLR = interruptMask;
;;;531    }
000004  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.I2C_InitTransferStateMachineDMA||, CODE, READONLY, ALIGN=1

                  I2C_InitTransferStateMachineDMA PROC
;;;94      */
;;;95     static status_t I2C_InitTransferStateMachineDMA(I2C_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96                                                     i2c_master_dma_handle_t *handle,
;;;97                                                     i2c_master_transfer_t *xfer)
;;;98     {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;99         struct _i2c_master_transfer *transfer;
;;;100    
;;;101        handle->transfer = *xfer;
00000a  2218              MOVS     r2,#0x18
00000c  4629              MOV      r1,r5
00000e  f104001c          ADD      r0,r4,#0x1c
000012  f7fffffe          BL       __aeabi_memcpy4
;;;102        transfer = &(handle->transfer);
000016  f104061c          ADD      r6,r4,#0x1c
;;;103    
;;;104        handle->transferCount = 0;
00001a  2000              MOVS     r0,#0
00001c  6060              STR      r0,[r4,#4]
;;;105        handle->remainingBytesDMA = 0;
00001e  60a0              STR      r0,[r4,#8]
;;;106        handle->buf = (uint8_t *)transfer->data;
000020  6930              LDR      r0,[r6,#0x10]
000022  60e0              STR      r0,[r4,#0xc]
;;;107        handle->remainingSubaddr = 0;
000024  2000              MOVS     r0,#0
000026  6120              STR      r0,[r4,#0x10]
;;;108    
;;;109        if (transfer->flags & kI2C_TransferNoStartFlag)
000028  7830              LDRB     r0,[r6,#0]
00002a  f0000001          AND      r0,r0,#1
00002e  b1d8              CBZ      r0,|L2.104|
;;;110        {
;;;111            /* Start condition shall be ommited, switch directly to next phase */
;;;112            if (transfer->dataSize == 0)
000030  6970              LDR      r0,[r6,#0x14]
000032  b910              CBNZ     r0,|L2.58|
;;;113            {
;;;114                handle->state = kStopState;
000034  2006              MOVS     r0,#6
000036  7020              STRB     r0,[r4,#0]
000038  e02e              B        |L2.152|
                  |L2.58|
;;;115            }
;;;116            else if (handle->transfer.direction == kI2C_Write)
00003a  2022              MOVS     r0,#0x22
00003c  5d00              LDRB     r0,[r0,r4]
00003e  b918              CBNZ     r0,|L2.72|
;;;117            {
;;;118                handle->state = xfer->dataSize = kTransmitDataState;
000040  2002              MOVS     r0,#2
000042  6168              STR      r0,[r5,#0x14]
000044  7020              STRB     r0,[r4,#0]
000046  e027              B        |L2.152|
                  |L2.72|
;;;119            }
;;;120            else if (handle->transfer.direction == kI2C_Read)
000048  2022              MOVS     r0,#0x22
00004a  5d00              LDRB     r0,[r0,r4]
00004c  2801              CMP      r0,#1
00004e  d107              BNE      |L2.96|
;;;121            {
;;;122                handle->state = (xfer->dataSize == 1) ? kReceiveLastDataState : kReceiveDataState;
000050  6968              LDR      r0,[r5,#0x14]
000052  2801              CMP      r0,#1
000054  d101              BNE      |L2.90|
000056  2004              MOVS     r0,#4
000058  e000              B        |L2.92|
                  |L2.90|
00005a  2003              MOVS     r0,#3
                  |L2.92|
00005c  7020              STRB     r0,[r4,#0]
00005e  e01b              B        |L2.152|
                  |L2.96|
;;;123            }
;;;124            else
;;;125            {
;;;126                return kStatus_I2C_InvalidParameter;
000060  f640202b          MOV      r0,#0xa2b
                  |L2.100|
;;;127            }
;;;128        }
;;;129        else
;;;130        {
;;;131            if (transfer->subaddressSize != 0)
;;;132            {
;;;133                int i;
;;;134                uint32_t subaddress;
;;;135    
;;;136                if (transfer->subaddressSize > sizeof(handle->subaddrBuf))
;;;137                {
;;;138                    return kStatus_I2C_InvalidParameter;
;;;139                }
;;;140    
;;;141                /* Prepare subaddress transmit buffer, most significant byte is stored at the lowest address */
;;;142                subaddress = xfer->subaddress;
;;;143                for (i = xfer->subaddressSize - 1; i >= 0; i--)
;;;144                {
;;;145                    handle->subaddrBuf[i] = subaddress & 0xff;
;;;146                    subaddress >>= 8;
;;;147                }
;;;148                handle->remainingSubaddr = transfer->subaddressSize;
;;;149            }
;;;150    
;;;151            handle->state = kStartState;
;;;152        }
;;;153    
;;;154        return kStatus_Success;
;;;155    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L2.104|
000068  68f0              LDR      r0,[r6,#0xc]          ;131
00006a  b198              CBZ      r0,|L2.148|
00006c  68f0              LDR      r0,[r6,#0xc]          ;136
00006e  2804              CMP      r0,#4                 ;136
000070  d902              BLS      |L2.120|
000072  f640202b          MOV      r0,#0xa2b             ;138
000076  e7f5              B        |L2.100|
                  |L2.120|
000078  68aa              LDR      r2,[r5,#8]            ;142
00007a  68e8              LDR      r0,[r5,#0xc]          ;143
00007c  1e41              SUBS     r1,r0,#1              ;143
00007e  e004              B        |L2.138|
                  |L2.128|
000080  f1040014          ADD      r0,r4,#0x14           ;145
000084  5442              STRB     r2,[r0,r1]            ;145
000086  0a12              LSRS     r2,r2,#8              ;146
000088  1e49              SUBS     r1,r1,#1              ;143
                  |L2.138|
00008a  2900              CMP      r1,#0                 ;143
00008c  daf8              BGE      |L2.128|
00008e  68f0              LDR      r0,[r6,#0xc]          ;148
000090  6120              STR      r0,[r4,#0x10]         ;148
000092  bf00              NOP                            ;149
                  |L2.148|
000094  2005              MOVS     r0,#5                 ;151
000096  7020              STRB     r0,[r4,#0]            ;151
                  |L2.152|
000098  2000              MOVS     r0,#0                 ;154
00009a  e7e3              B        |L2.100|
;;;156    
                          ENDP


                          AREA ||i.I2C_MasterClearStatusFlags||, CODE, READONLY, ALIGN=1

                  I2C_MasterClearStatusFlags PROC
;;;497     */
;;;498    static inline void I2C_MasterClearStatusFlags(I2C_Type *base, uint32_t statusMask)
000000  f0010250          AND      r2,r1,#0x50
;;;499    {
;;;500        /* Allow clearing just master status flags */
;;;501        base->STAT = statusMask & (I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
000004  f8c02804          STR      r2,[r0,#0x804]
;;;502    }
000008  4770              BX       lr
;;;503    
                          ENDP


                          AREA ||i.I2C_MasterTransferAbortDMA||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransferAbortDMA PROC
;;;532    
;;;533    void I2C_MasterTransferAbortDMA(I2C_Type *base, i2c_master_dma_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;534    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;535        uint32_t status;
;;;536        uint32_t master_state;
;;;537    
;;;538        if (handle->state != kIdleState)
000008  7830              LDRB     r0,[r6,#0]
00000a  b358              CBZ      r0,|L4.100|
;;;539        {
;;;540            DMA_AbortTransfer(handle->dmaHandle);
00000c  69b0              LDR      r0,[r6,#0x18]
00000e  f7fffffe          BL       DMA_AbortTransfer
;;;541    
;;;542            /* Disable DMA */
;;;543            base->MSTCTL = 0;
000012  2000              MOVS     r0,#0
000014  f8c40820          STR      r0,[r4,#0x820]
;;;544    
;;;545            /* Disable internal IRQ enables. */
;;;546            I2C_DisableInterrupts(base,
000018  2151              MOVS     r1,#0x51
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       I2C_DisableInterrupts
;;;547                                  I2C_INTSTAT_MSTPENDING_MASK | I2C_INTSTAT_MSTARBLOSS_MASK | I2C_INTSTAT_MSTSTSTPERR_MASK);
;;;548    
;;;549            /* Wait until module is ready */
;;;550            do
000020  bf00              NOP      
                  |L4.34|
;;;551            {
;;;552                status = I2C_GetStatusFlags(base);
000022  bf00              NOP      
000024  f8d45804          LDR      r5,[r4,#0x804]
000028  bf00              NOP      
;;;553            } while ((status & I2C_STAT_MSTPENDING_MASK) == 0);
00002a  f0050001          AND      r0,r5,#1
00002e  2800              CMP      r0,#0
000030  d0f7              BEQ      |L4.34|
;;;554    
;;;555            /* Clear controller state. */
;;;556            I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
000032  2150              MOVS     r1,#0x50
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_MasterClearStatusFlags
;;;557    
;;;558            /* Get the state of the I2C module */
;;;559            master_state = (status & I2C_STAT_MSTSTATE_MASK) >> I2C_STAT_MSTSTATE_SHIFT;
00003a  f3c50742          UBFX     r7,r5,#1,#3
;;;560    
;;;561            if (master_state != I2C_STAT_MSTCODE_IDLE)
00003e  b17f              CBZ      r7,|L4.96|
;;;562            {
;;;563                /* Send a stop command to finalize the transfer. */
;;;564                base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
000040  2004              MOVS     r0,#4
000042  f8c40820          STR      r0,[r4,#0x820]
;;;565    
;;;566                /* Wait until module is ready */
;;;567                do
000046  bf00              NOP      
                  |L4.72|
;;;568                {
;;;569                    status = I2C_GetStatusFlags(base);
000048  bf00              NOP      
00004a  f8d40804          LDR      r0,[r4,#0x804]
00004e  4605              MOV      r5,r0
;;;570                } while ((status & I2C_STAT_MSTPENDING_MASK) == 0);
000050  f0050001          AND      r0,r5,#1
000054  2800              CMP      r0,#0
000056  d0f7              BEQ      |L4.72|
;;;571    
;;;572                /* Clear controller state. */
;;;573                I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
000058  2150              MOVS     r1,#0x50
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       I2C_MasterClearStatusFlags
                  |L4.96|
;;;574            }
;;;575    
;;;576            /* Reset the state to idle. */
;;;577            handle->state = kIdleState;
000060  2000              MOVS     r0,#0
000062  7030              STRB     r0,[r6,#0]
                  |L4.100|
;;;578        }
;;;579    }
000064  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.I2C_MasterTransferCallbackDMA||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransferCallbackDMA PROC
;;;433    
;;;434    static void I2C_MasterTransferCallbackDMA(dma_handle_t *handle, void *userData)
000000  b570              PUSH     {r4-r6,lr}
;;;435    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;436        i2c_master_dma_private_handle_t *dmaPrivateHandle;
;;;437    
;;;438        /* Don't do anything if we don't have a valid handle. */
;;;439        if (!handle)
000006  b906              CBNZ     r6,|L5.10|
                  |L5.8|
;;;440        {
;;;441            return;
;;;442        }
;;;443    
;;;444        dmaPrivateHandle = (i2c_master_dma_private_handle_t *)userData;
;;;445        I2C_RunDMATransfer(dmaPrivateHandle->base, dmaPrivateHandle->handle);
;;;446    }
000008  bd70              POP      {r4-r6,pc}
                  |L5.10|
00000a  4625              MOV      r5,r4                 ;444
00000c  e9d50100          LDRD     r0,r1,[r5,#0]         ;445
000010  f7fffffe          BL       I2C_RunDMATransfer
000014  bf00              NOP      
000016  e7f7              B        |L5.8|
;;;447    
                          ENDP


                          AREA ||i.I2C_MasterTransferCreateHandleDMA||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferCreateHandleDMA PROC
;;;447    
;;;448    void I2C_MasterTransferCreateHandleDMA(I2C_Type *base,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;449                                           i2c_master_dma_handle_t *handle,
;;;450                                           i2c_master_dma_transfer_callback_t callback,
;;;451                                           void *userData,
;;;452                                           dma_handle_t *dmaHandle)
;;;453    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;454        uint32_t instance;
;;;455    
;;;456        assert(handle);
00000e  b104              CBZ      r4,|L6.18|
000010  e005              B        |L6.30|
                  |L6.18|
000012  f44f72e4          MOV      r2,#0x1c8
000016  a122              ADR      r1,|L6.160|
000018  a028              ADR      r0,|L6.188|
00001a  f7fffffe          BL       __aeabi_assert
                  |L6.30|
;;;457        assert(dmaHandle);
00001e  b106              CBZ      r6,|L6.34|
000020  e005              B        |L6.46|
                  |L6.34|
000022  f24012c9          MOV      r2,#0x1c9
000026  a11e              ADR      r1,|L6.160|
000028  a026              ADR      r0,|L6.196|
00002a  f7fffffe          BL       __aeabi_assert
                  |L6.46|
;;;458    
;;;459        /* Zero handle. */
;;;460        memset(handle, 0, sizeof(*handle));
00002e  213c              MOVS     r1,#0x3c
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       __aeabi_memclr4
;;;461    
;;;462        /* Look up instance number */
;;;463        instance = I2C_GetInstance(base);
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       I2C_GetInstance
00003c  4605              MOV      r5,r0
;;;464    
;;;465        /* Set the user callback and userData. */
;;;466        handle->completionCallback = callback;
00003e  f8c48034          STR      r8,[r4,#0x34]
;;;467        handle->userData = userData;
000042  f8c49038          STR      r9,[r4,#0x38]
;;;468    
;;;469        FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)I2C_MasterTransferDMAHandleIRQ, handle);
000046  4622              MOV      r2,r4
000048  4921              LDR      r1,|L6.208|
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       FLEXCOMM_SetIRQHandler
;;;470    
;;;471        /* Clear internal IRQ enables and enable NVIC IRQ. */
;;;472        I2C_DisableInterrupts(base,
000050  2151              MOVS     r1,#0x51
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       I2C_DisableInterrupts
;;;473                              I2C_INTSTAT_MSTPENDING_MASK | I2C_INTSTAT_MSTARBLOSS_MASK | I2C_INTSTAT_MSTSTSTPERR_MASK);
;;;474        EnableIRQ(s_i2cIRQ[instance]);
000058  491e              LDR      r1,|L6.212|
00005a  5748              LDRSB    r0,[r1,r5]
00005c  f1100f80          CMN      r0,#0x80
000060  d100              BNE      |L6.100|
000062  e00c              B        |L6.126|
                  |L6.100|
000064  bf00              NOP      
000066  f000021f          AND      r2,r0,#0x1f
00006a  2101              MOVS     r1,#1
00006c  4091              LSLS     r1,r1,r2
00006e  0942              LSRS     r2,r0,#5
000070  0092              LSLS     r2,r2,#2
000072  f10222e0          ADD      r2,r2,#0xe000e000
000076  f8c21100          STR      r1,[r2,#0x100]
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L6.126|
;;;475    
;;;476        /* Set the handle for DMA. */
;;;477        handle->dmaHandle = dmaHandle;
00007e  61a6              STR      r6,[r4,#0x18]
;;;478    
;;;479        s_dmaPrivateHandle[instance].base = base;
000080  4815              LDR      r0,|L6.216|
000082  f8407035          STR      r7,[r0,r5,LSL #3]
;;;480        s_dmaPrivateHandle[instance].handle = handle;
000086  eb0000c5          ADD      r0,r0,r5,LSL #3
00008a  6044              STR      r4,[r0,#4]
;;;481    
;;;482        DMA_SetCallback(dmaHandle, (dma_callback)(uintptr_t)I2C_MasterTransferCallbackDMA, &s_dmaPrivateHandle[instance]);
00008c  4812              LDR      r0,|L6.216|
00008e  eb0002c5          ADD      r2,r0,r5,LSL #3
000092  4912              LDR      r1,|L6.220|
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       DMA_SetCallback
;;;483    }
00009a  e8bd87f0          POP      {r4-r10,pc}
;;;484    
                          ENDP

00009e  0000              DCW      0x0000
                  |L6.160|
0000a0  5352435c          DCB      "SRC\\Drivers\\fsl_i2c_dma.c",0
0000a4  44726976
0000a8  6572735c
0000ac  66736c5f
0000b0  6932635f
0000b4  646d612e
0000b8  6300    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L6.188|
0000bc  68616e64          DCB      "handle",0
0000c0  6c6500  
0000c3  00                DCB      0
                  |L6.196|
0000c4  646d6148          DCB      "dmaHandle",0
0000c8  616e646c
0000cc  6500    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L6.208|
                          DCD      I2C_MasterTransferDMAHandleIRQ
                  |L6.212|
                          DCD      s_i2cIRQ
                  |L6.216|
                          DCD      s_dmaPrivateHandle
                  |L6.220|
                          DCD      I2C_MasterTransferCallbackDMA

                          AREA ||i.I2C_MasterTransferDMA||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferDMA PROC
;;;484    
;;;485    status_t I2C_MasterTransferDMA(I2C_Type *base, i2c_master_dma_handle_t *handle, i2c_master_transfer_t *xfer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;486    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;487        status_t result;
;;;488    
;;;489        assert(handle);
00000a  b104              CBZ      r4,|L7.14|
00000c  e005              B        |L7.26|
                  |L7.14|
00000e  f24012e9          MOV      r2,#0x1e9
000012  a116              ADR      r1,|L7.108|
000014  a01c              ADR      r0,|L7.136|
000016  f7fffffe          BL       __aeabi_assert
                  |L7.26|
;;;490        assert(xfer);
00001a  b105              CBZ      r5,|L7.30|
00001c  e005              B        |L7.42|
                  |L7.30|
00001e  f44f72f5          MOV      r2,#0x1ea
000022  a112              ADR      r1,|L7.108|
000024  a01a              ADR      r0,|L7.144|
000026  f7fffffe          BL       __aeabi_assert
                  |L7.42|
;;;491        assert(xfer->subaddressSize <= sizeof(xfer->subaddress));
00002a  68e8              LDR      r0,[r5,#0xc]
00002c  2804              CMP      r0,#4
00002e  d800              BHI      |L7.50|
000030  e005              B        |L7.62|
                  |L7.50|
000032  f24012eb          MOV      r2,#0x1eb
000036  a10d              ADR      r1,|L7.108|
000038  a017              ADR      r0,|L7.152|
00003a  f7fffffe          BL       __aeabi_assert
                  |L7.62|
;;;492    
;;;493        /* Return busy if another transaction is in progress. */
;;;494        if (handle->state != kIdleState)
00003e  7820              LDRB     r0,[r4,#0]
000040  b118              CBZ      r0,|L7.74|
;;;495        {
;;;496            return kStatus_I2C_Busy;
000042  f6402028          MOV      r0,#0xa28
                  |L7.70|
;;;497        }
;;;498    
;;;499        /* Prepare transfer state machine. */
;;;500        result = I2C_InitTransferStateMachineDMA(base, handle, xfer);
;;;501    
;;;502        /* Clear error flags. */
;;;503        I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
;;;504    
;;;505        /* Enable I2C internal IRQ sources */
;;;506        I2C_EnableInterrupts(base,
;;;507                             I2C_INTSTAT_MSTARBLOSS_MASK | I2C_INTSTAT_MSTSTSTPERR_MASK | I2C_INTSTAT_MSTPENDING_MASK);
;;;508    
;;;509        return result;
;;;510    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L7.74|
00004a  462a              MOV      r2,r5                 ;500
00004c  4621              MOV      r1,r4                 ;500
00004e  4630              MOV      r0,r6                 ;500
000050  f7fffffe          BL       I2C_InitTransferStateMachineDMA
000054  4607              MOV      r7,r0                 ;500
000056  2150              MOVS     r1,#0x50              ;503
000058  4630              MOV      r0,r6                 ;503
00005a  f7fffffe          BL       I2C_MasterClearStatusFlags
00005e  2051              MOVS     r0,#0x51              ;506
000060  f8c60808          STR      r0,[r6,#0x808]        ;506
000064  bf00              NOP                            ;506
000066  4638              MOV      r0,r7                 ;509
000068  e7ed              B        |L7.70|
;;;511    
                          ENDP

00006a  0000              DCW      0x0000
                  |L7.108|
00006c  5352435c          DCB      "SRC\\Drivers\\fsl_i2c_dma.c",0
000070  44726976
000074  6572735c
000078  66736c5f
00007c  6932635f
000080  646d612e
000084  6300    
000086  00                DCB      0
000087  00                DCB      0
                  |L7.136|
000088  68616e64          DCB      "handle",0
00008c  6c6500  
00008f  00                DCB      0
                  |L7.144|
000090  78666572          DCB      "xfer",0
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L7.152|
000098  78666572          DCB      "xfer->subaddressSize <= sizeof(xfer->subaddress)",0
00009c  2d3e7375
0000a0  62616464
0000a4  72657373
0000a8  53697a65
0000ac  203c3d20
0000b0  73697a65
0000b4  6f662878
0000b8  6665722d
0000bc  3e737562
0000c0  61646472
0000c4  65737329
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.I2C_MasterTransferDMAHandleIRQ||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransferDMAHandleIRQ PROC
;;;406    
;;;407    void I2C_MasterTransferDMAHandleIRQ(I2C_Type *base, i2c_master_dma_handle_t *handle)
000000  b5f8              PUSH     {r3-r7,lr}
;;;408    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;409        bool isDone;
;;;410        status_t result;
;;;411    
;;;412        /* Don't do anything if we don't have a valid handle. */
;;;413        if (!handle)
000006  b904              CBNZ     r4,|L8.10|
                  |L8.8|
;;;414        {
;;;415            return;
;;;416        }
;;;417    
;;;418        result = I2C_RunTransferStateMachineDMA(base, handle, &isDone);
;;;419    
;;;420        if (isDone || (result != kStatus_Success))
;;;421        {
;;;422            /* Disable internal IRQ enables. */
;;;423            I2C_DisableInterrupts(base,
;;;424                                  I2C_INTSTAT_MSTPENDING_MASK | I2C_INTSTAT_MSTARBLOSS_MASK | I2C_INTSTAT_MSTSTSTPERR_MASK);
;;;425    
;;;426            /* Invoke callback. */
;;;427            if (handle->completionCallback)
;;;428            {
;;;429                handle->completionCallback(base, handle, result, handle->userData);
;;;430            }
;;;431        }
;;;432    }
000008  bdf8              POP      {r3-r7,pc}
                  |L8.10|
00000a  466a              MOV      r2,sp                 ;418
00000c  4621              MOV      r1,r4                 ;418
00000e  4630              MOV      r0,r6                 ;418
000010  f7fffffe          BL       I2C_RunTransferStateMachineDMA
000014  4605              MOV      r5,r0                 ;418
000016  f89d0000          LDRB     r0,[sp,#0]            ;420
00001a  b900              CBNZ     r0,|L8.30|
00001c  b15d              CBZ      r5,|L8.54|
                  |L8.30|
00001e  2151              MOVS     r1,#0x51              ;423
000020  4630              MOV      r0,r6                 ;423
000022  f7fffffe          BL       I2C_DisableInterrupts
000026  6b60              LDR      r0,[r4,#0x34]         ;427
000028  b128              CBZ      r0,|L8.54|
00002a  462a              MOV      r2,r5                 ;429
00002c  4621              MOV      r1,r4                 ;429
00002e  4630              MOV      r0,r6                 ;429
000030  e9d4730d          LDRD     r7,r3,[r4,#0x34]      ;429
000034  47b8              BLX      r7                    ;429
                  |L8.54|
000036  bf00              NOP      
000038  e7e6              B        |L8.8|
;;;433    
                          ENDP


                          AREA ||i.I2C_MasterTransferGetCountDMA||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferGetCountDMA PROC
;;;511    
;;;512    status_t I2C_MasterTransferGetCountDMA(I2C_Type *base, i2c_master_dma_handle_t *handle, size_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;514        assert(handle);
000008  b104              CBZ      r4,|L9.12|
00000a  e005              B        |L9.24|
                  |L9.12|
00000c  f2402202          MOV      r2,#0x202
000010  a108              ADR      r1,|L9.52|
000012  a00f              ADR      r0,|L9.80|
000014  f7fffffe          BL       __aeabi_assert
                  |L9.24|
;;;515    
;;;516        if (!count)
000018  b90d              CBNZ     r5,|L9.30|
;;;517        {
;;;518            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L9.28|
;;;519        }
;;;520    
;;;521        /* Catch when there is not an active transfer. */
;;;522        if (handle->state == kIdleState)
;;;523        {
;;;524            *count = 0;
;;;525            return kStatus_NoTransferInProgress;
;;;526        }
;;;527    
;;;528        /* There is no necessity to disable interrupts as we read a single integer value */
;;;529        *count = handle->transferCount;
;;;530        return kStatus_Success;
;;;531    }
00001c  bd70              POP      {r4-r6,pc}
                  |L9.30|
00001e  7820              LDRB     r0,[r4,#0]            ;522
000020  b918              CBNZ     r0,|L9.42|
000022  2000              MOVS     r0,#0                 ;524
000024  6028              STR      r0,[r5,#0]            ;524
000026  2006              MOVS     r0,#6                 ;525
000028  e7f8              B        |L9.28|
                  |L9.42|
00002a  6860              LDR      r0,[r4,#4]            ;529
00002c  6028              STR      r0,[r5,#0]            ;529
00002e  2000              MOVS     r0,#0                 ;530
000030  e7f4              B        |L9.28|
;;;532    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_i2c_dma.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  6932635f
000048  646d612e
00004c  6300    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L9.80|
000050  68616e64          DCB      "handle",0
000054  6c6500  
000057  00                DCB      0

                          AREA ||i.I2C_RunDMATransfer||, CODE, READONLY, ALIGN=2

                  I2C_RunDMATransfer PROC
;;;156    
;;;157    static void I2C_RunDMATransfer(I2C_Type *base, i2c_master_dma_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;158    {
000002  b08a              SUB      sp,sp,#0x28
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;159        int transfer_size;
;;;160        dma_transfer_config_t xferConfig;
;;;161    
;;;162        /* Update transfer count */
;;;163        handle->transferCount = handle->buf - (uint8_t *)handle->transfer.data;
000008  68e1              LDR      r1,[r4,#0xc]
00000a  6ae0              LDR      r0,[r4,#0x2c]
00000c  1a08              SUBS     r0,r1,r0
00000e  6060              STR      r0,[r4,#4]
;;;164    
;;;165        /* Check if there is anything to be transferred at all */
;;;166        if (handle->remainingBytesDMA == 0)
000010  68a0              LDR      r0,[r4,#8]
000012  b920              CBNZ     r0,|L10.30|
;;;167        {
;;;168            /* No data to be transferrred, disable DMA */
;;;169            base->MSTCTL = 0;
000014  2000              MOVS     r0,#0
000016  f8c60820          STR      r0,[r6,#0x820]
                  |L10.26|
;;;170            return;
;;;171        }
;;;172    
;;;173        /* Calculate transfer size */
;;;174        transfer_size = handle->remainingBytesDMA;
;;;175        if (transfer_size > I2C_MAX_DMA_TRANSFER_COUNT)
;;;176        {
;;;177            transfer_size = I2C_MAX_DMA_TRANSFER_COUNT;
;;;178        }
;;;179    
;;;180        switch (handle->transfer.direction)
;;;181        {
;;;182            case kI2C_Write:
;;;183                DMA_PrepareTransfer(&xferConfig, handle->buf, (void *)&base->MSTDAT, sizeof(uint8_t), transfer_size,
;;;184                                    kDMA_MemoryToPeripheral, NULL);
;;;185                break;
;;;186    
;;;187            case kI2C_Read:
;;;188                DMA_PrepareTransfer(&xferConfig, (void *)&base->MSTDAT, handle->buf, sizeof(uint8_t), transfer_size,
;;;189                                    kDMA_PeripheralToMemory, NULL);
;;;190                break;
;;;191    
;;;192            default:
;;;193                /* This should never happen */
;;;194                assert(0);
;;;195                break;
;;;196        }
;;;197    
;;;198        DMA_SubmitTransfer(handle->dmaHandle, &xferConfig);
;;;199        DMA_StartTransfer(handle->dmaHandle);
;;;200    
;;;201        handle->remainingBytesDMA -= transfer_size;
;;;202        handle->buf += transfer_size;
;;;203    }
00001a  b00a              ADD      sp,sp,#0x28
00001c  bd70              POP      {r4-r6,pc}
                  |L10.30|
00001e  68a5              LDR      r5,[r4,#8]            ;174
000020  f5b56f80          CMP      r5,#0x400             ;175
000024  dd01              BLE      |L10.42|
000026  f44f6580          MOV      r5,#0x400             ;177
                  |L10.42|
00002a  2022              MOVS     r0,#0x22              ;180
00002c  5d00              LDRB     r0,[r0,r4]            ;180
00002e  b110              CBZ      r0,|L10.54|
000030  2801              CMP      r0,#1                 ;180
000032  d11a              BNE      |L10.106|
000034  e00c              B        |L10.80|
                  |L10.54|
000036  2000              MOVS     r0,#0                 ;183
000038  2102              MOVS     r1,#2                 ;183
00003a  e9cd5100          STRD     r5,r1,[sp,#0]         ;183
00003e  9002              STR      r0,[sp,#8]            ;183
000040  2301              MOVS     r3,#1                 ;183
000042  f6060228          ADD      r2,r6,#0x828          ;183
000046  a803              ADD      r0,sp,#0xc            ;183
000048  68e1              LDR      r1,[r4,#0xc]          ;183
00004a  f7fffffe          BL       DMA_PrepareTransfer
00004e  e011              B        |L10.116|
                  |L10.80|
000050  2000              MOVS     r0,#0                 ;188
000052  2101              MOVS     r1,#1                 ;188
000054  e9cd5100          STRD     r5,r1,[sp,#0]         ;188
000058  9002              STR      r0,[sp,#8]            ;188
00005a  460b              MOV      r3,r1                 ;188
00005c  f6060128          ADD      r1,r6,#0x828          ;188
000060  a803              ADD      r0,sp,#0xc            ;188
000062  68e2              LDR      r2,[r4,#0xc]          ;188
000064  f7fffffe          BL       DMA_PrepareTransfer
000068  e004              B        |L10.116|
                  |L10.106|
00006a  22c2              MOVS     r2,#0xc2              ;194
00006c  a109              ADR      r1,|L10.148|
00006e  a010              ADR      r0,|L10.176|
000070  f7fffffe          BL       __aeabi_assert
                  |L10.116|
000074  bf00              NOP                            ;185
000076  a903              ADD      r1,sp,#0xc            ;198
000078  69a0              LDR      r0,[r4,#0x18]         ;198
00007a  f7fffffe          BL       DMA_SubmitTransfer
00007e  69a0              LDR      r0,[r4,#0x18]         ;199
000080  f7fffffe          BL       DMA_StartTransfer
000084  68a0              LDR      r0,[r4,#8]            ;201
000086  1b40              SUBS     r0,r0,r5              ;201
000088  60a0              STR      r0,[r4,#8]            ;201
00008a  68e0              LDR      r0,[r4,#0xc]          ;202
00008c  4428              ADD      r0,r0,r5              ;202
00008e  60e0              STR      r0,[r4,#0xc]          ;202
000090  bf00              NOP      
000092  e7c2              B        |L10.26|
;;;204    
                          ENDP

                  |L10.148|
000094  5352435c          DCB      "SRC\\Drivers\\fsl_i2c_dma.c",0
000098  44726976
00009c  6572735c
0000a0  66736c5f
0000a4  6932635f
0000a8  646d612e
0000ac  6300    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L10.176|
0000b0  3000              DCB      "0",0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.I2C_RunTransferStateMachineDMA||, CODE, READONLY, ALIGN=1

                  I2C_RunTransferStateMachineDMA PROC
;;;212     */
;;;213    static status_t I2C_RunTransferStateMachineDMA(I2C_Type *base, i2c_master_dma_handle_t *handle, bool *isDone)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;214    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4691              MOV      r9,r2
;;;215        uint32_t status;
;;;216        uint32_t master_state;
;;;217        struct _i2c_master_transfer *transfer;
;;;218        dma_transfer_config_t xferConfig;
;;;219        status_t err;
;;;220        uint32_t start_flag = 0;
00000c  f04f0800          MOV      r8,#0
;;;221    
;;;222        transfer = &(handle->transfer);
000010  f104061c          ADD      r6,r4,#0x1c
;;;223    
;;;224        *isDone = false;
000014  2000              MOVS     r0,#0
000016  f8890000          STRB     r0,[r9,#0]
;;;225    
;;;226        status = I2C_GetStatusFlags(base);
00001a  bf00              NOP      
00001c  f8d50804          LDR      r0,[r5,#0x804]
000020  4682              MOV      r10,r0
;;;227    
;;;228        if (status & I2C_STAT_MSTARBLOSS_MASK)
000022  f00a0010          AND      r0,r10,#0x10
000026  b170              CBZ      r0,|L11.70|
;;;229        {
;;;230            I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK);
000028  2110              MOVS     r1,#0x10
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       I2C_MasterClearStatusFlags
;;;231            DMA_AbortTransfer(handle->dmaHandle);
000030  69a0              LDR      r0,[r4,#0x18]
000032  f7fffffe          BL       DMA_AbortTransfer
;;;232            base->MSTCTL = 0;
000036  2000              MOVS     r0,#0
000038  f8c50820          STR      r0,[r5,#0x820]
;;;233            return kStatus_I2C_ArbitrationLost;
00003c  f640202d          MOV      r0,#0xa2d
                  |L11.64|
;;;234        }
;;;235    
;;;236        if (status & I2C_STAT_MSTSTSTPERR_MASK)
;;;237        {
;;;238            I2C_MasterClearStatusFlags(base, I2C_STAT_MSTSTSTPERR_MASK);
;;;239            DMA_AbortTransfer(handle->dmaHandle);
;;;240            base->MSTCTL = 0;
;;;241            return kStatus_I2C_StartStopError;
;;;242        }
;;;243    
;;;244        if ((status & I2C_STAT_MSTPENDING_MASK) == 0)
;;;245        {
;;;246            return kStatus_I2C_Busy;
;;;247        }
;;;248    
;;;249        /* Get the state of the I2C module */
;;;250        master_state = (status & I2C_STAT_MSTSTATE_MASK) >> I2C_STAT_MSTSTATE_SHIFT;
;;;251    
;;;252        if ((master_state == I2C_STAT_MSTCODE_NACKADR) || (master_state == I2C_STAT_MSTCODE_NACKDAT))
;;;253        {
;;;254            /* Slave NACKed last byte, issue stop and return error */
;;;255            DMA_AbortTransfer(handle->dmaHandle);
;;;256            base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;257            handle->state = kWaitForCompletionState;
;;;258            return kStatus_I2C_Nak;
;;;259        }
;;;260    
;;;261        err = kStatus_Success;
;;;262    
;;;263        if (handle->state == kStartState)
;;;264        {
;;;265            /* set start flag for later use */
;;;266            start_flag = I2C_MSTCTL_MSTSTART_MASK;
;;;267    
;;;268            if (handle->remainingSubaddr)
;;;269            {
;;;270                base->MSTDAT = (uint32_t)transfer->slaveAddress << 1;
;;;271                handle->state = kTransmitSubaddrState;
;;;272            }
;;;273            else if (transfer->direction == kI2C_Write)
;;;274            {
;;;275                base->MSTDAT = (uint32_t)transfer->slaveAddress << 1;
;;;276                if (transfer->dataSize == 0)
;;;277                {
;;;278                    /* No data to be transferred, initiate start and schedule stop */
;;;279                    base->MSTCTL = I2C_MSTCTL_MSTSTART_MASK;
;;;280                    handle->state = kStopState;
;;;281                    return err;
;;;282                }
;;;283                handle->state = kTransmitDataState;
;;;284            }
;;;285            else if ((transfer->direction == kI2C_Read) && (transfer->dataSize > 0))
;;;286            {
;;;287                base->MSTDAT = ((uint32_t)transfer->slaveAddress << 1) | 1u;
;;;288                if (transfer->dataSize == 1)
;;;289                {
;;;290                    /* The very last byte is always received by means of SW */
;;;291                    base->MSTCTL = I2C_MSTCTL_MSTSTART_MASK;
;;;292                    handle->state = kReceiveLastDataState;
;;;293                    return err;
;;;294                }
;;;295                handle->state = kReceiveDataState;
;;;296            }
;;;297            else
;;;298            {
;;;299                handle->state = kIdleState;
;;;300                err = kStatus_I2C_UnexpectedState;
;;;301                return err;
;;;302            }
;;;303        }
;;;304    
;;;305        switch (handle->state)
;;;306        {
;;;307            case kTransmitSubaddrState:
;;;308                if ((master_state != I2C_STAT_MSTCODE_TXREADY) && (!start_flag))
;;;309                {
;;;310                    return kStatus_I2C_UnexpectedState;
;;;311                }
;;;312    
;;;313                base->MSTCTL = start_flag | I2C_MSTCTL_MSTDMA_MASK;
;;;314    
;;;315                /* Prepare and submit DMA transfer. */
;;;316                DMA_PrepareTransfer(&xferConfig, handle->subaddrBuf, (void *)&base->MSTDAT, sizeof(uint8_t),
;;;317                                    handle->remainingSubaddr, kDMA_MemoryToPeripheral, NULL);
;;;318                DMA_SubmitTransfer(handle->dmaHandle, &xferConfig);
;;;319    
;;;320                handle->remainingSubaddr = 0;
;;;321                if (transfer->dataSize)
;;;322                {
;;;323                    /* There is data to be transferred, if there is write to read turnaround it is necessary to perform
;;;324                     * repeated start */
;;;325                    handle->state = (transfer->direction == kI2C_Read) ? kStartState : kTransmitDataState;
;;;326                }
;;;327                else
;;;328                {
;;;329                    /* No more data, schedule stop condition */
;;;330                    handle->state = kStopState;
;;;331                }
;;;332                break;
;;;333    
;;;334            case kTransmitDataState:
;;;335                if ((master_state != I2C_STAT_MSTCODE_TXREADY) && (!start_flag))
;;;336                {
;;;337                    return kStatus_I2C_UnexpectedState;
;;;338                }
;;;339    
;;;340                base->MSTCTL = start_flag | I2C_MSTCTL_MSTDMA_MASK;
;;;341                handle->remainingBytesDMA = handle->transfer.dataSize;
;;;342    
;;;343                I2C_RunDMATransfer(base, handle);
;;;344    
;;;345                /* Schedule stop condition */
;;;346                handle->state = kStopState;
;;;347                break;
;;;348    
;;;349            case kReceiveDataState:
;;;350                if ((master_state != I2C_STAT_MSTCODE_RXREADY) && (!start_flag))
;;;351                {
;;;352                    return kStatus_I2C_UnexpectedState;
;;;353                }
;;;354    
;;;355                base->MSTCTL = start_flag | I2C_MSTCTL_MSTDMA_MASK;
;;;356                handle->remainingBytesDMA = handle->transfer.dataSize - 1;
;;;357    
;;;358                I2C_RunDMATransfer(base, handle);
;;;359    
;;;360                /* Schedule reception of last data byte */
;;;361                handle->state = kReceiveLastDataState;
;;;362                break;
;;;363    
;;;364            case kReceiveLastDataState:
;;;365                if (master_state != I2C_STAT_MSTCODE_RXREADY)
;;;366                {
;;;367                    return kStatus_I2C_UnexpectedState;
;;;368                }
;;;369    
;;;370                ((uint8_t *)transfer->data)[transfer->dataSize - 1] = base->MSTDAT;
;;;371                handle->transferCount++;
;;;372    
;;;373                /* No more data expected, issue NACK and STOP right away */
;;;374                base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;375                handle->state = kWaitForCompletionState;
;;;376                break;
;;;377    
;;;378            case kStopState:
;;;379                if (transfer->flags & kI2C_TransferNoStopFlag)
;;;380                {
;;;381                    /* Stop condition is omitted, we are done */
;;;382                    *isDone = true;
;;;383                    handle->state = kIdleState;
;;;384                    break;
;;;385                }
;;;386                /* Send stop condition */
;;;387                base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;388                handle->state = kWaitForCompletionState;
;;;389                break;
;;;390    
;;;391            case kWaitForCompletionState:
;;;392                *isDone = true;
;;;393                handle->state = kIdleState;
;;;394                break;
;;;395    
;;;396            case kStartState:
;;;397            case kIdleState:
;;;398            default:
;;;399                /* State machine shall not be invoked again once it enters the idle state */
;;;400                err = kStatus_I2C_UnexpectedState;
;;;401                break;
;;;402        }
;;;403    
;;;404        return err;
;;;405    }
000040  b00b              ADD      sp,sp,#0x2c
000042  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.70|
000046  f00a0040          AND      r0,r10,#0x40          ;236
00004a  b160              CBZ      r0,|L11.102|
00004c  2140              MOVS     r1,#0x40              ;238
00004e  4628              MOV      r0,r5                 ;238
000050  f7fffffe          BL       I2C_MasterClearStatusFlags
000054  69a0              LDR      r0,[r4,#0x18]         ;239
000056  f7fffffe          BL       DMA_AbortTransfer
00005a  2000              MOVS     r0,#0                 ;240
00005c  f8c50820          STR      r0,[r5,#0x820]        ;240
000060  f44f6023          MOV      r0,#0xa30             ;241
000064  e7ec              B        |L11.64|
                  |L11.102|
000066  f00a0001          AND      r0,r10,#1             ;244
00006a  b910              CBNZ     r0,|L11.114|
00006c  f6402028          MOV      r0,#0xa28             ;246
000070  e7e6              B        |L11.64|
                  |L11.114|
000072  f3ca0742          UBFX     r7,r10,#1,#3          ;250
000076  2f03              CMP      r7,#3                 ;252
000078  d001              BEQ      |L11.126|
00007a  2f04              CMP      r7,#4                 ;252
00007c  d10a              BNE      |L11.148|
                  |L11.126|
00007e  69a0              LDR      r0,[r4,#0x18]         ;255
000080  f7fffffe          BL       DMA_AbortTransfer
000084  2004              MOVS     r0,#4                 ;256
000086  f8c50820          STR      r0,[r5,#0x820]        ;256
00008a  2007              MOVS     r0,#7                 ;257
00008c  7020              STRB     r0,[r4,#0]            ;257
00008e  f640202a          MOV      r0,#0xa2a             ;258
000092  e7d5              B        |L11.64|
                  |L11.148|
000094  f04f0b00          MOV      r11,#0                ;261
000098  7820              LDRB     r0,[r4,#0]            ;263
00009a  2805              CMP      r0,#5                 ;263
00009c  d13a              BNE      |L11.276|
00009e  f04f0802          MOV      r8,#2                 ;266
0000a2  6920              LDR      r0,[r4,#0x10]         ;268
0000a4  b130              CBZ      r0,|L11.180|
0000a6  88b0              LDRH     r0,[r6,#4]            ;270
0000a8  0040              LSLS     r0,r0,#1              ;270
0000aa  f8c50828          STR      r0,[r5,#0x828]        ;270
0000ae  2001              MOVS     r0,#1                 ;271
0000b0  7020              STRB     r0,[r4,#0]            ;271
0000b2  e02f              B        |L11.276|
                  |L11.180|
0000b4  79b0              LDRB     r0,[r6,#6]            ;273
0000b6  b978              CBNZ     r0,|L11.216|
0000b8  88b0              LDRH     r0,[r6,#4]            ;275
0000ba  0040              LSLS     r0,r0,#1              ;275
0000bc  f8c50828          STR      r0,[r5,#0x828]        ;275
0000c0  6970              LDR      r0,[r6,#0x14]         ;276
0000c2  b930              CBNZ     r0,|L11.210|
0000c4  2002              MOVS     r0,#2                 ;279
0000c6  f8c50820          STR      r0,[r5,#0x820]        ;279
0000ca  2006              MOVS     r0,#6                 ;280
0000cc  7020              STRB     r0,[r4,#0]            ;280
0000ce  4658              MOV      r0,r11                ;281
0000d0  e7b6              B        |L11.64|
                  |L11.210|
0000d2  2002              MOVS     r0,#2                 ;283
0000d4  7020              STRB     r0,[r4,#0]            ;283
0000d6  e01d              B        |L11.276|
                  |L11.216|
0000d8  79b0              LDRB     r0,[r6,#6]            ;285
0000da  2801              CMP      r0,#1                 ;285
0000dc  d114              BNE      |L11.264|
0000de  6970              LDR      r0,[r6,#0x14]         ;285
0000e0  b190              CBZ      r0,|L11.264|
0000e2  88b0              LDRH     r0,[r6,#4]            ;287
0000e4  2101              MOVS     r1,#1                 ;287
0000e6  eb010040          ADD      r0,r1,r0,LSL #1       ;287
0000ea  f8c50828          STR      r0,[r5,#0x828]        ;287
0000ee  6970              LDR      r0,[r6,#0x14]         ;288
0000f0  2801              CMP      r0,#1                 ;288
0000f2  d106              BNE      |L11.258|
0000f4  2002              MOVS     r0,#2                 ;291
0000f6  f8c50820          STR      r0,[r5,#0x820]        ;291
0000fa  2004              MOVS     r0,#4                 ;292
0000fc  7020              STRB     r0,[r4,#0]            ;292
0000fe  4658              MOV      r0,r11                ;293
000100  e79e              B        |L11.64|
                  |L11.258|
000102  2003              MOVS     r0,#3                 ;295
000104  7020              STRB     r0,[r4,#0]            ;295
000106  e005              B        |L11.276|
                  |L11.264|
000108  2000              MOVS     r0,#0                 ;299
00010a  7020              STRB     r0,[r4,#0]            ;299
00010c  f6402b31          MOV      r11,#0xa31            ;300
000110  4658              MOV      r0,r11                ;301
000112  e795              B        |L11.64|
                  |L11.276|
000114  7820              LDRB     r0,[r4,#0]            ;305
000116  2808              CMP      r0,#8                 ;305
000118  d272              BCS      |L11.512|
00011a  e8dff000          TBB      [pc,r0]               ;305
00011e  8a04              DCB      0x8a,0x04
000120  31465c89          DCB      0x31,0x46,0x5c,0x89
000124  7282              DCB      0x72,0x82
000126  2f02              CMP      r7,#2                 ;308
000128  d005              BEQ      |L11.310|
00012a  f1b80f00          CMP      r8,#0                 ;308
00012e  d102              BNE      |L11.310|
000130  f6402031          MOV      r0,#0xa31             ;310
000134  e784              B        |L11.64|
                  |L11.310|
000136  f0480008          ORR      r0,r8,#8              ;313
00013a  f8c50820          STR      r0,[r5,#0x820]        ;313
00013e  2100              MOVS     r1,#0                 ;316
000140  2202              MOVS     r2,#2                 ;316
000142  6920              LDR      r0,[r4,#0x10]         ;316
000144  2301              MOVS     r3,#1                 ;316
000146  e9cd2101          STRD     r2,r1,[sp,#4]         ;316
00014a  9000              STR      r0,[sp,#0]            ;316
00014c  f6050228          ADD      r2,r5,#0x828          ;316
000150  f1040114          ADD      r1,r4,#0x14           ;316
000154  a804              ADD      r0,sp,#0x10           ;316
000156  f7fffffe          BL       DMA_PrepareTransfer
00015a  a904              ADD      r1,sp,#0x10           ;318
00015c  69a0              LDR      r0,[r4,#0x18]         ;318
00015e  f7fffffe          BL       DMA_SubmitTransfer
000162  2000              MOVS     r0,#0                 ;320
000164  6120              STR      r0,[r4,#0x10]         ;320
000166  6970              LDR      r0,[r6,#0x14]         ;321
000168  b138              CBZ      r0,|L11.378|
00016a  79b0              LDRB     r0,[r6,#6]            ;325
00016c  2801              CMP      r0,#1                 ;325
00016e  d101              BNE      |L11.372|
000170  2005              MOVS     r0,#5                 ;325
000172  e000              B        |L11.374|
                  |L11.372|
000174  2002              MOVS     r0,#2                 ;325
                  |L11.374|
000176  7020              STRB     r0,[r4,#0]            ;325
000178  e001              B        |L11.382|
                  |L11.378|
00017a  2006              MOVS     r0,#6                 ;330
00017c  7020              STRB     r0,[r4,#0]            ;330
                  |L11.382|
00017e  e05b              B        |L11.568|
000180  2f02              CMP      r7,#2                 ;335
000182  d005              BEQ      |L11.400|
000184  f1b80f00          CMP      r8,#0                 ;335
000188  d102              BNE      |L11.400|
00018a  f6402031          MOV      r0,#0xa31             ;337
00018e  e757              B        |L11.64|
                  |L11.400|
000190  f0480008          ORR      r0,r8,#8              ;340
000194  f8c50820          STR      r0,[r5,#0x820]        ;340
000198  6b20              LDR      r0,[r4,#0x30]         ;341
00019a  60a0              STR      r0,[r4,#8]            ;341
00019c  4621              MOV      r1,r4                 ;343
00019e  4628              MOV      r0,r5                 ;343
0001a0  f7fffffe          BL       I2C_RunDMATransfer
0001a4  2006              MOVS     r0,#6                 ;346
0001a6  7020              STRB     r0,[r4,#0]            ;346
0001a8  e046              B        |L11.568|
0001aa  2f01              CMP      r7,#1                 ;350
0001ac  d005              BEQ      |L11.442|
0001ae  f1b80f00          CMP      r8,#0                 ;350
0001b2  d102              BNE      |L11.442|
0001b4  f6402031          MOV      r0,#0xa31             ;352
0001b8  e742              B        |L11.64|
                  |L11.442|
0001ba  f0480008          ORR      r0,r8,#8              ;355
0001be  f8c50820          STR      r0,[r5,#0x820]        ;355
0001c2  6b20              LDR      r0,[r4,#0x30]         ;356
0001c4  1e40              SUBS     r0,r0,#1              ;356
0001c6  60a0              STR      r0,[r4,#8]            ;356
0001c8  4621              MOV      r1,r4                 ;358
0001ca  4628              MOV      r0,r5                 ;358
0001cc  f7fffffe          BL       I2C_RunDMATransfer
0001d0  2004              MOVS     r0,#4                 ;361
0001d2  7020              STRB     r0,[r4,#0]            ;361
0001d4  e030              B        |L11.568|
0001d6  2f01              CMP      r7,#1                 ;365
0001d8  d002              BEQ      |L11.480|
0001da  f6402031          MOV      r0,#0xa31             ;367
0001de  e72f              B        |L11.64|
                  |L11.480|
0001e0  f8d50828          LDR      r0,[r5,#0x828]        ;370
0001e4  b2c1              UXTB     r1,r0                 ;370
0001e6  e9d62004          LDRD     r2,r0,[r6,#0x10]      ;370
0001ea  1e40              SUBS     r0,r0,#1              ;370
0001ec  5411              STRB     r1,[r2,r0]            ;370
0001ee  6860              LDR      r0,[r4,#4]            ;371
0001f0  1c40              ADDS     r0,r0,#1              ;371
0001f2  6060              STR      r0,[r4,#4]            ;371
0001f4  2004              MOVS     r0,#4                 ;374
0001f6  f8c50820          STR      r0,[r5,#0x820]        ;374
0001fa  2007              MOVS     r0,#7                 ;375
0001fc  7020              STRB     r0,[r4,#0]            ;375
0001fe  e01b              B        |L11.568|
                  |L11.512|
000200  e015              B        |L11.558|
000202  7830              LDRB     r0,[r6,#0]            ;379
000204  f0000004          AND      r0,r0,#4              ;379
000208  b128              CBZ      r0,|L11.534|
00020a  2001              MOVS     r0,#1                 ;382
00020c  f8890000          STRB     r0,[r9,#0]            ;382
000210  2000              MOVS     r0,#0                 ;383
000212  7020              STRB     r0,[r4,#0]            ;383
000214  e010              B        |L11.568|
                  |L11.534|
000216  2004              MOVS     r0,#4                 ;387
000218  f8c50820          STR      r0,[r5,#0x820]        ;387
00021c  2007              MOVS     r0,#7                 ;388
00021e  7020              STRB     r0,[r4,#0]            ;388
000220  e00a              B        |L11.568|
000222  2001              MOVS     r0,#1                 ;392
000224  f8890000          STRB     r0,[r9,#0]            ;392
000228  2000              MOVS     r0,#0                 ;393
00022a  7020              STRB     r0,[r4,#0]            ;393
00022c  e004              B        |L11.568|
                  |L11.558|
00022e  bf00              NOP                            ;396
000230  bf00              NOP                            ;397
000232  f6402b31          MOV      r11,#0xa31            ;400
000236  bf00              NOP                            ;401
                  |L11.568|
000238  bf00              NOP                            ;332
00023a  4658              MOV      r0,r11                ;404
00023c  e700              B        |L11.64|
;;;406    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_dmaPrivateHandle
                          %        80

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_i2cIRQ
000000  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
000004  12131415          DCB      0x12,0x13,0x14,0x15
000008  2829              DCB      0x28,0x29

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_i2c_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_i2c_dma_c_fbf3b6b0____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_fsl_i2c_dma_c_fbf3b6b0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_i2c_dma_c_fbf3b6b0____REVSH|
#line 402
|__asm___13_fsl_i2c_dma_c_fbf3b6b0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_i2c_dma_c_fbf3b6b0____RRX|
#line 587
|__asm___13_fsl_i2c_dma_c_fbf3b6b0____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
