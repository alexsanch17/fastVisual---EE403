; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_i2s_dma.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_i2s_dma.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_i2s_dma.crf SRC\Drivers\fsl_i2s_dma.c]
                          THUMB

                          AREA ||i.I2S_AddTransferDMA||, CODE, READONLY, ALIGN=2

                  I2S_AddTransferDMA PROC
;;;427    
;;;428    static status_t I2S_AddTransferDMA(I2S_Type *base, i2s_dma_handle_t *handle, const uint16_t maxSize)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;429    {
000004  b084              SUB      sp,sp,#0x10
000006  4681              MOV      r9,r0
000008  460d              MOV      r5,r1
;;;430        dma_xfercfg_t xfercfg;
;;;431        i2s_transfer_t volatile *transfer;
;;;432        uint16_t transferBytes;
;;;433        uint32_t instance;
;;;434        i2s_dma_private_handle_t *privateHandle;
;;;435        dma_descriptor_t *descriptor;
;;;436        dma_descriptor_t *nextDescriptor;
;;;437    
;;;438        instance = I2S_GetInstance(base);
00000a  4648              MOV      r0,r9
00000c  f7fffffe          BL       I2S_GetInstance
000010  4682              MOV      r10,r0
;;;439        privateHandle = &(s_DmaPrivateHandle[instance]);
000012  eb0a008a          ADD      r0,r10,r10,LSL #2
000016  eb0000ca          ADD      r0,r0,r10,LSL #3
00001a  4968              LDR      r1,|L1.444|
00001c  eb010480          ADD      r4,r1,r0,LSL #2
;;;440    
;;;441        if (privateHandle->dmaDescriptorsUsed >= DMA_DESCRIPTORS)
000020  7c60              LDRB     r0,[r4,#0x11]
000022  2802              CMP      r0,#2
000024  d304              BCC      |L1.48|
;;;442        {
;;;443            /* No unprocessed DMA transfer descriptor */
;;;444            return kStatus_I2S_Busy;
000026  f640208e          MOV      r0,#0xa8e
                  |L1.42|
;;;445        }
;;;446    
;;;447        transfer = &(privateHandle->descriptorQueue[privateHandle->queueDescriptor]);
;;;448    
;;;449        /* Determine currently configured descriptor and the other which it will link to */
;;;450        descriptor = &(s_DmaDescriptors[(instance * FSL_FEATURE_SOC_I2S_COUNT) + privateHandle->descriptor]);
;;;451        privateHandle->descriptor = (privateHandle->descriptor + 1U) % DMA_DESCRIPTORS;
;;;452        nextDescriptor = &(s_DmaDescriptors[(instance * FSL_FEATURE_SOC_I2S_COUNT) + privateHandle->descriptor]);
;;;453    
;;;454        if (transfer->dataSize == 0U)
;;;455        {
;;;456            /* Currently nothing to enqueue, use dummy buffer instead */
;;;457    
;;;458            xfercfg.valid = false;
;;;459            xfercfg.reload = true;
;;;460            xfercfg.swtrig = false;
;;;461            xfercfg.clrtrig = false;
;;;462            xfercfg.intA = true;
;;;463            xfercfg.intB = false;
;;;464            xfercfg.byteWidth = sizeof(uint32_t);
;;;465            xfercfg.srcInc = 0U;
;;;466            xfercfg.dstInc = 0U;
;;;467            xfercfg.transferCount = I2S_FIFO_DEPTH + 1U;
;;;468    
;;;469            DMA_CreateDescriptor(descriptor, &xfercfg,
;;;470                                 (handle->state == kI2S_DmaStateTx) ? (void *)&s_DummyBufferTx : (void *)&(base->FIFORD),
;;;471                                 (handle->state == kI2S_DmaStateTx) ? (void *)&(base->FIFOWR) : (void *)&s_DummyBufferRx,
;;;472                                 (void *)nextDescriptor);
;;;473    
;;;474            /* TODO use API for this once it is available in DMA driver */
;;;475            descriptor->xfercfg |= DMA_CHANNEL_XFERCFG_CFGVALID(1U);
;;;476            handle->dmaHandle->base->COMMON->SETVALID = (1U << (handle->dmaHandle->channel));
;;;477    
;;;478            return kStatus_Success;
;;;479        }
;;;480        else if (transfer->dataSize > maxSize)
;;;481        {
;;;482            /* Take part of data - DMA transfer limitation */
;;;483            transferBytes = maxSize;
;;;484        }
;;;485        else
;;;486        {
;;;487            /* Entire buffer can fit into a single descriptor */
;;;488            transferBytes = transfer->dataSize;
;;;489            privateHandle->queueDescriptor = (privateHandle->queueDescriptor + 1U) % I2S_NUM_BUFFERS;
;;;490        }
;;;491    
;;;492        privateHandle->enqueuedBytes[privateHandle->enqueuedBytesEnd] = transferBytes;
;;;493        privateHandle->enqueuedBytesEnd = (privateHandle->enqueuedBytesEnd + 1U) % ENQUEUED_BYTES_BUFFER_SIZE;
;;;494    
;;;495        /* Configure descriptor */
;;;496    
;;;497        xfercfg.valid = false;
;;;498        xfercfg.reload = true;
;;;499        xfercfg.swtrig = false;
;;;500        xfercfg.clrtrig = false;
;;;501        xfercfg.intA = true;
;;;502        xfercfg.intB = false;
;;;503        xfercfg.byteWidth = sizeof(uint32_t);
;;;504        xfercfg.srcInc = (handle->state == kI2S_DmaStateTx) ? 1U : 0U;
;;;505        xfercfg.dstInc = (handle->state == kI2S_DmaStateTx) ? 0U : 1U;
;;;506        xfercfg.transferCount = transferBytes / sizeof(uint32_t);
;;;507    
;;;508        DMA_CreateDescriptor(
;;;509            descriptor, &xfercfg, (handle->state == kI2S_DmaStateTx) ? (void *)transfer->data : (void *)&(base->FIFORD),
;;;510            (handle->state == kI2S_DmaStateTx) ? (void *)&(base->FIFOWR) : (void *)transfer->data, (void *)nextDescriptor);
;;;511    
;;;512        /* TODO use API for this once it is available in DMA driver */
;;;513        descriptor->xfercfg |= DMA_CHANNEL_XFERCFG_CFGVALID(1U);
;;;514        handle->dmaHandle->base->COMMON->SETVALID = (1U << (handle->dmaHandle->channel));
;;;515    
;;;516        /* Advance internal state */
;;;517        privateHandle->dmaDescriptorsUsed++;
;;;518        transfer->dataSize -= transferBytes;
;;;519        transfer->data += transferBytes;
;;;520    
;;;521        return kStatus_Success;
;;;522    }
00002a  b007              ADD      sp,sp,#0x1c
00002c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.48|
000030  7ce1              LDRB     r1,[r4,#0x13]         ;447
000032  f1040014          ADD      r0,r4,#0x14           ;447
000036  eb0006c1          ADD      r6,r0,r1,LSL #3       ;447
00003a  7ca0              LDRB     r0,[r4,#0x12]         ;450
00003c  eb00004a          ADD      r0,r0,r10,LSL #1      ;450
000040  495f              LDR      r1,|L1.448|
000042  eb011800          ADD      r8,r1,r0,LSL #4       ;450
000046  7ca0              LDRB     r0,[r4,#0x12]         ;451
000048  1c40              ADDS     r0,r0,#1              ;451
00004a  f0000001          AND      r0,r0,#1              ;451
00004e  74a0              STRB     r0,[r4,#0x12]         ;451
000050  7ca0              LDRB     r0,[r4,#0x12]         ;452
000052  eb00004a          ADD      r0,r0,r10,LSL #1      ;452
000056  eb011b00          ADD      r11,r1,r0,LSL #4      ;452
00005a  6870              LDR      r0,[r6,#4]            ;454
00005c  2800              CMP      r0,#0                 ;454
00005e  d13f              BNE      |L1.224|
000060  f88d0004          STRB     r0,[sp,#4]            ;458
000064  2001              MOVS     r0,#1                 ;459
000066  f88d0005          STRB     r0,[sp,#5]            ;459
00006a  2000              MOVS     r0,#0                 ;460
00006c  f88d0006          STRB     r0,[sp,#6]            ;460
000070  f88d0007          STRB     r0,[sp,#7]            ;461
000074  2001              MOVS     r0,#1                 ;462
000076  f88d0008          STRB     r0,[sp,#8]            ;462
00007a  2000              MOVS     r0,#0                 ;463
00007c  f88d0009          STRB     r0,[sp,#9]            ;463
000080  2004              MOVS     r0,#4                 ;464
000082  f88d000a          STRB     r0,[sp,#0xa]          ;464
000086  2000              MOVS     r0,#0                 ;465
000088  f88d000b          STRB     r0,[sp,#0xb]          ;465
00008c  f88d000c          STRB     r0,[sp,#0xc]          ;466
000090  2009              MOVS     r0,#9                 ;467
000092  f8ad000e          STRH     r0,[sp,#0xe]          ;467
000096  f8cdb000          STR      r11,[sp,#0]           ;469
00009a  6828              LDR      r0,[r5,#0]            ;469
00009c  2801              CMP      r0,#1                 ;469
00009e  d102              BNE      |L1.166|
0000a0  f5096062          ADD      r0,r9,#0xe20          ;471
0000a4  e000              B        |L1.168|
                  |L1.166|
0000a6  4847              LDR      r0,|L1.452|
                  |L1.168|
0000a8  4603              MOV      r3,r0                 ;471
0000aa  6828              LDR      r0,[r5,#0]            ;471
0000ac  2801              CMP      r0,#1                 ;471
0000ae  d101              BNE      |L1.180|
0000b0  4845              LDR      r0,|L1.456|
0000b2  e001              B        |L1.184|
                  |L1.180|
0000b4  f5096063          ADD      r0,r9,#0xe30          ;470
                  |L1.184|
0000b8  4602              MOV      r2,r0                 ;470
0000ba  a901              ADD      r1,sp,#4              ;470
0000bc  4640              MOV      r0,r8                 ;470
0000be  f7fffffe          BL       DMA_CreateDescriptor
0000c2  f8d80000          LDR      r0,[r8,#0]            ;475
0000c6  f0400001          ORR      r0,r0,#1              ;475
0000ca  f8c80000          STR      r0,[r8,#0]            ;475
0000ce  68e8              LDR      r0,[r5,#0xc]          ;476
0000d0  7b01              LDRB     r1,[r0,#0xc]          ;476
0000d2  2001              MOVS     r0,#1                 ;476
0000d4  4088              LSLS     r0,r0,r1              ;476
0000d6  68e9              LDR      r1,[r5,#0xc]          ;476
0000d8  6889              LDR      r1,[r1,#8]            ;476
0000da  6688              STR      r0,[r1,#0x68]         ;476
0000dc  2000              MOVS     r0,#0                 ;478
0000de  e7a4              B        |L1.42|
                  |L1.224|
0000e0  6871              LDR      r1,[r6,#4]            ;480
0000e2  9806              LDR      r0,[sp,#0x18]         ;480
0000e4  4281              CMP      r1,r0                 ;480
0000e6  d901              BLS      |L1.236|
0000e8  9f06              LDR      r7,[sp,#0x18]         ;483
0000ea  e006              B        |L1.250|
                  |L1.236|
0000ec  6870              LDR      r0,[r6,#4]            ;488
0000ee  b287              UXTH     r7,r0                 ;488
0000f0  7ce0              LDRB     r0,[r4,#0x13]         ;489
0000f2  1c40              ADDS     r0,r0,#1              ;489
0000f4  f0000003          AND      r0,r0,#3              ;489
0000f8  74e0              STRB     r0,[r4,#0x13]         ;489
                  |L1.250|
0000fa  7be1              LDRB     r1,[r4,#0xf]          ;492
0000fc  f1040008          ADD      r0,r4,#8              ;492
000100  f8207011          STRH     r7,[r0,r1,LSL #1]     ;492
000104  7be0              LDRB     r0,[r4,#0xf]          ;493
000106  1c40              ADDS     r0,r0,#1              ;493
000108  2103              MOVS     r1,#3                 ;493
00010a  fbb0f2f1          UDIV     r2,r0,r1              ;493
00010e  fb010012          MLS      r0,r1,r2,r0           ;493
000112  73e0              STRB     r0,[r4,#0xf]          ;493
000114  2000              MOVS     r0,#0                 ;497
000116  f88d0004          STRB     r0,[sp,#4]            ;497
00011a  2001              MOVS     r0,#1                 ;498
00011c  f88d0005          STRB     r0,[sp,#5]            ;498
000120  2000              MOVS     r0,#0                 ;499
000122  f88d0006          STRB     r0,[sp,#6]            ;499
000126  f88d0007          STRB     r0,[sp,#7]            ;500
00012a  2001              MOVS     r0,#1                 ;501
00012c  f88d0008          STRB     r0,[sp,#8]            ;501
000130  2000              MOVS     r0,#0                 ;502
000132  f88d0009          STRB     r0,[sp,#9]            ;502
000136  2004              MOVS     r0,#4                 ;503
000138  f88d000a          STRB     r0,[sp,#0xa]          ;503
00013c  6828              LDR      r0,[r5,#0]            ;504
00013e  2801              CMP      r0,#1                 ;504
000140  d100              BNE      |L1.324|
000142  e000              B        |L1.326|
                  |L1.324|
000144  2000              MOVS     r0,#0                 ;504
                  |L1.326|
000146  f88d000b          STRB     r0,[sp,#0xb]          ;504
00014a  6828              LDR      r0,[r5,#0]            ;505
00014c  2801              CMP      r0,#1                 ;505
00014e  d001              BEQ      |L1.340|
000150  2001              MOVS     r0,#1                 ;505
000152  e000              B        |L1.342|
                  |L1.340|
000154  2000              MOVS     r0,#0                 ;505
                  |L1.342|
000156  f88d000c          STRB     r0,[sp,#0xc]          ;505
00015a  08b8              LSRS     r0,r7,#2              ;506
00015c  f8ad000e          STRH     r0,[sp,#0xe]          ;506
000160  f8cdb000          STR      r11,[sp,#0]           ;508
000164  6828              LDR      r0,[r5,#0]            ;508
000166  2801              CMP      r0,#1                 ;508
000168  d102              BNE      |L1.368|
00016a  f5096062          ADD      r0,r9,#0xe20          ;510
00016e  e000              B        |L1.370|
                  |L1.368|
000170  6830              LDR      r0,[r6,#0]            ;510
                  |L1.370|
000172  4603              MOV      r3,r0                 ;510
000174  6828              LDR      r0,[r5,#0]            ;510
000176  2801              CMP      r0,#1                 ;510
000178  d101              BNE      |L1.382|
00017a  6830              LDR      r0,[r6,#0]            ;509
00017c  e001              B        |L1.386|
                  |L1.382|
00017e  f5096063          ADD      r0,r9,#0xe30          ;509
                  |L1.386|
000182  4602              MOV      r2,r0                 ;509
000184  a901              ADD      r1,sp,#4              ;509
000186  4640              MOV      r0,r8                 ;509
000188  f7fffffe          BL       DMA_CreateDescriptor
00018c  f8d80000          LDR      r0,[r8,#0]            ;513
000190  f0400001          ORR      r0,r0,#1              ;513
000194  f8c80000          STR      r0,[r8,#0]            ;513
000198  68e8              LDR      r0,[r5,#0xc]          ;514
00019a  7b01              LDRB     r1,[r0,#0xc]          ;514
00019c  2001              MOVS     r0,#1                 ;514
00019e  4088              LSLS     r0,r0,r1              ;514
0001a0  68e9              LDR      r1,[r5,#0xc]          ;514
0001a2  6889              LDR      r1,[r1,#8]            ;514
0001a4  6688              STR      r0,[r1,#0x68]         ;514
0001a6  7c60              LDRB     r0,[r4,#0x11]         ;517
0001a8  1c40              ADDS     r0,r0,#1              ;517
0001aa  7460              STRB     r0,[r4,#0x11]         ;517
0001ac  6870              LDR      r0,[r6,#4]            ;518
0001ae  1bc0              SUBS     r0,r0,r7              ;518
0001b0  6070              STR      r0,[r6,#4]            ;518
0001b2  6830              LDR      r0,[r6,#0]            ;519
0001b4  4438              ADD      r0,r0,r7              ;519
0001b6  6030              STR      r0,[r6,#0]            ;519
0001b8  2000              MOVS     r0,#0                 ;521
0001ba  e736              B        |L1.42|
;;;523    
                          ENDP

                  |L1.444|
                          DCD      s_DmaPrivateHandle
                  |L1.448|
                          DCD      s_DmaDescriptors
                  |L1.452|
                          DCD      s_DummyBufferRx
                  |L1.456|
                          DCD      s_DummyBufferTx

                          AREA ||i.I2S_DMACallback||, CODE, READONLY, ALIGN=2

                  I2S_DMACallback PROC
;;;523    
;;;524    void I2S_DMACallback(dma_handle_t *handle, void *userData, bool transferDone, uint32_t tcds)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;525    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  469a              MOV      r10,r3
;;;526        i2s_dma_private_handle_t *privateHandle = (i2s_dma_private_handle_t *)userData;
00000c  4634              MOV      r4,r6
;;;527        i2s_dma_handle_t *i2sHandle = privateHandle->handle;
00000e  6865              LDR      r5,[r4,#4]
;;;528        I2S_Type *base = privateHandle->base;
000010  f8d48000          LDR      r8,[r4,#0]
;;;529    
;;;530        if (!transferDone)
000014  b90f              CBNZ     r7,|L2.26|
                  |L2.22|
;;;531        {
;;;532            return;
;;;533        }
;;;534    
;;;535        if (i2sHandle->i2sQueue[i2sHandle->queueDriver].dataSize == 0U)
;;;536        {
;;;537            /*
;;;538             * All user buffers processed before, dataSize already zero,
;;;539             * this means at least one dummy buffer sent/received
;;;540             * and no new buffer enqueued by user meanwhile.
;;;541             */
;;;542    
;;;543            I2S_TransferAbortDMA(base, i2sHandle);
;;;544    
;;;545            /* Notify user about completion of the final buffer */
;;;546            if (i2sHandle->completionCallback)
;;;547            {
;;;548                (i2sHandle->completionCallback)(base, i2sHandle, kStatus_I2S_Done, i2sHandle->userData);
;;;549            }
;;;550    
;;;551            return;
;;;552        }
;;;553    
;;;554        if (privateHandle->initialDescriptor)
;;;555        {
;;;556            /* Initial descriptor finished, decrease amount of data to be processed */
;;;557    
;;;558            assert(privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart] > 0U);
;;;559    
;;;560            i2sHandle->i2sQueue[i2sHandle->queueDriver].dataSize -=
;;;561                privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart];
;;;562            i2sHandle->i2sQueue[i2sHandle->queueDriver].data +=
;;;563                privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart];
;;;564            privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart] = 0U;
;;;565            privateHandle->enqueuedBytesStart = (privateHandle->enqueuedBytesStart + 1U) % ENQUEUED_BYTES_BUFFER_SIZE;
;;;566    
;;;567            privateHandle->initialDescriptor = false;
;;;568        }
;;;569        else
;;;570        {
;;;571            if (privateHandle->dmaDescriptorsUsed > 0U)
;;;572            {
;;;573                /* Finished one of chained descriptors, decrease amount of data to be processed */
;;;574    
;;;575                assert(privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart] > 0U);
;;;576    
;;;577                i2sHandle->i2sQueue[i2sHandle->queueDriver].dataSize -=
;;;578                    privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart];
;;;579                i2sHandle->i2sQueue[i2sHandle->queueDriver].data +=
;;;580                    privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart];
;;;581                privateHandle->enqueuedBytes[privateHandle->enqueuedBytesStart] = 0U;
;;;582                privateHandle->enqueuedBytesStart = (privateHandle->enqueuedBytesStart + 1U) % ENQUEUED_BYTES_BUFFER_SIZE;
;;;583    
;;;584                privateHandle->dmaDescriptorsUsed--;
;;;585            }
;;;586        }
;;;587    
;;;588        if (i2sHandle->i2sQueue[i2sHandle->queueDriver].dataSize == 0U)
;;;589        {
;;;590            /* Entire user buffer sent or received - advance to next one */
;;;591            i2sHandle->i2sQueue[i2sHandle->queueDriver].data = NULL;
;;;592            i2sHandle->queueDriver = (i2sHandle->queueDriver + 1U) % I2S_NUM_BUFFERS;
;;;593    
;;;594            /* Notify user about buffer completion */
;;;595            if (i2sHandle->completionCallback)
;;;596            {
;;;597                (i2sHandle->completionCallback)(base, i2sHandle, kStatus_I2S_BufferComplete, i2sHandle->userData);
;;;598            }
;;;599        }
;;;600    
;;;601        /* Enqueue new chunk of data to DMA (if any) */
;;;602        I2S_AddTransferDMA(base, i2sHandle, DMA_MAX_TRANSFER_BYTES);
;;;603    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L2.26|
00001a  f8951031          LDRB     r1,[r5,#0x31]         ;535
00001e  f1050010          ADD      r0,r5,#0x10           ;535
000022  eb0000c1          ADD      r0,r0,r1,LSL #3       ;535
000026  6840              LDR      r0,[r0,#4]            ;535
000028  b968              CBNZ     r0,|L2.70|
00002a  4629              MOV      r1,r5                 ;543
00002c  4640              MOV      r0,r8                 ;543
00002e  f7fffffe          BL       I2S_TransferAbortDMA
000032  6868              LDR      r0,[r5,#4]            ;546
000034  b130              CBZ      r0,|L2.68|
000036  f640228d          MOV      r2,#0xa8d             ;548
00003a  4629              MOV      r1,r5                 ;548
00003c  4640              MOV      r0,r8                 ;548
00003e  e9d5c301          LDRD     r12,r3,[r5,#4]        ;548
000042  47e0              BLX      r12                   ;548
                  |L2.68|
000044  e7e7              B        |L2.22|
                  |L2.70|
000046  7c20              LDRB     r0,[r4,#0x10]         ;554
000048  b3d0              CBZ      r0,|L2.192|
00004a  7ba1              LDRB     r1,[r4,#0xe]          ;558
00004c  f1040008          ADD      r0,r4,#8              ;558
000050  f8300011          LDRH     r0,[r0,r1,LSL #1]     ;558
000054  b100              CBZ      r0,|L2.88|
000056  e005              B        |L2.100|
                  |L2.88|
000058  f240222e          MOV      r2,#0x22e             ;558
00005c  a14b              ADR      r1,|L2.396|
00005e  4852              LDR      r0,|L2.424|
000060  f7fffffe          BL       __aeabi_assert
                  |L2.100|
000064  f8952031          LDRB     r2,[r5,#0x31]         ;560
000068  f1050110          ADD      r1,r5,#0x10           ;560
00006c  eb0101c2          ADD      r1,r1,r2,LSL #3       ;560
000070  1d08              ADDS     r0,r1,#4              ;560
000072  684a              LDR      r2,[r1,#4]            ;560
000074  7ba3              LDRB     r3,[r4,#0xe]          ;560
000076  f1040108          ADD      r1,r4,#8              ;560
00007a  f8311013          LDRH     r1,[r1,r3,LSL #1]     ;560
00007e  1a51              SUBS     r1,r2,r1              ;560
000080  6001              STR      r1,[r0,#0]            ;560
000082  f8952031          LDRB     r2,[r5,#0x31]         ;562
000086  f1050110          ADD      r1,r5,#0x10           ;562
00008a  eb0100c2          ADD      r0,r1,r2,LSL #3       ;562
00008e  6802              LDR      r2,[r0,#0]            ;562
000090  7ba3              LDRB     r3,[r4,#0xe]          ;562
000092  f1040108          ADD      r1,r4,#8              ;562
000096  f8311013          LDRH     r1,[r1,r3,LSL #1]     ;562
00009a  4411              ADD      r1,r1,r2              ;562
00009c  6001              STR      r1,[r0,#0]            ;562
00009e  2100              MOVS     r1,#0                 ;564
0000a0  7ba2              LDRB     r2,[r4,#0xe]          ;564
0000a2  f1040008          ADD      r0,r4,#8              ;564
0000a6  f8201012          STRH     r1,[r0,r2,LSL #1]     ;564
0000aa  7ba0              LDRB     r0,[r4,#0xe]          ;565
0000ac  1c40              ADDS     r0,r0,#1              ;565
0000ae  2103              MOVS     r1,#3                 ;565
0000b0  fbb0f2f1          UDIV     r2,r0,r1              ;565
0000b4  fb010012          MLS      r0,r1,r2,r0           ;565
0000b8  73a0              STRB     r0,[r4,#0xe]          ;565
0000ba  2000              MOVS     r0,#0                 ;567
0000bc  7420              STRB     r0,[r4,#0x10]         ;567
0000be  e03d              B        |L2.316|
                  |L2.192|
0000c0  e7ff              B        |L2.194|
                  |L2.194|
0000c2  7c60              LDRB     r0,[r4,#0x11]         ;571
0000c4  b3d0              CBZ      r0,|L2.316|
0000c6  7ba1              LDRB     r1,[r4,#0xe]          ;575
0000c8  f1040008          ADD      r0,r4,#8              ;575
0000cc  f8300011          LDRH     r0,[r0,r1,LSL #1]     ;575
0000d0  b100              CBZ      r0,|L2.212|
0000d2  e005              B        |L2.224|
                  |L2.212|
0000d4  f240223f          MOV      r2,#0x23f             ;575
0000d8  a12c              ADR      r1,|L2.396|
0000da  4833              LDR      r0,|L2.424|
0000dc  f7fffffe          BL       __aeabi_assert
                  |L2.224|
0000e0  f8952031          LDRB     r2,[r5,#0x31]         ;577
0000e4  f1050110          ADD      r1,r5,#0x10           ;577
0000e8  eb0101c2          ADD      r1,r1,r2,LSL #3       ;577
0000ec  1d08              ADDS     r0,r1,#4              ;577
0000ee  684a              LDR      r2,[r1,#4]            ;577
0000f0  7ba3              LDRB     r3,[r4,#0xe]          ;577
0000f2  f1040108          ADD      r1,r4,#8              ;577
0000f6  f8311013          LDRH     r1,[r1,r3,LSL #1]     ;577
0000fa  1a51              SUBS     r1,r2,r1              ;577
0000fc  6001              STR      r1,[r0,#0]            ;577
0000fe  f8952031          LDRB     r2,[r5,#0x31]         ;579
000102  f1050110          ADD      r1,r5,#0x10           ;579
000106  eb0100c2          ADD      r0,r1,r2,LSL #3       ;579
00010a  6802              LDR      r2,[r0,#0]            ;579
00010c  7ba3              LDRB     r3,[r4,#0xe]          ;579
00010e  f1040108          ADD      r1,r4,#8              ;579
000112  f8311013          LDRH     r1,[r1,r3,LSL #1]     ;579
000116  4411              ADD      r1,r1,r2              ;579
000118  6001              STR      r1,[r0,#0]            ;579
00011a  2100              MOVS     r1,#0                 ;581
00011c  7ba2              LDRB     r2,[r4,#0xe]          ;581
00011e  f1040008          ADD      r0,r4,#8              ;581
000122  f8201012          STRH     r1,[r0,r2,LSL #1]     ;581
000126  7ba0              LDRB     r0,[r4,#0xe]          ;582
000128  1c40              ADDS     r0,r0,#1              ;582
00012a  2103              MOVS     r1,#3                 ;582
00012c  fbb0f2f1          UDIV     r2,r0,r1              ;582
000130  fb010012          MLS      r0,r1,r2,r0           ;582
000134  73a0              STRB     r0,[r4,#0xe]          ;582
000136  7c60              LDRB     r0,[r4,#0x11]         ;584
000138  1e40              SUBS     r0,r0,#1              ;584
00013a  7460              STRB     r0,[r4,#0x11]         ;584
                  |L2.316|
00013c  f8951031          LDRB     r1,[r5,#0x31]         ;588
000140  f1050010          ADD      r0,r5,#0x10           ;588
000144  eb0000c1          ADD      r0,r0,r1,LSL #3       ;588
000148  6840              LDR      r0,[r0,#4]            ;588
00014a  b9b0              CBNZ     r0,|L2.378|
00014c  2100              MOVS     r1,#0                 ;591
00014e  f8952031          LDRB     r2,[r5,#0x31]         ;591
000152  f1050010          ADD      r0,r5,#0x10           ;591
000156  f8401032          STR      r1,[r0,r2,LSL #3]     ;591
00015a  f8950031          LDRB     r0,[r5,#0x31]         ;592
00015e  1c40              ADDS     r0,r0,#1              ;592
000160  f0000003          AND      r0,r0,#3              ;592
000164  f8850031          STRB     r0,[r5,#0x31]         ;592
000168  6868              LDR      r0,[r5,#4]            ;595
00016a  b130              CBZ      r0,|L2.378|
00016c  f640228c          MOV      r2,#0xa8c             ;597
000170  4629              MOV      r1,r5                 ;597
000172  4640              MOV      r0,r8                 ;597
000174  e9d5c301          LDRD     r12,r3,[r5,#4]        ;597
000178  47e0              BLX      r12                   ;597
                  |L2.378|
00017a  f44f5280          MOV      r2,#0x1000            ;602
00017e  4629              MOV      r1,r5                 ;602
000180  4640              MOV      r0,r8                 ;602
000182  f7fffffe          BL       I2S_AddTransferDMA
000186  bf00              NOP      
000188  e745              B        |L2.22|
                          ENDP

00018a  0000              DCW      0x0000
                  |L2.396|
00018c  5352435c          DCB      "SRC\\Drivers\\fsl_i2s_dma.c",0
000190  44726976
000194  6572735c
000198  66736c5f
00019c  6932735f
0001a0  646d612e
0001a4  6300    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L2.424|
                          DCD      ||.conststring||

                          AREA ||i.I2S_EnqueueUserBuffer||, CODE, READONLY, ALIGN=2

                  I2S_EnqueueUserBuffer PROC
;;;123    
;;;124    static status_t I2S_EnqueueUserBuffer(I2S_Type *base, i2s_dma_handle_t *handle, i2s_transfer_t transfer)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;125    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;126        uint32_t instance = I2S_GetInstance(base);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       I2S_GetInstance
00000e  4607              MOV      r7,r0
;;;127        i2s_dma_private_handle_t *privateHandle = &(s_DmaPrivateHandle[instance]);
000010  eb070087          ADD      r0,r7,r7,LSL #2
000014  eb0000c7          ADD      r0,r0,r7,LSL #3
000018  4933              LDR      r1,|L3.232|
00001a  eb010580          ADD      r5,r1,r0,LSL #2
;;;128    
;;;129        /* Validate input data and tranfer buffer */
;;;130    
;;;131        assert(handle);
00001e  b104              CBZ      r4,|L3.34|
000020  e004              B        |L3.44|
                  |L3.34|
000022  2283              MOVS     r2,#0x83
000024  a131              ADR      r1,|L3.236|
000026  a038              ADR      r0,|L3.264|
000028  f7fffffe          BL       __aeabi_assert
                  |L3.44|
;;;132        if (!handle)
00002c  b91c              CBNZ     r4,|L3.54|
;;;133        {
;;;134            return kStatus_InvalidArgument;
00002e  2004              MOVS     r0,#4
                  |L3.48|
;;;135        }
;;;136    
;;;137        assert((((uint32_t)transfer.data) % 4U) == 0U);
;;;138        if ((((uint32_t)transfer.data) % 4U) != 0U)
;;;139        {
;;;140            /* Data not 4-bytes aligned */
;;;141            return kStatus_InvalidArgument;
;;;142        }
;;;143    
;;;144        assert(transfer.dataSize != 0U);
;;;145        if (transfer.dataSize == 0U)
;;;146        {
;;;147            /* No data to send or receive */
;;;148            return kStatus_InvalidArgument;
;;;149        }
;;;150    
;;;151        assert((transfer.dataSize % 4U) == 0U);
;;;152        if ((transfer.dataSize % 4U) != 0U)
;;;153        {
;;;154            /* Data length not multiply of 4 bytes */
;;;155            return kStatus_InvalidArgument;
;;;156        }
;;;157    
;;;158        if (handle->i2sQueue[handle->queueUser].dataSize)
;;;159        {
;;;160            /* Previously prepared buffers not processed yet, reject request */
;;;161            return kStatus_I2S_Busy;
;;;162        }
;;;163    
;;;164        /* Enqueue data */
;;;165        privateHandle->descriptorQueue[handle->queueUser].data = transfer.data;
;;;166        privateHandle->descriptorQueue[handle->queueUser].dataSize = transfer.dataSize;
;;;167        handle->i2sQueue[handle->queueUser].data = transfer.data;
;;;168        handle->i2sQueue[handle->queueUser].dataSize = transfer.dataSize;
;;;169        handle->queueUser = (handle->queueUser + 1U) % I2S_NUM_BUFFERS;
;;;170    
;;;171        return kStatus_Success;
;;;172    }
000030  b004              ADD      sp,sp,#0x10
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L3.54|
000036  9802              LDR      r0,[sp,#8]            ;137
000038  f0000003          AND      r0,r0,#3              ;137
00003c  b900              CBNZ     r0,|L3.64|
00003e  e004              B        |L3.74|
                  |L3.64|
000040  2289              MOVS     r2,#0x89              ;137
000042  a12a              ADR      r1,|L3.236|
000044  a032              ADR      r0,|L3.272|
000046  f7fffffe          BL       __aeabi_assert
                  |L3.74|
00004a  9802              LDR      r0,[sp,#8]            ;138
00004c  f0000003          AND      r0,r0,#3              ;138
000050  b108              CBZ      r0,|L3.86|
000052  2004              MOVS     r0,#4                 ;141
000054  e7ec              B        |L3.48|
                  |L3.86|
000056  9803              LDR      r0,[sp,#0xc]          ;144
000058  b100              CBZ      r0,|L3.92|
00005a  e004              B        |L3.102|
                  |L3.92|
00005c  2290              MOVS     r2,#0x90              ;144
00005e  a123              ADR      r1,|L3.236|
000060  a035              ADR      r0,|L3.312|
000062  f7fffffe          BL       __aeabi_assert
                  |L3.102|
000066  9803              LDR      r0,[sp,#0xc]          ;145
000068  b908              CBNZ     r0,|L3.110|
00006a  2004              MOVS     r0,#4                 ;148
00006c  e7e0              B        |L3.48|
                  |L3.110|
00006e  9803              LDR      r0,[sp,#0xc]          ;151
000070  f0000003          AND      r0,r0,#3              ;151
000074  b900              CBNZ     r0,|L3.120|
000076  e004              B        |L3.130|
                  |L3.120|
000078  2297              MOVS     r2,#0x97              ;151
00007a  a11c              ADR      r1,|L3.236|
00007c  a034              ADR      r0,|L3.336|
00007e  f7fffffe          BL       __aeabi_assert
                  |L3.130|
000082  9803              LDR      r0,[sp,#0xc]          ;152
000084  f0000003          AND      r0,r0,#3              ;152
000088  b108              CBZ      r0,|L3.142|
00008a  2004              MOVS     r0,#4                 ;155
00008c  e7d0              B        |L3.48|
                  |L3.142|
00008e  f8941030          LDRB     r1,[r4,#0x30]         ;158
000092  f1040010          ADD      r0,r4,#0x10           ;158
000096  eb0000c1          ADD      r0,r0,r1,LSL #3       ;158
00009a  6840              LDR      r0,[r0,#4]            ;158
00009c  b110              CBZ      r0,|L3.164|
00009e  f640208e          MOV      r0,#0xa8e             ;161
0000a2  e7c5              B        |L3.48|
                  |L3.164|
0000a4  9902              LDR      r1,[sp,#8]            ;165
0000a6  f8142f30          LDRB     r2,[r4,#0x30]!        ;165
0000aa  f1050014          ADD      r0,r5,#0x14           ;165
0000ae  f8401032          STR      r1,[r0,r2,LSL #3]     ;165
0000b2  9903              LDR      r1,[sp,#0xc]          ;166
0000b4  7822              LDRB     r2,[r4,#0]            ;166
0000b6  eb0000c2          ADD      r0,r0,r2,LSL #3       ;166
0000ba  6041              STR      r1,[r0,#4]            ;166
0000bc  9902              LDR      r1,[sp,#8]            ;167
0000be  f8142930          LDRB     r2,[r4],#-0x30        ;167
0000c2  f1040010          ADD      r0,r4,#0x10           ;167
0000c6  f8401032          STR      r1,[r0,r2,LSL #3]     ;167
0000ca  9903              LDR      r1,[sp,#0xc]          ;168
0000cc  f8942030          LDRB     r2,[r4,#0x30]         ;168
0000d0  eb0000c2          ADD      r0,r0,r2,LSL #3       ;168
0000d4  6041              STR      r1,[r0,#4]            ;168
0000d6  f8940030          LDRB     r0,[r4,#0x30]         ;169
0000da  1c40              ADDS     r0,r0,#1              ;169
0000dc  f0000003          AND      r0,r0,#3              ;169
0000e0  f8840030          STRB     r0,[r4,#0x30]         ;169
0000e4  2000              MOVS     r0,#0                 ;171
0000e6  e7a3              B        |L3.48|
;;;173    
                          ENDP

                  |L3.232|
                          DCD      s_DmaPrivateHandle
                  |L3.236|
0000ec  5352435c          DCB      "SRC\\Drivers\\fsl_i2s_dma.c",0
0000f0  44726976
0000f4  6572735c
0000f8  66736c5f
0000fc  6932735f
000100  646d612e
000104  6300    
000106  00                DCB      0
000107  00                DCB      0
                  |L3.264|
000108  68616e64          DCB      "handle",0
00010c  6c6500  
00010f  00                DCB      0
                  |L3.272|
000110  28282875          DCB      "(((uint32_t)transfer.data) % 4U) == 0U",0
000114  696e7433
000118  325f7429
00011c  7472616e
000120  73666572
000124  2e646174
000128  61292025
00012c  20345529
000130  203d3d20
000134  305500  
000137  00                DCB      0
                  |L3.312|
000138  7472616e          DCB      "transfer.dataSize != 0U",0
00013c  73666572
000140  2e646174
000144  6153697a
000148  6520213d
00014c  20305500
                  |L3.336|
000150  28747261          DCB      "(transfer.dataSize % 4U) == 0U",0
000154  6e736665
000158  722e6461
00015c  74615369
000160  7a652025
000164  20345529
000168  203d3d20
00016c  305500  
00016f  00                DCB      0

                          AREA ||i.I2S_GetInstance||, CODE, READONLY, ALIGN=2

                  I2S_GetInstance PROC
;;;173    
;;;174    static uint32_t I2S_GetInstance(I2S_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
000002  4605              MOV      r5,r0
;;;176        uint32_t i;
;;;177    
;;;178        for (i = 0U; i < FSL_FEATURE_SOC_I2S_COUNT; i++)
000004  2400              MOVS     r4,#0
000006  e007              B        |L4.24|
                  |L4.8|
;;;179        {
;;;180            if ((uint32_t)base == s_I2sBaseAddrs[i])
000008  4807              LDR      r0,|L4.40|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d101              BNE      |L4.22|
;;;181            {
;;;182                return i;
000012  4620              MOV      r0,r4
;;;183            }
;;;184        }
;;;185    
;;;186        assert(false);
;;;187        return 0U;
;;;188    }
000014  bd70              POP      {r4-r6,pc}
                  |L4.22|
000016  1c64              ADDS     r4,r4,#1              ;178
                  |L4.24|
000018  2c02              CMP      r4,#2                 ;178
00001a  d3f5              BCC      |L4.8|
00001c  22ba              MOVS     r2,#0xba              ;186
00001e  a103              ADR      r1,|L4.44|
000020  a009              ADR      r0,|L4.72|
000022  f7fffffe          BL       __aeabi_assert
;;;189    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      s_I2sBaseAddrs
                  |L4.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_i2s_dma.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  6932735f
000040  646d612e
000044  6300    
000046  00                DCB      0
000047  00                DCB      0
                  |L4.72|
000048  66616c73          DCB      "false",0
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.I2S_RxEnableDMA||, CODE, READONLY, ALIGN=1

                  I2S_RxEnableDMA PROC
;;;314    
;;;315    static void I2S_RxEnableDMA(I2S_Type *base, bool enable)
000000  b131              CBZ      r1,|L5.16|
;;;316    {
;;;317        if (enable)
;;;318        {
;;;319            base->FIFOCFG |= I2S_FIFOCFG_DMARX_MASK;
000002  f8d02e00          LDR      r2,[r0,#0xe00]
000006  f4425200          ORR      r2,r2,#0x2000
00000a  f8c02e00          STR      r2,[r0,#0xe00]
00000e  e00b              B        |L5.40|
                  |L5.16|
;;;320        }
;;;321        else
;;;322        {
;;;323            base->FIFOCFG &= (~I2S_FIFOCFG_DMARX_MASK);
000010  f8d02e00          LDR      r2,[r0,#0xe00]
000014  f4225200          BIC      r2,r2,#0x2000
000018  f8c02e00          STR      r2,[r0,#0xe00]
;;;324            base->FIFOCFG |= I2S_FIFOCFG_EMPTYRX_MASK;
00001c  f8d02e00          LDR      r2,[r0,#0xe00]
000020  f4423200          ORR      r2,r2,#0x20000
000024  f8c02e00          STR      r2,[r0,#0xe00]
                  |L5.40|
;;;325        }
;;;326    }
000028  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.I2S_RxTransferCreateHandleDMA||, CODE, READONLY, ALIGN=1

                  I2S_RxTransferCreateHandleDMA PROC
;;;273    
;;;274    void I2S_RxTransferCreateHandleDMA(I2S_Type *base,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;275                                       i2s_dma_handle_t *handle,
;;;276                                       dma_handle_t *dmaHandle,
;;;277                                       i2s_dma_transfer_callback_t callback,
;;;278                                       void *userData)
;;;279    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;280        I2S_TxTransferCreateHandleDMA(base, handle, dmaHandle, callback, userData);
000010  463b              MOV      r3,r7
000012  4632              MOV      r2,r6
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f8cd8000          STR      r8,[sp,#0]
00001c  f7fffffe          BL       I2S_TxTransferCreateHandleDMA
;;;281    }
000020  e8bd83f8          POP      {r3-r9,pc}
;;;282    
                          ENDP


                          AREA ||i.I2S_RxTransferReceiveDMA||, CODE, READONLY, ALIGN=1

                  I2S_RxTransferReceiveDMA PROC
;;;282    
;;;283    status_t I2S_RxTransferReceiveDMA(I2S_Type *base, i2s_dma_handle_t *handle, i2s_transfer_t transfer)
000000  b57f              PUSH     {r0-r6,lr}
;;;284    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;285        /* Enqueue transfer buffer */
;;;286        status_t status = I2S_EnqueueUserBuffer(base, handle, transfer);
000008  9804              LDR      r0,[sp,#0x10]
00000a  9000              STR      r0,[sp,#0]
00000c  9805              LDR      r0,[sp,#0x14]
00000e  9001              STR      r0,[sp,#4]
000010  4621              MOV      r1,r4
000012  4630              MOV      r0,r6
000014  e9dd2300          LDRD     r2,r3,[sp,#0]
000018  f7fffffe          BL       I2S_EnqueueUserBuffer
00001c  4605              MOV      r5,r0
;;;287        if (status != kStatus_Success)
00001e  b115              CBZ      r5,|L7.38|
;;;288        {
;;;289            return status;
000020  4628              MOV      r0,r5
                  |L7.34|
;;;290        }
;;;291    
;;;292        /* Initialize DMA transfer */
;;;293        if (handle->state == kI2S_DmaStateIdle)
;;;294        {
;;;295            handle->state = kI2S_DmaStateRx;
;;;296            return I2S_StartTransferDMA(base, handle);
;;;297        }
;;;298    
;;;299        return kStatus_Success;
;;;300    }
000022  b006              ADD      sp,sp,#0x18
000024  bd70              POP      {r4-r6,pc}
                  |L7.38|
000026  6820              LDR      r0,[r4,#0]            ;293
000028  b930              CBNZ     r0,|L7.56|
00002a  2002              MOVS     r0,#2                 ;295
00002c  6020              STR      r0,[r4,#0]            ;295
00002e  4621              MOV      r1,r4                 ;296
000030  4630              MOV      r0,r6                 ;296
000032  f7fffffe          BL       I2S_StartTransferDMA
000036  e7f4              B        |L7.34|
                  |L7.56|
000038  2000              MOVS     r0,#0                 ;299
00003a  e7f2              B        |L7.34|
;;;301    
                          ENDP


                          AREA ||i.I2S_StartTransferDMA||, CODE, READONLY, ALIGN=2

                  I2S_StartTransferDMA PROC
;;;327    
;;;328    static status_t I2S_StartTransferDMA(I2S_Type *base, i2s_dma_handle_t *handle)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;329    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4680              MOV      r8,r0
000008  460f              MOV      r7,r1
;;;330        status_t status;
;;;331        dma_transfer_config_t xferConfig = {0};
00000a  211c              MOVS     r1,#0x1c
00000c  a804              ADD      r0,sp,#0x10
00000e  f7fffffe          BL       __aeabi_memclr4
;;;332        i2s_dma_private_handle_t *privateHandle;
;;;333        i2s_transfer_t volatile *transfer;
;;;334        uint16_t transferBytes;
;;;335        uint32_t instance;
;;;336        uint32_t i;
;;;337    
;;;338        instance = I2S_GetInstance(base);
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       I2S_GetInstance
000018  4683              MOV      r11,r0
;;;339        privateHandle = &(s_DmaPrivateHandle[instance]);
00001a  eb0b008b          ADD      r0,r11,r11,LSL #2
00001e  eb0000cb          ADD      r0,r0,r11,LSL #3
000022  4950              LDR      r1,|L8.356|
000024  eb010680          ADD      r6,r1,r0,LSL #2
;;;340        transfer = &(privateHandle->descriptorQueue[privateHandle->queueDescriptor]);
000028  7cf1              LDRB     r1,[r6,#0x13]
00002a  f1060014          ADD      r0,r6,#0x14
00002e  eb0005c1          ADD      r5,r0,r1,LSL #3
;;;341    
;;;342        /*
;;;343         * Divide first buffer between initial DMA descriptor and chained DMA descriptors.
;;;344         * This allows to enqueue more data before entire buffer is processed
;;;345         * and thus could prevent audio drop-outs due to requeing.
;;;346         * But user is expected to enqueue more data in order for this to work.
;;;347         */
;;;348        transferBytes = (transfer->dataSize / (DMA_DESCRIPTORS + 1U));
000032  6868              LDR      r0,[r5,#4]
000034  2103              MOVS     r1,#3
000036  fbb0f0f1          UDIV     r0,r0,r1
00003a  b284              UXTH     r4,r0
;;;349    
;;;350        if (transferBytes > DMA_MAX_TRANSFER_BYTES)
00003c  f5b45f80          CMP      r4,#0x1000
000040  d901              BLS      |L8.70|
;;;351        {
;;;352            transferBytes = DMA_MAX_TRANSFER_BYTES;
000042  f44f5480          MOV      r4,#0x1000
                  |L8.70|
;;;353        }
;;;354    
;;;355        if ((transferBytes % 4U) != 0U)
000046  f0040003          AND      r0,r4,#3
00004a  b118              CBZ      r0,|L8.84|
;;;356        {
;;;357            transferBytes -= (transferBytes % 4U);
00004c  f0040003          AND      r0,r4,#3
000050  1a20              SUBS     r0,r4,r0
000052  b284              UXTH     r4,r0
                  |L8.84|
;;;358        }
;;;359    
;;;360        assert(transferBytes > 0U);
000054  b104              CBZ      r4,|L8.88|
000056  e005              B        |L8.100|
                  |L8.88|
000058  f44f72b4          MOV      r2,#0x168
00005c  a142              ADR      r1,|L8.360|
00005e  a049              ADR      r0,|L8.388|
000060  f7fffffe          BL       __aeabi_assert
                  |L8.100|
;;;361        if (transferBytes == 0U)
000064  b91c              CBNZ     r4,|L8.110|
;;;362        {
;;;363            /*
;;;364             * TODO buffer too small to be divided for multiple descriptors
;;;365             * return invalid argument status for now
;;;366             */
;;;367            return kStatus_InvalidArgument;
000066  2004              MOVS     r0,#4
                  |L8.104|
;;;368        }
;;;369    
;;;370        /* Prepare transfer of data via initial DMA transfer descriptor */
;;;371        DMA_PrepareTransfer(
;;;372            &xferConfig, (handle->state == kI2S_DmaStateTx) ? (void *)transfer->data : (void *)&(base->FIFORD),
;;;373            (handle->state == kI2S_DmaStateTx) ? (void *)&(base->FIFOWR) : (void *)transfer->data, sizeof(uint32_t),
;;;374            transferBytes, (handle->state == kI2S_DmaStateTx) ? kDMA_MemoryToPeripheral : kDMA_PeripheralToMemory,
;;;375            (void *)&(s_DmaDescriptors[(instance * FSL_FEATURE_SOC_I2S_COUNT) + 0U]));
;;;376    
;;;377        privateHandle->initialDescriptor = true; /* For IRQ handler to know that it will be fired for first descriptor */
;;;378        privateHandle->enqueuedBytes[privateHandle->enqueuedBytesEnd] = transferBytes;
;;;379        privateHandle->enqueuedBytesEnd = (privateHandle->enqueuedBytesEnd + 1U) % ENQUEUED_BYTES_BUFFER_SIZE;
;;;380    
;;;381        transfer->dataSize -= transferBytes;
;;;382        transfer->data += transferBytes;
;;;383        if (transfer->dataSize == 0U)
;;;384        {
;;;385            transfer->data = NULL;
;;;386            privateHandle->queueDescriptor = (privateHandle->queueDescriptor + 1U) % I2S_NUM_BUFFERS;
;;;387        }
;;;388    
;;;389        /* Prepare chained descriptors to transfer 2nd and 3rd part of initial data */
;;;390        for (i = 0; i < DMA_DESCRIPTORS; i++)
;;;391        {
;;;392            if (i == (DMA_DESCRIPTORS - 1))
;;;393            {
;;;394                /* Last buffer will take the rest of data (because of possible truncating by division) */
;;;395                transferBytes = transfer->dataSize;
;;;396                if (transferBytes > DMA_MAX_TRANSFER_BYTES)
;;;397                {
;;;398                    transferBytes = DMA_MAX_TRANSFER_BYTES;
;;;399                }
;;;400            }
;;;401    
;;;402            I2S_AddTransferDMA(base, handle, transferBytes);
;;;403        }
;;;404    
;;;405        /* Submit and start initial DMA transfer */
;;;406    
;;;407        if (handle->state == kI2S_DmaStateTx)
;;;408        {
;;;409            I2S_TxEnableDMA(base, true);
;;;410        }
;;;411        else
;;;412        {
;;;413            I2S_RxEnableDMA(base, true);
;;;414        }
;;;415    
;;;416        status = DMA_SubmitTransfer(handle->dmaHandle, &xferConfig);
;;;417        if (status != kStatus_Success)
;;;418        {
;;;419            return status;
;;;420        }
;;;421    
;;;422        DMA_StartTransfer(handle->dmaHandle);
;;;423    
;;;424        I2S_Enable(base);
;;;425        return kStatus_Success;
;;;426    }
000068  b00b              ADD      sp,sp,#0x2c
00006a  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.110|
00006e  2000              MOVS     r0,#0                 ;371
000070  eb00004b          ADD      r0,r0,r11,LSL #1      ;371
000074  4948              LDR      r1,|L8.408|
000076  eb011000          ADD      r0,r1,r0,LSL #4       ;371
00007a  6839              LDR      r1,[r7,#0]            ;371
00007c  2901              CMP      r1,#1                 ;371
00007e  d101              BNE      |L8.132|
000080  2102              MOVS     r1,#2                 ;374
000082  e000              B        |L8.134|
                  |L8.132|
000084  2101              MOVS     r1,#1                 ;374
                  |L8.134|
000086  e9cd4100          STRD     r4,r1,[sp,#0]         ;374
00008a  9002              STR      r0,[sp,#8]            ;374
00008c  6838              LDR      r0,[r7,#0]            ;374
00008e  2801              CMP      r0,#1                 ;374
000090  d102              BNE      |L8.152|
000092  f5086062          ADD      r0,r8,#0xe20          ;373
000096  e000              B        |L8.154|
                  |L8.152|
000098  6828              LDR      r0,[r5,#0]            ;373
                  |L8.154|
00009a  4602              MOV      r2,r0                 ;373
00009c  6838              LDR      r0,[r7,#0]            ;373
00009e  2801              CMP      r0,#1                 ;373
0000a0  d101              BNE      |L8.166|
0000a2  6828              LDR      r0,[r5,#0]            ;372
0000a4  e001              B        |L8.170|
                  |L8.166|
0000a6  f5086063          ADD      r0,r8,#0xe30          ;372
                  |L8.170|
0000aa  4601              MOV      r1,r0                 ;372
0000ac  2304              MOVS     r3,#4                 ;372
0000ae  a804              ADD      r0,sp,#0x10           ;372
0000b0  f7fffffe          BL       DMA_PrepareTransfer
0000b4  2001              MOVS     r0,#1                 ;377
0000b6  7430              STRB     r0,[r6,#0x10]         ;377
0000b8  7bf1              LDRB     r1,[r6,#0xf]          ;378
0000ba  f1060008          ADD      r0,r6,#8              ;378
0000be  f8204011          STRH     r4,[r0,r1,LSL #1]     ;378
0000c2  7bf0              LDRB     r0,[r6,#0xf]          ;379
0000c4  1c40              ADDS     r0,r0,#1              ;379
0000c6  2103              MOVS     r1,#3                 ;379
0000c8  fbb0f2f1          UDIV     r2,r0,r1              ;379
0000cc  fb010012          MLS      r0,r1,r2,r0           ;379
0000d0  73f0              STRB     r0,[r6,#0xf]          ;379
0000d2  6868              LDR      r0,[r5,#4]            ;381
0000d4  1b00              SUBS     r0,r0,r4              ;381
0000d6  6068              STR      r0,[r5,#4]            ;381
0000d8  6828              LDR      r0,[r5,#0]            ;382
0000da  4420              ADD      r0,r0,r4              ;382
0000dc  6028              STR      r0,[r5,#0]            ;382
0000de  6868              LDR      r0,[r5,#4]            ;383
0000e0  b930              CBNZ     r0,|L8.240|
0000e2  2000              MOVS     r0,#0                 ;385
0000e4  6028              STR      r0,[r5,#0]            ;385
0000e6  7cf0              LDRB     r0,[r6,#0x13]         ;386
0000e8  1c40              ADDS     r0,r0,#1              ;386
0000ea  f0000003          AND      r0,r0,#3              ;386
0000ee  74f0              STRB     r0,[r6,#0x13]         ;386
                  |L8.240|
0000f0  f04f0900          MOV      r9,#0                 ;390
0000f4  e010              B        |L8.280|
                  |L8.246|
0000f6  f1b90f01          CMP      r9,#1                 ;392
0000fa  d106              BNE      |L8.266|
0000fc  6868              LDR      r0,[r5,#4]            ;395
0000fe  b284              UXTH     r4,r0                 ;395
000100  f5b45f80          CMP      r4,#0x1000            ;396
000104  d901              BLS      |L8.266|
000106  f44f5480          MOV      r4,#0x1000            ;398
                  |L8.266|
00010a  4622              MOV      r2,r4                 ;402
00010c  4639              MOV      r1,r7                 ;402
00010e  4640              MOV      r0,r8                 ;402
000110  f7fffffe          BL       I2S_AddTransferDMA
000114  f1090901          ADD      r9,r9,#1              ;390
                  |L8.280|
000118  f1b90f02          CMP      r9,#2                 ;390
00011c  d3eb              BCC      |L8.246|
00011e  6838              LDR      r0,[r7,#0]            ;407
000120  2801              CMP      r0,#1                 ;407
000122  d104              BNE      |L8.302|
000124  2101              MOVS     r1,#1                 ;409
000126  4640              MOV      r0,r8                 ;409
000128  f7fffffe          BL       I2S_TxEnableDMA
00012c  e003              B        |L8.310|
                  |L8.302|
00012e  2101              MOVS     r1,#1                 ;413
000130  4640              MOV      r0,r8                 ;413
000132  f7fffffe          BL       I2S_RxEnableDMA
                  |L8.310|
000136  a904              ADD      r1,sp,#0x10           ;416
000138  68f8              LDR      r0,[r7,#0xc]          ;416
00013a  f7fffffe          BL       DMA_SubmitTransfer
00013e  4682              MOV      r10,r0                ;416
000140  f1ba0f00          CMP      r10,#0                ;417
000144  d001              BEQ      |L8.330|
000146  4650              MOV      r0,r10                ;419
000148  e78e              B        |L8.104|
                  |L8.330|
00014a  68f8              LDR      r0,[r7,#0xc]          ;422
00014c  f7fffffe          BL       DMA_StartTransfer
000150  bf00              NOP                            ;424
000152  f8d80c00          LDR      r0,[r8,#0xc00]        ;424
000156  f0400001          ORR      r0,r0,#1              ;424
00015a  f8c80c00          STR      r0,[r8,#0xc00]        ;424
00015e  bf00              NOP                            ;424
000160  2000              MOVS     r0,#0                 ;425
000162  e781              B        |L8.104|
;;;427    
                          ENDP

                  |L8.356|
                          DCD      s_DmaPrivateHandle
                  |L8.360|
000168  5352435c          DCB      "SRC\\Drivers\\fsl_i2s_dma.c",0
00016c  44726976
000170  6572735c
000174  66736c5f
000178  6932735f
00017c  646d612e
000180  6300    
000182  00                DCB      0
000183  00                DCB      0
                  |L8.388|
000184  7472616e          DCB      "transferBytes > 0U",0
000188  73666572
00018c  42797465
000190  73203e20
000194  305500  
000197  00                DCB      0
                  |L8.408|
                          DCD      s_DmaDescriptors

                          AREA ||i.I2S_TransferAbortDMA||, CODE, READONLY, ALIGN=2

                  I2S_TransferAbortDMA PROC
;;;234    
;;;235    void I2S_TransferAbortDMA(I2S_Type *base, i2s_dma_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;236    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;237        assert(handle);
000008  b104              CBZ      r4,|L9.12|
00000a  e004              B        |L9.22|
                  |L9.12|
00000c  22ed              MOVS     r2,#0xed
00000e  a125              ADR      r1,|L9.164|
000010  a02b              ADR      r0,|L9.192|
000012  f7fffffe          BL       __aeabi_assert
                  |L9.22|
;;;238        assert(handle->dmaHandle);
000016  68e0              LDR      r0,[r4,#0xc]
000018  b100              CBZ      r0,|L9.28|
00001a  e004              B        |L9.38|
                  |L9.28|
00001c  22ee              MOVS     r2,#0xee
00001e  a121              ADR      r1,|L9.164|
000020  a029              ADR      r0,|L9.200|
000022  f7fffffe          BL       __aeabi_assert
                  |L9.38|
;;;239    
;;;240        uint32_t instance = I2S_GetInstance(base);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       I2S_GetInstance
00002c  4607              MOV      r7,r0
;;;241        i2s_dma_private_handle_t *privateHandle = &(s_DmaPrivateHandle[instance]);
00002e  eb070087          ADD      r0,r7,r7,LSL #2
000032  eb0000c7          ADD      r0,r0,r7,LSL #3
000036  4929              LDR      r1,|L9.220|
000038  eb010580          ADD      r5,r1,r0,LSL #2
;;;242    
;;;243        /* Abort operation */
;;;244        DMA_AbortTransfer(handle->dmaHandle);
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  f7fffffe          BL       DMA_AbortTransfer
;;;245        if (handle->state == kI2S_DmaStateTx)
000042  6820              LDR      r0,[r4,#0]
000044  2801              CMP      r0,#1
000046  d104              BNE      |L9.82|
;;;246        {
;;;247            I2S_TxEnableDMA(base, false);
000048  2100              MOVS     r1,#0
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       I2S_TxEnableDMA
000050  e003              B        |L9.90|
                  |L9.82|
;;;248        }
;;;249        else
;;;250        {
;;;251            I2S_RxEnableDMA(base, false);
000052  2100              MOVS     r1,#0
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       I2S_RxEnableDMA
                  |L9.90|
;;;252        }
;;;253        I2S_Disable(base);
00005a  bf00              NOP      
00005c  f8d60c00          LDR      r0,[r6,#0xc00]
000060  f0200001          BIC      r0,r0,#1
000064  f8c60c00          STR      r0,[r6,#0xc00]
000068  bf00              NOP      
;;;254    
;;;255        /* Reset state */
;;;256        handle->state = kI2S_DmaStateIdle;
00006a  2000              MOVS     r0,#0
00006c  6020              STR      r0,[r4,#0]
;;;257    
;;;258        /* Clear transfer queue */
;;;259        memset((void *)&(handle->i2sQueue), 0U, sizeof(handle->i2sQueue));
00006e  2120              MOVS     r1,#0x20
000070  f1040010          ADD      r0,r4,#0x10
000074  f7fffffe          BL       __aeabi_memclr4
;;;260        handle->queueDriver = 0U;
000078  2000              MOVS     r0,#0
00007a  f8840031          STRB     r0,[r4,#0x31]
;;;261        handle->queueUser = 0U;
00007e  f8840030          STRB     r0,[r4,#0x30]
;;;262    
;;;263        /* Clear internal state */
;;;264        memset((void *)&(privateHandle->descriptorQueue), 0U, sizeof(privateHandle->descriptorQueue));
000082  2120              MOVS     r1,#0x20
000084  f1050014          ADD      r0,r5,#0x14
000088  f7fffffe          BL       __aeabi_memclr4
;;;265        memset((void *)&(privateHandle->enqueuedBytes), 0U, sizeof(privateHandle->enqueuedBytes));
00008c  2000              MOVS     r0,#0
00008e  60a8              STR      r0,[r5,#8]
000090  81a8              STRH     r0,[r5,#0xc]
;;;266        privateHandle->enqueuedBytesStart = 0U;
000092  73a8              STRB     r0,[r5,#0xe]
;;;267        privateHandle->enqueuedBytesEnd = 0U;
000094  73e8              STRB     r0,[r5,#0xf]
;;;268        privateHandle->initialDescriptor = false;
000096  7428              STRB     r0,[r5,#0x10]
;;;269        privateHandle->dmaDescriptorsUsed = 0U;
000098  7468              STRB     r0,[r5,#0x11]
;;;270        privateHandle->descriptor = 0U;
00009a  74a8              STRB     r0,[r5,#0x12]
;;;271        privateHandle->queueDescriptor = 0U;
00009c  74e8              STRB     r0,[r5,#0x13]
;;;272    }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;273    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L9.164|
0000a4  5352435c          DCB      "SRC\\Drivers\\fsl_i2s_dma.c",0
0000a8  44726976
0000ac  6572735c
0000b0  66736c5f
0000b4  6932735f
0000b8  646d612e
0000bc  6300    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L9.192|
0000c0  68616e64          DCB      "handle",0
0000c4  6c6500  
0000c7  00                DCB      0
                  |L9.200|
0000c8  68616e64          DCB      "handle->dmaHandle",0
0000cc  6c652d3e
0000d0  646d6148
0000d4  616e646c
0000d8  6500    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L9.220|
                          DCD      s_DmaPrivateHandle

                          AREA ||i.I2S_TxEnableDMA||, CODE, READONLY, ALIGN=1

                  I2S_TxEnableDMA PROC
;;;301    
;;;302    static void I2S_TxEnableDMA(I2S_Type *base, bool enable)
000000  b131              CBZ      r1,|L10.16|
;;;303    {
;;;304        if (enable)
;;;305        {
;;;306            base->FIFOCFG |= I2S_FIFOCFG_DMATX_MASK;
000002  f8d02e00          LDR      r2,[r0,#0xe00]
000006  f4425280          ORR      r2,r2,#0x1000
00000a  f8c02e00          STR      r2,[r0,#0xe00]
00000e  e00b              B        |L10.40|
                  |L10.16|
;;;307        }
;;;308        else
;;;309        {
;;;310            base->FIFOCFG &= (~I2S_FIFOCFG_DMATX_MASK);
000010  f8d02e00          LDR      r2,[r0,#0xe00]
000014  f4225280          BIC      r2,r2,#0x1000
000018  f8c02e00          STR      r2,[r0,#0xe00]
;;;311            base->FIFOCFG |= I2S_FIFOCFG_EMPTYTX_MASK;
00001c  f8d02e00          LDR      r2,[r0,#0xe00]
000020  f4423280          ORR      r2,r2,#0x10000
000024  f8c02e00          STR      r2,[r0,#0xe00]
                  |L10.40|
;;;312        }
;;;313    }
000028  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.I2S_TxTransferCreateHandleDMA||, CODE, READONLY, ALIGN=2

                  I2S_TxTransferCreateHandleDMA PROC
;;;189    
;;;190    void I2S_TxTransferCreateHandleDMA(I2S_Type *base,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;191                                       i2s_dma_handle_t *handle,
;;;192                                       dma_handle_t *dmaHandle,
;;;193                                       i2s_dma_transfer_callback_t callback,
;;;194                                       void *userData)
;;;195    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
00000c  f8dda020          LDR      r10,[sp,#0x20]
;;;196        assert(handle);
000010  b104              CBZ      r4,|L11.20|
000012  e004              B        |L11.30|
                  |L11.20|
000014  22c4              MOVS     r2,#0xc4
000016  a118              ADR      r1,|L11.120|
000018  a01e              ADR      r0,|L11.148|
00001a  f7fffffe          BL       __aeabi_assert
                  |L11.30|
;;;197        assert(dmaHandle);
00001e  b106              CBZ      r6,|L11.34|
000020  e004              B        |L11.44|
                  |L11.34|
000022  22c5              MOVS     r2,#0xc5
000024  a114              ADR      r1,|L11.120|
000026  a01d              ADR      r0,|L11.156|
000028  f7fffffe          BL       __aeabi_assert
                  |L11.44|
;;;198    
;;;199        uint32_t instance = I2S_GetInstance(base);
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       I2S_GetInstance
000032  4607              MOV      r7,r0
;;;200        i2s_dma_private_handle_t *privateHandle = &(s_DmaPrivateHandle[instance]);
000034  eb070087          ADD      r0,r7,r7,LSL #2
000038  eb0000c7          ADD      r0,r0,r7,LSL #3
00003c  491a              LDR      r1,|L11.168|
00003e  eb010580          ADD      r5,r1,r0,LSL #2
;;;201    
;;;202        memset(handle, 0U, sizeof(*handle));
000042  2134              MOVS     r1,#0x34
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       __aeabi_memclr4
;;;203        handle->state = kI2S_DmaStateIdle;
00004a  2000              MOVS     r0,#0
00004c  6020              STR      r0,[r4,#0]
;;;204        handle->dmaHandle = dmaHandle;
00004e  60e6              STR      r6,[r4,#0xc]
;;;205        handle->completionCallback = callback;
000050  f8c49004          STR      r9,[r4,#4]
;;;206        handle->userData = userData;
000054  f8c4a008          STR      r10,[r4,#8]
;;;207    
;;;208        memset(privateHandle, 0U, sizeof(*privateHandle));
000058  2134              MOVS     r1,#0x34
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       __aeabi_memclr4
;;;209        privateHandle->base = base;
000060  f8c58000          STR      r8,[r5,#0]
;;;210        privateHandle->handle = handle;
000064  606c              STR      r4,[r5,#4]
;;;211        privateHandle->initialDescriptor = false;
000066  2000              MOVS     r0,#0
000068  7428              STRB     r0,[r5,#0x10]
;;;212    
;;;213        DMA_SetCallback(dmaHandle, I2S_DMACallback, privateHandle);
00006a  462a              MOV      r2,r5
00006c  490f              LDR      r1,|L11.172|
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       DMA_SetCallback
;;;214    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;215    
                          ENDP

                  |L11.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_i2s_dma.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  6932735f
00008c  646d612e
000090  6300    
000092  00                DCB      0
000093  00                DCB      0
                  |L11.148|
000094  68616e64          DCB      "handle",0
000098  6c6500  
00009b  00                DCB      0
                  |L11.156|
00009c  646d6148          DCB      "dmaHandle",0
0000a0  616e646c
0000a4  6500    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L11.168|
                          DCD      s_DmaPrivateHandle
                  |L11.172|
                          DCD      I2S_DMACallback

                          AREA ||i.I2S_TxTransferSendDMA||, CODE, READONLY, ALIGN=1

                  I2S_TxTransferSendDMA PROC
;;;215    
;;;216    status_t I2S_TxTransferSendDMA(I2S_Type *base, i2s_dma_handle_t *handle, i2s_transfer_t transfer)
000000  b57f              PUSH     {r0-r6,lr}
;;;217    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;218        /* Enqueue transfer buffer */
;;;219        status_t status = I2S_EnqueueUserBuffer(base, handle, transfer);
000008  9804              LDR      r0,[sp,#0x10]
00000a  9000              STR      r0,[sp,#0]
00000c  9805              LDR      r0,[sp,#0x14]
00000e  9001              STR      r0,[sp,#4]
000010  4621              MOV      r1,r4
000012  4630              MOV      r0,r6
000014  e9dd2300          LDRD     r2,r3,[sp,#0]
000018  f7fffffe          BL       I2S_EnqueueUserBuffer
00001c  4605              MOV      r5,r0
;;;220        if (status != kStatus_Success)
00001e  b115              CBZ      r5,|L12.38|
;;;221        {
;;;222            return status;
000020  4628              MOV      r0,r5
                  |L12.34|
;;;223        }
;;;224    
;;;225        /* Initialize DMA transfer */
;;;226        if (handle->state == kI2S_DmaStateIdle)
;;;227        {
;;;228            handle->state = kI2S_DmaStateTx;
;;;229            return I2S_StartTransferDMA(base, handle);
;;;230        }
;;;231    
;;;232        return kStatus_Success;
;;;233    }
000022  b006              ADD      sp,sp,#0x18
000024  bd70              POP      {r4-r6,pc}
                  |L12.38|
000026  6820              LDR      r0,[r4,#0]            ;226
000028  b930              CBNZ     r0,|L12.56|
00002a  2001              MOVS     r0,#1                 ;228
00002c  6020              STR      r0,[r4,#0]            ;228
00002e  4621              MOV      r1,r4                 ;229
000030  4630              MOV      r0,r6                 ;229
000032  f7fffffe          BL       I2S_StartTransferDMA
000036  e7f4              B        |L12.34|
                  |L12.56|
000038  2000              MOVS     r0,#0                 ;232
00003a  e7f2              B        |L12.34|
;;;234    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=4

                  s_DmaDescriptors
                          %        64
                  s_DmaPrivateHandle
                          %        104

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_I2sBaseAddrs
                          DCD      0x40097000
                          DCD      0x40098000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  70726976          DCB      "privateHandle->enqueuedBytes[privateHandle->enqueuedByt"
000004  61746548
000008  616e646c
00000c  652d3e65
000010  6e717565
000014  75656442
000018  79746573
00001c  5b707269
000020  76617465
000024  48616e64
000028  6c652d3e
00002c  656e7175
000030  65756564
000034  427974  
000037  65735374          DCB      "esStart] > 0U",0
00003b  6172745d
00003f  203e2030
000043  5500    

                          AREA ||.data||, DATA, ALIGN=2

                  s_DummyBufferTx
                          DCD      0x00000000
                  s_DummyBufferRx
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_i2s_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_i2s_dma_c_e29bf968____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_fsl_i2s_dma_c_e29bf968____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_i2s_dma_c_e29bf968____REVSH|
#line 402
|__asm___13_fsl_i2s_dma_c_e29bf968____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_fsl_i2s_dma_c_e29bf968____RRX|
#line 587
|__asm___13_fsl_i2s_dma_c_e29bf968____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
