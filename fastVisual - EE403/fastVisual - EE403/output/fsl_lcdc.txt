; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_lcdc.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_lcdc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_lcdc.crf SRC\Drivers\fsl_lcdc.c]
                          THUMB

                          AREA ||i.CLOCK_EnableClock||, CODE, READONLY, ALIGN=2

                  CLOCK_EnableClock PROC
;;;705    
;;;706    static inline void CLOCK_EnableClock(clock_ip_name_t clk)
000000  0a01              LSRS     r1,r0,#8
;;;707    {
;;;708        uint32_t index = CLK_GATE_ABSTRACT_REG_OFFSET(clk);
;;;709        if (index < 3)
000002  2903              CMP      r1,#3
000004  d205              BCS      |L1.18|
;;;710        {
;;;711            SYSCON->AHBCLKCTRLSET[index] = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
000006  2201              MOVS     r2,#1
000008  4082              LSLS     r2,r2,r0
00000a  4b05              LDR      r3,|L1.32|
00000c  f8432021          STR      r2,[r3,r1,LSL #2]
000010  e005              B        |L1.30|
                  |L1.18|
;;;712        }
;;;713        else
;;;714        {
;;;715            SYSCON->ASYNCAPBCTRL = SYSCON_ASYNCAPBCTRL_ENABLE(1);
000012  2201              MOVS     r2,#1
000014  0793              LSLS     r3,r2,#30
000016  64da              STR      r2,[r3,#0x4c]
;;;716            ASYNC_SYSCON->ASYNCAPBCLKCTRLSET = (1U << CLK_GATE_ABSTRACT_BITS_SHIFT(clk));
000018  4082              LSLS     r2,r2,r0
00001a  4b02              LDR      r3,|L1.36|
00001c  615a              STR      r2,[r3,#0x14]
                  |L1.30|
;;;717        }
;;;718    }
00001e  4770              BX       lr
;;;719    
                          ENDP

                  |L1.32|
                          DCD      0x40000220
                  |L1.36|
                          DCD      0x40040000

                          AREA ||i.LCDC_ClearInterruptsStatus||, CODE, READONLY, ALIGN=1

                  LCDC_ClearInterruptsStatus PROC
;;;372    
;;;373    void LCDC_ClearInterruptsStatus(LCD_Type *base, uint32_t mask)
000000  4602              MOV      r2,r0
;;;374    {
;;;375        uint32_t reg;
;;;376    
;;;377        reg = mask & LCDC_CURSOR_INT_MASK;
000002  f0010001          AND      r0,r1,#1
;;;378        if (reg)
000006  b108              CBZ      r0,|L2.12|
;;;379        {
;;;380            base->CRSR_INTCLR = reg;
000008  f8c20c24          STR      r0,[r2,#0xc24]
                  |L2.12|
;;;381        }
;;;382    
;;;383        reg = mask & LCDC_NORMAL_INT_MASK;
00000c  f001001e          AND      r0,r1,#0x1e
;;;384        if (reg)
000010  b100              CBZ      r0,|L2.20|
;;;385        {
;;;386            base->INTCLR = reg;
000012  6290              STR      r0,[r2,#0x28]
                  |L2.20|
;;;387        }
;;;388    }
000014  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.LCDC_CursorGetDefaultConfig||, CODE, READONLY, ALIGN=1

                  LCDC_CursorGetDefaultConfig PROC
;;;426    
;;;427    void LCDC_CursorGetDefaultConfig(lcdc_cursor_config_t *config)
000000  2200              MOVS     r2,#0
;;;428    {
;;;429        uint32_t i;
;;;430    
;;;431        config->size = kLCDC_CursorSize32;
000002  7002              STRB     r2,[r0,#0]
;;;432        config->syncMode = kLCDC_CursorAsync;
000004  7042              STRB     r2,[r0,#1]
;;;433        config->palette0.red = 0U;
000006  7082              STRB     r2,[r0,#2]
;;;434        config->palette0.green = 0U;
000008  2300              MOVS     r3,#0
00000a  70c3              STRB     r3,[r0,#3]
;;;435        config->palette0.blue = 0U;
00000c  7103              STRB     r3,[r0,#4]
;;;436        config->palette1.red = 255U;
00000e  22ff              MOVS     r2,#0xff
000010  7142              STRB     r2,[r0,#5]
;;;437        config->palette1.green = 255U;
000012  23ff              MOVS     r3,#0xff
000014  7183              STRB     r3,[r0,#6]
;;;438        config->palette1.blue = 255U;
000016  71c3              STRB     r3,[r0,#7]
;;;439    
;;;440        for (i = 0; i < LCDC_CURSOR_COUNT; i++)
000018  2100              MOVS     r1,#0
00001a  e005              B        |L3.40|
                  |L3.28|
;;;441        {
;;;442            config->image[i] = (uint32_t *)0;
00001c  2300              MOVS     r3,#0
00001e  f1000208          ADD      r2,r0,#8
000022  f8423021          STR      r3,[r2,r1,LSL #2]
000026  1c49              ADDS     r1,r1,#1              ;440
                  |L3.40|
000028  2904              CMP      r1,#4                 ;440
00002a  d3f7              BCC      |L3.28|
;;;443        }
;;;444    }
00002c  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.LCDC_Deinit||, CODE, READONLY, ALIGN=2

                  LCDC_Deinit PROC
;;;261    
;;;262    void LCDC_Deinit(LCD_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4604              MOV      r4,r0
;;;264    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;265        CLOCK_EnableClock(s_lcdClocks[LCDC_GetInstance(base)]);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       LCDC_GetInstance
00000a  4903              LDR      r1,|L4.24|
00000c  f8315010          LDRH     r5,[r1,r0,LSL #1]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       CLOCK_EnableClock
;;;266    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;267    }
000016  bd70              POP      {r4-r6,pc}
;;;268    
                          ENDP

                  |L4.24|
                          DCD      s_lcdClocks

                          AREA ||i.LCDC_DisableInterrupts||, CODE, READONLY, ALIGN=1

                  LCDC_DisableInterrupts PROC
;;;335    
;;;336    void LCDC_DisableInterrupts(LCD_Type *base, uint32_t mask)
000000  460a              MOV      r2,r1
;;;337    {
;;;338        uint32_t reg;
;;;339    
;;;340        reg = mask & LCDC_CURSOR_INT_MASK;
000002  f0020101          AND      r1,r2,#1
;;;341        if (reg)
000006  b121              CBZ      r1,|L5.18|
;;;342        {
;;;343            base->CRSR_INTMSK &= ~reg;
000008  f8d03c20          LDR      r3,[r0,#0xc20]
00000c  438b              BICS     r3,r3,r1
00000e  f8c03c20          STR      r3,[r0,#0xc20]
                  |L5.18|
;;;344        }
;;;345    
;;;346        reg = mask & LCDC_NORMAL_INT_MASK;
000012  f002011e          AND      r1,r2,#0x1e
;;;347        if (reg)
000016  b111              CBZ      r1,|L5.30|
;;;348        {
;;;349            base->INTMSK &= ~reg;
000018  69c3              LDR      r3,[r0,#0x1c]
00001a  438b              BICS     r3,r3,r1
00001c  61c3              STR      r3,[r0,#0x1c]
                  |L5.30|
;;;350        }
;;;351    }
00001e  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.LCDC_EnableInterrupts||, CODE, READONLY, ALIGN=1

                  LCDC_EnableInterrupts PROC
;;;318    
;;;319    void LCDC_EnableInterrupts(LCD_Type *base, uint32_t mask)
000000  460a              MOV      r2,r1
;;;320    {
;;;321        uint32_t reg;
;;;322    
;;;323        reg = mask & LCDC_CURSOR_INT_MASK;
000002  f0020101          AND      r1,r2,#1
;;;324        if (reg)
000006  b121              CBZ      r1,|L6.18|
;;;325        {
;;;326            base->CRSR_INTMSK |= reg;
000008  f8d03c20          LDR      r3,[r0,#0xc20]
00000c  430b              ORRS     r3,r3,r1
00000e  f8c03c20          STR      r3,[r0,#0xc20]
                  |L6.18|
;;;327        }
;;;328    
;;;329        reg = mask & LCDC_NORMAL_INT_MASK;
000012  f002011e          AND      r1,r2,#0x1e
;;;330        if (reg)
000016  b111              CBZ      r1,|L6.30|
;;;331        {
;;;332            base->INTMSK |= reg;
000018  69c3              LDR      r3,[r0,#0x1c]
00001a  430b              ORRS     r3,r3,r1
00001c  61c3              STR      r3,[r0,#0x1c]
                  |L6.30|
;;;333        }
;;;334    }
00001e  4770              BX       lr
;;;335    
                          ENDP


                          AREA ||i.LCDC_GetClockDivider||, CODE, READONLY, ALIGN=2

                  LCDC_GetClockDivider PROC
;;;116    
;;;117    static bool LCDC_GetClockDivider(const lcdc_config_t *config, uint32_t srcClock_Hz, uint32_t *divider)
000000  b5f0              PUSH     {r4-r7,lr}
;;;118    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
;;;119        uint16_t cpl;
;;;120        uint32_t pcd;
;;;121    
;;;122        *divider = 0U;
000006  2000              MOVS     r0,#0
000008  6010              STR      r0,[r2,#0]
;;;123    
;;;124        /* Find the PCD. */
;;;125        pcd = (srcClock_Hz + (config->panelClock_Hz / 2U)) / config->panelClock_Hz;
00000a  6818              LDR      r0,[r3,#0]
00000c  eb050050          ADD      r0,r5,r0,LSR #1
000010  681e              LDR      r6,[r3,#0]
000012  fbb0f1f6          UDIV     r1,r0,r6
;;;126    
;;;127        if (pcd <= 1U)
000016  2901              CMP      r1,#1
000018  d809              BHI      |L7.46|
;;;128        {
;;;129            if (kLCDC_DisplayTFT == config->display)
00001a  f8930021          LDRB     r0,[r3,#0x21]
00001e  2820              CMP      r0,#0x20
000020  d103              BNE      |L7.42|
;;;130            {
;;;131                pcd = 0U;
000022  2100              MOVS     r1,#0
;;;132                *divider = LCD_POL_BCD_MASK;
000024  0540              LSLS     r0,r0,#21
000026  6010              STR      r0,[r2,#0]
000028  e02a              B        |L7.128|
                  |L7.42|
;;;133            }
;;;134            else
;;;135            {
;;;136                return false;
00002a  2000              MOVS     r0,#0
                  |L7.44|
;;;137            }
;;;138        }
;;;139        else
;;;140        {
;;;141            pcd -= 2U;
;;;142    
;;;143            /* Verify the PCD value. */
;;;144            if (pcd > LCD_PCD_MAX)
;;;145            {
;;;146                return false;
;;;147            }
;;;148    
;;;149            if (((kLCDC_DisplaySingleColorSTN8Bit == config->display) && (pcd < 1U)) ||
;;;150                ((kLCDC_DisplayDualColorSTN8Bit == config->display) && (pcd < 4U)) ||
;;;151                ((kLCDC_DisplaySingleMonoSTN4Bit == config->display) && (pcd < 2U)) ||
;;;152                ((kLCDC_DisplaySingleMonoSTN8Bit == config->display) && (pcd < 8U)) ||
;;;153                ((kLCDC_DisplayDualMonoSTN4Bit == config->display) && (pcd < 8U)) ||
;;;154                ((kLCDC_DisplayDualMonoSTN8Bit == config->display) && (pcd < 14U)))
;;;155            {
;;;156                return false;
;;;157            }
;;;158        }
;;;159    
;;;160        if (config->display & LCD_CTRL_LCDTFT_MASK)
;;;161        {
;;;162            /* TFT panel. */
;;;163            cpl = config->ppl - 1U;
;;;164        }
;;;165        else
;;;166        {
;;;167            if (config->display & LCD_CTRL_LCDBW_MASK)
;;;168            {
;;;169                if (config->display & LCD_CTRL_LCDMONO8_MASK)
;;;170                {
;;;171                    /* 8-bit monochrome STN panel. */
;;;172                    cpl = (config->ppl / 8U) - 1U;
;;;173                }
;;;174                else
;;;175                {
;;;176                    /* 4-bit monochrome STN panel. */
;;;177                    cpl = (config->ppl / 4U) - 1U;
;;;178                }
;;;179            }
;;;180            else
;;;181            {
;;;182                /* Color STN panel. */
;;;183                cpl = ((config->ppl * 3U) / 8U) - 1U;
;;;184            }
;;;185        }
;;;186    
;;;187        *divider |= (LCD_POL_CPL(cpl) | LCD_POL_PCD(pcd));
;;;188    
;;;189        return true;
;;;190    }
00002c  bdf0              POP      {r4-r7,pc}
                  |L7.46|
00002e  1e89              SUBS     r1,r1,#2              ;141
000030  291f              CMP      r1,#0x1f              ;144
000032  d901              BLS      |L7.56|
000034  2000              MOVS     r0,#0                 ;146
000036  e7f9              B        |L7.44|
                  |L7.56|
000038  f8930021          LDRB     r0,[r3,#0x21]         ;149
00003c  b900              CBNZ     r0,|L7.64|
00003e  b1e9              CBZ      r1,|L7.124|
                  |L7.64|
000040  f8930021          LDRB     r0,[r3,#0x21]         ;150
000044  2880              CMP      r0,#0x80              ;150
000046  d101              BNE      |L7.76|
000048  2904              CMP      r1,#4                 ;150
00004a  d317              BCC      |L7.124|
                  |L7.76|
00004c  f8930021          LDRB     r0,[r3,#0x21]         ;151
000050  2810              CMP      r0,#0x10              ;151
000052  d101              BNE      |L7.88|
000054  2902              CMP      r1,#2                 ;151
000056  d311              BCC      |L7.124|
                  |L7.88|
000058  f8930021          LDRB     r0,[r3,#0x21]         ;152
00005c  2850              CMP      r0,#0x50              ;152
00005e  d101              BNE      |L7.100|
000060  2908              CMP      r1,#8                 ;152
000062  d30b              BCC      |L7.124|
                  |L7.100|
000064  f8930021          LDRB     r0,[r3,#0x21]         ;153
000068  2890              CMP      r0,#0x90              ;153
00006a  d101              BNE      |L7.112|
00006c  2908              CMP      r1,#8                 ;153
00006e  d305              BCC      |L7.124|
                  |L7.112|
000070  f8930021          LDRB     r0,[r3,#0x21]         ;154
000074  28d0              CMP      r0,#0xd0              ;154
000076  d103              BNE      |L7.128|
000078  290e              CMP      r1,#0xe               ;154
00007a  d201              BCS      |L7.128|
                  |L7.124|
00007c  2000              MOVS     r0,#0                 ;156
00007e  e7d5              B        |L7.44|
                  |L7.128|
000080  f8930021          LDRB     r0,[r3,#0x21]         ;160
000084  f0000020          AND      r0,r0,#0x20           ;160
000088  b118              CBZ      r0,|L7.146|
00008a  8898              LDRH     r0,[r3,#4]            ;163
00008c  1e40              SUBS     r0,r0,#1              ;163
00008e  b284              UXTH     r4,r0                 ;163
000090  e01c              B        |L7.204|
                  |L7.146|
000092  f8930021          LDRB     r0,[r3,#0x21]         ;167
000096  f0000010          AND      r0,r0,#0x10           ;167
00009a  b180              CBZ      r0,|L7.190|
00009c  f8930021          LDRB     r0,[r3,#0x21]         ;169
0000a0  f0000040          AND      r0,r0,#0x40           ;169
0000a4  b128              CBZ      r0,|L7.178|
0000a6  8898              LDRH     r0,[r3,#4]            ;172
0000a8  2601              MOVS     r6,#1                 ;172
0000aa  ebc600d0          RSB      r0,r6,r0,LSR #3       ;172
0000ae  b284              UXTH     r4,r0                 ;172
0000b0  e00c              B        |L7.204|
                  |L7.178|
0000b2  8898              LDRH     r0,[r3,#4]            ;177
0000b4  2601              MOVS     r6,#1                 ;177
0000b6  ebc60090          RSB      r0,r6,r0,LSR #2       ;177
0000ba  b284              UXTH     r4,r0                 ;177
0000bc  e006              B        |L7.204|
                  |L7.190|
0000be  8898              LDRH     r0,[r3,#4]            ;183
0000c0  eb000040          ADD      r0,r0,r0,LSL #1       ;183
0000c4  2601              MOVS     r6,#1                 ;183
0000c6  ebc600d0          RSB      r0,r6,r0,LSR #3       ;183
0000ca  b284              UXTH     r4,r0                 ;183
                  |L7.204|
0000cc  f001001f          AND      r0,r1,#0x1f           ;187
0000d0  094e              LSRS     r6,r1,#5              ;187
0000d2  f04f4778          MOV      r7,#0xf8000000        ;187
0000d6  ea0766c6          AND      r6,r7,r6,LSL #27      ;187
0000da  4330              ORRS     r0,r0,r6              ;187
0000dc  4e04              LDR      r6,|L7.240|
0000de  ea064604          AND      r6,r6,r4,LSL #16      ;187
0000e2  4330              ORRS     r0,r0,r6              ;187
0000e4  6816              LDR      r6,[r2,#0]            ;187
0000e6  4330              ORRS     r0,r0,r6              ;187
0000e8  6010              STR      r0,[r2,#0]            ;187
0000ea  2001              MOVS     r0,#1                 ;189
0000ec  e79e              B        |L7.44|
;;;191    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L7.240|
                          DCD      0x03ff0000

                          AREA ||i.LCDC_GetDefaultConfig||, CODE, READONLY, ALIGN=1

                  LCDC_GetDefaultConfig PROC
;;;268    
;;;269    void LCDC_GetDefaultConfig(lcdc_config_t *config)
000000  2100              MOVS     r1,#0
;;;270    {
;;;271        config->panelClock_Hz = 0U;
000002  6001              STR      r1,[r0,#0]
;;;272        config->ppl = 0U;
000004  8081              STRH     r1,[r0,#4]
;;;273        config->hsw = 0U;
000006  7181              STRB     r1,[r0,#6]
;;;274        config->hfp = 0U;
000008  71c1              STRB     r1,[r0,#7]
;;;275        config->hbp = 0U;
00000a  7201              STRB     r1,[r0,#8]
;;;276        config->lpp = 0U;
00000c  8141              STRH     r1,[r0,#0xa]
;;;277        config->vsw = 0U;
00000e  7301              STRB     r1,[r0,#0xc]
;;;278        config->vfp = 0U;
000010  7341              STRB     r1,[r0,#0xd]
;;;279        config->vbp = 0U;
000012  7381              STRB     r1,[r0,#0xe]
;;;280        config->acBiasFreq = 1U;
000014  2101              MOVS     r1,#1
000016  73c1              STRB     r1,[r0,#0xf]
;;;281        config->polarityFlags = 0U;
000018  2100              MOVS     r1,#0
00001a  8201              STRH     r1,[r0,#0x10]
;;;282        config->enableLineEnd = false;
00001c  7481              STRB     r1,[r0,#0x12]
;;;283        config->lineEndDelay = 0U;
00001e  74c1              STRB     r1,[r0,#0x13]
;;;284        config->upperPanelAddr = 0U;
000020  6141              STR      r1,[r0,#0x14]
;;;285        config->lowerPanelAddr = 0U;
000022  6181              STR      r1,[r0,#0x18]
;;;286        config->bpp = kLCDC_1BPP;
000024  7701              STRB     r1,[r0,#0x1c]
;;;287        config->dataFormat = kLCDC_LittleEndian;
000026  83c1              STRH     r1,[r0,#0x1e]
;;;288        config->swapRedBlue = false;
000028  f8801020          STRB     r1,[r0,#0x20]
;;;289        config->display = kLCDC_DisplayTFT;
00002c  2120              MOVS     r1,#0x20
00002e  f8801021          STRB     r1,[r0,#0x21]
;;;290    }
000032  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||i.LCDC_GetEnabledInterruptsPendingStatus||, CODE, READONLY, ALIGN=1

                  LCDC_GetEnabledInterruptsPendingStatus PROC
;;;362    
;;;363    uint32_t LCDC_GetEnabledInterruptsPendingStatus(LCD_Type *base)
000000  4601              MOV      r1,r0
;;;364    {
;;;365        uint32_t reg;
;;;366    
;;;367        reg = base->CRSR_INTSTAT;
000002  f8d10c2c          LDR      r0,[r1,#0xc2c]
;;;368        reg |= base->INTSTAT;
000006  6a4a              LDR      r2,[r1,#0x24]
000008  4310              ORRS     r0,r0,r2
;;;369    
;;;370        return reg;
;;;371    }
00000a  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.LCDC_GetInstance||, CODE, READONLY, ALIGN=2

                  LCDC_GetInstance PROC
;;;98      ******************************************************************************/
;;;99     static uint32_t LCDC_GetInstance(LCD_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
000002  4605              MOV      r5,r0
;;;101        uint32_t instance;
;;;102    
;;;103        /* Find the instance index from base address mappings. */
;;;104        for (instance = 0; instance < ARRAY_SIZE(s_lcdBases); instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L10.22|
                  |L10.8|
;;;105        {
;;;106            if (s_lcdBases[instance] == base)
000008  4809              LDR      r0,|L10.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L10.20|
;;;107            {
;;;108                break;
000012  e002              B        |L10.26|
                  |L10.20|
000014  1c64              ADDS     r4,r4,#1              ;104
                  |L10.22|
000016  2c00              CMP      r4,#0                 ;104
000018  d0f6              BEQ      |L10.8|
                  |L10.26|
00001a  bf00              NOP      
;;;109            }
;;;110        }
;;;111    
;;;112        assert(instance < ARRAY_SIZE(s_lcdBases));
00001c  b904              CBNZ     r4,|L10.32|
00001e  e004              B        |L10.42|
                  |L10.32|
000020  2270              MOVS     r2,#0x70
000022  a104              ADR      r1,|L10.52|
000024  a009              ADR      r0,|L10.76|
000026  f7fffffe          BL       __aeabi_assert
                  |L10.42|
;;;113    
;;;114        return instance;
00002a  4620              MOV      r0,r4
;;;115    }
00002c  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      s_lcdBases
                  |L10.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_lcdc.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  6c636463
000048  2e6300  
00004b  00                DCB      0
                  |L10.76|
00004c  696e7374          DCB      "instance < ARRAY_SIZE(s_lcdBases)",0
000050  616e6365
000054  203c2041
000058  52524159
00005c  5f53495a
000060  4528735f
000064  6c636442
000068  61736573
00006c  2900    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.LCDC_GetInterruptsPendingStatus||, CODE, READONLY, ALIGN=1

                  LCDC_GetInterruptsPendingStatus PROC
;;;352    
;;;353    uint32_t LCDC_GetInterruptsPendingStatus(LCD_Type *base)
000000  4601              MOV      r1,r0
;;;354    {
;;;355        uint32_t reg;
;;;356    
;;;357        reg = base->CRSR_INTRAW;
000002  f8d10c28          LDR      r0,[r1,#0xc28]
;;;358        reg |= base->INTRAW;
000006  6a0a              LDR      r2,[r1,#0x20]
000008  4310              ORRS     r0,r0,r2
;;;359    
;;;360        return reg;
;;;361    }
00000a  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.LCDC_Init||, CODE, READONLY, ALIGN=2

                  LCDC_Init PROC
;;;191    
;;;192    status_t LCDC_Init(LCD_Type *base, const lcdc_config_t *config, uint32_t srcClock_Hz)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;193    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;194        assert(config);
00000a  b104              CBZ      r4,|L12.14|
00000c  e004              B        |L12.24|
                  |L12.14|
00000e  22c2              MOVS     r2,#0xc2
000010  a156              ADR      r1,|L12.364|
000012  a05c              ADR      r0,|L12.388|
000014  f7fffffe          BL       __aeabi_assert
                  |L12.24|
;;;195        assert(srcClock_Hz);
000018  b106              CBZ      r6,|L12.28|
00001a  e004              B        |L12.38|
                  |L12.28|
00001c  22c3              MOVS     r2,#0xc3
00001e  a153              ADR      r1,|L12.364|
000020  a05a              ADR      r0,|L12.396|
000022  f7fffffe          BL       __aeabi_assert
                  |L12.38|
;;;196        assert((config->ppl & 0xFU) == 0U);
000026  7920              LDRB     r0,[r4,#4]
000028  f000000f          AND      r0,r0,#0xf
00002c  b900              CBNZ     r0,|L12.48|
00002e  e004              B        |L12.58|
                  |L12.48|
000030  22c4              MOVS     r2,#0xc4
000032  a14e              ADR      r1,|L12.364|
000034  a058              ADR      r0,|L12.408|
000036  f7fffffe          BL       __aeabi_assert
                  |L12.58|
;;;197        assert((config->upperPanelAddr & 0x07U) == 0U);
00003a  7d20              LDRB     r0,[r4,#0x14]
00003c  f0000007          AND      r0,r0,#7
000040  b900              CBNZ     r0,|L12.68|
000042  e004              B        |L12.78|
                  |L12.68|
000044  22c5              MOVS     r2,#0xc5
000046  a149              ADR      r1,|L12.364|
000048  a05a              ADR      r0,|L12.436|
00004a  f7fffffe          BL       __aeabi_assert
                  |L12.78|
;;;198        assert((config->lowerPanelAddr & 0x07U) == 0U);
00004e  7e20              LDRB     r0,[r4,#0x18]
000050  f0000007          AND      r0,r0,#7
000054  b900              CBNZ     r0,|L12.88|
000056  e004              B        |L12.98|
                  |L12.88|
000058  22c6              MOVS     r2,#0xc6
00005a  a144              ADR      r1,|L12.364|
00005c  a05f              ADR      r0,|L12.476|
00005e  f7fffffe          BL       __aeabi_assert
                  |L12.98|
;;;199    
;;;200        uint32_t reg;
;;;201        uint32_t divider;
;;;202        uint32_t instance;
;;;203    
;;;204        /* Verify the clock here. */
;;;205        if (!LCDC_GetClockDivider(config, srcClock_Hz, &divider))
000062  466a              MOV      r2,sp
000064  4631              MOV      r1,r6
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       LCDC_GetClockDivider
00006c  b910              CBNZ     r0,|L12.116|
;;;206        {
;;;207            return kStatus_InvalidArgument;
00006e  2004              MOVS     r0,#4
                  |L12.112|
;;;208        }
;;;209    
;;;210        instance = LCDC_GetInstance(base);
;;;211    
;;;212    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;213        CLOCK_EnableClock(s_lcdClocks[instance]);
;;;214    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;215    
;;;216        /* Reset the module */
;;;217        RESET_PeripheralReset(s_lcdResets[instance]);
;;;218    
;;;219        /* Set register CTRL. */
;;;220        reg = base->CTRL & (LCD_CTRL_LCDVCOMP_MASK | LCD_CTRL_WATERMARK_MASK);
;;;221        reg |= (uint32_t)(config->dataFormat) | (uint32_t)(config->display) | LCD_CTRL_LCDBPP(config->bpp);
;;;222    
;;;223        if (config->swapRedBlue)
;;;224        {
;;;225            reg |= LCD_CTRL_BGR_MASK;
;;;226        }
;;;227    
;;;228        base->CTRL = reg;
;;;229    
;;;230        /* Clean pending interrupts and disable all interrupts. */
;;;231        base->INTCLR = LCDC_NORMAL_INT_MASK;
;;;232        base->CRSR_INTCLR = LCDC_CURSOR_INT_MASK;
;;;233        base->INTMSK = 0U;
;;;234        base->CRSR_INTMSK = 0U;
;;;235    
;;;236        /* Configure timing. */
;;;237        base->TIMH = LCD_TIMH_PPL((config->ppl / 16U) - 1U) | LCD_TIMH_HSW(config->hsw - 1U) |
;;;238                     LCD_TIMH_HFP(config->hfp - 1U) | LCD_TIMH_HBP(config->hbp - 1U);
;;;239    
;;;240        base->TIMV = LCD_TIMV_LPP(config->lpp - 1U) | LCD_TIMV_VSW(config->vsw - 1U) | LCD_TIMV_VFP(config->vfp - 1U) |
;;;241                     LCD_TIMV_VBP(config->vbp - 1U);
;;;242    
;;;243        base->POL = (uint32_t)(config->polarityFlags) | LCD_POL_ACB(config->acBiasFreq - 1U) | divider;
;;;244    
;;;245        /* Line end configuration. */
;;;246        if (config->enableLineEnd)
;;;247        {
;;;248            base->LE = LCD_LE_LED(config->lineEndDelay - 1U) | LCD_LE_LEE_MASK;
;;;249        }
;;;250        else
;;;251        {
;;;252            base->LE = 0U;
;;;253        }
;;;254    
;;;255        /* Set panel frame base address. */
;;;256        base->UPBASE = config->upperPanelAddr;
;;;257        base->LPBASE = config->lowerPanelAddr;
;;;258    
;;;259        return kStatus_Success;
;;;260    }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L12.116|
000074  4628              MOV      r0,r5                 ;210
000076  f7fffffe          BL       LCDC_GetInstance
00007a  4680              MOV      r8,r0                 ;210
00007c  4961              LDR      r1,|L12.516|
00007e  f8310018          LDRH     r0,[r1,r8,LSL #1]     ;213
000082  f7fffffe          BL       CLOCK_EnableClock
000086  4960              LDR      r1,|L12.520|
000088  f8510028          LDR      r0,[r1,r8,LSL #2]     ;217
00008c  f7fffffe          BL       RESET_PeripheralReset
000090  69a8              LDR      r0,[r5,#0x18]         ;220
000092  f4003798          AND      r7,r0,#0x13000        ;220
000096  8be0              LDRH     r0,[r4,#0x1e]         ;221
000098  f8941021          LDRB     r1,[r4,#0x21]         ;221
00009c  4308              ORRS     r0,r0,r1              ;221
00009e  7f21              LDRB     r1,[r4,#0x1c]         ;221
0000a0  220e              MOVS     r2,#0xe               ;221
0000a2  ea020141          AND      r1,r2,r1,LSL #1       ;221
0000a6  4308              ORRS     r0,r0,r1              ;221
0000a8  4307              ORRS     r7,r7,r0              ;221
0000aa  f8940020          LDRB     r0,[r4,#0x20]         ;223
0000ae  b108              CBZ      r0,|L12.180|
0000b0  f4477780          ORR      r7,r7,#0x100          ;225
                  |L12.180|
0000b4  61af              STR      r7,[r5,#0x18]         ;228
0000b6  201e              MOVS     r0,#0x1e              ;231
0000b8  62a8              STR      r0,[r5,#0x28]         ;231
0000ba  2001              MOVS     r0,#1                 ;232
0000bc  f8c50c24          STR      r0,[r5,#0xc24]        ;232
0000c0  2000              MOVS     r0,#0                 ;233
0000c2  61e8              STR      r0,[r5,#0x1c]         ;233
0000c4  f8c50c20          STR      r0,[r5,#0xc20]        ;234
0000c8  88a0              LDRH     r0,[r4,#4]            ;237
0000ca  2101              MOVS     r1,#1                 ;237
0000cc  ebc11010          RSB      r0,r1,r0,LSR #4       ;237
0000d0  21fc              MOVS     r1,#0xfc              ;237
0000d2  ea010080          AND      r0,r1,r0,LSL #2       ;237
0000d6  79a1              LDRB     r1,[r4,#6]            ;237
0000d8  1e49              SUBS     r1,r1,#1              ;237
0000da  f44f427f          MOV      r2,#0xff00            ;237
0000de  ea022101          AND      r1,r2,r1,LSL #8       ;237
0000e2  4308              ORRS     r0,r0,r1              ;237
0000e4  79e1              LDRB     r1,[r4,#7]            ;237
0000e6  1e49              SUBS     r1,r1,#1              ;237
0000e8  0212              LSLS     r2,r2,#8              ;237
0000ea  ea024101          AND      r1,r2,r1,LSL #16      ;237
0000ee  4308              ORRS     r0,r0,r1              ;237
0000f0  7a21              LDRB     r1,[r4,#8]            ;237
0000f2  1e49              SUBS     r1,r1,#1              ;237
0000f4  0212              LSLS     r2,r2,#8              ;237
0000f6  ea026101          AND      r1,r2,r1,LSL #24      ;237
0000fa  4308              ORRS     r0,r0,r1              ;237
0000fc  6028              STR      r0,[r5,#0]            ;237
0000fe  8960              LDRH     r0,[r4,#0xa]          ;240
000100  1e40              SUBS     r0,r0,#1              ;240
000102  f3c00009          UBFX     r0,r0,#0,#10          ;240
000106  7b21              LDRB     r1,[r4,#0xc]          ;240
000108  1e49              SUBS     r1,r1,#1              ;240
00010a  f44f427c          MOV      r2,#0xfc00            ;240
00010e  ea022181          AND      r1,r2,r1,LSL #10      ;240
000112  4308              ORRS     r0,r0,r1              ;240
000114  7b61              LDRB     r1,[r4,#0xd]          ;240
000116  1e49              SUBS     r1,r1,#1              ;240
000118  f44f027f          MOV      r2,#0xff0000          ;240
00011c  ea024101          AND      r1,r2,r1,LSL #16      ;240
000120  4308              ORRS     r0,r0,r1              ;240
000122  7ba1              LDRB     r1,[r4,#0xe]          ;240
000124  1e49              SUBS     r1,r1,#1              ;240
000126  0212              LSLS     r2,r2,#8              ;240
000128  ea026101          AND      r1,r2,r1,LSL #24      ;240
00012c  4308              ORRS     r0,r0,r1              ;240
00012e  6068              STR      r0,[r5,#4]            ;240
000130  8a20              LDRH     r0,[r4,#0x10]         ;243
000132  7be1              LDRB     r1,[r4,#0xf]          ;243
000134  1e49              SUBS     r1,r1,#1              ;243
000136  f44f62f8          MOV      r2,#0x7c0             ;243
00013a  ea021181          AND      r1,r2,r1,LSL #6       ;243
00013e  4308              ORRS     r0,r0,r1              ;243
000140  9900              LDR      r1,[sp,#0]            ;243
000142  4308              ORRS     r0,r0,r1              ;243
000144  60a8              STR      r0,[r5,#8]            ;243
000146  7ca0              LDRB     r0,[r4,#0x12]         ;246
000148  b138              CBZ      r0,|L12.346|
00014a  7ce0              LDRB     r0,[r4,#0x13]         ;248
00014c  1e40              SUBS     r0,r0,#1              ;248
00014e  f000007f          AND      r0,r0,#0x7f           ;248
000152  f4403080          ORR      r0,r0,#0x10000        ;248
000156  60e8              STR      r0,[r5,#0xc]          ;248
000158  e001              B        |L12.350|
                  |L12.346|
00015a  2000              MOVS     r0,#0                 ;252
00015c  60e8              STR      r0,[r5,#0xc]          ;252
                  |L12.350|
00015e  6960              LDR      r0,[r4,#0x14]         ;256
000160  6128              STR      r0,[r5,#0x10]         ;256
000162  69a0              LDR      r0,[r4,#0x18]         ;257
000164  6168              STR      r0,[r5,#0x14]         ;257
000166  2000              MOVS     r0,#0                 ;259
000168  e782              B        |L12.112|
;;;261    
                          ENDP

00016a  0000              DCW      0x0000
                  |L12.364|
00016c  5352435c          DCB      "SRC\\Drivers\\fsl_lcdc.c",0
000170  44726976
000174  6572735c
000178  66736c5f
00017c  6c636463
000180  2e6300  
000183  00                DCB      0
                  |L12.388|
000184  636f6e66          DCB      "config",0
000188  696700  
00018b  00                DCB      0
                  |L12.396|
00018c  73726343          DCB      "srcClock_Hz",0
000190  6c6f636b
000194  5f487a00
                  |L12.408|
000198  28636f6e          DCB      "(config->ppl & 0xFU) == 0U",0
00019c  6669672d
0001a0  3e70706c
0001a4  20262030
0001a8  78465529
0001ac  203d3d20
0001b0  305500  
0001b3  00                DCB      0
                  |L12.436|
0001b4  28636f6e          DCB      "(config->upperPanelAddr & 0x07U) == 0U",0
0001b8  6669672d
0001bc  3e757070
0001c0  65725061
0001c4  6e656c41
0001c8  64647220
0001cc  26203078
0001d0  30375529
0001d4  203d3d20
0001d8  305500  
0001db  00                DCB      0
                  |L12.476|
0001dc  28636f6e          DCB      "(config->lowerPanelAddr & 0x07U) == 0U",0
0001e0  6669672d
0001e4  3e6c6f77
0001e8  65725061
0001ec  6e656c41
0001f0  64647220
0001f4  26203078
0001f8  30375529
0001fc  203d3d20
000200  305500  
000203  00                DCB      0
                  |L12.516|
                          DCD      s_lcdClocks
                  |L12.520|
                          DCD      s_lcdResets

                          AREA ||i.LCDC_SetCursorConfig||, CODE, READONLY, ALIGN=2

                  LCDC_SetCursorConfig PROC
;;;389    
;;;390    void LCDC_SetCursorConfig(LCD_Type *base, const lcdc_cursor_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;391    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;392        assert(config);
000006  b104              CBZ      r4,|L13.10|
000008  e005              B        |L13.22|
                  |L13.10|
00000a  f44f72c4          MOV      r2,#0x188
00000e  a126              ADR      r1,|L13.168|
000010  a02b              ADR      r0,|L13.192|
000012  f7fffffe          BL       __aeabi_assert
                  |L13.22|
;;;393    
;;;394        uint32_t i;
;;;395    
;;;396        base->CRSR_CFG = LCD_CRSR_CFG_CRSRSIZE(config->size) | LCD_CRSR_CFG_FRAMESYNC(config->syncMode);
000016  7820              LDRB     r0,[r4,#0]
000018  f0000001          AND      r0,r0,#1
00001c  7861              LDRB     r1,[r4,#1]
00001e  2202              MOVS     r2,#2
000020  ea020141          AND      r1,r2,r1,LSL #1
000024  4308              ORRS     r0,r0,r1
000026  f8c60c04          STR      r0,[r6,#0xc04]
;;;397    
;;;398        /* Set position. */
;;;399        LCDC_SetCursorPosition(base, 0, 0);
00002a  2200              MOVS     r2,#0
00002c  4611              MOV      r1,r2
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       LCDC_SetCursorPosition
;;;400    
;;;401        /* Palette. */
;;;402        base->CRSR_PAL0 = ((uint32_t)config->palette0.red << LCD_CRSR_PAL0_RED_SHIFT) |
000034  78a1              LDRB     r1,[r4,#2]
000036  7920              LDRB     r0,[r4,#4]
000038  ea414100          ORR      r1,r1,r0,LSL #16
00003c  78e0              LDRB     r0,[r4,#3]
00003e  ea412000          ORR      r0,r1,r0,LSL #8
000042  f8c60c08          STR      r0,[r6,#0xc08]
;;;403                          ((uint32_t)config->palette0.blue << LCD_CRSR_PAL0_BLUE_SHIFT) |
;;;404                          ((uint32_t)config->palette0.green << LCD_CRSR_PAL0_GREEN_SHIFT);
;;;405        base->CRSR_PAL1 = ((uint32_t)config->palette1.red << LCD_CRSR_PAL1_RED_SHIFT) |
000046  7961              LDRB     r1,[r4,#5]
000048  79e0              LDRB     r0,[r4,#7]
00004a  ea414100          ORR      r1,r1,r0,LSL #16
00004e  79a0              LDRB     r0,[r4,#6]
000050  ea412000          ORR      r0,r1,r0,LSL #8
000054  f8c60c0c          STR      r0,[r6,#0xc0c]
;;;406                          ((uint32_t)config->palette1.blue << LCD_CRSR_PAL1_BLUE_SHIFT) |
;;;407                          ((uint32_t)config->palette1.green << LCD_CRSR_PAL1_GREEN_SHIFT);
;;;408    
;;;409        /* Image of cursors. */
;;;410        if (kLCDC_CursorSize64 == config->size)
000058  7820              LDRB     r0,[r4,#0]
00005a  2801              CMP      r0,#1
00005c  d10f              BNE      |L13.126|
;;;411        {
;;;412            assert(config->image[0]);
00005e  68a0              LDR      r0,[r4,#8]
000060  b100              CBZ      r0,|L13.100|
000062  e005              B        |L13.112|
                  |L13.100|
000064  f44f72ce          MOV      r2,#0x19c
000068  a10f              ADR      r1,|L13.168|
00006a  a017              ADR      r0,|L13.200|
00006c  f7fffffe          BL       __aeabi_assert
                  |L13.112|
;;;413            LCDC_SetCursorImage(base, config->size, 0, config->image[0]);
000070  7821              LDRB     r1,[r4,#0]
000072  2200              MOVS     r2,#0
000074  4630              MOV      r0,r6
000076  68a3              LDR      r3,[r4,#8]
000078  f7fffffe          BL       LCDC_SetCursorImage
00007c  e012              B        |L13.164|
                  |L13.126|
;;;414        }
;;;415        else
;;;416        {
;;;417            for (i = 0; i < LCDC_CURSOR_COUNT; i++)
00007e  2500              MOVS     r5,#0
000080  e00e              B        |L13.160|
                  |L13.130|
;;;418            {
;;;419                if (config->image[i])
000082  f1040008          ADD      r0,r4,#8
000086  f8500025          LDR      r0,[r0,r5,LSL #2]
00008a  b140              CBZ      r0,|L13.158|
;;;420                {
;;;421                    LCDC_SetCursorImage(base, config->size, i, config->image[i]);
00008c  f1040008          ADD      r0,r4,#8
000090  f8503025          LDR      r3,[r0,r5,LSL #2]
000094  b2ea              UXTB     r2,r5
000096  7821              LDRB     r1,[r4,#0]
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       LCDC_SetCursorImage
                  |L13.158|
00009e  1c6d              ADDS     r5,r5,#1              ;417
                  |L13.160|
0000a0  2d04              CMP      r5,#4                 ;417
0000a2  d3ee              BCC      |L13.130|
                  |L13.164|
;;;422                }
;;;423            }
;;;424        }
;;;425    }
0000a4  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L13.168|
0000a8  5352435c          DCB      "SRC\\Drivers\\fsl_lcdc.c",0
0000ac  44726976
0000b0  6572735c
0000b4  66736c5f
0000b8  6c636463
0000bc  2e6300  
0000bf  00                DCB      0
                  |L13.192|
0000c0  636f6e66          DCB      "config",0
0000c4  696700  
0000c7  00                DCB      0
                  |L13.200|
0000c8  636f6e66          DCB      "config->image[0]",0
0000cc  69672d3e
0000d0  696d6167
0000d4  655b305d
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.LCDC_SetCursorImage||, CODE, READONLY, ALIGN=1

                  LCDC_SetCursorImage PROC
;;;486    
;;;487    void LCDC_SetCursorImage(LCD_Type *base, lcdc_cursor_size_t size, uint8_t index, const uint32_t *image)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;488    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;489        uint32_t regStart;
;;;490        uint32_t i;
;;;491        uint32_t len;
;;;492    
;;;493        if (kLCDC_CursorSize64 == size)
00000a  2c01              CMP      r4,#1
00000c  d102              BNE      |L14.20|
;;;494        {
;;;495            regStart = 0U;
00000e  2100              MOVS     r1,#0
;;;496            len = LCDC_CURSOR_IMG_64X64_WORDS;
000010  0222              LSLS     r2,r4,#8
000012  e001              B        |L14.24|
                  |L14.20|
;;;497        }
;;;498        else
;;;499        {
;;;500            regStart = index * LCDC_CURSOR_IMG_32X32_WORDS;
000014  01a9              LSLS     r1,r5,#6
;;;501            len = LCDC_CURSOR_IMG_32X32_WORDS;
000016  2240              MOVS     r2,#0x40
                  |L14.24|
;;;502        }
;;;503    
;;;504        for (i = 0U; i < len; i++)
000018  2000              MOVS     r0,#0
00001a  e008              B        |L14.46|
                  |L14.28|
;;;505        {
;;;506            base->CRSR_IMG[regStart + i] = image[i];
00001c  f853c020          LDR      r12,[r3,r0,LSL #2]
000020  eb010800          ADD      r8,r1,r0
000024  f5066700          ADD      r7,r6,#0x800
000028  f847c028          STR      r12,[r7,r8,LSL #2]
00002c  1c40              ADDS     r0,r0,#1              ;504
                  |L14.46|
00002e  4290              CMP      r0,r2                 ;504
000030  d3f4              BCC      |L14.28|
;;;507        }
;;;508    }
000032  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.LCDC_SetCursorPosition||, CODE, READONLY, ALIGN=2

                  LCDC_SetCursorPosition PROC
;;;445    
;;;446    void LCDC_SetCursorPosition(LCD_Type *base, int32_t positionX, int32_t positionY)
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  4604              MOV      r4,r0
;;;448        uint32_t clipX;
;;;449        uint32_t clipY;
;;;450    
;;;451        if (positionX < 0)
000004  2900              CMP      r1,#0
000006  da05              BGE      |L15.20|
;;;452        {
;;;453            clipX = -positionX;
000008  4248              RSBS     r0,r1,#0
;;;454            positionX = 0U;
00000a  2100              MOVS     r1,#0
;;;455    
;;;456            /* If clip value too large, set to the max value. */
;;;457            if (clipX > LCDC_CLIP_MAX)
00000c  283f              CMP      r0,#0x3f
00000e  d902              BLS      |L15.22|
;;;458            {
;;;459                clipX = LCDC_CLIP_MAX;
000010  203f              MOVS     r0,#0x3f
000012  e000              B        |L15.22|
                  |L15.20|
;;;460            }
;;;461        }
;;;462        else
;;;463        {
;;;464            clipX = 0U;
000014  2000              MOVS     r0,#0
                  |L15.22|
;;;465        }
;;;466    
;;;467        if (positionY < 0)
000016  2a00              CMP      r2,#0
000018  da05              BGE      |L15.38|
;;;468        {
;;;469            clipY = -positionY;
00001a  4253              RSBS     r3,r2,#0
;;;470            positionY = 0U;
00001c  2200              MOVS     r2,#0
;;;471    
;;;472            /* If clip value too large, set to the max value. */
;;;473            if (clipY > LCDC_CLIP_MAX)
00001e  2b3f              CMP      r3,#0x3f
000020  d902              BLS      |L15.40|
;;;474            {
;;;475                clipY = LCDC_CLIP_MAX;
000022  233f              MOVS     r3,#0x3f
000024  e000              B        |L15.40|
                  |L15.38|
;;;476            }
;;;477        }
;;;478        else
;;;479        {
;;;480            clipY = 0U;
000026  2300              MOVS     r3,#0
                  |L15.40|
;;;481        }
;;;482    
;;;483        base->CRSR_CLIP = LCD_CRSR_CLIP_CRSRCLIPX(clipX) | LCD_CRSR_CLIP_CRSRCLIPY(clipY);
000028  f000053f          AND      r5,r0,#0x3f
00002c  f44f567c          MOV      r6,#0x3f00
000030  ea062603          AND      r6,r6,r3,LSL #8
000034  4335              ORRS     r5,r5,r6
000036  f8c45c14          STR      r5,[r4,#0xc14]
;;;484        base->CRSR_XY = LCD_CRSR_XY_CRSRX(positionX) | LCD_CRSR_XY_CRSRY(positionY);
00003a  f3c10509          UBFX     r5,r1,#0,#10
00003e  4e03              LDR      r6,|L15.76|
000040  ea064602          AND      r6,r6,r2,LSL #16
000044  4335              ORRS     r5,r5,r6
000046  f8c45c10          STR      r5,[r4,#0xc10]
;;;485    }
00004a  bd70              POP      {r4-r6,pc}
;;;486    
                          ENDP

                  |L15.76|
                          DCD      0x03ff0000

                          AREA ||i.LCDC_SetPalette||, CODE, READONLY, ALIGN=2

                  LCDC_SetPalette PROC
;;;306    
;;;307    void LCDC_SetPalette(LCD_Type *base, const uint32_t *palette, uint8_t count_words)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;308    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;309        assert(count_words <= ARRAY_SIZE(base->PAL));
00000a  2d80              CMP      r5,#0x80
00000c  d800              BHI      |L16.16|
00000e  e005              B        |L16.28|
                  |L16.16|
000010  f2401235          MOV      r2,#0x135
000014  a108              ADR      r1,|L16.56|
000016  a00e              ADR      r0,|L16.80|
000018  f7fffffe          BL       __aeabi_assert
                  |L16.28|
;;;310    
;;;311        uint32_t i;
;;;312    
;;;313        for (i = 0; i < count_words; i++)
00001c  2400              MOVS     r4,#0
00001e  e006              B        |L16.46|
                  |L16.32|
;;;314        {
;;;315            base->PAL[i] = palette[i];
000020  f8561024          LDR      r1,[r6,r4,LSL #2]
000024  f5077000          ADD      r0,r7,#0x200
000028  f8401024          STR      r1,[r0,r4,LSL #2]
00002c  1c64              ADDS     r4,r4,#1              ;313
                  |L16.46|
00002e  42ac              CMP      r4,r5                 ;313
000030  d3f6              BCC      |L16.32|
;;;316        }
;;;317    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;318    
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
000038  5352435c          DCB      "SRC\\Drivers\\fsl_lcdc.c",0
00003c  44726976
000040  6572735c
000044  66736c5f
000048  6c636463
00004c  2e6300  
00004f  00                DCB      0
                  |L16.80|
000050  636f756e          DCB      "count_words <= ARRAY_SIZE(base->PAL)",0
000054  745f776f
000058  72647320
00005c  3c3d2041
000060  52524159
000064  5f53495a
000068  45286261
00006c  73652d3e
000070  50414c29
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.LCDC_SetPanelAddr||, CODE, READONLY, ALIGN=2

                  LCDC_SetPanelAddr PROC
;;;291    
;;;292    void LCDC_SetPanelAddr(LCD_Type *base, lcdc_panel_t panel, uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;293    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;294        /* The base address must be doubleword aligned. */
;;;295        assert((addr & 0x07U) == 0U);
000008  f0040007          AND      r0,r4,#7
00000c  b900              CBNZ     r0,|L17.16|
00000e  e005              B        |L17.28|
                  |L17.16|
000010  f2401227          MOV      r2,#0x127
000014  a104              ADR      r1,|L17.40|
000016  a00a              ADR      r0,|L17.64|
000018  f7fffffe          BL       __aeabi_assert
                  |L17.28|
;;;296    
;;;297        if (kLCDC_UpperPanel == panel)
00001c  b90e              CBNZ     r6,|L17.34|
;;;298        {
;;;299            base->UPBASE = addr;
00001e  612c              STR      r4,[r5,#0x10]
000020  e000              B        |L17.36|
                  |L17.34|
;;;300        }
;;;301        else
;;;302        {
;;;303            base->LPBASE = addr;
000022  616c              STR      r4,[r5,#0x14]
                  |L17.36|
;;;304        }
;;;305    }
000024  bd70              POP      {r4-r6,pc}
;;;306    
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_lcdc.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  6c636463
00003c  2e6300  
00003f  00                DCB      0
                  |L17.64|
000040  28616464          DCB      "(addr & 0x07U) == 0U",0
000044  72202620
000048  30783037
00004c  5529203d
000050  3d203055
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_lcdBases
                          DCD      0x40083000
                  s_lcdClocks
000004  0202              DCW      0x0202
000006  0000              DCB      0x00,0x00
                  s_lcdResets
                          DCD      0x00020002

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_lcdc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_lcdc_c_bd74c457____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fsl_lcdc_c_bd74c457____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_lcdc_c_bd74c457____REVSH|
#line 402
|__asm___10_fsl_lcdc_c_bd74c457____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_lcdc_c_bd74c457____RRX|
#line 587
|__asm___10_fsl_lcdc_c_bd74c457____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
