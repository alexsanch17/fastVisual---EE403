; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_enet.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_enet.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_enet.crf SRC\Drivers\fsl_enet.c]
                          THUMB

                          AREA ||i.ENET_ClearMacInterruptStatus||, CODE, READONLY, ALIGN=1

                  ENET_ClearMacInterruptStatus PROC
;;;1015   
;;;1016   void ENET_ClearMacInterruptStatus(ENET_Type *base, uint32_t mask)
000000  b508              PUSH     {r3,lr}
;;;1017   {
;;;1018       volatile uint32_t dummy;
;;;1019   
;;;1020       if (mask & kENET_MacTimestamp)
000002  f0015280          AND      r2,r1,#0x10000000
000006  b11a              CBZ      r2,|L1.16|
;;;1021       {
;;;1022          dummy = base->MAC_SYS_TIMESTMP_STAT;
000008  f8d02b20          LDR      r2,[r0,#0xb20]
00000c  9200              STR      r2,[sp,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;1023       }
;;;1024       else if (mask & kENET_MacPmt)
000010  f4011280          AND      r2,r1,#0x100000
000014  b112              CBZ      r2,|L1.28|
;;;1025       {
;;;1026          dummy = base->MAC_PMT_CRTL_STAT;
000016  f8d020c0          LDR      r2,[r0,#0xc0]
00001a  9200              STR      r2,[sp,#0]
                  |L1.28|
;;;1027       }
;;;1028       else
;;;1029       {
;;;1030           /* Add for avoid the misra 2004 rule 14.10 */
;;;1031       }
;;;1032   }
00001c  bd08              POP      {r3,pc}
;;;1033   
                          ENDP


                          AREA ||i.ENET_CreateHandler||, CODE, READONLY, ALIGN=2

                  ENET_CreateHandler PROC
;;;1064   
;;;1065   void ENET_CreateHandler(ENET_Type *base,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1066                           enet_handle_t *handle,
;;;1067                           enet_config_t *config,
;;;1068                           enet_buffer_config_t *bufferConfig,
;;;1069                           enet_callback_t callback,
;;;1070                           void *userData)
;;;1071   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb030          LDR      r11,[sp,#0x30]
;;;1072       assert(config);
000010  b107              CBZ      r7,|L2.20|
000012  e005              B        |L2.32|
                  |L2.20|
000014  f44f6286          MOV      r2,#0x430
000018  a155              ADR      r1,|L2.368|
00001a  a05b              ADR      r0,|L2.392|
00001c  f7fffffe          BL       __aeabi_assert
                  |L2.32|
;;;1073       assert(bufferConfig);
000020  f1b90f00          CMP      r9,#0
000024  d000              BEQ      |L2.40|
000026  e005              B        |L2.52|
                  |L2.40|
000028  f2404231          MOV      r2,#0x431
00002c  a150              ADR      r1,|L2.368|
00002e  a058              ADR      r0,|L2.400|
000030  f7fffffe          BL       __aeabi_assert
                  |L2.52|
;;;1074       assert(callback);
000034  f1bb0f00          CMP      r11,#0
000038  d000              BEQ      |L2.60|
00003a  e005              B        |L2.72|
                  |L2.60|
00003c  f2404232          MOV      r2,#0x432
000040  a14b              ADR      r1,|L2.368|
000042  a057              ADR      r0,|L2.416|
000044  f7fffffe          BL       __aeabi_assert
                  |L2.72|
;;;1075   
;;;1076       uint8_t ringNum = 1;
000048  2001              MOVS     r0,#1
00004a  9001              STR      r0,[sp,#4]
;;;1077       uint8_t count = 0;
00004c  2500              MOVS     r5,#0
;;;1078       uint8_t rxIntEnable = 0;
00004e  f04f0a00          MOV      r10,#0
;;;1079       enet_buffer_config_t *buffConfig = bufferConfig;
000052  464e              MOV      r6,r9
;;;1080   
;;;1081       if (config->multiqueueCfg)
000054  6878              LDR      r0,[r7,#4]
000056  b118              CBZ      r0,|L2.96|
;;;1082       {
;;;1083           ringNum = 2;
000058  2002              MOVS     r0,#2
00005a  9001              STR      r0,[sp,#4]
;;;1084           handle->multiQueEnable = true;
00005c  2001              MOVS     r0,#1
00005e  7020              STRB     r0,[r4,#0]
                  |L2.96|
;;;1085       }
;;;1086   
;;;1087       /* Store transfer parameters in handle pointer. */
;;;1088       memset(handle, 0, sizeof(enet_handle_t));
000060  213c              MOVS     r1,#0x3c
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       __aeabi_memclr4
;;;1089       if (config->specialControl & kENET_DescDoubleBuffer)
000068  7838              LDRB     r0,[r7,#0]
00006a  f0000001          AND      r0,r0,#1
00006e  b108              CBZ      r0,|L2.116|
;;;1090       {
;;;1091           handle->doubleBuffEnable = true;
000070  2001              MOVS     r0,#1
000072  7060              STRB     r0,[r4,#1]
                  |L2.116|
;;;1092       }
;;;1093       if (config->multiqueueCfg)
000074  6878              LDR      r0,[r7,#4]
000076  b108              CBZ      r0,|L2.124|
;;;1094       {
;;;1095           handle->multiQueEnable = true;
000078  2001              MOVS     r0,#1
00007a  7020              STRB     r0,[r4,#0]
                  |L2.124|
;;;1096       }
;;;1097       for (count = 0; count < ringNum; count++)
00007c  2500              MOVS     r5,#0
00007e  e055              B        |L2.300|
                  |L2.128|
;;;1098       {
;;;1099           handle->rxBdRing[count].rxBdBase = buffConfig->rxDescStartAddrAlign;
000080  eb050245          ADD      r2,r5,r5,LSL #1
000084  1d20              ADDS     r0,r4,#4
000086  68f1              LDR      r1,[r6,#0xc]
000088  f8401022          STR      r1,[r0,r2,LSL #2]
;;;1100           handle->rxBdRing[count].rxGenIdx = 0;
00008c  2100              MOVS     r1,#0
00008e  eb050245          ADD      r2,r5,r5,LSL #1
000092  eb000082          ADD      r0,r0,r2,LSL #2
000096  8081              STRH     r1,[r0,#4]
;;;1101           handle->rxBdRing[count].rxRingLen = buffConfig->rxRingLen;
000098  7831              LDRB     r1,[r6,#0]
00009a  eb050245          ADD      r2,r5,r5,LSL #1
00009e  1d20              ADDS     r0,r4,#4
0000a0  eb000082          ADD      r0,r0,r2,LSL #2
0000a4  80c1              STRH     r1,[r0,#6]
;;;1102           handle->rxBdRing[count].rxBuffSizeAlign = buffConfig->rxBuffSizeAlign;
0000a6  eb050245          ADD      r2,r5,r5,LSL #1
0000aa  1d20              ADDS     r0,r4,#4
0000ac  eb000082          ADD      r0,r0,r2,LSL #2
0000b0  69b1              LDR      r1,[r6,#0x18]
0000b2  6081              STR      r1,[r0,#8]
;;;1103   
;;;1104           handle->txBdRing[count].txBdBase = buffConfig->txDescStartAddrAlign;
0000b4  eb050245          ADD      r2,r5,r5,LSL #1
0000b8  f104001c          ADD      r0,r4,#0x1c
0000bc  6871              LDR      r1,[r6,#4]
0000be  f8401022          STR      r1,[r0,r2,LSL #2]
;;;1105           handle->txBdRing[count].txRingLen = buffConfig->txRingLen;
0000c2  7871              LDRB     r1,[r6,#1]
0000c4  eb050245          ADD      r2,r5,r5,LSL #1
0000c8  eb000082          ADD      r0,r0,r2,LSL #2
0000cc  8141              STRH     r1,[r0,#0xa]
;;;1106           handle->txBdRing[count].txGenIdx = 0;
0000ce  2100              MOVS     r1,#0
0000d0  eb050245          ADD      r2,r5,r5,LSL #1
0000d4  f104001c          ADD      r0,r4,#0x1c
0000d8  eb000082          ADD      r0,r0,r2,LSL #2
0000dc  8081              STRH     r1,[r0,#4]
;;;1107           handle->txBdRing[count].txConsumIdx = 0;
0000de  eb050245          ADD      r2,r5,r5,LSL #1
0000e2  f104001c          ADD      r0,r4,#0x1c
0000e6  eb000082          ADD      r0,r0,r2,LSL #2
0000ea  80c1              STRH     r1,[r0,#6]
;;;1108           handle->txBdRing[count].txDescUsed = 0;
0000ec  eb050245          ADD      r2,r5,r5,LSL #1
0000f0  f104001c          ADD      r0,r4,#0x1c
0000f4  eb000082          ADD      r0,r0,r2,LSL #2
0000f8  8101              STRH     r1,[r0,#8]
;;;1109   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1110           assert(bufferConfig->rxPtpTsData);
;;;1111           assert(bufferConfig->txPtpTsData);
;;;1112           assert(buffConfig->rxRingLen <= ENET_RXBUFFSTORE_NUM);
;;;1113   
;;;1114           uint32_t index;
;;;1115   
;;;1116           handle->rxBdRing[count].rxPtpTsDataRing.ptpTsData = buffConfig->rxPtpTsData;
;;;1117           handle->rxBdRing[count].rxPtpTsDataRing.front = 0;
;;;1118           handle->rxBdRing[count].rxPtpTsDataRing.end = 0;
;;;1119           handle->rxBdRing[count].rxPtpTsDataRing.size = buffConfig->ptpTsRxBuffNum;
;;;1120           handle->txBdRing[count].txPtpTsDataRing.ptpTsData = buffConfig->txPtpTsData;
;;;1121           handle->txBdRing[count].txPtpTsDataRing.front = 0;
;;;1122           handle->txBdRing[count].txPtpTsDataRing.end = 0;
;;;1123           handle->txBdRing[count].txPtpTsDataRing.size = buffConfig->ptpTsTxBuffNum;
;;;1124   
;;;1125           for (index = 0; index < buffConfig->rxRingLen; index++)
;;;1126           {
;;;1127               handle->rxbuffers[index] = *(buffConfig->rxBufferStartAddr + index);
;;;1128           }
;;;1129   #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;1130           /* Enable tx interrupt for use transactional API to do tx buffer free/requeue. */
;;;1131           base->DMA_CH[count].DMA_CHX_INT_EN |= ENET_DMA_CH_DMA_CHX_INT_EN_TIE_MASK | ENET_DMA_CH_DMA_CHX_INT_EN_NIE_MASK;
0000fa  f5085088          ADD      r0,r8,#0x1100
0000fe  eb0010c5          ADD      r0,r0,r5,LSL #7
000102  6b40              LDR      r0,[r0,#0x34]
000104  f2480101          MOV      r1,#0x8001
000108  4308              ORRS     r0,r0,r1
00010a  f5085188          ADD      r1,r8,#0x1100
00010e  eb0111c5          ADD      r1,r1,r5,LSL #7
000112  6348              STR      r0,[r1,#0x34]
;;;1132           /* Check if the rx interrrupt is enabled. */
;;;1133           rxIntEnable |= (base->DMA_CH[count].DMA_CHX_INT_EN & ENET_DMA_CH_DMA_CHX_INT_EN_RIE_MASK);
000114  f5085088          ADD      r0,r8,#0x1100
000118  eb0010c5          ADD      r0,r0,r5,LSL #7
00011c  6b40              LDR      r0,[r0,#0x34]
00011e  f0000040          AND      r0,r0,#0x40
000122  ea400a0a          ORR      r10,r0,r10
;;;1134           buffConfig++;
000126  361c              ADDS     r6,r6,#0x1c
000128  1c68              ADDS     r0,r5,#1              ;1097
00012a  b2c5              UXTB     r5,r0                 ;1097
                  |L2.300|
00012c  9801              LDR      r0,[sp,#4]            ;1097
00012e  4285              CMP      r5,r0                 ;1097
000130  dba6              BLT      |L2.128|
;;;1135       }
;;;1136   
;;;1137       handle->rxintEnable = rxIntEnable ? true : false;
000132  f1ba0f00          CMP      r10,#0
000136  d001              BEQ      |L2.316|
000138  2001              MOVS     r0,#1
00013a  e000              B        |L2.318|
                  |L2.316|
00013c  2000              MOVS     r0,#0
                  |L2.318|
00013e  70a0              STRB     r0,[r4,#2]
;;;1138   
;;;1139       /* Save the handle pointer in the global variables. */
;;;1140       s_ENETHandle[ENET_GetInstance(base)] = handle;
000140  4640              MOV      r0,r8
000142  f7fffffe          BL       ENET_GetInstance
000146  4919              LDR      r1,|L2.428|
000148  f8414020          STR      r4,[r1,r0,LSL #2]
;;;1141   
;;;1142       /* Set callback and userData. */
;;;1143       handle->callback = callback;
00014c  f8c4b034          STR      r11,[r4,#0x34]
;;;1144       handle->userData = userData;
000150  980d              LDR      r0,[sp,#0x34]
000152  63a0              STR      r0,[r4,#0x38]
;;;1145   
;;;1146       /* Enable the NVIC for tx. */
;;;1147       s_enetIsr = ENET_IRQHandler;
000154  4816              LDR      r0,|L2.432|
000156  4917              LDR      r1,|L2.436|
000158  6008              STR      r0,[r1,#0]  ; s_enetIsr
;;;1148       EnableIRQ(s_enetIrqId[ENET_GetInstance(base)]);
00015a  4640              MOV      r0,r8
00015c  f7fffffe          BL       ENET_GetInstance
000160  4915              LDR      r1,|L2.440|
000162  5608              LDRSB    r0,[r1,r0]
000164  9000              STR      r0,[sp,#0]
000166  f7fffffe          BL       EnableIRQ
;;;1149   }
00016a  e8bd9ffc          POP      {r2-r12,pc}
;;;1150   
                          ENDP

00016e  0000              DCW      0x0000
                  |L2.368|
000170  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000174  44726976
000178  6572735c
00017c  66736c5f
000180  656e6574
000184  2e6300  
000187  00                DCB      0
                  |L2.392|
000188  636f6e66          DCB      "config",0
00018c  696700  
00018f  00                DCB      0
                  |L2.400|
000190  62756666          DCB      "bufferConfig",0
000194  6572436f
000198  6e666967
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L2.416|
0001a0  63616c6c          DCB      "callback",0
0001a4  6261636b
0001a8  00      
0001a9  00                DCB      0
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L2.428|
                          DCD      s_ENETHandle
                  |L2.432|
                          DCD      ENET_IRQHandler
                  |L2.436|
                          DCD      s_enetIsr
                  |L2.440|
                          DCD      s_enetIrqId

                          AREA ||i.ENET_Deinit||, CODE, READONLY, ALIGN=2

                  ENET_Deinit PROC
;;;904    
;;;905    void ENET_Deinit(ENET_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;906    {
000002  4604              MOV      r4,r0
;;;907        /* Reset first and wait for the complete
;;;908         * The reset bit will automatically be cleared after complete. */
;;;909        base->DMA_MODE |= ENET_DMA_MODE_SWR_MASK;
000004  f44f5080          MOV      r0,#0x1000
000008  5900              LDR      r0,[r0,r4]
00000a  f0400101          ORR      r1,r0,#1
00000e  f44f5080          MOV      r0,#0x1000
000012  5101              STR      r1,[r0,r4]
;;;910        while (base->DMA_MODE & ENET_DMA_MODE_SWR_MASK)
000014  bf00              NOP      
                  |L3.22|
000016  f44f5080          MOV      r0,#0x1000
00001a  5900              LDR      r0,[r0,r4]
00001c  f0000001          AND      r0,r0,#1
000020  2800              CMP      r0,#0
000022  d1f8              BNE      |L3.22|
;;;911        {
;;;912        }
;;;913    
;;;914    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;915        /* Disables the clock source. */
;;;916        CLOCK_DisableClock(s_enetClock[ENET_GetInstance(base)]);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       ENET_GetInstance
00002a  490a              LDR      r1,|L3.84|
00002c  f8315010          LDRH     r5,[r1,r0,LSL #1]
000030  0a28              LSRS     r0,r5,#8
000032  2803              CMP      r0,#3
000034  d205              BCS      |L3.66|
000036  2101              MOVS     r1,#1
000038  40a9              LSLS     r1,r1,r5
00003a  4a07              LDR      r2,|L3.88|
00003c  f8421020          STR      r1,[r2,r0,LSL #2]
000040  e006              B        |L3.80|
                  |L3.66|
000042  2101              MOVS     r1,#1
000044  40a9              LSLS     r1,r1,r5
000046  4a05              LDR      r2,|L3.92|
000048  6191              STR      r1,[r2,#0x18]
00004a  2100              MOVS     r1,#0
00004c  0312              LSLS     r2,r2,#12
00004e  64d1              STR      r1,[r2,#0x4c]
                  |L3.80|
000050  bf00              NOP      
;;;917    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;918    }
000052  bd70              POP      {r4-r6,pc}
;;;919    
                          ENDP

                  |L3.84|
                          DCD      s_enetClock
                  |L3.88|
                          DCD      0x40000240
                  |L3.92|
                          DCD      0x40040000

                          AREA ||i.ENET_DescriptorInit||, CODE, READONLY, ALIGN=2

                  ENET_DescriptorInit PROC
;;;919    
;;;920    status_t ENET_DescriptorInit(ENET_Type *base, enet_config_t *config, enet_buffer_config_t *bufferConfig)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;921    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;922        assert(config);
00000a  b106              CBZ      r6,|L4.14|
00000c  e005              B        |L4.26|
                  |L4.14|
00000e  f240329a          MOV      r2,#0x39a
000012  a122              ADR      r1,|L4.156|
000014  a027              ADR      r0,|L4.180|
000016  f7fffffe          BL       __aeabi_assert
                  |L4.26|
;;;923        assert(bufferConfig);
00001a  b105              CBZ      r5,|L4.30|
00001c  e005              B        |L4.42|
                  |L4.30|
00001e  f240329b          MOV      r2,#0x39b
000022  a11e              ADR      r1,|L4.156|
000024  a025              ADR      r0,|L4.188|
000026  f7fffffe          BL       __aeabi_assert
                  |L4.42|
;;;924    
;;;925        bool intTxEnable;
;;;926        bool intRxEnable;
;;;927        bool doubleBuffEnable = (config->specialControl & kENET_DescDoubleBuffer) ? true : false;
00002a  7830              LDRB     r0,[r6,#0]
00002c  f0000a01          AND      r10,r0,#1
;;;928        uint8_t ringNum = config->multiqueueCfg == NULL ? 1 : 2;
000030  6870              LDR      r0,[r6,#4]
000032  b908              CBNZ     r0,|L4.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L4.58|
                  |L4.56|
000038  2002              MOVS     r0,#2
                  |L4.58|
00003a  4683              MOV      r11,r0
;;;929        uint8_t channel;
;;;930    
;;;931        for (channel = 0; channel < ringNum; channel++)
00003c  2400              MOVS     r4,#0
00003e  e028              B        |L4.146|
                  |L4.64|
;;;932        {
;;;933            intRxEnable = (base->DMA_CH[channel].DMA_CHX_INT_EN & ENET_DMA_CH_DMA_CHX_INT_EN_RIE_MASK) ? true : false;
000040  f5075088          ADD      r0,r7,#0x1100
000044  eb0010c4          ADD      r0,r0,r4,LSL #7
000048  6b40              LDR      r0,[r0,#0x34]
00004a  f3c01980          UBFX     r9,r0,#6,#1
;;;934    
;;;935            if (ENET_TxDescriptorsInit(base, bufferConfig, intTxEnable, channel) != kStatus_Success)
00004e  4623              MOV      r3,r4
000050  4642              MOV      r2,r8
000052  4629              MOV      r1,r5
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       ENET_TxDescriptorsInit
00005a  b110              CBZ      r0,|L4.98|
;;;936            {
;;;937                return kStatus_Fail;
00005c  2001              MOVS     r0,#1
                  |L4.94|
;;;938            }
;;;939            intTxEnable = (base->DMA_CH[channel].DMA_CHX_INT_EN & ENET_DMA_CH_DMA_CHX_INT_EN_TIE_MASK) ? true : false;
;;;940    
;;;941            if (ENET_RxDescriptorsInit(base, bufferConfig, intRxEnable, channel, doubleBuffEnable) != kStatus_Success)
;;;942            {
;;;943                return kStatus_Fail;
;;;944            }
;;;945    
;;;946            bufferConfig++;
;;;947            if (!bufferConfig)
;;;948            {
;;;949                return kStatus_InvalidArgument;
;;;950            }
;;;951        }
;;;952        return kStatus_Success;
;;;953    }
00005e  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.98|
000062  f5075088          ADD      r0,r7,#0x1100         ;939
000066  eb0010c4          ADD      r0,r0,r4,LSL #7       ;939
00006a  6b40              LDR      r0,[r0,#0x34]         ;939
00006c  f0000801          AND      r8,r0,#1              ;939
000070  4623              MOV      r3,r4                 ;941
000072  464a              MOV      r2,r9                 ;941
000074  4629              MOV      r1,r5                 ;941
000076  4638              MOV      r0,r7                 ;941
000078  f8cda000          STR      r10,[sp,#0]           ;941
00007c  f7fffffe          BL       ENET_RxDescriptorsInit
000080  b108              CBZ      r0,|L4.134|
000082  2001              MOVS     r0,#1                 ;943
000084  e7eb              B        |L4.94|
                  |L4.134|
000086  351c              ADDS     r5,r5,#0x1c           ;946
000088  b90d              CBNZ     r5,|L4.142|
00008a  2004              MOVS     r0,#4                 ;949
00008c  e7e7              B        |L4.94|
                  |L4.142|
00008e  1c60              ADDS     r0,r4,#1              ;931
000090  b2c4              UXTB     r4,r0                 ;931
                  |L4.146|
000092  455c              CMP      r4,r11                ;931
000094  dbd4              BLT      |L4.64|
000096  2000              MOVS     r0,#0                 ;952
000098  e7e1              B        |L4.94|
;;;954    
                          ENDP

00009a  0000              DCW      0x0000
                  |L4.156|
00009c  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
0000a0  44726976
0000a4  6572735c
0000a8  66736c5f
0000ac  656e6574
0000b0  2e6300  
0000b3  00                DCB      0
                  |L4.180|
0000b4  636f6e66          DCB      "config",0
0000b8  696700  
0000bb  00                DCB      0
                  |L4.188|
0000bc  62756666          DCB      "bufferConfig",0
0000c0  6572436f
0000c4  6e666967
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.ENET_DisableInterrupts||, CODE, READONLY, ALIGN=1

                  ENET_DisableInterrupts PROC
;;;1033   
;;;1034   void ENET_DisableInterrupts(ENET_Type *base, uint32_t mask)
000000  b530              PUSH     {r4,r5,lr}
;;;1035   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1036       uint32_t interrupt = mask & 0xFFFFU;
000006  b298              UXTH     r0,r3
;;;1037       uint8_t index;
;;;1038   
;;;1039       /* For dma interrupt. */
;;;1040       if (interrupt)
000008  b1e0              CBZ      r0,|L5.68|
;;;1041       {
;;;1042           for (index = 0; index < ENET_RING_NUM_MAX; index++)
00000a  2100              MOVS     r1,#0
00000c  e018              B        |L5.64|
                  |L5.14|
;;;1043           {
;;;1044               /* Set for all abnormal interrupts. */
;;;1045               if (ENET_ABNORM_INT_MASK & interrupt)
00000e  f2417482          MOV      r4,#0x1782
000012  4004              ANDS     r4,r4,r0
000014  b10c              CBZ      r4,|L5.26|
;;;1046               {
;;;1047                   interrupt |= ENET_DMA_CH_DMA_CHX_INT_EN_AIE_MASK;
000016  f4404080          ORR      r0,r0,#0x4000
                  |L5.26|
;;;1048               }
;;;1049               /* Set for all normal interrupts. */
;;;1050               if (ENET_NORM_INT_MASK & interrupt)
00001a  f6400445          MOV      r4,#0x845
00001e  4004              ANDS     r4,r4,r0
000020  b10c              CBZ      r4,|L5.38|
;;;1051               {
;;;1052                   interrupt |= ENET_DMA_CH_DMA_CHX_INT_EN_NIE_MASK;
000022  f4404000          ORR      r0,r0,#0x8000
                  |L5.38|
;;;1053               }
;;;1054               base->DMA_CH[index].DMA_CHX_INT_EN &= ~interrupt;
000026  f5025488          ADD      r4,r2,#0x1100
00002a  eb0414c1          ADD      r4,r4,r1,LSL #7
00002e  6b64              LDR      r4,[r4,#0x34]
000030  4384              BICS     r4,r4,r0
000032  f5025588          ADD      r5,r2,#0x1100
000036  eb0515c1          ADD      r5,r5,r1,LSL #7
00003a  636c              STR      r4,[r5,#0x34]
00003c  1c4c              ADDS     r4,r1,#1              ;1042
00003e  b2e1              UXTB     r1,r4                 ;1042
                  |L5.64|
000040  2902              CMP      r1,#2                 ;1042
000042  d3e4              BCC      |L5.14|
                  |L5.68|
;;;1055           }
;;;1056       }
;;;1057       interrupt = interrupt >> ENET_MACINT_ENUM_OFFSET;
000044  0c00              LSRS     r0,r0,#16
;;;1058       if (interrupt)
000046  b120              CBZ      r0,|L5.82|
;;;1059       {
;;;1060           /* MAC interrupt */
;;;1061           base->MAC_INTR_EN &= ~interrupt;
000048  f8d240b4          LDR      r4,[r2,#0xb4]
00004c  4384              BICS     r4,r4,r0
00004e  f8c240b4          STR      r4,[r2,#0xb4]
                  |L5.82|
;;;1062       }
;;;1063   }
000052  bd30              POP      {r4,r5,pc}
;;;1064   
                          ENDP


                          AREA ||i.ENET_EnableInterrupts||, CODE, READONLY, ALIGN=1

                  ENET_EnableInterrupts PROC
;;;984    
;;;985    void ENET_EnableInterrupts(ENET_Type *base, uint32_t mask)
000000  b510              PUSH     {r4,lr}
;;;986    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;987        uint32_t interrupt = mask & 0xFFFFU;
000006  b298              UXTH     r0,r3
;;;988        uint8_t index;
;;;989    
;;;990        /* For dma interrupt. */
;;;991        if (interrupt)
000008  b1b0              CBZ      r0,|L6.56|
;;;992        {
;;;993            for (index = 0; index < ENET_RING_NUM_MAX; index++)
00000a  2100              MOVS     r1,#0
00000c  e012              B        |L6.52|
                  |L6.14|
;;;994            {
;;;995                /* Set for all abnormal interrupts. */
;;;996                if (ENET_ABNORM_INT_MASK & interrupt)
00000e  f2417482          MOV      r4,#0x1782
000012  4004              ANDS     r4,r4,r0
000014  b10c              CBZ      r4,|L6.26|
;;;997                {
;;;998                    interrupt |= ENET_DMA_CH_DMA_CHX_INT_EN_AIE_MASK;
000016  f4404080          ORR      r0,r0,#0x4000
                  |L6.26|
;;;999                }
;;;1000               /* Set for all normal interrupts. */
;;;1001               if (ENET_NORM_INT_MASK & interrupt)
00001a  f6400445          MOV      r4,#0x845
00001e  4004              ANDS     r4,r4,r0
000020  b10c              CBZ      r4,|L6.38|
;;;1002               {
;;;1003                   interrupt |= ENET_DMA_CH_DMA_CHX_INT_EN_NIE_MASK;
000022  f4404000          ORR      r0,r0,#0x8000
                  |L6.38|
;;;1004               }
;;;1005               base->DMA_CH[index].DMA_CHX_INT_EN = interrupt;
000026  f5025488          ADD      r4,r2,#0x1100
00002a  eb0414c1          ADD      r4,r4,r1,LSL #7
00002e  6360              STR      r0,[r4,#0x34]
000030  1c4c              ADDS     r4,r1,#1              ;993
000032  b2e1              UXTB     r1,r4                 ;993
                  |L6.52|
000034  2902              CMP      r1,#2                 ;993
000036  d3ea              BCC      |L6.14|
                  |L6.56|
;;;1006           }
;;;1007       }
;;;1008       interrupt = interrupt >> ENET_MACINT_ENUM_OFFSET;
000038  0c00              LSRS     r0,r0,#16
;;;1009       if (interrupt)
00003a  b120              CBZ      r0,|L6.70|
;;;1010       {
;;;1011           /* MAC interrupt */
;;;1012           base->MAC_INTR_EN |= interrupt;
00003c  f8d240b4          LDR      r4,[r2,#0xb4]
000040  4304              ORRS     r4,r4,r0
000042  f8c240b4          STR      r4,[r2,#0xb4]
                  |L6.70|
;;;1013       }
;;;1014   }
000046  bd10              POP      {r4,pc}
;;;1015   
                          ENDP


                          AREA ||i.ENET_EnterPowerDown||, CODE, READONLY, ALIGN=1

                  ENET_EnterPowerDown PROC
;;;1214   
;;;1215   void ENET_EnterPowerDown(ENET_Type *base, uint32_t *wakeFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;1216   {
;;;1217       uint8_t index;
;;;1218       uint32_t *reg = wakeFilter;
000002  460b              MOV      r3,r1
;;;1219   
;;;1220       /* Disable the tx dma. */
;;;1221       base->DMA_CH[0].DMA_CHX_TX_CTRL &= ~ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_MASK;
000004  f2411404          MOV      r4,#0x1104
000008  5824              LDR      r4,[r4,r0]
00000a  f0240501          BIC      r5,r4,#1
00000e  f2411404          MOV      r4,#0x1104
000012  5025              STR      r5,[r4,r0]
;;;1222       base->DMA_CH[1].DMA_CHX_TX_CTRL &= ~ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_MASK;
000014  f2411484          MOV      r4,#0x1184
000018  5824              LDR      r4,[r4,r0]
00001a  f0240501          BIC      r5,r4,#1
00001e  f2411484          MOV      r4,#0x1184
000022  5025              STR      r5,[r4,r0]
;;;1223   
;;;1224       /* Disable the mac tx/rx. */
;;;1225       base->MAC_CONFIG &= ~(ENET_MAC_CONFIG_RE_MASK | ENET_MAC_CONFIG_TE_MASK);
000024  6804              LDR      r4,[r0,#0]
000026  f0240403          BIC      r4,r4,#3
00002a  6004              STR      r4,[r0,#0]
;;;1226       /* Enable the remote wakeup packet and enable the power down mode. */
;;;1227       if (wakeFilter)
00002c  b149              CBZ      r1,|L7.66|
;;;1228       {
;;;1229           for (index = 0; index < ENET_WAKEUPFILTER_NUM; index++)
00002e  2200              MOVS     r2,#0
000030  e005              B        |L7.62|
                  |L7.50|
;;;1230           {
;;;1231               base->MAC_RWAKE_FRFLT = *reg;
000032  681c              LDR      r4,[r3,#0]
000034  f8c040c4          STR      r4,[r0,#0xc4]
;;;1232               reg++;
000038  1d1b              ADDS     r3,r3,#4
00003a  1c54              ADDS     r4,r2,#1              ;1229
00003c  b2e2              UXTB     r2,r4                 ;1229
                  |L7.62|
00003e  2a08              CMP      r2,#8                 ;1229
000040  d3f7              BCC      |L7.50|
                  |L7.66|
;;;1233           }
;;;1234       }
;;;1235       base->MAC_PMT_CRTL_STAT = ENET_MAC_PMT_CRTL_STAT_MGKPKTEN_MASK | ENET_MAC_PMT_CRTL_STAT_RWKPKTEN_MASK |
000042  2407              MOVS     r4,#7
000044  f8c040c0          STR      r4,[r0,#0xc0]
;;;1236                                 ENET_MAC_PMT_CRTL_STAT_PWRDWN_MASK;
;;;1237   
;;;1238       /* Enable the MAC rx. */
;;;1239       base->MAC_CONFIG |= ENET_MAC_CONFIG_RE_MASK;
000048  6804              LDR      r4,[r0,#0]
00004a  f0440401          ORR      r4,r4,#1
00004e  6004              STR      r4,[r0,#0]
;;;1240   }
000050  bd30              POP      {r4,r5,pc}
;;;1241   
                          ENDP


                          AREA ||i.ENET_GetDefaultConfig||, CODE, READONLY, ALIGN=2

                  ENET_GetDefaultConfig PROC
;;;858    
;;;859    void ENET_GetDefaultConfig(enet_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;860    {
000002  4604              MOV      r4,r0
;;;861        /* Checks input parameter. */
;;;862        assert(config);
000004  b104              CBZ      r4,|L8.8|
000006  e005              B        |L8.20|
                  |L8.8|
000008  f240325e          MOV      r2,#0x35e
00000c  a106              ADR      r1,|L8.40|
00000e  a00c              ADR      r0,|L8.64|
000010  f7fffffe          BL       __aeabi_assert
                  |L8.20|
;;;863    
;;;864        /* Sets MII mode, full duplex, 100Mbps for MAC and PHY data interface. */
;;;865        config->miiMode = kENET_RmiiMode;
000014  2001              MOVS     r0,#1
000016  7220              STRB     r0,[r4,#8]
;;;866        config->miiSpeed = kENET_MiiSpeed100M;
000018  7260              STRB     r0,[r4,#9]
;;;867        config->miiDuplex = kENET_MiiFullDuplex;
00001a  72a0              STRB     r0,[r4,#0xa]
;;;868    
;;;869        /* Sets default configuration for other options. */
;;;870        config->specialControl = false;
00001c  2000              MOVS     r0,#0
00001e  8020              STRH     r0,[r4,#0]
;;;871        config->multiqueueCfg = NULL;
000020  6060              STR      r0,[r4,#4]
;;;872        config->pauseDuration = 0;
000022  81a0              STRH     r0,[r4,#0xc]
;;;873    
;;;874    #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;875        config->ptpConfig = NULL;
;;;876    #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;877    }
000024  bd10              POP      {r4,pc}
;;;878    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
000028  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
00002c  44726976
000030  6572735c
000034  66736c5f
000038  656e6574
00003c  2e6300  
00003f  00                DCB      0
                  |L8.64|
000040  636f6e66          DCB      "config",0
000044  696700  
000047  00                DCB      0

                          AREA ||i.ENET_GetInstance||, CODE, READONLY, ALIGN=2

                  ENET_GetInstance PROC
;;;840    
;;;841    uint32_t ENET_GetInstance(ENET_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;842    {
000002  4605              MOV      r5,r0
;;;843        uint32_t instance;
;;;844    
;;;845        /* Find the instance index from base address mappings. */
;;;846        for (instance = 0; instance < FSL_FEATURE_SOC_LPC_ENET_COUNT; instance++)
000004  2400              MOVS     r4,#0
000006  e006              B        |L9.22|
                  |L9.8|
;;;847        {
;;;848            if (s_enetBases[instance] == base)
000008  4809              LDR      r0,|L9.48|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d100              BNE      |L9.20|
;;;849            {
;;;850                break;
000012  e002              B        |L9.26|
                  |L9.20|
000014  1c64              ADDS     r4,r4,#1              ;846
                  |L9.22|
000016  2c00              CMP      r4,#0                 ;846
000018  d0f6              BEQ      |L9.8|
                  |L9.26|
00001a  bf00              NOP      
;;;851            }
;;;852        }
;;;853    
;;;854        assert(instance < FSL_FEATURE_SOC_LPC_ENET_COUNT);
00001c  b904              CBNZ     r4,|L9.32|
00001e  e005              B        |L9.44|
                  |L9.32|
000020  f2403256          MOV      r2,#0x356
000024  a103              ADR      r1,|L9.52|
000026  a009              ADR      r0,|L9.76|
000028  f7fffffe          BL       __aeabi_assert
                  |L9.44|
;;;855    
;;;856        return instance;
00002c  4620              MOV      r0,r4
;;;857    }
00002e  bd70              POP      {r4-r6,pc}
;;;858    
                          ENDP

                  |L9.48|
                          DCD      s_enetBases
                  |L9.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  656e6574
000048  2e6300  
00004b  00                DCB      0
                  |L9.76|
00004c  696e7374          DCB      "instance < FSL_FEATURE_SOC_LPC_ENET_COUNT",0
000050  616e6365
000054  203c2046
000058  534c5f46
00005c  45415455
000060  52455f53
000064  4f435f4c
000068  50435f45
00006c  4e45545f
000070  434f554e
000074  5400    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.ENET_GetMacAddr||, CODE, READONLY, ALIGN=2

                  ENET_GetMacAddr PROC
;;;1150   
;;;1151   void ENET_GetMacAddr(ENET_Type *base, uint8_t *macAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;1152   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1153       assert(macAddr);
000006  b104              CBZ      r4,|L10.10|
000008  e005              B        |L10.22|
                  |L10.10|
00000a  f2404281          MOV      r2,#0x481
00000e  a109              ADR      r1,|L10.52|
000010  a00e              ADR      r0,|L10.76|
000012  f7fffffe          BL       __aeabi_assert
                  |L10.22|
;;;1154   
;;;1155       uint32_t address = base->MAC_ADDR_LOW;
000016  f8d65304          LDR      r5,[r6,#0x304]
;;;1156   
;;;1157       /* Get from physical address lower register. */
;;;1158       macAddr[2] = 0xFFU & (address >> 24U);
00001a  0e28              LSRS     r0,r5,#24
00001c  70a0              STRB     r0,[r4,#2]
;;;1159       macAddr[3] = 0xFFU & (address >> 16U);
00001e  0c28              LSRS     r0,r5,#16
000020  70e0              STRB     r0,[r4,#3]
;;;1160       macAddr[4] = 0xFFU & (address >> 8U);
000022  0a28              LSRS     r0,r5,#8
000024  7120              STRB     r0,[r4,#4]
;;;1161       macAddr[5] = 0xFFU & address;
000026  7165              STRB     r5,[r4,#5]
;;;1162   
;;;1163       /* Get from physical address high register. */
;;;1164       address = base->MAC_ADDR_HIGH;
000028  f8d65300          LDR      r5,[r6,#0x300]
;;;1165       macAddr[0] = 0xFFU & (address >> 8U);
00002c  0a28              LSRS     r0,r5,#8
00002e  7020              STRB     r0,[r4,#0]
;;;1166       macAddr[1] = 0xFFU & address;
000030  7065              STRB     r5,[r4,#1]
;;;1167   }
000032  bd70              POP      {r4-r6,pc}
;;;1168   
                          ENDP

                  |L10.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  656e6574
000048  2e6300  
00004b  00                DCB      0
                  |L10.76|
00004c  6d616341          DCB      "macAddr",0
000050  64647200

                          AREA ||i.ENET_GetRxFrameSize||, CODE, READONLY, ALIGN=2

                  ENET_GetRxFrameSize PROC
;;;1241   
;;;1242   status_t ENET_GetRxFrameSize(ENET_Type *base, enet_handle_t *handle, uint32_t *length, uint8_t channel)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1243   {
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;1244       assert(handle);
00000c  b107              CBZ      r7,|L11.16|
00000e  e005              B        |L11.28|
                  |L11.16|
000010  f24042dc          MOV      r2,#0x4dc
000014  a11f              ADR      r1,|L11.148|
000016  a025              ADR      r0,|L11.172|
000018  f7fffffe          BL       __aeabi_assert
                  |L11.28|
;;;1245       assert(length);
00001c  b106              CBZ      r6,|L11.32|
00001e  e005              B        |L11.44|
                  |L11.32|
000020  f24042dd          MOV      r2,#0x4dd
000024  a11b              ADR      r1,|L11.148|
000026  a023              ADR      r0,|L11.180|
000028  f7fffffe          BL       __aeabi_assert
                  |L11.44|
;;;1246   
;;;1247       enet_rx_bd_ring_t *rxBdRing = (enet_rx_bd_ring_t *)&handle->rxBdRing[channel];
00002c  eb090149          ADD      r1,r9,r9,LSL #1
000030  1d38              ADDS     r0,r7,#4
000032  eb000481          ADD      r4,r0,r1,LSL #2
;;;1248       enet_rx_bd_struct_t *rxDesc = rxBdRing->rxBdBase + rxBdRing->rxGenIdx;
000036  88a1              LDRH     r1,[r4,#4]
000038  6820              LDR      r0,[r4,#0]
00003a  eb001501          ADD      r5,r0,r1,LSL #4
;;;1249       uint16_t index;
;;;1250   
;;;1251       /* Reset the length to zero. */
;;;1252       *length = 0;
00003e  2000              MOVS     r0,#0
000040  6030              STR      r0,[r6,#0]
;;;1253   
;;;1254       if (rxDesc->control & ENET_RXDESCRIP_WR_OWN_MASK)
000042  68e8              LDR      r0,[r5,#0xc]
000044  f0004000          AND      r0,r0,#0x80000000
000048  b118              CBZ      r0,|L11.82|
;;;1255       {
;;;1256           return kStatus_ENET_RxFrameEmpty;
00004a  f64070a2          MOV      r0,#0xfa2
                  |L11.78|
;;;1257       }
;;;1258       else
;;;1259       {
;;;1260           do
;;;1261           {
;;;1262               /* Application owns the buffer descriptor, get the length. */
;;;1263               if (rxDesc->control & ENET_RXDESCRIP_WR_LD_MASK)
;;;1264               {
;;;1265                   if (rxDesc->control & ENET_RXDESCRIP_WR_ERRSUM_MASK)
;;;1266                   {
;;;1267                       return kStatus_ENET_RxFrameError;
;;;1268                   }
;;;1269                   *length = rxDesc->control & ENET_RXDESCRIP_WR_PACKETLEN_MASK;
;;;1270                   return kStatus_Success;
;;;1271               }
;;;1272   
;;;1273               index = ENET_IncreaseIndex(index, rxBdRing->rxRingLen);
;;;1274               rxDesc = rxBdRing->rxBdBase + index;
;;;1275           } while (index != rxBdRing->rxGenIdx);
;;;1276   
;;;1277           return kStatus_ENET_RxFrameError;
;;;1278       }
;;;1279   }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L11.82|
000052  bf00              NOP                            ;1260
                  |L11.84|
000054  68e8              LDR      r0,[r5,#0xc]          ;1263
000056  f0005080          AND      r0,r0,#0x10000000     ;1263
00005a  b160              CBZ      r0,|L11.118|
00005c  68e8              LDR      r0,[r5,#0xc]          ;1265
00005e  f4004000          AND      r0,r0,#0x8000         ;1265
000062  b110              CBZ      r0,|L11.106|
000064  f44f607a          MOV      r0,#0xfa0             ;1267
000068  e7f1              B        |L11.78|
                  |L11.106|
00006a  68e8              LDR      r0,[r5,#0xc]          ;1269
00006c  f3c0000e          UBFX     r0,r0,#0,#15          ;1269
000070  6030              STR      r0,[r6,#0]            ;1269
000072  2000              MOVS     r0,#0                 ;1270
000074  e7eb              B        |L11.78|
                  |L11.118|
000076  88e1              LDRH     r1,[r4,#6]            ;1273
000078  4640              MOV      r0,r8                 ;1273
00007a  f7fffffe          BL       ENET_IncreaseIndex
00007e  fa1ff880          UXTH     r8,r0                 ;1273
000082  6820              LDR      r0,[r4,#0]            ;1274
000084  eb001508          ADD      r5,r0,r8,LSL #4       ;1274
000088  88a0              LDRH     r0,[r4,#4]            ;1275
00008a  4540              CMP      r0,r8                 ;1275
00008c  d1e2              BNE      |L11.84|
00008e  f44f607a          MOV      r0,#0xfa0             ;1277
000092  e7dc              B        |L11.78|
;;;1280   
                          ENDP

                  |L11.148|
000094  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000098  44726976
00009c  6572735c
0000a0  66736c5f
0000a4  656e6574
0000a8  2e6300  
0000ab  00                DCB      0
                  |L11.172|
0000ac  68616e64          DCB      "handle",0
0000b0  6c6500  
0000b3  00                DCB      0
                  |L11.180|
0000b4  6c656e67          DCB      "length",0
0000b8  746800  
0000bb  00                DCB      0

                          AREA ||i.ENET_GetTxRingId||, CODE, READONLY, ALIGN=1

                  ENET_GetTxRingId PROC
;;;553    
;;;554    static uint8_t ENET_GetTxRingId(uint8_t *data, enet_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;555    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;556        /* Defuault use the queue/ring 0. */
;;;557        uint8_t ringId = 0;
000006  2600              MOVS     r6,#0
;;;558    
;;;559        if (handle->multiQueEnable)
000008  7828              LDRB     r0,[r5,#0]
00000a  b170              CBZ      r0,|L12.42|
;;;560        {
;;;561            /* Parse the frame and choose the queue id for different avb frames
;;;562             *  AVB Class frame in queue 1.
;;;563             *  non-AVB frame in queue 0.
;;;564             */
;;;565            if ((*(uint16_t *)(data + ENET_HEAD_TYPE_OFFSET) == ENET_HTONS(ENET_8021QVLAN)) &&
00000c  f44f4001          MOV      r0,#0x8100
000010  f7fffffe          BL       __asm___10_fsl_enet_c_676864a7____REV16
000014  89a1              LDRH     r1,[r4,#0xc]
000016  4288              CMP      r0,r1
000018  d107              BNE      |L12.42|
;;;566                ((*(uint16_t *)(data + ENET_HEAD_AVBTYPE_OFFSET)) == ENET_HTONS(ENET_AVBTYPE)))
00001a  f24220f0          MOV      r0,#0x22f0
00001e  f7fffffe          BL       __asm___10_fsl_enet_c_676864a7____REV16
000022  8a21              LDRH     r1,[r4,#0x10]
000024  4288              CMP      r0,r1
000026  d100              BNE      |L12.42|
;;;567            {
;;;568                /* AVBTP stream data frame. */
;;;569                ringId = 1;
000028  2601              MOVS     r6,#1
                  |L12.42|
;;;570            }
;;;571        }
;;;572    
;;;573        return ringId;
00002a  4630              MOV      r0,r6
;;;574    }
00002c  bd70              POP      {r4-r6,pc}
;;;575    
                          ENDP


                          AREA ||i.ENET_IRQHandler||, CODE, READONLY, ALIGN=1

                  ENET_IRQHandler PROC
;;;1752   
;;;1753   void ENET_IRQHandler(ENET_Type *base, enet_handle_t *handle)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1754   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1755       /* Check for the interrupt source type. */
;;;1756       /* DMA CHANNEL 0. */
;;;1757       if (base->DMA_INTR_STAT & ENET_DMA_INTR_STAT_DC0IS_MASK)
000006  f2410008          MOV      r0,#0x1008
00000a  5900              LDR      r0,[r0,r4]
00000c  f0000001          AND      r0,r0,#1
000010  b310              CBZ      r0,|L13.88|
;;;1758       {
;;;1759           uint32_t flag = base->DMA_CH[0].DMA_CHX_STAT;
000012  f44f508b          MOV      r0,#0x1160
000016  5906              LDR      r6,[r0,r4]
;;;1760           if (flag & ENET_DMA_CH_DMA_CHX_STAT_RI_MASK)
000018  f0060040          AND      r0,r6,#0x40
00001c  b170              CBZ      r0,|L13.60|
;;;1761           {
;;;1762               base->DMA_CH[0].DMA_CHX_STAT = ENET_DMA_CH_DMA_CHX_STAT_RI_MASK | ENET_DMA_CH_DMA_CHX_STAT_NIS_MASK;
00001e  f2480140          MOV      r1,#0x8040
000022  f44f508b          MOV      r0,#0x1160
000026  5101              STR      r1,[r0,r4]
;;;1763               if (handle->callback)
000028  6b68              LDR      r0,[r5,#0x34]
00002a  b138              CBZ      r0,|L13.60|
;;;1764               {
;;;1765                   handle->callback(base, handle, kENET_RxIntEvent, 0, handle->userData);
00002c  6ba8              LDR      r0,[r5,#0x38]
00002e  9000              STR      r0,[sp,#0]
000030  2300              MOVS     r3,#0
000032  461a              MOV      r2,r3
000034  4629              MOV      r1,r5
000036  4620              MOV      r0,r4
000038  6b6f              LDR      r7,[r5,#0x34]
00003a  47b8              BLX      r7
                  |L13.60|
;;;1766               }
;;;1767           }
;;;1768           if (flag & ENET_DMA_CH_DMA_CHX_STAT_TI_MASK)
00003c  f0060001          AND      r0,r6,#1
000040  b148              CBZ      r0,|L13.86|
;;;1769           {
;;;1770               base->DMA_CH[0].DMA_CHX_STAT = ENET_DMA_CH_DMA_CHX_STAT_TI_MASK | ENET_DMA_CH_DMA_CHX_STAT_NIS_MASK;
000042  f2480101          MOV      r1,#0x8001
000046  f44f508b          MOV      r0,#0x1160
00004a  5101              STR      r1,[r0,r4]
;;;1771               ENET_ReclaimTxDescriptor(base, handle, 0);
00004c  2200              MOVS     r2,#0
00004e  4629              MOV      r1,r5
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       ENET_ReclaimTxDescriptor
                  |L13.86|
;;;1772           }
;;;1773       }
000056  bf00              NOP      
                  |L13.88|
;;;1774   
;;;1775       /* DMA CHANNEL 1. */
;;;1776       if (base->DMA_INTR_STAT & ENET_DMA_INTR_STAT_DC1IS_MASK)
000058  f2410008          MOV      r0,#0x1008
00005c  5900              LDR      r0,[r0,r4]
00005e  f0000002          AND      r0,r0,#2
000062  b310              CBZ      r0,|L13.170|
;;;1777       {
;;;1778           uint32_t flag = base->DMA_CH[1].DMA_CHX_STAT;
000064  f44f508f          MOV      r0,#0x11e0
000068  5906              LDR      r6,[r0,r4]
;;;1779           if (flag & ENET_DMA_CH_DMA_CHX_STAT_RI_MASK)
00006a  f0060040          AND      r0,r6,#0x40
00006e  b170              CBZ      r0,|L13.142|
;;;1780           {
;;;1781               base->DMA_CH[1].DMA_CHX_STAT = ENET_DMA_CH_DMA_CHX_STAT_RI_MASK | ENET_DMA_CH_DMA_CHX_STAT_NIS_MASK;
000070  f2480140          MOV      r1,#0x8040
000074  f44f508f          MOV      r0,#0x11e0
000078  5101              STR      r1,[r0,r4]
;;;1782               if (handle->callback)
00007a  6b68              LDR      r0,[r5,#0x34]
00007c  b138              CBZ      r0,|L13.142|
;;;1783               {
;;;1784                   handle->callback(base, handle, kENET_RxIntEvent, 1, handle->userData);
00007e  6ba8              LDR      r0,[r5,#0x38]
000080  9000              STR      r0,[sp,#0]
000082  2301              MOVS     r3,#1
000084  2200              MOVS     r2,#0
000086  4629              MOV      r1,r5
000088  4620              MOV      r0,r4
00008a  6b6f              LDR      r7,[r5,#0x34]
00008c  47b8              BLX      r7
                  |L13.142|
;;;1785               }
;;;1786           }
;;;1787           if (flag & ENET_DMA_CH_DMA_CHX_STAT_TI_MASK)
00008e  f0060001          AND      r0,r6,#1
000092  b148              CBZ      r0,|L13.168|
;;;1788           {
;;;1789               base->DMA_CH[1].DMA_CHX_STAT = ENET_DMA_CH_DMA_CHX_STAT_TI_MASK | ENET_DMA_CH_DMA_CHX_STAT_NIS_MASK;
000094  f2480101          MOV      r1,#0x8001
000098  f44f508f          MOV      r0,#0x11e0
00009c  5101              STR      r1,[r0,r4]
;;;1790               ENET_ReclaimTxDescriptor(base, handle, 1);
00009e  2201              MOVS     r2,#1
0000a0  4629              MOV      r1,r5
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       ENET_ReclaimTxDescriptor
                  |L13.168|
;;;1791           }
;;;1792       }
0000a8  bf00              NOP      
                  |L13.170|
;;;1793   
;;;1794   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1795       /* MAC TIMESTAMP. */
;;;1796       if (base->DMA_INTR_STAT & ENET_DMA_INTR_STAT_MACIS_MASK)
;;;1797       {
;;;1798           if (base->MAC_INTR_STAT & ENET_MAC_INTR_STAT_TSIS_MASK)
;;;1799           {
;;;1800               if (handle->callback)
;;;1801               {
;;;1802                   handle->callback(base, handle, kENET_TimeStampIntEvent, 0, handle->userData);
;;;1803               }
;;;1804           }
;;;1805       }
;;;1806   #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;1807   }
0000aa  bdf8              POP      {r3-r7,pc}
;;;1808   
                          ENDP


                          AREA ||i.ENET_IncreaseIndex||, CODE, READONLY, ALIGN=1

                  ENET_IncreaseIndex PROC
;;;293     ******************************************************************************/
;;;294    static uint32_t ENET_IncreaseIndex(uint32_t index, uint32_t max)
000000  1c40              ADDS     r0,r0,#1
;;;295    {
;;;296        /* Increase the index. */
;;;297        index++;
;;;298        if (index >= max)
000002  4288              CMP      r0,r1
000004  d300              BCC      |L14.8|
;;;299        {
;;;300            index = 0;
000006  2000              MOVS     r0,#0
                  |L14.8|
;;;301        }
;;;302        return index;
;;;303    }
000008  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.ENET_Init||, CODE, READONLY, ALIGN=2

                  ENET_Init PROC
;;;878    
;;;879    void ENET_Init(ENET_Type *base, const enet_config_t *config, uint8_t *macAddr, uint32_t refclkSrc_Hz)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;880    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;881        assert(config);
00000c  b104              CBZ      r4,|L15.16|
00000e  e005              B        |L15.28|
                  |L15.16|
000010  f2403271          MOV      r2,#0x371
000014  a116              ADR      r1,|L15.112|
000016  a01c              ADR      r0,|L15.136|
000018  f7fffffe          BL       __aeabi_assert
                  |L15.28|
;;;882    
;;;883        uint32_t instance = ENET_GetInstance(base);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       ENET_GetInstance
000022  4605              MOV      r5,r0
;;;884    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;885        /* Ungate ENET clock. */
;;;886        CLOCK_EnableClock(s_enetClock[instance]);
000024  491a              LDR      r1,|L15.144|
000026  f8310015          LDRH     r0,[r1,r5,LSL #1]
00002a  0a01              LSRS     r1,r0,#8
00002c  2903              CMP      r1,#3
00002e  d205              BCS      |L15.60|
000030  2201              MOVS     r2,#1
000032  4082              LSLS     r2,r2,r0
000034  4b17              LDR      r3,|L15.148|
000036  f8432021          STR      r2,[r3,r1,LSL #2]
00003a  e005              B        |L15.72|
                  |L15.60|
00003c  2201              MOVS     r2,#1
00003e  0793              LSLS     r3,r2,#30
000040  64da              STR      r2,[r3,#0x4c]
000042  4082              LSLS     r2,r2,r0
000044  4b14              LDR      r3,|L15.152|
000046  615a              STR      r2,[r3,#0x14]
                  |L15.72|
000048  bf00              NOP      
;;;887    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;888        /* System configure fistly. */
;;;889        ENET_SetSYSControl(config->miiMode);
00004a  7a20              LDRB     r0,[r4,#8]
00004c  f7fffffe          BL       ENET_SetSYSControl
;;;890    
;;;891        /* Initializes the ENET DMA with basic function. */
;;;892        ENET_SetDMAControl(base, config);
000050  4621              MOV      r1,r4
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       ENET_SetDMAControl
;;;893    
;;;894        /* Initializes the ENET MTL with basic function. */
;;;895        ENET_SetMTL(base, config);
000058  4621              MOV      r1,r4
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       ENET_SetMTL
;;;896    
;;;897        /* Initializes the ENET MAC with basic function. */
;;;898        ENET_SetMacControl(base, config, macAddr);
000060  463a              MOV      r2,r7
000062  4621              MOV      r1,r4
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       ENET_SetMacControl
;;;899    
;;;900    #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;901        ENET_SetPtp1588(base, config, refclkSrc_Hz);
;;;902    #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;903    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;904    
                          ENDP

00006e  0000              DCW      0x0000
                  |L15.112|
000070  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000074  44726976
000078  6572735c
00007c  66736c5f
000080  656e6574
000084  2e6300  
000087  00                DCB      0
                  |L15.136|
000088  636f6e66          DCB      "config",0
00008c  696700  
00008f  00                DCB      0
                  |L15.144|
                          DCD      s_enetClock
                  |L15.148|
                          DCD      0x40000220
                  |L15.152|
                          DCD      0x40040000

                          AREA ||i.ENET_ReadFrame||, CODE, READONLY, ALIGN=2

                  ENET_ReadFrame PROC
;;;1280   
;;;1281   status_t ENET_ReadFrame(ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length, uint8_t channel)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1282   {
000004  b087              SUB      sp,sp,#0x1c
000006  4681              MOV      r9,r0
000008  460e              MOV      r6,r1
00000a  4690              MOV      r8,r2
00000c  f8dda050          LDR      r10,[sp,#0x50]
;;;1283       assert(handle);
000010  b106              CBZ      r6,|L16.20|
000012  e005              B        |L16.32|
                  |L16.20|
000014  f2405203          MOV      r2,#0x503
000018  a160              ADR      r1,|L16.412|
00001a  a066              ADR      r0,|L16.436|
00001c  f7fffffe          BL       __aeabi_assert
                  |L16.32|
;;;1284   
;;;1285       uint32_t len = 0;
000020  f04f0b00          MOV      r11,#0
;;;1286       uint32_t offset = 0;
000024  2700              MOVS     r7,#0
;;;1287       uint32_t control;
;;;1288       bool isLastBuff = false;
000026  2000              MOVS     r0,#0
000028  9005              STR      r0,[sp,#0x14]
;;;1289       enet_rx_bd_ring_t *rxBdRing = (enet_rx_bd_ring_t *)&handle->rxBdRing[channel];
00002a  eb0a014a          ADD      r1,r10,r10,LSL #1
00002e  1d30              ADDS     r0,r6,#4
000030  eb000481          ADD      r4,r0,r1,LSL #2
;;;1290       enet_rx_bd_struct_t *rxDesc;
;;;1291       status_t result = kStatus_Fail;
000034  2001              MOVS     r0,#1
000036  9004              STR      r0,[sp,#0x10]
;;;1292       uint16_t index = rxBdRing->rxGenIdx;
000038  88a0              LDRH     r0,[r4,#4]
00003a  9003              STR      r0,[sp,#0xc]
;;;1293       bool suspend = false;
00003c  2000              MOVS     r0,#0
00003e  9002              STR      r0,[sp,#8]
;;;1294   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1295       uint32_t buffer;
;;;1296       uint32_t bufferAdd;
;;;1297   #endif /* ENET_PTP1588FEATURE_REQUIRED  */
;;;1298   
;;;1299       /* Suspend and command for rx. */
;;;1300       if (base->DMA_CH[channel].DMA_CHX_STAT & ENET_DMA_CH_DMA_CHX_STAT_RBU_MASK)
000040  f5095088          ADD      r0,r9,#0x1100
000044  eb0010ca          ADD      r0,r0,r10,LSL #7
000048  6e00              LDR      r0,[r0,#0x60]
00004a  f0000080          AND      r0,r0,#0x80
00004e  b108              CBZ      r0,|L16.84|
;;;1301       {
;;;1302           suspend = true;
000050  2001              MOVS     r0,#1
000052  9002              STR      r0,[sp,#8]
                  |L16.84|
;;;1303       }
;;;1304   
;;;1305       /* For data-NULL input, only update the buffer descriptor. */
;;;1306       if ((!data))
000054  f1b80f00          CMP      r8,#0
000058  d120              BNE      |L16.156|
;;;1307       {
;;;1308           do
00005a  bf00              NOP      
                  |L16.92|
;;;1309           {
;;;1310               /* Get the control flag. */
;;;1311               rxDesc = rxBdRing->rxBdBase + rxBdRing->rxGenIdx;
00005c  88a1              LDRH     r1,[r4,#4]
00005e  6820              LDR      r0,[r4,#0]
000060  eb001501          ADD      r5,r0,r1,LSL #4
;;;1312               rxBdRing->rxGenIdx = ENET_IncreaseIndex(rxBdRing->rxGenIdx, rxBdRing->rxRingLen);
000064  88e1              LDRH     r1,[r4,#6]
000066  88a0              LDRH     r0,[r4,#4]
000068  f7fffffe          BL       ENET_IncreaseIndex
00006c  80a0              STRH     r0,[r4,#4]
;;;1313               control = rxDesc->control;
00006e  68e8              LDR      r0,[r5,#0xc]
000070  9006              STR      r0,[sp,#0x18]
;;;1314               /* Updates the receive buffer descriptors. */
;;;1315               ENET_UpdateRxDescriptor(rxDesc, NULL, NULL, handle->rxintEnable, handle->doubleBuffEnable);
000072  7870              LDRB     r0,[r6,#1]
000074  9000              STR      r0,[sp,#0]
000076  78b3              LDRB     r3,[r6,#2]
000078  2200              MOVS     r2,#0
00007a  4611              MOV      r1,r2
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       ENET_UpdateRxDescriptor
;;;1316   
;;;1317               /* Find the last buffer descriptor for the frame. */
;;;1318               if (control & ENET_RXDESCRIP_WR_LD_MASK)
000082  9806              LDR      r0,[sp,#0x18]
000084  f0005080          AND      r0,r0,#0x10000000
000088  b100              CBZ      r0,|L16.140|
;;;1319               {
;;;1320   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1321                   /* Reinit for the context descritor which has been updated by DMA. */
;;;1322                   rxDesc = rxBdRing->rxBdBase + rxBdRing->rxGenIdx;
;;;1323                   if (rxDesc->control & ENET_RXDESCRIP_WR_CTXT_MASK)
;;;1324                   {
;;;1325                       if (!handle->doubleBuffEnable)
;;;1326                       {
;;;1327                           buffer = handle->rxbuffers[rxBdRing->rxGenIdx];
;;;1328                           ENET_UpdateRxDescriptor(rxDesc, (void *)buffer, NULL, handle->rxintEnable,
;;;1329                                                   handle->doubleBuffEnable);
;;;1330                       }
;;;1331                       else
;;;1332                       {
;;;1333                           buffer = handle->rxbuffers[2 * rxBdRing->rxGenIdx];
;;;1334                           bufferAdd = handle->rxbuffers[2 * rxBdRing->rxGenIdx + 1];
;;;1335                           ENET_UpdateRxDescriptor(rxDesc, (void *)buffer, (void *)bufferAdd, handle->rxintEnable,
;;;1336                                                   handle->doubleBuffEnable);
;;;1337                       }
;;;1338                       rxBdRing->rxGenIdx = ENET_IncreaseIndex(rxBdRing->rxGenIdx, rxBdRing->rxRingLen);
;;;1339                   }
;;;1340   #endif /*  ENET_PTP1588FEATURE_REQUIRED */
;;;1341                   break;
00008a  e003              B        |L16.148|
                  |L16.140|
;;;1342               }
;;;1343           } while (rxBdRing->rxGenIdx != index);
00008c  88a1              LDRH     r1,[r4,#4]
00008e  9803              LDR      r0,[sp,#0xc]
000090  4281              CMP      r1,r0
000092  d1e3              BNE      |L16.92|
                  |L16.148|
000094  bf00              NOP                            ;1341
;;;1344   
;;;1345           result = kStatus_Success;
000096  2000              MOVS     r0,#0
000098  9004              STR      r0,[sp,#0x10]
00009a  e06f              B        |L16.380|
                  |L16.156|
;;;1346       }
;;;1347       else
;;;1348       {
;;;1349   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1350           enet_ptp_time_data_t ptpTsData;
;;;1351           bool ptp1588 = false;
;;;1352   #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;1353   
;;;1354           while ((!isLastBuff))
00009c  e06a              B        |L16.372|
                  |L16.158|
;;;1355           {
;;;1356               /* The last buffer descriptor of a frame. */
;;;1357               rxDesc = rxBdRing->rxBdBase + rxBdRing->rxGenIdx;
00009e  88a1              LDRH     r1,[r4,#4]
0000a0  6820              LDR      r0,[r4,#0]
0000a2  eb001501          ADD      r5,r0,r1,LSL #4
;;;1358               rxBdRing->rxGenIdx = ENET_IncreaseIndex(rxBdRing->rxGenIdx, rxBdRing->rxRingLen);
0000a6  88e1              LDRH     r1,[r4,#6]
0000a8  88a0              LDRH     r0,[r4,#4]
0000aa  f7fffffe          BL       ENET_IncreaseIndex
0000ae  80a0              STRH     r0,[r4,#4]
;;;1359   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1360               if (rxDesc->control & ENET_RXDESCRIP_WR_FD_MASK)
;;;1361               {
;;;1362                   ptp1588 = ENET_Ptp1588ParseFrame((uint8_t *)rxDesc->buff1Addr, &ptpTsData, false);
;;;1363               }
;;;1364   #endif
;;;1365               if (rxDesc->control & ENET_RXDESCRIP_WR_LD_MASK)
0000b0  68e8              LDR      r0,[r5,#0xc]
0000b2  f0005080          AND      r0,r0,#0x10000000
0000b6  b390              CBZ      r0,|L16.286|
;;;1366               {
;;;1367                   /* This is a valid frame. */
;;;1368                   isLastBuff = true;
0000b8  2001              MOVS     r0,#1
0000ba  9005              STR      r0,[sp,#0x14]
;;;1369                   if (length == (rxDesc->control & ENET_RXDESCRIP_WR_PACKETLEN_MASK))
0000bc  68e8              LDR      r0,[r5,#0xc]
0000be  f3c0010e          UBFX     r1,r0,#0,#15
0000c2  980a              LDR      r0,[sp,#0x28]
0000c4  4281              CMP      r1,r0
0000c6  d121              BNE      |L16.268|
;;;1370                   {
;;;1371                       /* Copy the frame to user's buffer. */
;;;1372                       len = rxDesc->control & ENET_RXDESCRIP_WR_PACKETLEN_MASK - offset;
0000c8  68e8              LDR      r0,[r5,#0xc]
0000ca  f64771ff          MOV      r1,#0x7fff
0000ce  1bc9              SUBS     r1,r1,r7
0000d0  ea000b01          AND      r11,r0,r1
;;;1373                       if (len > rxBdRing->rxBuffSizeAlign)
0000d4  68a0              LDR      r0,[r4,#8]
0000d6  4558              CMP      r0,r11
0000d8  d210              BCS      |L16.252|
;;;1374                       {
;;;1375                           memcpy(data + offset, (void *)rxDesc->buff1Addr, rxBdRing->rxBuffSizeAlign);
0000da  68a2              LDR      r2,[r4,#8]
0000dc  6829              LDR      r1,[r5,#0]
0000de  eb080007          ADD      r0,r8,r7
0000e2  f7fffffe          BL       __aeabi_memcpy
;;;1376                           offset += rxBdRing->rxBuffSizeAlign;
0000e6  68a0              LDR      r0,[r4,#8]
0000e8  4407              ADD      r7,r7,r0
;;;1377                           memcpy(data + offset, (void *)rxDesc->buff2Addr, len - rxBdRing->rxBuffSizeAlign);
0000ea  68a3              LDR      r3,[r4,#8]
0000ec  ebab0203          SUB      r2,r11,r3
0000f0  68a9              LDR      r1,[r5,#8]
0000f2  eb080007          ADD      r0,r8,r7
0000f6  f7fffffe          BL       __aeabi_memcpy
0000fa  e005              B        |L16.264|
                  |L16.252|
;;;1378                       }
;;;1379                       else
;;;1380                       {
;;;1381                           memcpy(data + offset, (void *)rxDesc->buff1Addr, len);
0000fc  6829              LDR      r1,[r5,#0]
0000fe  eb080007          ADD      r0,r8,r7
000102  465a              MOV      r2,r11
000104  f7fffffe          BL       __aeabi_memcpy
                  |L16.264|
;;;1382                       }
;;;1383   
;;;1384                       result = kStatus_Success;
000108  2000              MOVS     r0,#0
00010a  9004              STR      r0,[sp,#0x10]
                  |L16.268|
;;;1385                   }
;;;1386   
;;;1387                   /* Updates the receive buffer descriptors. */
;;;1388                   ENET_UpdateRxDescriptor(rxDesc, NULL, NULL, handle->rxintEnable, handle->doubleBuffEnable);
00010c  7870              LDRB     r0,[r6,#1]
00010e  9000              STR      r0,[sp,#0]
000110  78b3              LDRB     r3,[r6,#2]
000112  2200              MOVS     r2,#0
000114  4611              MOV      r1,r2
000116  4628              MOV      r0,r5
000118  f7fffffe          BL       ENET_UpdateRxDescriptor
00011c  e02a              B        |L16.372|
                  |L16.286|
00011e  e7ff              B        |L16.288|
                  |L16.288|
;;;1389   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1390                   /* Store the rx timestamp which is in the next buffer descriptor of the last
;;;1391                    * descriptor of a frame. */
;;;1392                   rxDesc = rxBdRing->rxBdBase + rxBdRing->rxGenIdx;
;;;1393   
;;;1394                   /* Reinit for the context descritor which has been updated by DMA. */
;;;1395                   if (rxDesc->control & ENET_RXDESCRIP_WR_CTXT_MASK)
;;;1396                   {
;;;1397                       if (ptp1588)
;;;1398                       {
;;;1399                           ENET_StoreRxFrameTime(base, handle, rxDesc, channel, &ptpTsData);
;;;1400                       }
;;;1401   
;;;1402                       if (!handle->doubleBuffEnable)
;;;1403                       {
;;;1404                           buffer = handle->rxbuffers[rxBdRing->rxGenIdx];
;;;1405                           ENET_UpdateRxDescriptor(rxDesc, (void *)buffer, NULL, handle->rxintEnable,
;;;1406                                                   handle->doubleBuffEnable);
;;;1407                       }
;;;1408                       else
;;;1409                       {
;;;1410                           buffer = handle->rxbuffers[2 * rxBdRing->rxGenIdx];
;;;1411                           bufferAdd = handle->rxbuffers[2 * rxBdRing->rxGenIdx + 1];
;;;1412                           ENET_UpdateRxDescriptor(rxDesc, (void *)buffer, (void *)bufferAdd, handle->rxintEnable,
;;;1413                                                   handle->doubleBuffEnable);
;;;1414                       }
;;;1415                       rxBdRing->rxGenIdx = ENET_IncreaseIndex(rxBdRing->rxGenIdx, rxBdRing->rxRingLen);
;;;1416                   }
;;;1417                   base->DMA_CH[channel].DMA_CHX_RXDESC_TAIL_PTR = base->DMA_CH[channel].DMA_CHX_RXDESC_TAIL_PTR;
;;;1418   #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;1419               }
;;;1420               else
;;;1421               {
;;;1422                   /* Store a frame on several buffer descriptors. */
;;;1423                   isLastBuff = false;
000120  2000              MOVS     r0,#0
000122  9005              STR      r0,[sp,#0x14]
;;;1424                   /* Length check. */
;;;1425                   if (offset >= length)
000124  980a              LDR      r0,[sp,#0x28]
000126  4287              CMP      r7,r0
000128  d308              BCC      |L16.316|
;;;1426                   {
;;;1427                       /* Updates the receive buffer descriptors. */
;;;1428                       ENET_UpdateRxDescriptor(rxDesc, NULL, NULL, handle->rxintEnable, handle->doubleBuffEnable);
00012a  7870              LDRB     r0,[r6,#1]
00012c  9000              STR      r0,[sp,#0]
00012e  78b3              LDRB     r3,[r6,#2]
000130  2200              MOVS     r2,#0
000132  4611              MOV      r1,r2
000134  4628              MOV      r0,r5
000136  f7fffffe          BL       ENET_UpdateRxDescriptor
;;;1429                       break;
00013a  e01e              B        |L16.378|
                  |L16.316|
;;;1430                   }
;;;1431   
;;;1432                   memcpy(data + offset, (void *)rxDesc->buff1Addr, rxBdRing->rxBuffSizeAlign);
00013c  68a2              LDR      r2,[r4,#8]
00013e  6829              LDR      r1,[r5,#0]
000140  eb080007          ADD      r0,r8,r7
000144  f7fffffe          BL       __aeabi_memcpy
;;;1433                   offset += rxBdRing->rxBuffSizeAlign;
000148  68a0              LDR      r0,[r4,#8]
00014a  4407              ADD      r7,r7,r0
;;;1434                   if ((rxDesc->buff2Addr) && (handle->doubleBuffEnable))
00014c  68a8              LDR      r0,[r5,#8]
00014e  b148              CBZ      r0,|L16.356|
000150  7870              LDRB     r0,[r6,#1]
000152  b138              CBZ      r0,|L16.356|
;;;1435                   {
;;;1436                       memcpy(data + offset, (void *)rxDesc->buff2Addr, rxBdRing->rxBuffSizeAlign);
000154  68a2              LDR      r2,[r4,#8]
000156  68a9              LDR      r1,[r5,#8]
000158  eb080007          ADD      r0,r8,r7
00015c  f7fffffe          BL       __aeabi_memcpy
;;;1437                       offset += rxBdRing->rxBuffSizeAlign;
000160  68a0              LDR      r0,[r4,#8]
000162  4407              ADD      r7,r7,r0
                  |L16.356|
;;;1438                   }
;;;1439   
;;;1440                   /* Updates the receive buffer descriptors. */
;;;1441                   ENET_UpdateRxDescriptor(rxDesc, NULL, NULL, handle->rxintEnable, handle->doubleBuffEnable);
000164  7870              LDRB     r0,[r6,#1]
000166  9000              STR      r0,[sp,#0]
000168  78b3              LDRB     r3,[r6,#2]
00016a  2200              MOVS     r2,#0
00016c  4611              MOV      r1,r2
00016e  4628              MOV      r0,r5
000170  f7fffffe          BL       ENET_UpdateRxDescriptor
                  |L16.372|
000174  9805              LDR      r0,[sp,#0x14]         ;1354
000176  2800              CMP      r0,#0                 ;1354
000178  d091              BEQ      |L16.158|
                  |L16.378|
00017a  bf00              NOP                            ;1429
                  |L16.380|
;;;1442               }
;;;1443           }
;;;1444       }
;;;1445   
;;;1446       /* Set command for rx when it is suspend. */
;;;1447       if (suspend)
00017c  9802              LDR      r0,[sp,#8]
00017e  b148              CBZ      r0,|L16.404|
;;;1448       {
;;;1449           base->DMA_CH[channel].DMA_CHX_RXDESC_TAIL_PTR = base->DMA_CH[channel].DMA_CHX_RXDESC_TAIL_PTR;
000180  f5095088          ADD      r0,r9,#0x1100
000184  eb0010ca          ADD      r0,r0,r10,LSL #7
000188  6a81              LDR      r1,[r0,#0x28]
00018a  f5095088          ADD      r0,r9,#0x1100
00018e  eb0010ca          ADD      r0,r0,r10,LSL #7
000192  6281              STR      r1,[r0,#0x28]
                  |L16.404|
;;;1450       }
;;;1451   
;;;1452       return result;
000194  9804              LDR      r0,[sp,#0x10]
;;;1453   }
000196  b00b              ADD      sp,sp,#0x2c
000198  e8bd8ff0          POP      {r4-r11,pc}
;;;1454   
                          ENDP

                  |L16.412|
00019c  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
0001a0  44726976
0001a4  6572735c
0001a8  66736c5f
0001ac  656e6574
0001b0  2e6300  
0001b3  00                DCB      0
                  |L16.436|
0001b4  68616e64          DCB      "handle",0
0001b8  6c6500  
0001bb  00                DCB      0

                          AREA ||i.ENET_ReclaimTxDescriptor||, CODE, READONLY, ALIGN=1

                  ENET_ReclaimTxDescriptor PROC
;;;1529   
;;;1530   void ENET_ReclaimTxDescriptor(ENET_Type *base, enet_handle_t *handle, uint8_t channel)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1531   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1532       enet_tx_bd_ring_t *txBdRing = &handle->txBdRing[channel];
00000a  eb060146          ADD      r1,r6,r6,LSL #1
00000e  f105001c          ADD      r0,r5,#0x1c
000012  eb000481          ADD      r4,r0,r1,LSL #2
;;;1533       enet_tx_bd_struct_t *txDesc = txBdRing->txBdBase + txBdRing->txConsumIdx;
000016  88e1              LDRH     r1,[r4,#6]
000018  6820              LDR      r0,[r4,#0]
00001a  eb001801          ADD      r8,r0,r1,LSL #4
;;;1534   
;;;1535       /* Need to update the first index for transmit buffer free. */
;;;1536       while ((txBdRing->txDescUsed > 0) && (!(txDesc->controlStat & ENET_TXDESCRIP_RD_OWN_MASK)))
00001e  e016              B        |L17.78|
                  |L17.32|
;;;1537       {
;;;1538   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1539           uint32_t nanosecond;
;;;1540           uint32_t nanoOverSize = ENET_NANOSECS_ONESECOND; /* Default use the digital rollover. */
;;;1541   
;;;1542           if (txDesc->controlStat & ENET_TXDESCRIP_RD_LD_MASK)
;;;1543           {
;;;1544               enet_ptp_time_data_t *ptpTsData = txBdRing->txPtpTsDataRing.ptpTsData + txBdRing->txPtpTsDataRing.end;
;;;1545               if (txDesc->controlStat & ENET_TXDESCRIP_WB_TTSS_MASK)
;;;1546               {
;;;1547                   /* Get transmit time stamp second. */
;;;1548                   nanosecond = txDesc->buff2Addr | txDesc->buff1Addr;
;;;1549                   if (!(base->MAC_TIMESTAMP_CTRL & ENET_MAC_TIMESTAMP_CTRL_TSCTRLSSR_MASK))
;;;1550                   {
;;;1551                       /* Binary rollover. */
;;;1552                       nanoOverSize = ENET_MAC_SYS_TIME_NSCND_TSSS_MASK;
;;;1553                   }
;;;1554                   ptpTsData->timeStamp.second = nanosecond / nanoOverSize;
;;;1555                   ptpTsData->timeStamp.nanosecond = nanosecond % nanoOverSize;
;;;1556   
;;;1557                   /* Store the timestamp to the transmit timestamp ring. */
;;;1558                   ENET_Ptp1588UpdateTimeRing(&txBdRing->txPtpTsDataRing, ptpTsData);
;;;1559               }
;;;1560           }
;;;1561   #endif  /* ENET_PTP1588FEATURE_REQUIRED */
;;;1562   
;;;1563           /* For tx buffer free or requeue for each descriptor.
;;;1564            * The tx interrupt callback should free/requeue the tx buffer. */
;;;1565           if (handle->callback)
000020  6b68              LDR      r0,[r5,#0x34]
000022  b140              CBZ      r0,|L17.54|
;;;1566           {
;;;1567               handle->callback(base, handle, kENET_TxIntEvent, channel, handle->userData);
000024  6ba8              LDR      r0,[r5,#0x38]
000026  9000              STR      r0,[sp,#0]
000028  4633              MOV      r3,r6
00002a  2201              MOVS     r2,#1
00002c  4629              MOV      r1,r5
00002e  4638              MOV      r0,r7
000030  f8d5c034          LDR      r12,[r5,#0x34]
000034  47e0              BLX      r12
                  |L17.54|
;;;1568           }
;;;1569   
;;;1570           txBdRing->txDescUsed--;
000036  8920              LDRH     r0,[r4,#8]
000038  1e40              SUBS     r0,r0,#1
00003a  8120              STRH     r0,[r4,#8]
;;;1571   
;;;1572           /* Update the txConsumIdx/txDesc. */
;;;1573           txBdRing->txConsumIdx = ENET_IncreaseIndex(txBdRing->txConsumIdx, txBdRing->txRingLen);
00003c  8961              LDRH     r1,[r4,#0xa]
00003e  88e0              LDRH     r0,[r4,#6]
000040  f7fffffe          BL       ENET_IncreaseIndex
000044  80e0              STRH     r0,[r4,#6]
;;;1574           txDesc = txBdRing->txBdBase + txBdRing->txConsumIdx;
000046  88e1              LDRH     r1,[r4,#6]
000048  6820              LDR      r0,[r4,#0]
00004a  eb001801          ADD      r8,r0,r1,LSL #4
                  |L17.78|
00004e  8920              LDRH     r0,[r4,#8]            ;1536
000050  2800              CMP      r0,#0                 ;1536
000052  dd05              BLE      |L17.96|
000054  f8d8000c          LDR      r0,[r8,#0xc]          ;1536
000058  f0004000          AND      r0,r0,#0x80000000     ;1536
00005c  2800              CMP      r0,#0                 ;1536
00005e  d0df              BEQ      |L17.32|
                  |L17.96|
;;;1575       }
;;;1576   }
000060  e8bd83f8          POP      {r3-r9,pc}
;;;1577   
                          ENDP


                          AREA ||i.ENET_RxDescriptorsInit||, CODE, READONLY, ALIGN=1

                  ENET_RxDescriptorsInit PROC
;;;479    
;;;480    static status_t ENET_RxDescriptorsInit(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;481        ENET_Type *base, const enet_buffer_config_t *bufferConfig, bool intRxEnable, uint8_t channel, bool doubleBuffEnable)
;;;482    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  9e09              LDR      r6,[sp,#0x24]
;;;483        uint16_t j;
;;;484        uint32_t reg;
;;;485        enet_rx_bd_struct_t *rxbdPtr;
;;;486        uint16_t index;
;;;487        const enet_buffer_config_t *buffCfg = bufferConfig;
00000c  4639              MOV      r1,r7
;;;488        uint32_t control = ENET_RXDESCRIP_WR_OWN_MASK | ENET_RXDESCRIP_RD_BUFF1VALID_MASK;
00000e  f04f4c01          MOV      r12,#0x81000000
;;;489    
;;;490        if (!buffCfg)
000012  b911              CBNZ     r1,|L18.26|
;;;491        {
;;;492            return kStatus_InvalidArgument;
000014  2004              MOVS     r0,#4
                  |L18.22|
;;;493        }
;;;494    
;;;495        if (intRxEnable)
;;;496        {
;;;497            control |= ENET_RXDESCRIP_RD_IOC_MASK;
;;;498        }
;;;499    
;;;500        if (doubleBuffEnable)
;;;501        {
;;;502            control |= ENET_RXDESCRIP_RD_BUFF2VALID_MASK;
;;;503        }
;;;504    
;;;505        /* Check the ring length. */
;;;506        if (buffCfg->rxRingLen < ENET_MIN_RINGLEN)
;;;507        {
;;;508            return kStatus_InvalidArgument;
;;;509        }
;;;510    
;;;511        /* Set the rx descriptor start/tail pointer, shall be word aligned. */
;;;512        base->DMA_CH[channel].DMA_CHX_RXDESC_LIST_ADDR =
;;;513            (uint32_t)buffCfg->rxDescStartAddrAlign & ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL_MASK;
;;;514        base->DMA_CH[channel].DMA_CHX_RXDESC_TAIL_PTR =
;;;515            (uint32_t)buffCfg->rxDescTailAddrAlign & ENET_DMA_CH_DMA_CHX_RXDESC_LIST_ADDR_SRL_MASK;
;;;516        base->DMA_CH[channel].DMA_CHX_RXDESC_RING_LENGTH =
;;;517            (uint16_t)(buffCfg->rxRingLen - 1) & ENET_DMA_CH_DMA_CHX_RXDESC_RING_LENGTH_RDRL_MASK;
;;;518        reg = base->DMA_CH[channel].DMA_CHX_RX_CTRL & ~ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ_MASK;
;;;519        reg |= ENET_DMA_CH_DMA_CHX_RX_CTRL_RBSZ(buffCfg->rxBuffSizeAlign >> ENET_RXBUFF_IGNORELSB_BITS);
;;;520        base->DMA_CH[channel].DMA_CHX_RX_CTRL = reg;
;;;521    
;;;522        /* Init the rxbdPtr to the receive descriptor start address. */
;;;523        rxbdPtr = (enet_rx_bd_struct_t *)(buffCfg->rxDescStartAddrAlign);
;;;524    
;;;525        for (j = 0; j < buffCfg->rxRingLen; j++)
;;;526        {
;;;527            if (doubleBuffEnable)
;;;528            {
;;;529                index = 2 * j;
;;;530            }
;;;531            else
;;;532            {
;;;533                index = j;
;;;534            }
;;;535            rxbdPtr->buff1Addr = *(buffCfg->rxBufferStartAddr + index);
;;;536            /* The second buffer is set with 0 because it is not required for normal case. */
;;;537            if (doubleBuffEnable)
;;;538            {
;;;539                rxbdPtr->buff2Addr = *(buffCfg->rxBufferStartAddr + index + 1);
;;;540            }
;;;541            else
;;;542            {
;;;543                rxbdPtr->buff2Addr = 0;
;;;544            }
;;;545    
;;;546            /* Set the valid and DMA own flag.*/
;;;547            rxbdPtr->control = control;
;;;548            rxbdPtr++;
;;;549        }
;;;550    
;;;551        return kStatus_Success;
;;;552    }
000016  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.26|
00001a  f1b80f00          CMP      r8,#0                 ;495
00001e  d001              BEQ      |L18.36|
000020  f04c4c80          ORR      r12,r12,#0x40000000   ;497
                  |L18.36|
000024  b10e              CBZ      r6,|L18.42|
000026  f04c7c00          ORR      r12,r12,#0x2000000    ;502
                  |L18.42|
00002a  7808              LDRB     r0,[r1,#0]            ;506
00002c  2804              CMP      r0,#4                 ;506
00002e  d201              BCS      |L18.52|
000030  2004              MOVS     r0,#4                 ;508
000032  e7f0              B        |L18.22|
                  |L18.52|
000034  68c8              LDR      r0,[r1,#0xc]          ;512
000036  f0200b03          BIC      r11,r0,#3             ;512
00003a  f5045088          ADD      r0,r4,#0x1100         ;512
00003e  eb0010c3          ADD      r0,r0,r3,LSL #7       ;512
000042  f8c0b01c          STR      r11,[r0,#0x1c]        ;512
000046  6908              LDR      r0,[r1,#0x10]         ;514
000048  f0200b03          BIC      r11,r0,#3             ;514
00004c  f5045088          ADD      r0,r4,#0x1100         ;514
000050  eb0010c3          ADD      r0,r0,r3,LSL #7       ;514
000054  f8c0b028          STR      r11,[r0,#0x28]        ;514
000058  7808              LDRB     r0,[r1,#0]            ;516
00005a  1e40              SUBS     r0,r0,#1              ;516
00005c  f3c00b09          UBFX     r11,r0,#0,#10         ;516
000060  f5045088          ADD      r0,r4,#0x1100         ;516
000064  eb0010c3          ADD      r0,r0,r3,LSL #7       ;516
000068  f8c0b030          STR      r11,[r0,#0x30]        ;516
00006c  f5045088          ADD      r0,r4,#0x1100         ;518
000070  eb0010c3          ADD      r0,r0,r3,LSL #7       ;518
000074  6880              LDR      r0,[r0,#8]            ;518
000076  f6477bf8          MOV      r11,#0x7ff8           ;518
00007a  ea20090b          BIC      r9,r0,r11             ;518
00007e  6988              LDR      r0,[r1,#0x18]         ;519
000080  0880              LSRS     r0,r0,#2              ;519
000082  ea0b00c0          AND      r0,r11,r0,LSL #3      ;519
000086  ea400909          ORR      r9,r0,r9              ;519
00008a  f5045088          ADD      r0,r4,#0x1100         ;520
00008e  eb0010c3          ADD      r0,r0,r3,LSL #7       ;520
000092  f8c09008          STR      r9,[r0,#8]            ;520
000096  68ca              LDR      r2,[r1,#0xc]          ;523
000098  2500              MOVS     r5,#0                 ;525
00009a  e017              B        |L18.204|
                  |L18.156|
00009c  b11e              CBZ      r6,|L18.166|
00009e  0468              LSLS     r0,r5,#17             ;529
0000a0  ea4f4a10          LSR      r10,r0,#16            ;529
0000a4  e000              B        |L18.168|
                  |L18.166|
0000a6  46aa              MOV      r10,r5                ;533
                  |L18.168|
0000a8  6948              LDR      r0,[r1,#0x14]         ;535
0000aa  f850002a          LDR      r0,[r0,r10,LSL #2]    ;535
0000ae  6010              STR      r0,[r2,#0]            ;535
0000b0  b12e              CBZ      r6,|L18.190|
0000b2  6948              LDR      r0,[r1,#0x14]         ;539
0000b4  eb00008a          ADD      r0,r0,r10,LSL #2      ;539
0000b8  6840              LDR      r0,[r0,#4]            ;539
0000ba  6090              STR      r0,[r2,#8]            ;539
0000bc  e001              B        |L18.194|
                  |L18.190|
0000be  2000              MOVS     r0,#0                 ;543
0000c0  6090              STR      r0,[r2,#8]            ;543
                  |L18.194|
0000c2  f8c2c00c          STR      r12,[r2,#0xc]         ;547
0000c6  3210              ADDS     r2,r2,#0x10           ;548
0000c8  1c68              ADDS     r0,r5,#1              ;525
0000ca  b285              UXTH     r5,r0                 ;525
                  |L18.204|
0000cc  7808              LDRB     r0,[r1,#0]            ;525
0000ce  42a8              CMP      r0,r5                 ;525
0000d0  dce4              BGT      |L18.156|
0000d2  2000              MOVS     r0,#0                 ;551
0000d4  e79f              B        |L18.22|
;;;553    
                          ENDP


                          AREA ||i.ENET_SendFrame||, CODE, READONLY, ALIGN=2

                  ENET_SendFrame PROC
;;;1577   
;;;1578   status_t ENET_SendFrame(ENET_Type *base, enet_handle_t *handle, uint8_t *data, uint32_t length)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1579   {
000004  b087              SUB      sp,sp,#0x1c
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1580       assert(handle);
00000c  f1b80f00          CMP      r8,#0
000010  d000              BEQ      |L19.20|
000012  e005              B        |L19.32|
                  |L19.20|
000014  f240622c          MOV      r2,#0x62c
000018  a146              ADR      r1,|L19.308|
00001a  a04c              ADR      r0,|L19.332|
00001c  f7fffffe          BL       __aeabi_assert
                  |L19.32|
;;;1581       assert(data);
000020  b107              CBZ      r7,|L19.36|
000022  e005              B        |L19.48|
                  |L19.36|
000024  f240622d          MOV      r2,#0x62d
000028  a142              ADR      r1,|L19.308|
00002a  a04a              ADR      r0,|L19.340|
00002c  f7fffffe          BL       __aeabi_assert
                  |L19.48|
;;;1582   
;;;1583       enet_tx_bd_ring_t *txBdRing;
;;;1584       enet_tx_bd_struct_t *txDesc;
;;;1585       uint8_t channel = 0;
000030  f04f0a00          MOV      r10,#0
;;;1586       bool ptp1588 = false;
000034  46d3              MOV      r11,r10
;;;1587   
;;;1588       if (length > 2 * ENET_TXDESCRIP_RD_BL1_MASK)
000036  f64770fe          MOV      r0,#0x7ffe
00003a  4285              CMP      r5,r0
00003c  d904              BLS      |L19.72|
;;;1589       {
;;;1590           return kStatus_ENET_TxFrameOverLen;
00003e  f64070a5          MOV      r0,#0xfa5
                  |L19.66|
;;;1591       }
;;;1592   
;;;1593       /* Choose the transit queue. */
;;;1594       channel = ENET_GetTxRingId(data, handle);
;;;1595   
;;;1596       /* Check if the DMA owns the descriptor. */
;;;1597       txBdRing = (enet_tx_bd_ring_t *)&handle->txBdRing[channel];
;;;1598       txDesc = txBdRing->txBdBase + txBdRing->txGenIdx;
;;;1599       if (txBdRing->txRingLen == txBdRing->txDescUsed)
;;;1600       {
;;;1601           return kStatus_ENET_TxFrameBusy;
;;;1602       }
;;;1603   
;;;1604   #ifdef ENET_PTP1588FEATURE_REQUIRED
;;;1605       enet_ptp_time_data_t ptpTsData;
;;;1606   
;;;1607       ptp1588 = ENET_Ptp1588ParseFrame(data, &ptpTsData, true);
;;;1608   #endif /* ENET_PTP1588FEATURE_REQUIRED */
;;;1609   
;;;1610       /* Fill the descriptor. */
;;;1611       if (length <= ENET_TXDESCRIP_RD_BL1_MASK)
;;;1612       {
;;;1613           ENET_SetupTxDescriptor(txDesc, data, length, NULL, 0, length, true, ptp1588, kENET_FirstLastFlag, 0);
;;;1614       }
;;;1615       else
;;;1616       {
;;;1617           ENET_SetupTxDescriptor(txDesc, data, ENET_TXDESCRIP_RD_BL1_MASK, data + ENET_TXDESCRIP_RD_BL1_MASK,
;;;1618                                  (length - ENET_TXDESCRIP_RD_BL1_MASK), length, true, ptp1588, kENET_FirstLastFlag, 0);
;;;1619       }
;;;1620   
;;;1621       /* Increase the index. */
;;;1622       txBdRing->txGenIdx = ENET_IncreaseIndex(txBdRing->txGenIdx, txBdRing->txRingLen);
;;;1623       /* Disable interrupt first and then enable interrupt to avoid the race condition. */
;;;1624       DisableIRQ(s_enetIrqId[ENET_GetInstance(base)]);
;;;1625       txBdRing->txDescUsed++;
;;;1626       EnableIRQ(s_enetIrqId[ENET_GetInstance(base)]);
;;;1627   
;;;1628       /* Update the transmit tail address. */
;;;1629       txDesc = txBdRing->txBdBase + txBdRing->txGenIdx;
;;;1630       if (!txBdRing->txGenIdx)
;;;1631       {
;;;1632           txDesc = txBdRing->txBdBase + txBdRing->txRingLen;
;;;1633       }
;;;1634       base->DMA_CH[channel].DMA_CHX_TXDESC_TAIL_PTR = (uint32_t)txDesc & ~ENET_ADDR_ALIGNMENT;
;;;1635   
;;;1636       return kStatus_Success;
;;;1637   }
000042  b00b              ADD      sp,sp,#0x2c
000044  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.72|
000048  4641              MOV      r1,r8                 ;1594
00004a  4638              MOV      r0,r7                 ;1594
00004c  f7fffffe          BL       ENET_GetTxRingId
000050  4682              MOV      r10,r0                ;1594
000052  eb0a014a          ADD      r1,r10,r10,LSL #1     ;1597
000056  f108001c          ADD      r0,r8,#0x1c           ;1597
00005a  eb000481          ADD      r4,r0,r1,LSL #2       ;1597
00005e  88a1              LDRH     r1,[r4,#4]            ;1598
000060  6820              LDR      r0,[r4,#0]            ;1598
000062  eb001901          ADD      r9,r0,r1,LSL #4       ;1598
000066  8960              LDRH     r0,[r4,#0xa]          ;1599
000068  8921              LDRH     r1,[r4,#8]            ;1599
00006a  4288              CMP      r0,r1                 ;1599
00006c  d102              BNE      |L19.116|
00006e  f64070a3          MOV      r0,#0xfa3             ;1601
000072  e7e6              B        |L19.66|
                  |L19.116|
000074  f5b54f80          CMP      r5,#0x4000            ;1611
000078  d20f              BCS      |L19.154|
00007a  2000              MOVS     r0,#0                 ;1613
00007c  2103              MOVS     r1,#3                 ;1613
00007e  2201              MOVS     r2,#1                 ;1613
000080  e9cd1004          STRD     r1,r0,[sp,#0x10]      ;1613
000084  4603              MOV      r3,r0                 ;1613
000086  e9cd2b02          STRD     r2,r11,[sp,#8]        ;1613
00008a  e9cd0500          STRD     r0,r5,[sp,#0]         ;1613
00008e  462a              MOV      r2,r5                 ;1613
000090  4639              MOV      r1,r7                 ;1613
000092  4648              MOV      r0,r9                 ;1613
000094  f7fffffe          BL       ENET_SetupTxDescriptor
000098  e013              B        |L19.194|
                  |L19.154|
00009a  2000              MOVS     r0,#0                 ;1617
00009c  2103              MOVS     r1,#3                 ;1617
00009e  2201              MOVS     r2,#1                 ;1617
0000a0  e9cd2b02          STRD     r2,r11,[sp,#8]        ;1617
0000a4  e9cd1004          STRD     r1,r0,[sp,#0x10]      ;1617
0000a8  f5a5507c          SUB      r0,r5,#0x3f00         ;1617
0000ac  38ff              SUBS     r0,r0,#0xff           ;1617
0000ae  e9cd0500          STRD     r0,r5,[sp,#0]         ;1617
0000b2  f64370ff          MOV      r0,#0x3fff            ;1617
0000b6  183b              ADDS     r3,r7,r0              ;1617
0000b8  4602              MOV      r2,r0                 ;1617
0000ba  4639              MOV      r1,r7                 ;1617
0000bc  4648              MOV      r0,r9                 ;1617
0000be  f7fffffe          BL       ENET_SetupTxDescriptor
                  |L19.194|
0000c2  8961              LDRH     r1,[r4,#0xa]          ;1622
0000c4  88a0              LDRH     r0,[r4,#4]            ;1622
0000c6  f7fffffe          BL       ENET_IncreaseIndex
0000ca  80a0              STRH     r0,[r4,#4]            ;1622
0000cc  9807              LDR      r0,[sp,#0x1c]         ;1624
0000ce  f7fffffe          BL       ENET_GetInstance
0000d2  4922              LDR      r1,|L19.348|
0000d4  560e              LDRSB    r6,[r1,r0]            ;1624
0000d6  f1160f80          CMN      r6,#0x80              ;1624
0000da  d100              BNE      |L19.222|
0000dc  e00a              B        |L19.244|
                  |L19.222|
0000de  bf00              NOP                            ;1624
0000e0  f006011f          AND      r1,r6,#0x1f           ;1624
0000e4  2001              MOVS     r0,#1                 ;1624
0000e6  4088              LSLS     r0,r0,r1              ;1624
0000e8  491d              LDR      r1,|L19.352|
0000ea  0972              LSRS     r2,r6,#5              ;1624
0000ec  f8410022          STR      r0,[r1,r2,LSL #2]     ;1624
0000f0  bf00              NOP                            ;1624
0000f2  bf00              NOP                            ;1624
                  |L19.244|
0000f4  8920              LDRH     r0,[r4,#8]            ;1625
0000f6  1c40              ADDS     r0,r0,#1              ;1625
0000f8  8120              STRH     r0,[r4,#8]            ;1625
0000fa  9807              LDR      r0,[sp,#0x1c]         ;1626
0000fc  f7fffffe          BL       ENET_GetInstance
000100  4916              LDR      r1,|L19.348|
000102  560e              LDRSB    r6,[r1,r0]            ;1626
000104  4630              MOV      r0,r6                 ;1626
000106  f7fffffe          BL       EnableIRQ
00010a  88a1              LDRH     r1,[r4,#4]            ;1629
00010c  6820              LDR      r0,[r4,#0]            ;1629
00010e  eb001901          ADD      r9,r0,r1,LSL #4       ;1629
000112  88a0              LDRH     r0,[r4,#4]            ;1630
000114  b918              CBNZ     r0,|L19.286|
000116  8961              LDRH     r1,[r4,#0xa]          ;1632
000118  6820              LDR      r0,[r4,#0]            ;1632
00011a  eb001901          ADD      r9,r0,r1,LSL #4       ;1632
                  |L19.286|
00011e  f0290103          BIC      r1,r9,#3              ;1634
000122  9807              LDR      r0,[sp,#0x1c]         ;1634
000124  f5005088          ADD      r0,r0,#0x1100         ;1634
000128  eb0010ca          ADD      r0,r0,r10,LSL #7      ;1634
00012c  6201              STR      r1,[r0,#0x20]         ;1634
00012e  2000              MOVS     r0,#0                 ;1636
000130  e787              B        |L19.66|
;;;1638   
                          ENDP

000132  0000              DCW      0x0000
                  |L19.308|
000134  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000138  44726976
00013c  6572735c
000140  66736c5f
000144  656e6574
000148  2e6300  
00014b  00                DCB      0
                  |L19.332|
00014c  68616e64          DCB      "handle",0
000150  6c6500  
000153  00                DCB      0
                  |L19.340|
000154  64617461          DCB      "data",0
000158  00      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L19.348|
                          DCD      s_enetIrqId
                  |L19.352|
                          DCD      0xe000e180

                          AREA ||i.ENET_SetDMAControl||, CODE, READONLY, ALIGN=2

                  ENET_SetDMAControl PROC
;;;313    
;;;314    static void ENET_SetDMAControl(ENET_Type *base, const enet_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;315    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;316        assert(config);
000008  b106              CBZ      r6,|L20.12|
00000a  e005              B        |L20.24|
                  |L20.12|
00000c  f44f729e          MOV      r2,#0x13c
000010  a125              ADR      r1,|L20.168|
000012  a02b              ADR      r0,|L20.192|
000014  f7fffffe          BL       __aeabi_assert
                  |L20.24|
;;;317    
;;;318        uint8_t index;
;;;319        uint32_t reg;
;;;320        uint32_t burstLen;
;;;321    
;;;322        /* Reset first and wait for the complete
;;;323         * The reset bit will automatically be cleared after complete. */
;;;324        base->DMA_MODE |= ENET_DMA_MODE_SWR_MASK;
000018  f44f5080          MOV      r0,#0x1000
00001c  5900              LDR      r0,[r0,r4]
00001e  f0400101          ORR      r1,r0,#1
000022  f44f5080          MOV      r0,#0x1000
000026  5101              STR      r1,[r0,r4]
;;;325        while (base->DMA_MODE & ENET_DMA_MODE_SWR_MASK)
000028  bf00              NOP      
                  |L20.42|
00002a  f44f5080          MOV      r0,#0x1000
00002e  5900              LDR      r0,[r0,r4]
000030  f0000001          AND      r0,r0,#1
000034  2800              CMP      r0,#0
000036  d1f8              BNE      |L20.42|
;;;326        {
;;;327        }
;;;328    
;;;329        /* Set the burst length. */
;;;330        for (index = 0; index < ENET_RING_NUM_MAX; index++)
000038  2500              MOVS     r5,#0
00003a  e031              B        |L20.160|
                  |L20.60|
;;;331        {
;;;332            burstLen = kENET_BurstLen1;
00003c  2701              MOVS     r7,#1
;;;333            if (config->multiqueueCfg)
00003e  6870              LDR      r0,[r6,#4]
000040  b108              CBZ      r0,|L20.70|
;;;334            {
;;;335                burstLen = config->multiqueueCfg->burstLen;
000042  6870              LDR      r0,[r6,#4]
000044  6847              LDR      r7,[r0,#4]
                  |L20.70|
;;;336            }
;;;337            base->DMA_CH[index].DMA_CHX_CTRL = burstLen & ENET_DMA_CH_DMA_CHX_CTRL_PBLx8_MASK;
000046  f4073180          AND      r1,r7,#0x10000
00004a  f5045088          ADD      r0,r4,#0x1100
00004e  eb0010c5          ADD      r0,r0,r5,LSL #7
000052  6001              STR      r1,[r0,#0]
;;;338    
;;;339            reg = base->DMA_CH[index].DMA_CHX_TX_CTRL & ~ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL_MASK;
000054  f5045088          ADD      r0,r4,#0x1100
000058  eb0010c5          ADD      r0,r0,r5,LSL #7
00005c  6840              LDR      r0,[r0,#4]
00005e  f420187c          BIC      r8,r0,#0x3f0000
;;;340            base->DMA_CH[index].DMA_CHX_TX_CTRL = reg | ENET_DMA_CH_DMA_CHX_TX_CTRL_TxPBL(burstLen & 0x3F);
000062  f44f107c          MOV      r0,#0x3f0000
000066  ea004007          AND      r0,r0,r7,LSL #16
00006a  ea400008          ORR      r0,r0,r8
00006e  f5045188          ADD      r1,r4,#0x1100
000072  eb0111c5          ADD      r1,r1,r5,LSL #7
000076  6048              STR      r0,[r1,#4]
;;;341    
;;;342            reg = base->DMA_CH[index].DMA_CHX_RX_CTRL & ~ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL_MASK;
000078  f5045088          ADD      r0,r4,#0x1100
00007c  eb0010c5          ADD      r0,r0,r5,LSL #7
000080  6880              LDR      r0,[r0,#8]
000082  f420187c          BIC      r8,r0,#0x3f0000
;;;343            base->DMA_CH[index].DMA_CHX_RX_CTRL = reg | ENET_DMA_CH_DMA_CHX_RX_CTRL_RxPBL(burstLen & 0x3F);
000086  f44f107c          MOV      r0,#0x3f0000
00008a  ea004007          AND      r0,r0,r7,LSL #16
00008e  ea400008          ORR      r0,r0,r8
000092  f5045188          ADD      r1,r4,#0x1100
000096  eb0111c5          ADD      r1,r1,r5,LSL #7
00009a  6088              STR      r0,[r1,#8]
00009c  1c68              ADDS     r0,r5,#1              ;330
00009e  b2c5              UXTB     r5,r0                 ;330
                  |L20.160|
0000a0  2d02              CMP      r5,#2                 ;330
0000a2  d3cb              BCC      |L20.60|
;;;344        }
;;;345    }
0000a4  e8bd81f0          POP      {r4-r8,pc}
;;;346    
                          ENDP

                  |L20.168|
0000a8  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
0000ac  44726976
0000b0  6572735c
0000b4  66736c5f
0000b8  656e6574
0000bc  2e6300  
0000bf  00                DCB      0
                  |L20.192|
0000c0  636f6e66          DCB      "config",0
0000c4  696700  
0000c7  00                DCB      0

                          AREA ||i.ENET_SetMII||, CODE, READONLY, ALIGN=1

                  ENET_SetMII PROC
;;;597     */
;;;598    static void ENET_SetMII(ENET_Type *base, enet_mii_speed_t speed, enet_mii_duplex_t duplex)
000000  b530              PUSH     {r4,r5,lr}
;;;599    {
;;;600        uint32_t reg = base->MAC_CONFIG & ~(ENET_MAC_CONFIG_DM_MASK | ENET_MAC_CONFIG_FES_MASK);
000002  6804              LDR      r4,[r0,#0]
000004  f42443c0          BIC      r3,r4,#0x6000
;;;601        reg |= ENET_MAC_CONFIG_DM(duplex) | ENET_MAC_CONFIG_FES(speed);
000008  f44f5400          MOV      r4,#0x2000
00000c  ea043442          AND      r4,r4,r2,LSL #13
000010  f44f4580          MOV      r5,#0x4000
000014  ea053581          AND      r5,r5,r1,LSL #14
000018  432c              ORRS     r4,r4,r5
00001a  4323              ORRS     r3,r3,r4
;;;602    
;;;603        base->MAC_CONFIG = reg;
00001c  6003              STR      r3,[r0,#0]
;;;604    }
00001e  bd30              POP      {r4,r5,pc}
;;;605    
                          ENDP


                          AREA ||i.ENET_SetMTL||, CODE, READONLY, ALIGN=2

                  ENET_SetMTL PROC
;;;346    
;;;347    static void ENET_SetMTL(ENET_Type *base, const enet_config_t *config)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;348    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;349        assert(config);
000008  b107              CBZ      r7,|L22.12|
00000a  e005              B        |L22.24|
                  |L22.12|
00000c  f240125d          MOV      r2,#0x15d
000010  a128              ADR      r1,|L22.180|
000012  a02e              ADR      r0,|L22.204|
000014  f7fffffe          BL       __aeabi_assert
                  |L22.24|
;;;350    
;;;351        uint32_t txqOpreg = 0;
000018  f04f0800          MOV      r8,#0
;;;352        uint32_t rxqOpReg = 0;
00001c  46c1              MOV      r9,r8
;;;353        enet_multiqueue_config_t *multiqCfg = config->multiqueueCfg;
00001e  687d              LDR      r5,[r7,#4]
;;;354        uint8_t index;
;;;355    
;;;356        /* Set transmit operation mode. */
;;;357        if (config->specialControl & kENET_StoreAndForward)
000020  7838              LDRB     r0,[r7,#0]
000022  f0000002          AND      r0,r0,#2
000026  b118              CBZ      r0,|L22.48|
;;;358        {
;;;359            txqOpreg = ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TSF_MASK;
000028  f04f0802          MOV      r8,#2
;;;360            rxqOpReg = ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RSF_MASK;
00002c  f04f0920          MOV      r9,#0x20
                  |L22.48|
;;;361        }
;;;362        txqOpreg |= ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_FTQ_MASK |
000030  4828              LDR      r0,|L22.212|
000032  ea480800          ORR      r8,r8,r0
;;;363                    ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TQS(ENET_MTL_TXFIFOSIZE / ENET_FIFOSIZE_UNIT - 1);
;;;364        base->MTL_QUEUE[0].MTL_TXQX_OP_MODE = txqOpreg | ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN(2);
000036  f0480008          ORR      r0,r8,#8
00003a  f8c40d00          STR      r0,[r4,#0xd00]
;;;365        base->MTL_QUEUE[1].MTL_TXQX_OP_MODE = txqOpreg;
00003e  f8c48d40          STR      r8,[r4,#0xd40]
;;;366    
;;;367        /* Set receive operation mode. */
;;;368        rxqOpReg |= ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_FUP_MASK |
000042  4825              LDR      r0,|L22.216|
000044  ea490900          ORR      r9,r9,r0
;;;369                    ENET_MTL_QUEUE_MTL_RXQX_OP_MODE_RQS(ENET_MTL_RXFIFOSIZE / ENET_FIFOSIZE_UNIT - 1);
;;;370        base->MTL_QUEUE[0].MTL_RXQX_OP_MODE = rxqOpReg;
000048  f8c49d30          STR      r9,[r4,#0xd30]
;;;371    
;;;372        /* Set the schedule/arbitration(set for multiple queues). */
;;;373        if (multiqCfg)
00004c  b385              CBZ      r5,|L22.176|
;;;374        {
;;;375            base->MTL_OP_MODE = ENET_MTL_OP_MODE_SCHALG(multiqCfg->mtltxSche) | ENET_MTL_OP_MODE_RAA(multiqCfg->mtlrxSche);
00004e  7aa8              LDRB     r0,[r5,#0xa]
000050  2160              MOVS     r1,#0x60
000052  ea011040          AND      r0,r1,r0,LSL #5
000056  7ae9              LDRB     r1,[r5,#0xb]
000058  2204              MOVS     r2,#4
00005a  ea020181          AND      r1,r2,r1,LSL #2
00005e  4308              ORRS     r0,r0,r1
000060  f8c40c00          STR      r0,[r4,#0xc00]
;;;376            /* Set the rx queue mapping to dma channel. */
;;;377            base->MTL_RXQ_DMA_MAP = multiqCfg->mtlrxQuemap;
000064  8ba8              LDRH     r0,[r5,#0x1c]
000066  f8c40c30          STR      r0,[r4,#0xc30]
;;;378            /* Set the tx/rx queue operation mode for multi-queue. */
;;;379            base->MTL_QUEUE[1].MTL_TXQX_OP_MODE |= ENET_MTL_QUEUE_MTL_TXQX_OP_MODE_TXQEN(2);
00006a  f44f6054          MOV      r0,#0xd40
00006e  5900              LDR      r0,[r0,r4]
000070  f0400108          ORR      r1,r0,#8
000074  f44f6054          MOV      r0,#0xd40
000078  5101              STR      r1,[r0,r4]
;;;380            base->MTL_QUEUE[1].MTL_RXQX_OP_MODE = rxqOpReg;
00007a  f8c49d70          STR      r9,[r4,#0xd70]
;;;381    
;;;382            /* Set the tx/rx queue weight. */
;;;383            for (index = 0; index < ENET_RING_NUM_MAX; index++)
00007e  2600              MOVS     r6,#0
000080  e014              B        |L22.172|
                  |L22.130|
;;;384            {
;;;385                base->MTL_QUEUE[index].MTL_TXQX_QNTM_WGHT = multiqCfg->txqueweight[index];
000082  f1050010          ADD      r0,r5,#0x10
000086  f8501026          LDR      r1,[r0,r6,LSL #2]
00008a  f5046050          ADD      r0,r4,#0xd00
00008e  eb001086          ADD      r0,r0,r6,LSL #6
000092  6181              STR      r1,[r0,#0x18]
;;;386                base->MTL_QUEUE[index].MTL_RXQX_CTRL = ENET_MTL_QUEUE_MTL_RXQX_CTRL_RXQ_WEGT(multiqCfg->rxqueweight[index]);
000094  f105000c          ADD      r0,r5,#0xc
000098  5d80              LDRB     r0,[r0,r6]
00009a  f0000107          AND      r1,r0,#7
00009e  f5046050          ADD      r0,r4,#0xd00
0000a2  eb001086          ADD      r0,r0,r6,LSL #6
0000a6  63c1              STR      r1,[r0,#0x3c]
0000a8  1c70              ADDS     r0,r6,#1              ;383
0000aa  b2c6              UXTB     r6,r0                 ;383
                  |L22.172|
0000ac  2e02              CMP      r6,#2                 ;383
0000ae  d3e8              BCC      |L22.130|
                  |L22.176|
;;;387            }
;;;388        }
;;;389    }
0000b0  e8bd87f0          POP      {r4-r10,pc}
;;;390    
                          ENDP

                  |L22.180|
0000b4  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
0000b8  44726976
0000bc  6572735c
0000c0  66736c5f
0000c4  656e6574
0000c8  2e6300  
0000cb  00                DCB      0
                  |L22.204|
0000cc  636f6e66          DCB      "config",0
0000d0  696700  
0000d3  00                DCB      0
                  |L22.212|
                          DCD      0x00070001
                  |L22.216|
                          DCD      0x00700008

                          AREA ||i.ENET_SetMacControl||, CODE, READONLY, ALIGN=2

                  ENET_SetMacControl PROC
;;;390    
;;;391    static void ENET_SetMacControl(ENET_Type *base, const enet_config_t *config, uint8_t *macAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;392    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;393        assert(config);
00000a  b104              CBZ      r4,|L23.14|
00000c  e005              B        |L23.26|
                  |L23.14|
00000e  f2401289          MOV      r2,#0x189
000012  a139              ADR      r1,|L23.248|
000014  a03e              ADR      r0,|L23.272|
000016  f7fffffe          BL       __aeabi_assert
                  |L23.26|
;;;394    
;;;395        uint32_t reg = 0;
00001a  2700              MOVS     r7,#0
;;;396    
;;;397        /* Set Macaddr */
;;;398        /* The dma channel 0 is set as to which the rx packet
;;;399         * whose DA matches the MAC address content is routed. */
;;;400        if (macAddr)
00001c  f1b80f00          CMP      r8,#0
000020  d01c              BEQ      |L23.92|
;;;401        {
;;;402            ENET_SetMacAddr(base, macAddr);
000022  4646              MOV      r6,r8
000024  b106              CBZ      r6,|L23.40|
000026  e005              B        |L23.52|
                  |L23.40|
000028  f240229f          MOV      r2,#0x29f
00002c  a13a              ADR      r1,|L23.280|
00002e  a040              ADR      r0,|L23.304|
000030  f7fffffe          BL       __aeabi_assert
                  |L23.52|
000034  78f0              LDRB     r0,[r6,#3]
000036  0600              LSLS     r0,r0,#24
000038  78b1              LDRB     r1,[r6,#2]
00003a  ea404001          ORR      r0,r0,r1,LSL #16
00003e  7871              LDRB     r1,[r6,#1]
000040  ea402001          ORR      r0,r0,r1,LSL #8
000044  7831              LDRB     r1,[r6,#0]
000046  4308              ORRS     r0,r0,r1
000048  f8c50304          STR      r0,[r5,#0x304]
00004c  7930              LDRB     r0,[r6,#4]
00004e  7971              LDRB     r1,[r6,#5]
000050  ea402001          ORR      r0,r0,r1,LSL #8
000054  f8c50300          STR      r0,[r5,#0x300]
000058  bf00              NOP      
00005a  bf00              NOP      
                  |L23.92|
;;;403        }
;;;404    
;;;405        /* Set the receive filter. */
;;;406        reg = ENET_MAC_FRAME_FILTER_PR(!!(config->specialControl & kENET_PromiscuousEnable)) |
00005c  7820              LDRB     r0,[r4,#0]
00005e  f3c00080          UBFX     r0,r0,#2,#1
000062  7821              LDRB     r1,[r4,#0]
000064  f3c11100          UBFX     r1,r1,#4,#1
000068  2220              MOVS     r2,#0x20
00006a  ea021141          AND      r1,r2,r1,LSL #5
00006e  4308              ORRS     r0,r0,r1
000070  7821              LDRB     r1,[r4,#0]
000072  f3c11140          UBFX     r1,r1,#5,#1
000076  2210              MOVS     r2,#0x10
000078  ea021101          AND      r1,r2,r1,LSL #4
00007c  ea400701          ORR      r7,r0,r1
;;;407              ENET_MAC_FRAME_FILTER_DBF(!!(config->specialControl & kENET_BroadCastRxDisable)) |
;;;408              ENET_MAC_FRAME_FILTER_PM(!!(config->specialControl & kENET_MulticastAllEnable));
;;;409        base->MAC_FRAME_FILTER = reg;
000080  60af              STR      r7,[r5,#8]
;;;410        /* Flow control. */
;;;411        if (config->specialControl & kENET_FlowControlEnable)
000082  7820              LDRB     r0,[r4,#0]
000084  f0000008          AND      r0,r0,#8
000088  b158              CBZ      r0,|L23.162|
;;;412        {
;;;413            base->MAC_RX_FLOW_CTRL = ENET_MAC_RX_FLOW_CTRL_RFE_MASK | ENET_MAC_RX_FLOW_CTRL_UP_MASK;
00008a  2003              MOVS     r0,#3
00008c  f8c50090          STR      r0,[r5,#0x90]
;;;414            base->MAC_TX_FLOW_CTRL_Q[0] = ENET_MAC_TX_FLOW_CTRL_Q_PT(config->pauseDuration);
000090  89a0              LDRH     r0,[r4,#0xc]
000092  4929              LDR      r1,|L23.312|
000094  ea014000          AND      r0,r1,r0,LSL #16
000098  6728              STR      r0,[r5,#0x70]
;;;415            base->MAC_TX_FLOW_CTRL_Q[1] = ENET_MAC_TX_FLOW_CTRL_Q_PT(config->pauseDuration);
00009a  89a0              LDRH     r0,[r4,#0xc]
00009c  ea014100          AND      r1,r1,r0,LSL #16
0000a0  6769              STR      r1,[r5,#0x74]
                  |L23.162|
;;;416        }
;;;417    
;;;418        /* Set the 1us ticket. */
;;;419        reg = CLOCK_GetFreq(kCLOCK_CoreSysClk) / ENET_MICRSECS_ONESECOND - 1;
0000a2  2000              MOVS     r0,#0
0000a4  f7fffffe          BL       CLOCK_GetFreq
0000a8  4924              LDR      r1,|L23.316|
0000aa  fbb0f0f1          UDIV     r0,r0,r1
0000ae  1e47              SUBS     r7,r0,#1
;;;420        base->MAC_1US_TIC_COUNTR = ENET_MAC_1US_TIC_COUNTR_TIC_1US_CNTR(reg);
0000b0  f3c7000b          UBFX     r0,r7,#0,#12
0000b4  f8c500dc          STR      r0,[r5,#0xdc]
;;;421    
;;;422        /* Set the speed and duplex. */
;;;423        reg = ENET_MAC_CONFIG_ECRSFD_MASK | ENET_MAC_CONFIG_PS_MASK | ENET_MAC_CONFIG_DM(config->miiDuplex) |
0000b8  7aa0              LDRB     r0,[r4,#0xa]
0000ba  f44f5100          MOV      r1,#0x2000
0000be  ea013040          AND      r0,r1,r0,LSL #13
0000c2  f4404008          ORR      r0,r0,#0x8800
0000c6  7a61              LDRB     r1,[r4,#9]
0000c8  f44f4280          MOV      r2,#0x4000
0000cc  ea023181          AND      r1,r2,r1,LSL #14
0000d0  4308              ORRS     r0,r0,r1
0000d2  7821              LDRB     r1,[r4,#0]
0000d4  f3c11180          UBFX     r1,r1,#6,#1
0000d8  0212              LSLS     r2,r2,#8
0000da  ea025181          AND      r1,r2,r1,LSL #22
0000de  ea400701          ORR      r7,r0,r1
;;;424              ENET_MAC_CONFIG_FES(config->miiSpeed) |
;;;425              ENET_MAC_CONFIG_S2KP(!!(config->specialControl & kENET_8023AS2KPacket));
;;;426        if (config->miiDuplex == kENET_MiiHalfDuplex)
0000e2  7aa0              LDRB     r0,[r4,#0xa]
0000e4  b908              CBNZ     r0,|L23.234|
;;;427        {
;;;428            reg |= ENET_MAC_CONFIG_IPG(ENET_HALFDUPLEX_DEFAULTIPG);
0000e6  f0476780          ORR      r7,r7,#0x4000000
                  |L23.234|
;;;429        }
;;;430        base->MAC_CONFIG = reg;
0000ea  602f              STR      r7,[r5,#0]
;;;431    
;;;432        /* Enable channel. */
;;;433        base->MAC_RXQ_CTRL[0] = ENET_MAC_RXQ_CTRL_RXQ0EN(1) | ENET_MAC_RXQ_CTRL_RXQ1EN(1);
0000ec  2005              MOVS     r0,#5
0000ee  f8c500a0          STR      r0,[r5,#0xa0]
;;;434    }
0000f2  e8bd81f0          POP      {r4-r8,pc}
;;;435    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L23.248|
0000f8  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
0000fc  44726976
000100  6572735c
000104  66736c5f
000108  656e6574
00010c  2e6300  
00010f  00                DCB      0
                  |L23.272|
000110  636f6e66          DCB      "config",0
000114  696700  
000117  00                DCB      0
                  |L23.280|
000118  5352435c          DCB      "SRC\\Drivers\\fsl_enet.h",0
00011c  44726976
000120  6572735c
000124  66736c5f
000128  656e6574
00012c  2e6800  
00012f  00                DCB      0
                  |L23.304|
000130  6d616341          DCB      "macAddr",0
000134  64647200
                  |L23.312|
                          DCD      0xffff0000
                  |L23.316|
                          DCD      0x000f4240

                          AREA ||i.ENET_SetSMI||, CODE, READONLY, ALIGN=2

                  ENET_SetSMI PROC
;;;1168   
;;;1169   void ENET_SetSMI(ENET_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;1170   {
000002  4606              MOV      r6,r0
;;;1171       uint32_t crDiv;
;;;1172       uint32_t srcClock_Hz = CLOCK_GetFreq(kCLOCK_CoreSysClk) / 1000000U;
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       CLOCK_GetFreq
00000a  490e              LDR      r1,|L24.68|
00000c  fbb0f4f1          UDIV     r4,r0,r1
;;;1173   
;;;1174       if ((srcClock_Hz >= 20U) && (srcClock_Hz < 35))
000010  2c14              CMP      r4,#0x14
000012  d303              BCC      |L24.28|
000014  2c23              CMP      r4,#0x23
000016  d201              BCS      |L24.28|
;;;1175       {
;;;1176           crDiv = 2;
000018  2502              MOVS     r5,#2
00001a  e00c              B        |L24.54|
                  |L24.28|
;;;1177       }
;;;1178       else if ((srcClock_Hz >= 35) && (srcClock_Hz < 60))
00001c  2c23              CMP      r4,#0x23
00001e  d303              BCC      |L24.40|
000020  2c3c              CMP      r4,#0x3c
000022  d201              BCS      |L24.40|
;;;1179       {
;;;1180           crDiv = 3;
000024  2503              MOVS     r5,#3
000026  e006              B        |L24.54|
                  |L24.40|
;;;1181       }
;;;1182       else if ((srcClock_Hz >= 100) && (srcClock_Hz < 150))
000028  2c64              CMP      r4,#0x64
00002a  d303              BCC      |L24.52|
00002c  2c96              CMP      r4,#0x96
00002e  d201              BCS      |L24.52|
;;;1183       {
;;;1184           crDiv = 1;
000030  2501              MOVS     r5,#1
000032  e000              B        |L24.54|
                  |L24.52|
;;;1185       }
;;;1186       else
;;;1187       {
;;;1188           crDiv = 0;
000034  2500              MOVS     r5,#0
                  |L24.54|
;;;1189       }
;;;1190   
;;;1191       base->MAC_MDIO_ADDR = ENET_MAC_MDIO_ADDR_CR(crDiv);
000036  f44f6070          MOV      r0,#0xf00
00003a  ea002005          AND      r0,r0,r5,LSL #8
00003e  f8c60200          STR      r0,[r6,#0x200]
;;;1192   }
000042  bd70              POP      {r4-r6,pc}
;;;1193   
                          ENDP

                  |L24.68|
                          DCD      0x000f4240

                          AREA ||i.ENET_SetSYSControl||, CODE, READONLY, ALIGN=2

                  ENET_SetSYSControl PROC
;;;304    
;;;305    static void ENET_SetSYSControl(enet_mii_mode_t miiMode)
000000  f44f7280          MOV      r2,#0x100
;;;306    {
;;;307        /* Reset first. */
;;;308        SYSCON->PRESETCTRL[2] = SYSCON_PRESETCTRL_ETH_RST_MASK;
000004  4906              LDR      r1,|L25.32|
000006  600a              STR      r2,[r1,#0]
;;;309        SYSCON->PRESETCTRL[2] &= ~SYSCON_PRESETCTRL_ETH_RST_MASK;
000008  6809              LDR      r1,[r1,#0]
00000a  f4217280          BIC      r2,r1,#0x100
00000e  4904              LDR      r1,|L25.32|
000010  600a              STR      r2,[r1,#0]
;;;310        /* Set MII/RMII before the peripheral ethernet dma reset. */
;;;311        SYSCON->ETHPHYSEL = (SYSCON->ETHPHYSEL & ~SYSCON_ETHPHYSEL_PHY_SEL_MASK) | SYSCON_ETHPHYSEL_PHY_SEL(miiMode);
000012  4904              LDR      r1,|L25.36|
000014  6809              LDR      r1,[r1,#0]
000016  f3600182          BFI      r1,r0,#2,#1
00001a  4a02              LDR      r2,|L25.36|
00001c  6011              STR      r1,[r2,#0]
;;;312    }
00001e  4770              BX       lr
;;;313    
                          ENDP

                  |L25.32|
                          DCD      0x40000108
                  |L25.36|
                          DCD      0x40000450

                          AREA ||i.ENET_SetupTxDescriptor||, CODE, READONLY, ALIGN=1

                  ENET_SetupTxDescriptor PROC
;;;1488   
;;;1489   void ENET_SetupTxDescriptor(enet_tx_bd_struct_t *txDesc,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1490                               void *buffer1,
;;;1491                               uint32_t bytes1,
;;;1492                               void *buffer2,
;;;1493                               uint32_t bytes2,
;;;1494                               uint32_t framelen,
;;;1495                               bool intEnable,
;;;1496                               bool tsEnable,
;;;1497                               enet_desc_flag flag,
;;;1498                               uint8_t slotNum)
;;;1499   {
000004  4604              MOV      r4,r0
000006  ad09              ADD      r5,sp,#0x24
000008  e89510e0          LDM      r5,{r5-r7,r12}
00000c  e9dd890d          LDRD     r8,r9,[sp,#0x34]
;;;1500       uint32_t control = ENET_TXDESCRIP_RD_BL1(bytes1) | ENET_TXDESCRIP_RD_BL2(bytes2);
000010  f3c20a0d          UBFX     r10,r2,#0,#14
000014  f3c50b0d          UBFX     r11,r5,#0,#14
000018  ea4a400b          ORR      r0,r10,r11,LSL #16
;;;1501   
;;;1502       if (tsEnable)
00001c  f1bc0f00          CMP      r12,#0
000020  d002              BEQ      |L26.40|
;;;1503       {
;;;1504           control |= ENET_TXDESCRIP_RD_TTSE_MASK;
000022  f0404080          ORR      r0,r0,#0x40000000
000026  e001              B        |L26.44|
                  |L26.40|
;;;1505       }
;;;1506       else
;;;1507       {
;;;1508           control &= ~ENET_TXDESCRIP_RD_TTSE_MASK;
000028  f0204080          BIC      r0,r0,#0x40000000
                  |L26.44|
;;;1509       }
;;;1510   
;;;1511       if (intEnable)
00002c  b117              CBZ      r7,|L26.52|
;;;1512       {
;;;1513           control |= ENET_TXDESCRIP_RD_IOC_MASK;
00002e  f0404000          ORR      r0,r0,#0x80000000
000032  e001              B        |L26.56|
                  |L26.52|
;;;1514       }
;;;1515       else
;;;1516       {
;;;1517           control &= ~ENET_TXDESCRIP_RD_IOC_MASK;
000034  f0204000          BIC      r0,r0,#0x80000000
                  |L26.56|
;;;1518       }
;;;1519   
;;;1520       /* Preare the descriptor for transmit. */
;;;1521       txDesc->buff1Addr = (uint32_t)buffer1;
000038  6021              STR      r1,[r4,#0]
;;;1522       txDesc->buff2Addr = (uint32_t)buffer2;
00003a  6063              STR      r3,[r4,#4]
;;;1523       txDesc->buffLen = control;
00003c  60a0              STR      r0,[r4,#8]
;;;1524   
;;;1525       control = ENET_TXDESCRIP_RD_FL(framelen) | ENET_TXDESCRIP_RD_LDFD(flag) | ENET_TXDESCRIP_RD_OWN_MASK;
00003e  f3c60a0e          UBFX     r10,r6,#0,#15
000042  f0080b03          AND      r11,r8,#3
000046  ea4a7a0b          ORR      r10,r10,r11,LSL #28
00004a  f04a4000          ORR      r0,r10,#0x80000000
;;;1526   
;;;1527       txDesc->controlStat = control;
00004e  60e0              STR      r0,[r4,#0xc]
;;;1528   }
000050  e8bd8ff0          POP      {r4-r11,pc}
;;;1529   
                          ENDP


                          AREA ||i.ENET_StartRxTx||, CODE, READONLY, ALIGN=2

                  ENET_StartRxTx PROC
;;;954    
;;;955    void ENET_StartRxTx(ENET_Type *base, uint8_t txRingNum, uint8_t rxRingNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;956    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;957        assert(txRingNum);
00000a  b106              CBZ      r6,|L27.14|
00000c  e005              B        |L27.26|
                  |L27.14|
00000e  f24032bd          MOV      r2,#0x3bd
000012  a120              ADR      r1,|L27.148|
000014  a025              ADR      r0,|L27.172|
000016  f7fffffe          BL       __aeabi_assert
                  |L27.26|
;;;958        assert(rxRingNum);
00001a  b107              CBZ      r7,|L27.30|
00001c  e005              B        |L27.42|
                  |L27.30|
00001e  f24032be          MOV      r2,#0x3be
000022  a11c              ADR      r1,|L27.148|
000024  a024              ADR      r0,|L27.184|
000026  f7fffffe          BL       __aeabi_assert
                  |L27.42|
;;;959    
;;;960        uint8_t index;
;;;961    
;;;962        if (txRingNum > ENET_RING_NUM_MAX)
00002a  2e02              CMP      r6,#2
00002c  d900              BLS      |L27.48|
;;;963        {
;;;964            txRingNum = ENET_RING_NUM_MAX;
00002e  2602              MOVS     r6,#2
                  |L27.48|
;;;965        }
;;;966        if (rxRingNum > ENET_RING_NUM_MAX)
000030  2f02              CMP      r7,#2
000032  d900              BLS      |L27.54|
;;;967        {
;;;968            rxRingNum = ENET_RING_NUM_MAX;
000034  2702              MOVS     r7,#2
                  |L27.54|
;;;969        }
;;;970        /* Start/Acive the DMA first. */
;;;971        for (index = 0; index < rxRingNum; index++)
000036  2500              MOVS     r5,#0
000038  e00d              B        |L27.86|
                  |L27.58|
;;;972        {
;;;973            base->DMA_CH[index].DMA_CHX_RX_CTRL |= ENET_DMA_CH_DMA_CHX_RX_CTRL_SR_MASK;
00003a  f5045088          ADD      r0,r4,#0x1100
00003e  eb0010c5          ADD      r0,r0,r5,LSL #7
000042  6880              LDR      r0,[r0,#8]
000044  f0400101          ORR      r1,r0,#1
000048  f5045088          ADD      r0,r4,#0x1100
00004c  eb0010c5          ADD      r0,r0,r5,LSL #7
000050  6081              STR      r1,[r0,#8]
000052  1c68              ADDS     r0,r5,#1              ;971
000054  b2c5              UXTB     r5,r0                 ;971
                  |L27.86|
000056  42bd              CMP      r5,r7                 ;971
000058  dbef              BLT      |L27.58|
;;;974        }
;;;975        for (index = 0; index < txRingNum; index++)
00005a  2500              MOVS     r5,#0
00005c  e00d              B        |L27.122|
                  |L27.94|
;;;976        {
;;;977            base->DMA_CH[index].DMA_CHX_TX_CTRL |= ENET_DMA_CH_DMA_CHX_TX_CTRL_ST_MASK;
00005e  f5045088          ADD      r0,r4,#0x1100
000062  eb0010c5          ADD      r0,r0,r5,LSL #7
000066  6840              LDR      r0,[r0,#4]
000068  f0400101          ORR      r1,r0,#1
00006c  f5045088          ADD      r0,r4,#0x1100
000070  eb0010c5          ADD      r0,r0,r5,LSL #7
000074  6041              STR      r1,[r0,#4]
000076  1c68              ADDS     r0,r5,#1              ;975
000078  b2c5              UXTB     r5,r0                 ;975
                  |L27.122|
00007a  42b5              CMP      r5,r6                 ;975
00007c  dbef              BLT      |L27.94|
;;;978        }
;;;979    
;;;980        /* Enable the RX/TX then. */
;;;981        base->MAC_CONFIG |= ENET_MAC_CONFIG_RE_MASK;
00007e  6820              LDR      r0,[r4,#0]
000080  f0400001          ORR      r0,r0,#1
000084  6020              STR      r0,[r4,#0]
;;;982        base->MAC_CONFIG |= ENET_MAC_CONFIG_TE_MASK;
000086  6820              LDR      r0,[r4,#0]
000088  f0400002          ORR      r0,r0,#2
00008c  6020              STR      r0,[r4,#0]
;;;983    }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;984    
                          ENDP

000092  0000              DCW      0x0000
                  |L27.148|
000094  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000098  44726976
00009c  6572735c
0000a0  66736c5f
0000a4  656e6574
0000a8  2e6300  
0000ab  00                DCB      0
                  |L27.172|
0000ac  74785269          DCB      "txRingNum",0
0000b0  6e674e75
0000b4  6d00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L27.184|
0000b8  72785269          DCB      "rxRingNum",0
0000bc  6e674e75
0000c0  6d00    
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i.ENET_StartSMIRead||, CODE, READONLY, ALIGN=1

                  ENET_StartSMIRead PROC
;;;1204   
;;;1205   void ENET_StartSMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg)
000000  b530              PUSH     {r4,r5,lr}
;;;1206   {
;;;1207       uint32_t reg = base->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_CR_MASK;
000002  f8d04200          LDR      r4,[r0,#0x200]
000006  f4046370          AND      r3,r4,#0xf00
;;;1208   
;;;1209       /* Build MII read command. */
;;;1210       base->MAC_MDIO_ADDR = reg | ENET_MAC_MDIO_ADDR_MOC(kENET_MiiReadFrame) | ENET_MAC_MDIO_ADDR_PA(phyAddr) |
00000a  f043040c          ORR      r4,r3,#0xc
00000e  f04f7578          MOV      r5,#0x3e00000
000012  ea055541          AND      r5,r5,r1,LSL #21
000016  432c              ORRS     r4,r4,r5
000018  f44f15f8          MOV      r5,#0x1f0000
00001c  ea054502          AND      r5,r5,r2,LSL #16
000020  432c              ORRS     r4,r4,r5
000022  f8c04200          STR      r4,[r0,#0x200]
;;;1211                             ENET_MAC_MDIO_ADDR_RDA(phyReg);
;;;1212       base->MAC_MDIO_ADDR |= ENET_MAC_MDIO_ADDR_MB_MASK;
000026  f8d04200          LDR      r4,[r0,#0x200]
00002a  f0440401          ORR      r4,r4,#1
00002e  f8c04200          STR      r4,[r0,#0x200]
;;;1213   }
000032  bd30              POP      {r4,r5,pc}
;;;1214   
                          ENDP


                          AREA ||i.ENET_StartSMIWrite||, CODE, READONLY, ALIGN=1

                  ENET_StartSMIWrite PROC
;;;1193   
;;;1194   void ENET_StartSMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;1195   {
;;;1196       uint32_t reg = base->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_CR_MASK;
000002  f5007000          ADD      r0,r0,#0x200
000006  6805              LDR      r5,[r0,#0]
000008  f4056470          AND      r4,r5,#0xf00
;;;1197   
;;;1198       /* Build MII write command. */
;;;1199       base->MAC_MDIO_ADDR = reg | ENET_MAC_MDIO_ADDR_MOC(kENET_MiiWriteFrame) | ENET_MAC_MDIO_ADDR_PA(phyAddr) |
00000c  f0440504          ORR      r5,r4,#4
000010  f04f7678          MOV      r6,#0x3e00000
000014  ea065641          AND      r6,r6,r1,LSL #21
000018  4335              ORRS     r5,r5,r6
00001a  f44f16f8          MOV      r6,#0x1f0000
00001e  ea064602          AND      r6,r6,r2,LSL #16
000022  4335              ORRS     r5,r5,r6
000024  6005              STR      r5,[r0,#0]
;;;1200                             ENET_MAC_MDIO_ADDR_RDA(phyReg);
;;;1201       base->MAC_MDIO_DATA = data;
000026  6043              STR      r3,[r0,#4]
;;;1202       base->MAC_MDIO_ADDR |= ENET_MAC_MDIO_ADDR_MB_MASK;
000028  6805              LDR      r5,[r0,#0]
00002a  f0450501          ORR      r5,r5,#1
00002e  6005              STR      r5,[r0,#0]
000030  f5a07000          SUB      r0,r0,#0x200
;;;1203   }
000034  bd70              POP      {r4-r6,pc}
;;;1204   
                          ENDP


                          AREA ||i.ENET_TxDescriptorsInit||, CODE, READONLY, ALIGN=1

                  ENET_TxDescriptorsInit PROC
;;;435    
;;;436    static status_t ENET_TxDescriptorsInit(ENET_Type *base,
000000  e92d42f0          PUSH     {r4-r7,r9,lr}
;;;437                                           const enet_buffer_config_t *bufferConfig,
;;;438                                           bool intTxEnable,
;;;439                                           uint8_t channel)
;;;440    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;441        uint16_t j;
;;;442        enet_tx_bd_struct_t *txbdPtr;
;;;443        uint32_t control = intTxEnable ? ENET_TXDESCRIP_RD_IOC_MASK : 0;
00000a  b117              CBZ      r7,|L30.18|
00000c  f04f4000          MOV      r0,#0x80000000
000010  e000              B        |L30.20|
                  |L30.18|
000012  2000              MOVS     r0,#0
                  |L30.20|
000014  4684              MOV      r12,r0
;;;444        uint32_t controlStat;
;;;445        const enet_buffer_config_t *buffCfg = bufferConfig;
000016  4629              MOV      r1,r5
;;;446    
;;;447        if (!buffCfg)
000018  b911              CBNZ     r1,|L30.32|
;;;448        {
;;;449            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L30.28|
;;;450        }
;;;451    
;;;452        /* Check the ring length. */
;;;453        if (buffCfg->txRingLen < ENET_MIN_RINGLEN)
;;;454        {
;;;455            return kStatus_InvalidArgument;
;;;456        }
;;;457        /* Set the tx descriptor start/tail pointer, shall be word aligned. */
;;;458        base->DMA_CH[channel].DMA_CHX_TXDESC_LIST_ADDR =
;;;459            (uint32_t)buffCfg->txDescStartAddrAlign & ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL_MASK;
;;;460        base->DMA_CH[channel].DMA_CHX_TXDESC_TAIL_PTR =
;;;461            (uint32_t)buffCfg->txDescTailAddrAlign & ENET_DMA_CH_DMA_CHX_TXDESC_LIST_ADDR_STL_MASK;
;;;462        /* Set the tx ring length. */
;;;463        base->DMA_CH[channel].DMA_CHX_TXDESC_RING_LENGTH =
;;;464            (uint16_t)(buffCfg->txRingLen - 1) & ENET_DMA_CH_DMA_CHX_TXDESC_RING_LENGTH_TDRL_MASK;
;;;465    
;;;466        /* Init the txbdPtr to the transmit descriptor start address. */
;;;467        txbdPtr = (enet_tx_bd_struct_t *)(buffCfg->txDescStartAddrAlign);
;;;468        for (j = 0; j < buffCfg->txRingLen; j++)
;;;469        {
;;;470            txbdPtr->buff1Addr = 0;
;;;471            txbdPtr->buff2Addr = 0;
;;;472            txbdPtr->buffLen = control;
;;;473            txbdPtr->controlStat = controlStat;
;;;474            txbdPtr++;
;;;475        }
;;;476    
;;;477        return kStatus_Success;
;;;478    }
00001c  e8bd82f0          POP      {r4-r7,r9,pc}
                  |L30.32|
000020  7848              LDRB     r0,[r1,#1]            ;453
000022  2804              CMP      r0,#4                 ;453
000024  d201              BCS      |L30.42|
000026  2004              MOVS     r0,#4                 ;455
000028  e7f8              B        |L30.28|
                  |L30.42|
00002a  6848              LDR      r0,[r1,#4]            ;458
00002c  f0200903          BIC      r9,r0,#3              ;458
000030  f5045088          ADD      r0,r4,#0x1100         ;458
000034  eb0010c3          ADD      r0,r0,r3,LSL #7       ;458
000038  f8c09014          STR      r9,[r0,#0x14]         ;458
00003c  6888              LDR      r0,[r1,#8]            ;460
00003e  f0200903          BIC      r9,r0,#3              ;460
000042  f5045088          ADD      r0,r4,#0x1100         ;460
000046  eb0010c3          ADD      r0,r0,r3,LSL #7       ;460
00004a  f8c09020          STR      r9,[r0,#0x20]         ;460
00004e  7848              LDRB     r0,[r1,#1]            ;463
000050  1e40              SUBS     r0,r0,#1              ;463
000052  f3c00909          UBFX     r9,r0,#0,#10          ;463
000056  f5045088          ADD      r0,r4,#0x1100         ;463
00005a  eb0010c3          ADD      r0,r0,r3,LSL #7       ;463
00005e  f8c0902c          STR      r9,[r0,#0x2c]         ;463
000062  684a              LDR      r2,[r1,#4]            ;467
000064  2600              MOVS     r6,#0                 ;468
000066  e009              B        |L30.124|
                  |L30.104|
000068  2000              MOVS     r0,#0                 ;470
00006a  6010              STR      r0,[r2,#0]            ;470
00006c  6050              STR      r0,[r2,#4]            ;471
00006e  f8c2c008          STR      r12,[r2,#8]           ;472
000072  f8c2800c          STR      r8,[r2,#0xc]          ;473
000076  3210              ADDS     r2,r2,#0x10           ;474
000078  1c70              ADDS     r0,r6,#1              ;468
00007a  b286              UXTH     r6,r0                 ;468
                  |L30.124|
00007c  7848              LDRB     r0,[r1,#1]            ;468
00007e  42b0              CMP      r0,r6                 ;468
000080  dcf2              BGT      |L30.104|
000082  2000              MOVS     r0,#0                 ;477
000084  e7ca              B        |L30.28|
;;;479    
                          ENDP


                          AREA ||i.ENET_UpdateRxDescriptor||, CODE, READONLY, ALIGN=2

                  ENET_UpdateRxDescriptor PROC
;;;1454   
;;;1455   void ENET_UpdateRxDescriptor(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1456       enet_rx_bd_struct_t *rxDesc, void *buffer1, void *buffer2, bool intEnable, bool doubleBuffEnable)
;;;1457   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1458       assert(rxDesc);
000010  b104              CBZ      r4,|L31.20|
000012  e005              B        |L31.32|
                  |L31.20|
000014  f24052b2          MOV      r2,#0x5b2
000018  a10d              ADR      r1,|L31.80|
00001a  a013              ADR      r0,|L31.104|
00001c  f7fffffe          BL       __aeabi_assert
                  |L31.32|
;;;1459       uint32_t control = ENET_RXDESCRIP_RD_OWN_MASK | ENET_RXDESCRIP_RD_BUFF1VALID_MASK;
000020  f04f4501          MOV      r5,#0x81000000
;;;1460   
;;;1461       if (intEnable)
000024  f1b80f00          CMP      r8,#0
000028  d001              BEQ      |L31.46|
;;;1462       {
;;;1463           control |= ENET_RXDESCRIP_RD_IOC_MASK;
00002a  f0454580          ORR      r5,r5,#0x40000000
                  |L31.46|
;;;1464       }
;;;1465   
;;;1466       if (doubleBuffEnable)
00002e  f1b90f00          CMP      r9,#0
000032  d001              BEQ      |L31.56|
;;;1467       {
;;;1468           control |= ENET_RXDESCRIP_RD_BUFF2VALID_MASK;
000034  f0457500          ORR      r5,r5,#0x2000000
                  |L31.56|
;;;1469       }
;;;1470   
;;;1471       /* Update the buffer if needed. */
;;;1472       if (buffer1)
000038  b106              CBZ      r6,|L31.60|
;;;1473       {
;;;1474           rxDesc->buff1Addr = (uint32_t)buffer1;
00003a  6026              STR      r6,[r4,#0]
                  |L31.60|
;;;1475       }
;;;1476       if (buffer2)
00003c  b10f              CBZ      r7,|L31.66|
;;;1477       {
;;;1478           rxDesc->buff2Addr = (uint32_t)buffer2;
00003e  60a7              STR      r7,[r4,#8]
000040  e001              B        |L31.70|
                  |L31.66|
;;;1479       }
;;;1480       else
;;;1481       {
;;;1482           rxDesc->buff2Addr = 0;
000042  2000              MOVS     r0,#0
000044  60a0              STR      r0,[r4,#8]
                  |L31.70|
;;;1483       }
;;;1484   
;;;1485       rxDesc->reserved = 0;
000046  2000              MOVS     r0,#0
000048  6060              STR      r0,[r4,#4]
;;;1486       rxDesc->control = control;
00004a  60e5              STR      r5,[r4,#0xc]
;;;1487   }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;1488   
                          ENDP

                  |L31.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_enet.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  656e6574
000064  2e6300  
000067  00                DCB      0
                  |L31.104|
000068  72784465          DCB      "rxDesc",0
00006c  736300  
00006f  00                DCB      0

                          AREA ||i.ETHERNET_DriverIRQHandler||, CODE, READONLY, ALIGN=2

                  ETHERNET_DriverIRQHandler PROC
;;;1808   
;;;1809   void ETHERNET_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1810   {
;;;1811       s_enetIsr(ENET, s_ENETHandle[0]);
000002  4803              LDR      r0,|L32.16|
000004  6801              LDR      r1,[r0,#0]  ; s_ENETHandle
000006  4803              LDR      r0,|L32.20|
000008  4a03              LDR      r2,|L32.24|
00000a  6812              LDR      r2,[r2,#0]  ; s_enetIsr
00000c  4790              BLX      r2
;;;1812   }
00000e  bd10              POP      {r4,pc}
                          ENDP

                  |L32.16|
                          DCD      s_ENETHandle
                  |L32.20|
                          DCD      0x40092000
                  |L32.24|
                          DCD      s_enetIsr

                          AREA ||i.EnableIRQ||, CODE, READONLY, ALIGN=1

                  EnableIRQ PROC
;;;198     */
;;;199    static inline void EnableIRQ(IRQn_Type interrupt)
000000  f1100f80          CMN      r0,#0x80
;;;200    {
;;;201        if (NotAvail_IRQn == interrupt)
000004  d100              BNE      |L33.8|
                  |L33.6|
;;;202        {
;;;203            return;
;;;204        }
;;;205    
;;;206    #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
;;;207        if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
;;;208    #endif
;;;209        {
;;;210            NVIC_EnableIRQ(interrupt);
;;;211        }
;;;212    }
000006  4770              BX       lr
                  |L33.8|
000008  bf00              NOP                            ;210
00000a  f000021f          AND      r2,r0,#0x1f           ;210
00000e  2101              MOVS     r1,#1                 ;210
000010  4091              LSLS     r1,r1,r2              ;210
000012  0942              LSRS     r2,r0,#5              ;210
000014  0092              LSLS     r2,r2,#2              ;210
000016  f10222e0          ADD      r2,r2,#0xe000e000     ;210
00001a  f8c21100          STR      r1,[r2,#0x100]        ;210
00001e  bf00              NOP                            ;210
000020  bf00              NOP      
000022  e7f0              B        |L33.6|
;;;213    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_enetClock
000000  0208              DCW      0x0208
000002  0000              DCB      0x00,0x00
                  s_enetBases
                          DCD      0x40092000
                  s_enetIrqId
000008  31                DCB      0x31

                          AREA ||.data||, DATA, ALIGN=2

                  s_ENETHandle
                          DCD      0x00000000
                  s_enetIsr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_enet.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_enet_c_676864a7____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_fsl_enet_c_676864a7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_enet_c_676864a7____REVSH|
#line 402
|__asm___10_fsl_enet_c_676864a7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_fsl_enet_c_676864a7____RRX|
#line 587
|__asm___10_fsl_enet_c_676864a7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
