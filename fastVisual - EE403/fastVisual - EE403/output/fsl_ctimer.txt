; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_ctimer.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_ctimer.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_ctimer.crf SRC\Drivers\fsl_ctimer.c]
                          THUMB

                          AREA ||i.CTIMER0_DriverIRQHandler||, CODE, READONLY, ALIGN=1

                  CTIMER0_DriverIRQHandler PROC
;;;318    /* IRQ handler functions overloading weak symbols in the startup */
;;;319    void CTIMER0_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;320    {
;;;321        CTIMER_GenericIRQHandler(0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       CTIMER_GenericIRQHandler
;;;322    }
000008  bd10              POP      {r4,pc}
;;;323    #endif
                          ENDP


                          AREA ||i.CTIMER1_DriverIRQHandler||, CODE, READONLY, ALIGN=1

                  CTIMER1_DriverIRQHandler PROC
;;;325    #if (FSL_FEATURE_SOC_CTIMER_COUNT > 1U)
;;;326    void CTIMER1_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;327    {
;;;328        CTIMER_GenericIRQHandler(1);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       CTIMER_GenericIRQHandler
;;;329    }
000008  bd10              POP      {r4,pc}
;;;330    #endif
                          ENDP


                          AREA ||i.CTIMER2_DriverIRQHandler||, CODE, READONLY, ALIGN=1

                  CTIMER2_DriverIRQHandler PROC
;;;332    #if (FSL_FEATURE_SOC_CTIMER_COUNT > 2U)
;;;333    void CTIMER2_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;334    {
;;;335        CTIMER_GenericIRQHandler(2);
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       CTIMER_GenericIRQHandler
;;;336    }
000008  bd10              POP      {r4,pc}
;;;337    #endif
                          ENDP


                          AREA ||i.CTIMER3_DriverIRQHandler||, CODE, READONLY, ALIGN=1

                  CTIMER3_DriverIRQHandler PROC
;;;339    #if (FSL_FEATURE_SOC_CTIMER_COUNT > 3U)
;;;340    void CTIMER3_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;341    {
;;;342        CTIMER_GenericIRQHandler(3);
000002  2003              MOVS     r0,#3
000004  f7fffffe          BL       CTIMER_GenericIRQHandler
;;;343    }
000008  bd10              POP      {r4,pc}
;;;344    #endif
                          ENDP


                          AREA ||i.CTIMER4_DriverIRQHandler||, CODE, READONLY, ALIGN=1

                  CTIMER4_DriverIRQHandler PROC
;;;346    #if (FSL_FEATURE_SOC_CTIMER_COUNT > 4U)
;;;347    void CTIMER4_DriverIRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;348    {
;;;349        CTIMER_GenericIRQHandler(4);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       CTIMER_GenericIRQHandler
;;;350    }
000008  bd10              POP      {r4,pc}
;;;351    
                          ENDP


                          AREA ||i.CTIMER_ClearStatusFlags||, CODE, READONLY, ALIGN=1

                  CTIMER_ClearStatusFlags PROC
;;;380     */
;;;381    static inline void CTIMER_ClearStatusFlags(CTIMER_Type *base, uint32_t mask)
000000  6001              STR      r1,[r0,#0]
;;;382    {
;;;383        base->IR = mask;
;;;384    }
000002  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.CTIMER_Deinit||, CODE, READONLY, ALIGN=2

                  CTIMER_Deinit PROC
;;;108    
;;;109    void CTIMER_Deinit(CTIMER_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
000002  4604              MOV      r4,r0
;;;111        uint32_t index = CTIMER_GetInstance(base);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CTIMER_GetInstance
00000a  4605              MOV      r5,r0
;;;112        /* Stop the timer */
;;;113        base->TCR &= ~CTIMER_TCR_CEN_MASK;
00000c  6860              LDR      r0,[r4,#4]
00000e  f0200001          BIC      r0,r0,#1
000012  6060              STR      r0,[r4,#4]
;;;114    
;;;115    #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;116        /* Disable the timer clock*/
;;;117        CLOCK_DisableClock(s_ctimerClocks[index]);
000014  4912              LDR      r1,|L7.96|
000016  f8310015          LDRH     r0,[r1,r5,LSL #1]
00001a  0a01              LSRS     r1,r0,#8
00001c  2903              CMP      r1,#3
00001e  d205              BCS      |L7.44|
000020  2201              MOVS     r2,#1
000022  4082              LSLS     r2,r2,r0
000024  4b0f              LDR      r3,|L7.100|
000026  f8432021          STR      r2,[r3,r1,LSL #2]
00002a  e006              B        |L7.58|
                  |L7.44|
00002c  2201              MOVS     r2,#1
00002e  4082              LSLS     r2,r2,r0
000030  4b0d              LDR      r3,|L7.104|
000032  619a              STR      r2,[r3,#0x18]
000034  2200              MOVS     r2,#0
000036  031b              LSLS     r3,r3,#12
000038  64da              STR      r2,[r3,#0x4c]
                  |L7.58|
00003a  bf00              NOP      
;;;118    #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;119    
;;;120        /* Disable IRQ at NVIC Level */
;;;121        DisableIRQ(s_ctimerIRQ[index]);
00003c  490b              LDR      r1,|L7.108|
00003e  5748              LDRSB    r0,[r1,r5]
000040  f1100f80          CMN      r0,#0x80
000044  d100              BNE      |L7.72|
000046  e00a              B        |L7.94|
                  |L7.72|
000048  bf00              NOP      
00004a  f000021f          AND      r2,r0,#0x1f
00004e  2101              MOVS     r1,#1
000050  4091              LSLS     r1,r1,r2
000052  4a07              LDR      r2,|L7.112|
000054  0943              LSRS     r3,r0,#5
000056  f8421023          STR      r1,[r2,r3,LSL #2]
00005a  bf00              NOP      
00005c  bf00              NOP      
                  |L7.94|
;;;122    }
00005e  bd70              POP      {r4-r6,pc}
;;;123    
                          ENDP

                  |L7.96|
                          DCD      s_ctimerClocks
                  |L7.100|
                          DCD      0x40000240
                  |L7.104|
                          DCD      0x40040000
                  |L7.108|
                          DCD      s_ctimerIRQ
                  |L7.112|
                          DCD      0xe000e180

                          AREA ||i.CTIMER_GenericIRQHandler||, CODE, READONLY, ALIGN=2

                  CTIMER_GenericIRQHandler PROC
;;;288    
;;;289    void CTIMER_GenericIRQHandler(uint32_t index)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;290    {
000004  4604              MOV      r4,r0
;;;291        uint32_t int_stat, i, mask;
;;;292        /* Get Interrupt status flags */
;;;293        int_stat = CTIMER_GetStatusFlags(s_ctimerBases[index]);
000006  491a              LDR      r1,|L8.112|
000008  f8510024          LDR      r0,[r1,r4,LSL #2]
00000c  6801              LDR      r1,[r0,#0]
00000e  460e              MOV      r6,r1
;;;294        /* Clear the status flags that were set */
;;;295        CTIMER_ClearStatusFlags(s_ctimerBases[index], int_stat);
000010  4917              LDR      r1,|L8.112|
000012  f8510024          LDR      r0,[r1,r4,LSL #2]
000016  4631              MOV      r1,r6
000018  f7fffffe          BL       CTIMER_ClearStatusFlags
;;;296        if (ctimerCallbackType[index] == kCTIMER_SingleCallback)
00001c  4815              LDR      r0,|L8.116|
00001e  5d00              LDRB     r0,[r0,r4]
000020  b958              CBNZ     r0,|L8.58|
;;;297        {
;;;298            if (s_ctimerCallback[index][0])
000022  4815              LDR      r0,|L8.120|
000024  f8500024          LDR      r0,[r0,r4,LSL #2]
000028  6800              LDR      r0,[r0,#0]
00002a  b1f0              CBZ      r0,|L8.106|
;;;299            {
;;;300                s_ctimerCallback[index][0](int_stat);
00002c  4812              LDR      r0,|L8.120|
00002e  f8500024          LDR      r0,[r0,r4,LSL #2]
000032  6801              LDR      r1,[r0,#0]
000034  4630              MOV      r0,r6
000036  4788              BLX      r1
000038  e017              B        |L8.106|
                  |L8.58|
;;;301            }
;;;302        }
;;;303        else
;;;304        {
;;;305            for (i = 0; i <= CTIMER_IR_CR3INT_SHIFT; i++)
00003a  2500              MOVS     r5,#0
00003c  e013              B        |L8.102|
                  |L8.62|
;;;306            {
;;;307                mask = 0x01 << i;
00003e  2001              MOVS     r0,#1
000040  fa00f705          LSL      r7,r0,r5
;;;308                /* For each status flag bit that was set call the callback function if it is valid */
;;;309                if ((int_stat & mask) && (s_ctimerCallback[index][i]))
000044  ea060007          AND      r0,r6,r7
000048  b160              CBZ      r0,|L8.100|
00004a  480b              LDR      r0,|L8.120|
00004c  f8500024          LDR      r0,[r0,r4,LSL #2]
000050  f8500025          LDR      r0,[r0,r5,LSL #2]
000054  b130              CBZ      r0,|L8.100|
;;;310                {
;;;311                    s_ctimerCallback[index][i](int_stat);
000056  4808              LDR      r0,|L8.120|
000058  f8500024          LDR      r0,[r0,r4,LSL #2]
00005c  f8501025          LDR      r1,[r0,r5,LSL #2]
000060  4630              MOV      r0,r6
000062  4788              BLX      r1
                  |L8.100|
000064  1c6d              ADDS     r5,r5,#1              ;305
                  |L8.102|
000066  2d07              CMP      r5,#7                 ;305
000068  d9e9              BLS      |L8.62|
                  |L8.106|
;;;312                }
;;;313            }
;;;314        }
;;;315    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;316    
                          ENDP

00006e  0000              DCW      0x0000
                  |L8.112|
                          DCD      s_ctimerBases
                  |L8.116|
                          DCD      ctimerCallbackType
                  |L8.120|
                          DCD      s_ctimerCallback

                          AREA ||i.CTIMER_GetDefaultConfig||, CODE, READONLY, ALIGN=2

                  CTIMER_GetDefaultConfig PROC
;;;123    
;;;124    void CTIMER_GetDefaultConfig(ctimer_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;125    {
000002  4604              MOV      r4,r0
;;;126        assert(config);
000004  b104              CBZ      r4,|L9.8|
000006  e004              B        |L9.18|
                  |L9.8|
000008  227e              MOVS     r2,#0x7e
00000a  a104              ADR      r1,|L9.28|
00000c  a00a              ADR      r0,|L9.56|
00000e  f7fffffe          BL       __aeabi_assert
                  |L9.18|
;;;127    
;;;128        /* Run as a timer */
;;;129        config->mode = kCTIMER_TimerMode;
000012  2000              MOVS     r0,#0
000014  7020              STRB     r0,[r4,#0]
;;;130        /* This field is ignored when mode is timer */
;;;131        config->input = kCTIMER_Capture_0;
000016  7060              STRB     r0,[r4,#1]
;;;132        /* Timer counter is incremented on every APB bus clock */
;;;133        config->prescale = 0;
000018  6060              STR      r0,[r4,#4]
;;;134    }
00001a  bd10              POP      {r4,pc}
;;;135    
                          ENDP

                  |L9.28|
00001c  5352435c          DCB      "SRC\\Drivers\\fsl_ctimer.c",0
000020  44726976
000024  6572735c
000028  66736c5f
00002c  6374696d
000030  65722e63
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0
                  |L9.56|
000038  636f6e66          DCB      "config",0
00003c  696700  
00003f  00                DCB      0

                          AREA ||i.CTIMER_GetInstance||, CODE, READONLY, ALIGN=2

                  CTIMER_GetInstance PROC
;;;70      ******************************************************************************/
;;;71     static uint32_t CTIMER_GetInstance(CTIMER_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;72     {
000002  4605              MOV      r5,r0
;;;73         uint32_t instance;
;;;74         uint32_t ctimerArrayCount = (sizeof(s_ctimerBases) / sizeof(s_ctimerBases[0]));
000004  2605              MOVS     r6,#5
;;;75     
;;;76         /* Find the instance index from base address mappings. */
;;;77         for (instance = 0; instance < ctimerArrayCount; instance++)
000006  2400              MOVS     r4,#0
000008  e006              B        |L10.24|
                  |L10.10|
;;;78         {
;;;79             if (s_ctimerBases[instance] == base)
00000a  480a              LDR      r0,|L10.52|
00000c  f8500024          LDR      r0,[r0,r4,LSL #2]
000010  42a8              CMP      r0,r5
000012  d100              BNE      |L10.22|
;;;80             {
;;;81                 break;
000014  e002              B        |L10.28|
                  |L10.22|
000016  1c64              ADDS     r4,r4,#1              ;77
                  |L10.24|
000018  42b4              CMP      r4,r6                 ;77
00001a  d3f6              BCC      |L10.10|
                  |L10.28|
00001c  bf00              NOP      
;;;82             }
;;;83         }
;;;84     
;;;85         assert(instance < ctimerArrayCount);
00001e  42b4              CMP      r4,r6
000020  d200              BCS      |L10.36|
000022  e004              B        |L10.46|
                  |L10.36|
000024  2255              MOVS     r2,#0x55
000026  a104              ADR      r1,|L10.56|
000028  a00a              ADR      r0,|L10.84|
00002a  f7fffffe          BL       __aeabi_assert
                  |L10.46|
;;;86     
;;;87         return instance;
00002e  4620              MOV      r0,r4
;;;88     }
000030  bd70              POP      {r4-r6,pc}
;;;89     
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      s_ctimerBases
                  |L10.56|
000038  5352435c          DCB      "SRC\\Drivers\\fsl_ctimer.c",0
00003c  44726976
000040  6572735c
000044  66736c5f
000048  6374696d
00004c  65722e63
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L10.84|
000054  696e7374          DCB      "instance < ctimerArrayCount",0
000058  616e6365
00005c  203c2063
000060  74696d65
000064  72417272
000068  6179436f
00006c  756e7400

                          AREA ||i.CTIMER_Init||, CODE, READONLY, ALIGN=2

                  CTIMER_Init PROC
;;;89     
;;;90     void CTIMER_Init(CTIMER_Type *base, const ctimer_config_t *config)
000000  b570              PUSH     {r4-r6,lr}
;;;91     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;92         assert(config);
000006  b104              CBZ      r4,|L11.10|
000008  e004              B        |L11.20|
                  |L11.10|
00000a  225c              MOVS     r2,#0x5c
00000c  a117              ADR      r1,|L11.108|
00000e  a01e              ADR      r0,|L11.136|
000010  f7fffffe          BL       __aeabi_assert
                  |L11.20|
;;;93     
;;;94     #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
;;;95         /* Enable the timer clock*/
;;;96         CLOCK_EnableClock(s_ctimerClocks[CTIMER_GetInstance(base)]);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       CTIMER_GetInstance
00001a  491d              LDR      r1,|L11.144|
00001c  f8315010          LDRH     r5,[r1,r0,LSL #1]
000020  0a28              LSRS     r0,r5,#8
000022  2803              CMP      r0,#3
000024  d205              BCS      |L11.50|
000026  2101              MOVS     r1,#1
000028  40a9              LSLS     r1,r1,r5
00002a  4a1a              LDR      r2,|L11.148|
00002c  f8421020          STR      r1,[r2,r0,LSL #2]
000030  e005              B        |L11.62|
                  |L11.50|
000032  2101              MOVS     r1,#1
000034  078a              LSLS     r2,r1,#30
000036  64d1              STR      r1,[r2,#0x4c]
000038  40a9              LSLS     r1,r1,r5
00003a  4a17              LDR      r2,|L11.152|
00003c  6151              STR      r1,[r2,#0x14]
                  |L11.62|
00003e  bf00              NOP      
;;;97     #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
;;;98     
;;;99         /* Reset the module */
;;;100        RESET_PeripheralReset(s_ctimerResets[CTIMER_GetInstance(base)]);
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       CTIMER_GetInstance
000046  4915              LDR      r1,|L11.156|
000048  f8515020          LDR      r5,[r1,r0,LSL #2]
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       RESET_PeripheralReset
;;;101    
;;;102        /* Setup the cimer mode and count select */
;;;103        base->CTCR = CTIMER_CTCR_CTMODE(config->mode) | CTIMER_CTCR_CINSEL(config->input);
000052  7820              LDRB     r0,[r4,#0]
000054  f0000003          AND      r0,r0,#3
000058  7861              LDRB     r1,[r4,#1]
00005a  220c              MOVS     r2,#0xc
00005c  ea020181          AND      r1,r2,r1,LSL #2
000060  4308              ORRS     r0,r0,r1
000062  6730              STR      r0,[r6,#0x70]
;;;104    
;;;105        /* Setup the timer prescale value */
;;;106        base->PR = CTIMER_PR_PRVAL(config->prescale);
000064  6860              LDR      r0,[r4,#4]
000066  60f0              STR      r0,[r6,#0xc]
;;;107    }
000068  bd70              POP      {r4-r6,pc}
;;;108    
                          ENDP

00006a  0000              DCW      0x0000
                  |L11.108|
00006c  5352435c          DCB      "SRC\\Drivers\\fsl_ctimer.c",0
000070  44726976
000074  6572735c
000078  66736c5f
00007c  6374696d
000080  65722e63
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L11.136|
000088  636f6e66          DCB      "config",0
00008c  696700  
00008f  00                DCB      0
                  |L11.144|
                          DCD      s_ctimerClocks
                  |L11.148|
                          DCD      0x40000220
                  |L11.152|
                          DCD      0x40040000
                  |L11.156|
                          DCD      s_ctimerResets

                          AREA ||i.CTIMER_RegisterCallBack||, CODE, READONLY, ALIGN=2

                  CTIMER_RegisterCallBack PROC
;;;281    
;;;282    void CTIMER_RegisterCallBack(CTIMER_Type *base, ctimer_callback_t *cb_func, ctimer_callback_type_t cb_type)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;283    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;284        uint32_t index = CTIMER_GetInstance(base);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       CTIMER_GetInstance
000010  4606              MOV      r6,r0
;;;285        s_ctimerCallback[index] = cb_func;
000012  4803              LDR      r0,|L12.32|
000014  f8404026          STR      r4,[r0,r6,LSL #2]
;;;286        ctimerCallbackType[index] = cb_type;
000018  4802              LDR      r0,|L12.36|
00001a  5585              STRB     r5,[r0,r6]
;;;287    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;288    
                          ENDP

                  |L12.32|
                          DCD      s_ctimerCallback
                  |L12.36|
                          DCD      ctimerCallbackType

                          AREA ||i.CTIMER_SetupCapture||, CODE, READONLY, ALIGN=2

                  CTIMER_SetupCapture PROC
;;;259    
;;;260    void CTIMER_SetupCapture(CTIMER_Type *base,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;261                             ctimer_capture_channel_t capture,
;;;262                             ctimer_capture_edge_t edge,
;;;263                             bool enableInt)
;;;264    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;265        uint32_t reg = base->CCR;
00000c  6ab5              LDR      r5,[r6,#0x28]
;;;266        uint32_t index = CTIMER_GetInstance(base);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       CTIMER_GetInstance
000014  4681              MOV      r9,r0
;;;267    
;;;268        /* Set the capture edge */
;;;269        reg &= ~((CTIMER_CCR_CAP0RE_MASK | CTIMER_CCR_CAP0FE_MASK | CTIMER_CCR_CAP0I_MASK) << (capture * 3));
000016  eb040144          ADD      r1,r4,r4,LSL #1
00001a  2007              MOVS     r0,#7
00001c  4088              LSLS     r0,r0,r1
00001e  4385              BICS     r5,r5,r0
;;;270        reg |= (uint32_t)edge << (CTIMER_CCR_CAP0RE_SHIFT + (capture * 3));
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  fa07f001          LSL      r0,r7,r1
000028  4305              ORRS     r5,r5,r0
;;;271        /* Clear status flags */
;;;272        CTIMER_ClearStatusFlags(base, (kCTIMER_Capture0Flag << capture));
00002a  2010              MOVS     r0,#0x10
00002c  fa00f104          LSL      r1,r0,r4
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       CTIMER_ClearStatusFlags
;;;273        /* If call back function is valid then enable capture interrupt for the channel and update the call back function */
;;;274        if (enableInt)
000036  f1b80f00          CMP      r8,#0
00003a  d009              BEQ      |L13.80|
;;;275        {
;;;276            reg |= CTIMER_CCR_CAP0I_MASK << (capture * 3);
00003c  eb040144          ADD      r1,r4,r4,LSL #1
000040  2004              MOVS     r0,#4
000042  4088              LSLS     r0,r0,r1
000044  4305              ORRS     r5,r5,r0
;;;277            EnableIRQ(s_ctimerIRQ[index]);
000046  4904              LDR      r1,|L13.88|
000048  f9110009          LDRSB    r0,[r1,r9]
00004c  f7fffffe          BL       EnableIRQ
                  |L13.80|
;;;278        }
;;;279        base->CCR = reg;
000050  62b5              STR      r5,[r6,#0x28]
;;;280    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;281    
                          ENDP

000056  0000              DCW      0x0000
                  |L13.88|
                          DCD      s_ctimerIRQ

                          AREA ||i.CTIMER_SetupMatch||, CODE, READONLY, ALIGN=2

                  CTIMER_SetupMatch PROC
;;;225    
;;;226    void CTIMER_SetupMatch(CTIMER_Type *base, ctimer_match_t matchChannel, const ctimer_match_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;227    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;228        uint32_t reg;
;;;229        uint32_t index = CTIMER_GetInstance(base);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       CTIMER_GetInstance
000010  4680              MOV      r8,r0
;;;230    
;;;231        /* Set the counter operation when a match on this channel occurs */
;;;232        reg = base->MCR;
000012  697d              LDR      r5,[r7,#0x14]
;;;233        reg &= ~((CTIMER_MCR_MR0R_MASK | CTIMER_MCR_MR0S_MASK | CTIMER_MCR_MR0I_MASK) << (matchChannel * 3));
000014  eb040144          ADD      r1,r4,r4,LSL #1
000018  2007              MOVS     r0,#7
00001a  4088              LSLS     r0,r0,r1
00001c  4385              BICS     r5,r5,r0
;;;234        reg |= (uint32_t)((uint32_t)(config->enableCounterReset) << (CTIMER_MCR_MR0R_SHIFT + (matchChannel * 3)));
00001e  7930              LDRB     r0,[r6,#4]
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  1c49              ADDS     r1,r1,#1
000026  4088              LSLS     r0,r0,r1
000028  4305              ORRS     r5,r5,r0
;;;235        reg |= (uint32_t)((uint32_t)(config->enableCounterStop) << (CTIMER_MCR_MR0S_SHIFT + (matchChannel * 3)));
00002a  7970              LDRB     r0,[r6,#5]
00002c  eb040144          ADD      r1,r4,r4,LSL #1
000030  1c89              ADDS     r1,r1,#2
000032  4088              LSLS     r0,r0,r1
000034  4305              ORRS     r5,r5,r0
;;;236        reg |= (uint32_t)((uint32_t)(config->enableInterrupt) << (CTIMER_MCR_MR0I_SHIFT + (matchChannel * 3)));
000036  7a30              LDRB     r0,[r6,#8]
000038  eb040144          ADD      r1,r4,r4,LSL #1
00003c  4088              LSLS     r0,r0,r1
00003e  4305              ORRS     r5,r5,r0
;;;237        base->MCR = reg;
000040  617d              STR      r5,[r7,#0x14]
;;;238    
;;;239        reg = base->EMR;
000042  6bfd              LDR      r5,[r7,#0x3c]
;;;240        /* Set the match output operation when a match on this channel occurs */
;;;241        reg &= ~(CTIMER_EMR_EMC0_MASK << (matchChannel * 2));
000044  0061              LSLS     r1,r4,#1
000046  2030              MOVS     r0,#0x30
000048  4088              LSLS     r0,r0,r1
00004a  4385              BICS     r5,r5,r0
;;;242        reg |= (uint32_t)config->outControl << (CTIMER_EMR_EMC0_SHIFT + (matchChannel * 2));
00004c  79b0              LDRB     r0,[r6,#6]
00004e  2104              MOVS     r1,#4
000050  eb010144          ADD      r1,r1,r4,LSL #1
000054  4088              LSLS     r0,r0,r1
000056  4305              ORRS     r5,r5,r0
;;;243    
;;;244        /* Set the initial state of the EM bit/output */
;;;245        reg &= ~(CTIMER_EMR_EM0_MASK << matchChannel);
000058  2001              MOVS     r0,#1
00005a  40a0              LSLS     r0,r0,r4
00005c  4385              BICS     r5,r5,r0
;;;246        reg |= (uint32_t)config->outPinInitState << matchChannel;
00005e  79f0              LDRB     r0,[r6,#7]
000060  40a0              LSLS     r0,r0,r4
000062  4305              ORRS     r5,r5,r0
;;;247        base->EMR = reg;
000064  63fd              STR      r5,[r7,#0x3c]
;;;248    
;;;249        /* Set the match value */
;;;250        base->MR[matchChannel] = config->matchValue;
000066  f1070018          ADD      r0,r7,#0x18
00006a  6831              LDR      r1,[r6,#0]
00006c  f8401024          STR      r1,[r0,r4,LSL #2]
;;;251        /* Clear status flags */
;;;252        CTIMER_ClearStatusFlags(base, CTIMER_IR_MR0INT_MASK << matchChannel);
000070  2001              MOVS     r0,#1
000072  fa00f104          LSL      r1,r0,r4
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       CTIMER_ClearStatusFlags
;;;253        /* If interrupt is enabled then enable interrupt and update the call back function */
;;;254        if (config->enableInterrupt)
00007c  7a30              LDRB     r0,[r6,#8]
00007e  b120              CBZ      r0,|L14.138|
;;;255        {
;;;256            EnableIRQ(s_ctimerIRQ[index]);
000080  4903              LDR      r1,|L14.144|
000082  f9110008          LDRSB    r0,[r1,r8]
000086  f7fffffe          BL       EnableIRQ
                  |L14.138|
;;;257        }
;;;258    }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;259    
                          ENDP

00008e  0000              DCW      0x0000
                  |L14.144|
                          DCD      s_ctimerIRQ

                          AREA ||i.CTIMER_SetupPwm||, CODE, READONLY, ALIGN=2

                  CTIMER_SetupPwm PROC
;;;135    
;;;136    status_t CTIMER_SetupPwm(CTIMER_Type *base,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;137                             ctimer_match_t matchChannel,
;;;138                             uint8_t dutyCyclePercent,
;;;139                             uint32_t pwmFreq_Hz,
;;;140                             uint32_t srcClock_Hz,
;;;141                             bool enableInt)
;;;142    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb034          LDR      r11,[sp,#0x34]
;;;143        assert(pwmFreq_Hz > 0);
000010  f1b90f00          CMP      r9,#0
000014  d000              BEQ      |L15.24|
000016  e004              B        |L15.34|
                  |L15.24|
000018  228f              MOVS     r2,#0x8f
00001a  a129              ADR      r1,|L15.192|
00001c  a02f              ADR      r0,|L15.220|
00001e  f7fffffe          BL       __aeabi_assert
                  |L15.34|
;;;144    
;;;145        uint32_t reg;
;;;146        uint32_t period, pulsePeriod = 0;
000022  2000              MOVS     r0,#0
000024  9001              STR      r0,[sp,#4]
;;;147        uint32_t timerClock = srcClock_Hz / (base->PR + 1);
000026  68e0              LDR      r0,[r4,#0xc]
000028  1c40              ADDS     r0,r0,#1
00002a  990c              LDR      r1,[sp,#0x30]
00002c  fbb1f0f0          UDIV     r0,r1,r0
000030  9000              STR      r0,[sp,#0]
;;;148        uint32_t index = CTIMER_GetInstance(base);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       CTIMER_GetInstance
000038  4682              MOV      r10,r0
;;;149    
;;;150        if (matchChannel == kCTIMER_Match_3)
00003a  2d03              CMP      r5,#3
00003c  d102              BNE      |L15.68|
;;;151        {
;;;152            return kStatus_Fail;
00003e  2001              MOVS     r0,#1
                  |L15.64|
;;;153        }
;;;154    
;;;155        /* Enable PWM mode on the channel */
;;;156        base->PWMC |= (1U << matchChannel);
;;;157    
;;;158        /* Clear the stop, reset and interrupt bits for this channel */
;;;159        reg = base->MCR;
;;;160        reg &= ~((CTIMER_MCR_MR0R_MASK | CTIMER_MCR_MR0S_MASK | CTIMER_MCR_MR0I_MASK) << (matchChannel * 3));
;;;161    
;;;162        /* If call back function is valid then enable match interrupt for the channel */
;;;163        if (enableInt)
;;;164        {
;;;165            reg |= (CTIMER_MCR_MR0I_MASK << (CTIMER_MCR_MR0I_SHIFT + (matchChannel * 3)));
;;;166        }
;;;167    
;;;168        /* Reset the counter when match on channel 3 */
;;;169        reg |= CTIMER_MCR_MR3R_MASK;
;;;170    
;;;171        base->MCR = reg;
;;;172    
;;;173        /* Calculate PWM period match value */
;;;174        period = (timerClock / pwmFreq_Hz) - 1;
;;;175    
;;;176        /* Calculate pulse width match value */
;;;177        if (dutyCyclePercent == 0)
;;;178        {
;;;179            pulsePeriod = period + 1;
;;;180        }
;;;181        else
;;;182        {
;;;183            pulsePeriod = (period * (100 - dutyCyclePercent)) / 100;
;;;184        }
;;;185    
;;;186        /* Match on channel 3 will define the PWM period */
;;;187        base->MR[kCTIMER_Match_3] = period;
;;;188    
;;;189        /* This will define the PWM pulse period */
;;;190        base->MR[matchChannel] = pulsePeriod;
;;;191        /* Clear status flags */
;;;192        CTIMER_ClearStatusFlags(base, CTIMER_IR_MR0INT_MASK << matchChannel);
;;;193        /* If call back function is valid then enable interrupt and update the call back function */
;;;194        if (enableInt)
;;;195        {
;;;196            EnableIRQ(s_ctimerIRQ[index]);
;;;197        }
;;;198    
;;;199        return kStatus_Success;
;;;200    }
000040  e8bd9ffc          POP      {r2-r12,pc}
                  |L15.68|
000044  6f60              LDR      r0,[r4,#0x74]         ;156
000046  2101              MOVS     r1,#1                 ;156
000048  40a9              LSLS     r1,r1,r5              ;156
00004a  4308              ORRS     r0,r0,r1              ;156
00004c  6760              STR      r0,[r4,#0x74]         ;156
00004e  6966              LDR      r6,[r4,#0x14]         ;159
000050  eb050145          ADD      r1,r5,r5,LSL #1       ;160
000054  2007              MOVS     r0,#7                 ;160
000056  4088              LSLS     r0,r0,r1              ;160
000058  4386              BICS     r6,r6,r0              ;160
00005a  f1bb0f00          CMP      r11,#0                ;163
00005e  d005              BEQ      |L15.108|
000060  eb050045          ADD      r0,r5,r5,LSL #1       ;165
000064  2101              MOVS     r1,#1                 ;165
000066  fa01f000          LSL      r0,r1,r0              ;165
00006a  4306              ORRS     r6,r6,r0              ;165
                  |L15.108|
00006c  f4466680          ORR      r6,r6,#0x400          ;169
000070  6166              STR      r6,[r4,#0x14]         ;171
000072  9800              LDR      r0,[sp,#0]            ;174
000074  fbb0f0f9          UDIV     r0,r0,r9              ;174
000078  1e47              SUBS     r7,r0,#1              ;174
00007a  f1b80f00          CMP      r8,#0                 ;177
00007e  d102              BNE      |L15.134|
000080  1c78              ADDS     r0,r7,#1              ;179
000082  9001              STR      r0,[sp,#4]            ;179
000084  e006              B        |L15.148|
                  |L15.134|
000086  f1c80064          RSB      r0,r8,#0x64           ;183
00008a  4378              MULS     r0,r7,r0              ;183
00008c  2164              MOVS     r1,#0x64              ;183
00008e  fbb0f0f1          UDIV     r0,r0,r1              ;183
000092  9001              STR      r0,[sp,#4]            ;183
                  |L15.148|
000094  6267              STR      r7,[r4,#0x24]         ;187
000096  f1040118          ADD      r1,r4,#0x18           ;190
00009a  9801              LDR      r0,[sp,#4]            ;190
00009c  f8410025          STR      r0,[r1,r5,LSL #2]     ;190
0000a0  2001              MOVS     r0,#1                 ;192
0000a2  fa00f105          LSL      r1,r0,r5              ;192
0000a6  4620              MOV      r0,r4                 ;192
0000a8  f7fffffe          BL       CTIMER_ClearStatusFlags
0000ac  f1bb0f00          CMP      r11,#0                ;194
0000b0  d004              BEQ      |L15.188|
0000b2  490e              LDR      r1,|L15.236|
0000b4  f911000a          LDRSB    r0,[r1,r10]           ;196
0000b8  f7fffffe          BL       EnableIRQ
                  |L15.188|
0000bc  2000              MOVS     r0,#0                 ;199
0000be  e7bf              B        |L15.64|
;;;201    
                          ENDP

                  |L15.192|
0000c0  5352435c          DCB      "SRC\\Drivers\\fsl_ctimer.c",0
0000c4  44726976
0000c8  6572735c
0000cc  66736c5f
0000d0  6374696d
0000d4  65722e63
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L15.220|
0000dc  70776d46          DCB      "pwmFreq_Hz > 0",0
0000e0  7265715f
0000e4  487a203e
0000e8  203000  
0000eb  00                DCB      0
                  |L15.236|
                          DCD      s_ctimerIRQ

                          AREA ||i.CTIMER_UpdatePwmDutycycle||, CODE, READONLY, ALIGN=1

                  CTIMER_UpdatePwmDutycycle PROC
;;;201    
;;;202    void CTIMER_UpdatePwmDutycycle(CTIMER_Type *base, ctimer_match_t matchChannel, uint8_t dutyCyclePercent)
000000  b570              PUSH     {r4-r6,lr}
;;;203    {
000002  460b              MOV      r3,r1
;;;204        uint32_t pulsePeriod = 0, period;
000004  2400              MOVS     r4,#0
;;;205    
;;;206        /* Match channel 3 defines the PWM period */
;;;207        period = base->MR[kCTIMER_Match_3];
000006  6a41              LDR      r1,[r0,#0x24]
;;;208    
;;;209        /* Calculate pulse width match value */
;;;210        pulsePeriod = (period * dutyCyclePercent) / 100;
000008  fb01f502          MUL      r5,r1,r2
00000c  2664              MOVS     r6,#0x64
00000e  fbb5f4f6          UDIV     r4,r5,r6
;;;211    
;;;212        /* For 0% dutycyle, make pulse period greater than period so the event will never occur */
;;;213        if (dutyCyclePercent == 0)
000012  b90a              CBNZ     r2,|L16.24|
;;;214        {
;;;215            pulsePeriod = period + 1;
000014  1c4c              ADDS     r4,r1,#1
000016  e005              B        |L16.36|
                  |L16.24|
;;;216        }
;;;217        else
;;;218        {
;;;219            pulsePeriod = (period * (100 - dutyCyclePercent)) / 100;
000018  f1c20564          RSB      r5,r2,#0x64
00001c  434d              MULS     r5,r1,r5
00001e  2664              MOVS     r6,#0x64
000020  fbb5f4f6          UDIV     r4,r5,r6
                  |L16.36|
;;;220        }
;;;221    
;;;222        /* Update dutycycle */
;;;223        base->MR[matchChannel] = pulsePeriod;
000024  f1000518          ADD      r5,r0,#0x18
000028  f8454023          STR      r4,[r5,r3,LSL #2]
;;;224    }
00002c  bd70              POP      {r4-r6,pc}
;;;225    
                          ENDP


                          AREA ||i.EnableIRQ||, CODE, READONLY, ALIGN=1

                  EnableIRQ PROC
;;;198     */
;;;199    static inline void EnableIRQ(IRQn_Type interrupt)
000000  f1100f80          CMN      r0,#0x80
;;;200    {
;;;201        if (NotAvail_IRQn == interrupt)
000004  d100              BNE      |L17.8|
                  |L17.6|
;;;202        {
;;;203            return;
;;;204        }
;;;205    
;;;206    #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
;;;207        if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
;;;208    #endif
;;;209        {
;;;210            NVIC_EnableIRQ(interrupt);
;;;211        }
;;;212    }
000006  4770              BX       lr
                  |L17.8|
000008  bf00              NOP                            ;210
00000a  f000021f          AND      r2,r0,#0x1f           ;210
00000e  2101              MOVS     r1,#1                 ;210
000010  4091              LSLS     r1,r1,r2              ;210
000012  0942              LSRS     r2,r0,#5              ;210
000014  0092              LSLS     r2,r2,#2              ;210
000016  f10222e0          ADD      r2,r2,#0xe000e000     ;210
00001a  f8c21100          STR      r1,[r2,#0x100]        ;210
00001e  bf00              NOP                            ;210
000020  bf00              NOP      
000022  e7f0              B        |L17.6|
;;;213    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_ctimerCallback
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_ctimerBases
                          DCD      0x40008000
                          DCD      0x40009000
                          DCD      0x40028000
                          DCD      0x40048000
                          DCD      0x40049000
                  s_ctimerClocks
000014  011a011b          DCW      0x011a,0x011b
000018  0116030d          DCW      0x0116,0x030d
00001c  030e              DCW      0x030e
00001e  0000              DCB      0x00,0x00
                  s_ctimerResets
                          DCD      0x0001001a
                          DCD      0x0001001b
                          DCD      0x00010016
                          DCD      0x0400000d
                          DCD      0x0400000e
                  s_ctimerIRQ
000034  0a0b240d          DCB      0x0a,0x0b,0x24,0x0d
000038  25                DCB      0x25

                          AREA ||.data||, DATA, ALIGN=0

                  ctimerCallbackType
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_ctimer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ctimer_c_fe4fb53e____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_fsl_ctimer_c_fe4fb53e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ctimer_c_fe4fb53e____REVSH|
#line 402
|__asm___12_fsl_ctimer_c_fe4fb53e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_fsl_ctimer_c_fe4fb53e____RRX|
#line 587
|__asm___12_fsl_ctimer_c_fe4fb53e____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
