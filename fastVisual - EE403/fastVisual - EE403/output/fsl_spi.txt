; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_spi.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_spi.crf SRC\Drivers\fsl_spi.c]
                          THUMB

                          AREA ||i.SPI_Deinit||, CODE, READONLY, ALIGN=2

                  SPI_Deinit PROC
;;;229    
;;;230    void SPI_Deinit(SPI_Type *base)
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232        /* Assert arguments */
;;;233        assert(NULL != base);
000004  b104              CBZ      r4,|L1.8|
000006  e004              B        |L1.18|
                  |L1.8|
000008  22e9              MOVS     r2,#0xe9
00000a  a10a              ADR      r1,|L1.52|
00000c  a00f              ADR      r0,|L1.76|
00000e  f7fffffe          BL       __aeabi_assert
                  |L1.18|
;;;234        /* Disable interrupts, disable dma requests, disable peripheral */
;;;235        base->FIFOINTENCLR = SPI_FIFOINTENCLR_TXERR_MASK | SPI_FIFOINTENCLR_RXERR_MASK | SPI_FIFOINTENCLR_TXLVL_MASK |
000012  200f              MOVS     r0,#0xf
000014  f8c40e14          STR      r0,[r4,#0xe14]
;;;236                             SPI_FIFOINTENCLR_RXLVL_MASK;
;;;237        base->FIFOCFG &= ~(SPI_FIFOCFG_DMATX_MASK | SPI_FIFOCFG_DMARX_MASK);
000018  f8d40e00          LDR      r0,[r4,#0xe00]
00001c  f4205040          BIC      r0,r0,#0x3000
000020  f8c40e00          STR      r0,[r4,#0xe00]
;;;238        base->CFG &= ~(SPI_CFG_ENABLE_MASK);
000024  f8d40400          LDR      r0,[r4,#0x400]
000028  f0200001          BIC      r0,r0,#1
00002c  f8c40400          STR      r0,[r4,#0x400]
;;;239    }
000030  bd10              POP      {r4,pc}
;;;240    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  7370692e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L1.76|
00004c  4e554c4c          DCB      "NULL != base",0
000050  20213d20
000054  62617365
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.SPI_Enable||, CODE, READONLY, ALIGN=1

                  SPI_Enable PROC
;;;344     */
;;;345    static inline void SPI_Enable(SPI_Type *base, bool enable)
000000  b131              CBZ      r1,|L2.16|
;;;346    {
;;;347        if (enable)
;;;348        {
;;;349            base->CFG |= SPI_CFG_ENABLE_MASK;
000002  f8d02400          LDR      r2,[r0,#0x400]
000006  f0420201          ORR      r2,r2,#1
00000a  f8c02400          STR      r2,[r0,#0x400]
00000e  e005              B        |L2.28|
                  |L2.16|
;;;350        }
;;;351        else
;;;352        {
;;;353            base->CFG &= ~SPI_CFG_ENABLE_MASK;
000010  f8d02400          LDR      r2,[r0,#0x400]
000014  f0220201          BIC      r2,r2,#1
000018  f8c02400          STR      r2,[r0,#0x400]
                  |L2.28|
;;;354        }
;;;355    }
00001c  4770              BX       lr
;;;356    
                          ENDP


                          AREA ||i.SPI_EnableRxDMA||, CODE, READONLY, ALIGN=1

                  SPI_EnableRxDMA PROC
;;;252    
;;;253    void SPI_EnableRxDMA(SPI_Type *base, bool enable)
000000  b131              CBZ      r1,|L3.16|
;;;254    {
;;;255        if (enable)
;;;256        {
;;;257            base->FIFOCFG |= SPI_FIFOCFG_DMARX_MASK;
000002  f8d02e00          LDR      r2,[r0,#0xe00]
000006  f4425200          ORR      r2,r2,#0x2000
00000a  f8c02e00          STR      r2,[r0,#0xe00]
00000e  e005              B        |L3.28|
                  |L3.16|
;;;258        }
;;;259        else
;;;260        {
;;;261            base->FIFOCFG &= ~SPI_FIFOCFG_DMARX_MASK;
000010  f8d02e00          LDR      r2,[r0,#0xe00]
000014  f4225200          BIC      r2,r2,#0x2000
000018  f8c02e00          STR      r2,[r0,#0xe00]
                  |L3.28|
;;;262        }
;;;263    }
00001c  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.SPI_EnableTxDMA||, CODE, READONLY, ALIGN=1

                  SPI_EnableTxDMA PROC
;;;240    
;;;241    void SPI_EnableTxDMA(SPI_Type *base, bool enable)
000000  b131              CBZ      r1,|L4.16|
;;;242    {
;;;243        if (enable)
;;;244        {
;;;245            base->FIFOCFG |= SPI_FIFOCFG_DMATX_MASK;
000002  f8d02e00          LDR      r2,[r0,#0xe00]
000006  f4425280          ORR      r2,r2,#0x1000
00000a  f8c02e00          STR      r2,[r0,#0xe00]
00000e  e005              B        |L4.28|
                  |L4.16|
;;;246        }
;;;247        else
;;;248        {
;;;249            base->FIFOCFG &= ~SPI_FIFOCFG_DMATX_MASK;
000010  f8d02e00          LDR      r2,[r0,#0xe00]
000014  f4225280          BIC      r2,r2,#0x1000
000018  f8c02e00          STR      r2,[r0,#0xe00]
                  |L4.28|
;;;250        }
;;;251    }
00001c  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.SPI_GetConfig||, CODE, READONLY, ALIGN=2

                  SPI_GetConfig PROC
;;;77     
;;;78     void *SPI_GetConfig(SPI_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;79     {
000002  4605              MOV      r5,r0
;;;80         int32_t instance;
;;;81         instance = SPI_GetInstance(base);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       SPI_GetInstance
00000a  4604              MOV      r4,r0
;;;82         if (instance < 0)
00000c  2c00              CMP      r4,#0
00000e  da01              BGE      |L5.20|
;;;83         {
;;;84             return NULL;
000010  2000              MOVS     r0,#0
                  |L5.18|
;;;85         }
;;;86         return &g_configs[instance];
;;;87     }
000012  bd70              POP      {r4-r6,pc}
                  |L5.20|
000014  4801              LDR      r0,|L5.28|
000016  eb000044          ADD      r0,r0,r4,LSL #1       ;86
00001a  e7fa              B        |L5.18|
;;;88     
                          ENDP

                  |L5.28|
                          DCD      g_configs

                          AREA ||i.SPI_GetInstance||, CODE, READONLY, ALIGN=2

                  SPI_GetInstance PROC
;;;61     /* Get the index corresponding to the FLEXCOMM */
;;;62     uint32_t SPI_GetInstance(SPI_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
000002  4605              MOV      r5,r0
;;;64         int i;
;;;65     
;;;66         for (i = 0; i < FSL_FEATURE_SOC_SPI_COUNT; i++)
000004  2400              MOVS     r4,#0
000006  e007              B        |L6.24|
                  |L6.8|
;;;67         {
;;;68             if ((uint32_t)base == s_spiBaseAddrs[i])
000008  4807              LDR      r0,|L6.40|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d101              BNE      |L6.22|
;;;69             {
;;;70                 return i;
000012  4620              MOV      r0,r4
;;;71             }
;;;72         }
;;;73     
;;;74         assert(false);
;;;75         return 0;
;;;76     }
000014  bd70              POP      {r4-r6,pc}
                  |L6.22|
000016  1c64              ADDS     r4,r4,#1              ;66
                  |L6.24|
000018  2c0a              CMP      r4,#0xa               ;66
00001a  dbf5              BLT      |L6.8|
00001c  224a              MOVS     r2,#0x4a              ;74
00001e  a103              ADR      r1,|L6.44|
000020  a008              ADR      r0,|L6.68|
000022  f7fffffe          BL       __aeabi_assert
;;;77     
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      s_spiBaseAddrs
                  |L6.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  7370692e
000040  6300    
000042  00                DCB      0
000043  00                DCB      0
                  |L6.68|
000044  66616c73          DCB      "false",0
000048  6500    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.SPI_MasterGetDefaultConfig||, CODE, READONLY, ALIGN=2

                  SPI_MasterGetDefaultConfig PROC
;;;88     
;;;89     void SPI_MasterGetDefaultConfig(spi_master_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91         assert(NULL != config);
000004  b104              CBZ      r4,|L7.8|
000006  e004              B        |L7.18|
                  |L7.8|
000008  225b              MOVS     r2,#0x5b
00000a  a10a              ADR      r1,|L7.52|
00000c  a00f              ADR      r0,|L7.76|
00000e  f7fffffe          BL       __aeabi_assert
                  |L7.18|
;;;92     
;;;93         config->enableLoopback = false;
000012  2000              MOVS     r0,#0
000014  7020              STRB     r0,[r4,#0]
;;;94         config->enableMaster = true;
000016  2001              MOVS     r0,#1
000018  7060              STRB     r0,[r4,#1]
;;;95         config->polarity = kSPI_ClockPolarityActiveHigh;
00001a  2000              MOVS     r0,#0
00001c  70a0              STRB     r0,[r4,#2]
;;;96         config->phase = kSPI_ClockPhaseFirstEdge;
00001e  70e0              STRB     r0,[r4,#3]
;;;97         config->direction = kSPI_MsbFirst;
000020  7120              STRB     r0,[r4,#4]
;;;98         config->baudRate_Bps = 500000U;
000022  480e              LDR      r0,|L7.92|
000024  60a0              STR      r0,[r4,#8]
;;;99         config->dataWidth = kSPI_Data8Bits;
000026  2007              MOVS     r0,#7
000028  7320              STRB     r0,[r4,#0xc]
;;;100        config->sselNum = kSPI_Ssel0;
00002a  2000              MOVS     r0,#0
00002c  7360              STRB     r0,[r4,#0xd]
;;;101        config->txWatermark = kSPI_TxFifo0;
00002e  73a0              STRB     r0,[r4,#0xe]
;;;102        config->rxWatermark = kSPI_RxFifo1;
000030  73e0              STRB     r0,[r4,#0xf]
;;;103    }
000032  bd10              POP      {r4,pc}
;;;104    
                          ENDP

                  |L7.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  7370692e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L7.76|
00004c  4e554c4c          DCB      "NULL != config",0
000050  20213d20
000054  636f6e66
000058  696700  
00005b  00                DCB      0
                  |L7.92|
                          DCD      0x0007a120

                          AREA ||i.SPI_MasterInit||, CODE, READONLY, ALIGN=2

                  SPI_MasterInit PROC
;;;104    
;;;105    status_t SPI_MasterInit(SPI_Type *base, const spi_master_config_t *config, uint32_t srcClock_Hz)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;106    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;107        int32_t result = 0, instance = 0;
00000a  2700              MOVS     r7,#0
00000c  46b9              MOV      r9,r7
;;;108        uint32_t tmp;
;;;109    
;;;110        /* assert params */
;;;111        assert(!((NULL == base) || (NULL == config) || (0 == srcClock_Hz)));
00000e  b125              CBZ      r5,|L8.26|
000010  b11c              CBZ      r4,|L8.26|
000012  f1b80f00          CMP      r8,#0
000016  d000              BEQ      |L8.26|
000018  e004              B        |L8.36|
                  |L8.26|
00001a  226f              MOVS     r2,#0x6f
00001c  a13d              ADR      r1,|L8.276|
00001e  a043              ADR      r0,|L8.300|
000020  f7fffffe          BL       __aeabi_assert
                  |L8.36|
;;;112        if ((NULL == base) || (NULL == config) || (0 == srcClock_Hz))
000024  b11d              CBZ      r5,|L8.46|
000026  b114              CBZ      r4,|L8.46|
000028  f1b80f00          CMP      r8,#0
00002c  d102              BNE      |L8.52|
                  |L8.46|
;;;113        {
;;;114            return kStatus_InvalidArgument;
00002e  2004              MOVS     r0,#4
                  |L8.48|
;;;115        }
;;;116    
;;;117        /* initialize flexcomm to SPI mode */
;;;118        result = FLEXCOMM_Init(base, FLEXCOMM_PERIPH_SPI);
;;;119        assert(kStatus_Success == result);
;;;120        if (kStatus_Success != result)
;;;121        {
;;;122            return result;
;;;123        }
;;;124    
;;;125        /* set divider */
;;;126        result = SPI_MasterSetBaud(base, config->baudRate_Bps, srcClock_Hz);
;;;127        if (kStatus_Success != result)
;;;128        {
;;;129            return result;
;;;130        }
;;;131        /* get instance number */
;;;132        instance = SPI_GetInstance(base);
;;;133        assert(instance >= 0);
;;;134    
;;;135        /* configure SPI mode */
;;;136        tmp = base->CFG;
;;;137        tmp &= ~(SPI_CFG_MASTER_MASK | SPI_CFG_LSBF_MASK | SPI_CFG_CPHA_MASK | SPI_CFG_CPOL_MASK | SPI_CFG_LOOP_MASK | SPI_CFG_ENABLE_MASK);
;;;138        /* phase */
;;;139        tmp |= SPI_CFG_CPHA(config->phase);
;;;140        /* polarity */
;;;141        tmp |= SPI_CFG_CPOL(config->polarity);
;;;142        /* direction */
;;;143        tmp |= SPI_CFG_LSBF(config->direction);
;;;144        /* master mode */
;;;145        tmp |= SPI_CFG_MASTER(1);
;;;146        /* loopback */
;;;147        tmp |= SPI_CFG_LOOP(config->enableLoopback);
;;;148        base->CFG = tmp;
;;;149    
;;;150        /* store configuration */
;;;151        g_configs[instance].dataWidth = config->dataWidth;
;;;152        g_configs[instance].sselNum = config->sselNum;
;;;153        /* enable FIFOs */
;;;154        base->FIFOCFG |= SPI_FIFOCFG_EMPTYTX_MASK | SPI_FIFOCFG_EMPTYRX_MASK;
;;;155        base->FIFOCFG |= SPI_FIFOCFG_ENABLETX_MASK | SPI_FIFOCFG_ENABLERX_MASK;
;;;156        /* trigger level - empty txFIFO, one item in rxFIFO */
;;;157        tmp = base->FIFOTRIG & (~(SPI_FIFOTRIG_RXLVL_MASK | SPI_FIFOTRIG_TXLVL_MASK));
;;;158        tmp |= SPI_FIFOTRIG_TXLVL(config->txWatermark) | SPI_FIFOTRIG_RXLVL(config->rxWatermark);
;;;159        /* enable generating interrupts for FIFOTRIG levels */
;;;160        tmp |= SPI_FIFOTRIG_TXLVLENA_MASK | SPI_FIFOTRIG_RXLVLENA_MASK;
;;;161        /* set FIFOTRIG */
;;;162        base->FIFOTRIG = tmp;
;;;163    
;;;164        SPI_Enable(base, config->enableMaster);
;;;165        return kStatus_Success;
;;;166    }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L8.52|
000034  2102              MOVS     r1,#2                 ;118
000036  4628              MOV      r0,r5                 ;118
000038  f7fffffe          BL       FLEXCOMM_Init
00003c  4607              MOV      r7,r0                 ;118
00003e  b907              CBNZ     r7,|L8.66|
000040  e004              B        |L8.76|
                  |L8.66|
000042  2277              MOVS     r2,#0x77              ;119
000044  a133              ADR      r1,|L8.276|
000046  a048              ADR      r0,|L8.360|
000048  f7fffffe          BL       __aeabi_assert
                  |L8.76|
00004c  b10f              CBZ      r7,|L8.82|
00004e  4638              MOV      r0,r7                 ;122
000050  e7ee              B        |L8.48|
                  |L8.82|
000052  4642              MOV      r2,r8                 ;126
000054  4628              MOV      r0,r5                 ;126
000056  68a1              LDR      r1,[r4,#8]            ;126
000058  f7fffffe          BL       SPI_MasterSetBaud
00005c  4607              MOV      r7,r0                 ;126
00005e  b10f              CBZ      r7,|L8.100|
000060  4638              MOV      r0,r7                 ;129
000062  e7e5              B        |L8.48|
                  |L8.100|
000064  4628              MOV      r0,r5                 ;132
000066  f7fffffe          BL       SPI_GetInstance
00006a  4681              MOV      r9,r0                 ;132
00006c  f1b90f00          CMP      r9,#0                 ;133
000070  db00              BLT      |L8.116|
000072  e004              B        |L8.126|
                  |L8.116|
000074  2285              MOVS     r2,#0x85              ;133
000076  a127              ADR      r1,|L8.276|
000078  a042              ADR      r0,|L8.388|
00007a  f7fffffe          BL       __aeabi_assert
                  |L8.126|
00007e  f8d56400          LDR      r6,[r5,#0x400]        ;136
000082  f02606bd          BIC      r6,r6,#0xbd           ;137
000086  78e0              LDRB     r0,[r4,#3]            ;139
000088  2110              MOVS     r1,#0x10              ;139
00008a  ea011000          AND      r0,r1,r0,LSL #4       ;139
00008e  4306              ORRS     r6,r6,r0              ;139
000090  78a0              LDRB     r0,[r4,#2]            ;141
000092  2120              MOVS     r1,#0x20              ;141
000094  ea011040          AND      r0,r1,r0,LSL #5       ;141
000098  4306              ORRS     r6,r6,r0              ;141
00009a  7920              LDRB     r0,[r4,#4]            ;143
00009c  2108              MOVS     r1,#8                 ;143
00009e  ea0100c0          AND      r0,r1,r0,LSL #3       ;143
0000a2  4306              ORRS     r6,r6,r0              ;143
0000a4  f0460604          ORR      r6,r6,#4              ;145
0000a8  7820              LDRB     r0,[r4,#0]            ;147
0000aa  2180              MOVS     r1,#0x80              ;147
0000ac  ea0110c0          AND      r0,r1,r0,LSL #7       ;147
0000b0  4306              ORRS     r6,r6,r0              ;147
0000b2  f8c56400          STR      r6,[r5,#0x400]        ;148
0000b6  7b20              LDRB     r0,[r4,#0xc]          ;151
0000b8  4936              LDR      r1,|L8.404|
0000ba  f8010019          STRB     r0,[r1,r9,LSL #1]     ;151
0000be  7b60              LDRB     r0,[r4,#0xd]          ;152
0000c0  eb010149          ADD      r1,r1,r9,LSL #1       ;152
0000c4  7048              STRB     r0,[r1,#1]            ;152
0000c6  f8d50e00          LDR      r0,[r5,#0xe00]        ;154
0000ca  f4403040          ORR      r0,r0,#0x30000        ;154
0000ce  f8c50e00          STR      r0,[r5,#0xe00]        ;154
0000d2  f8d50e00          LDR      r0,[r5,#0xe00]        ;155
0000d6  f0400003          ORR      r0,r0,#3              ;155
0000da  f8c50e00          STR      r0,[r5,#0xe00]        ;155
0000de  f8d50e08          LDR      r0,[r5,#0xe08]        ;157
0000e2  492d              LDR      r1,|L8.408|
0000e4  ea000601          AND      r6,r0,r1              ;157
0000e8  7ba0              LDRB     r0,[r4,#0xe]          ;158
0000ea  f44f6170          MOV      r1,#0xf00             ;158
0000ee  ea012000          AND      r0,r1,r0,LSL #8       ;158
0000f2  7be1              LDRB     r1,[r4,#0xf]          ;158
0000f4  f44f2270          MOV      r2,#0xf0000           ;158
0000f8  ea024101          AND      r1,r2,r1,LSL #16      ;158
0000fc  4308              ORRS     r0,r0,r1              ;158
0000fe  4306              ORRS     r6,r6,r0              ;158
000100  f0460603          ORR      r6,r6,#3              ;160
000104  f8c56e08          STR      r6,[r5,#0xe08]        ;162
000108  7861              LDRB     r1,[r4,#1]            ;164
00010a  4628              MOV      r0,r5                 ;164
00010c  f7fffffe          BL       SPI_Enable
000110  2000              MOVS     r0,#0                 ;165
000112  e78d              B        |L8.48|
;;;167    
                          ENDP

                  |L8.276|
000114  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000118  44726976
00011c  6572735c
000120  66736c5f
000124  7370692e
000128  6300    
00012a  00                DCB      0
00012b  00                DCB      0
                  |L8.300|
00012c  2128284e          DCB      "!((NULL == base) || (NULL == config) || (0 == srcClock_"
000130  554c4c20
000134  3d3d2062
000138  61736529
00013c  207c7c20
000140  284e554c
000144  4c203d3d
000148  20636f6e
00014c  66696729
000150  207c7c20
000154  2830203d
000158  3d207372
00015c  63436c6f
000160  636b5f  
000163  487a2929          DCB      "Hz))",0
000167  00      
                  |L8.360|
000168  6b537461          DCB      "kStatus_Success == result",0
00016c  7475735f
000170  53756363
000174  65737320
000178  3d3d2072
00017c  6573756c
000180  7400    
000182  00                DCB      0
000183  00                DCB      0
                  |L8.388|
000184  696e7374          DCB      "instance >= 0",0
000188  616e6365
00018c  203e3d20
000190  3000    
000192  00                DCB      0
000193  00                DCB      0
                  |L8.404|
                          DCD      g_configs
                  |L8.408|
                          DCD      0xfff0f0ff

                          AREA ||i.SPI_MasterSetBaud||, CODE, READONLY, ALIGN=2

                  SPI_MasterSetBaud PROC
;;;264    
;;;265    status_t SPI_MasterSetBaud(SPI_Type *base, uint32_t baudrate_Bps, uint32_t srcClock_Hz)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;266    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;267        uint32_t tmp;
;;;268    
;;;269        /* assert params */
;;;270        assert(!((NULL == base) || (0 == baudrate_Bps) || (0 == srcClock_Hz)));
00000a  b114              CBZ      r4,|L9.18|
00000c  b10d              CBZ      r5,|L9.18|
00000e  b106              CBZ      r6,|L9.18|
000010  e005              B        |L9.30|
                  |L9.18|
000012  f44f7287          MOV      r2,#0x10e
000016  a110              ADR      r1,|L9.88|
000018  a015              ADR      r0,|L9.112|
00001a  f7fffffe          BL       __aeabi_assert
                  |L9.30|
;;;271        if ((NULL == base) || (0 == baudrate_Bps) || (0 == srcClock_Hz))
00001e  b10c              CBZ      r4,|L9.36|
000020  b105              CBZ      r5,|L9.36|
000022  b916              CBNZ     r6,|L9.42|
                  |L9.36|
;;;272        {
;;;273            return kStatus_InvalidArgument;
000024  2004              MOVS     r0,#4
                  |L9.38|
;;;274        }
;;;275    
;;;276        /* calculate baudrate */
;;;277        tmp = (srcClock_Hz / baudrate_Bps) - 1;
;;;278        if (tmp > 0xFFFF)
;;;279        {
;;;280            return kStatus_SPI_BaudrateNotSupport;
;;;281        }
;;;282        base->DIV &= ~SPI_DIV_DIVVAL_MASK;
;;;283        base->DIV |= SPI_DIV_DIVVAL(tmp);
;;;284        return kStatus_Success;
;;;285    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L9.42|
00002a  fbb6f0f5          UDIV     r0,r6,r5              ;277
00002e  1e47              SUBS     r7,r0,#1              ;277
000030  f5b73f80          CMP      r7,#0x10000           ;278
000034  d302              BCC      |L9.60|
000036  f24150e3          MOV      r0,#0x15e3            ;280
00003a  e7f4              B        |L9.38|
                  |L9.60|
00003c  f8d40424          LDR      r0,[r4,#0x424]        ;282
000040  f36f000f          BFC      r0,#0,#16             ;282
000044  f8c40424          STR      r0,[r4,#0x424]        ;282
000048  f8d40424          LDR      r0,[r4,#0x424]        ;283
00004c  b2b9              UXTH     r1,r7                 ;283
00004e  4308              ORRS     r0,r0,r1              ;283
000050  f8c40424          STR      r0,[r4,#0x424]        ;283
000054  2000              MOVS     r0,#0                 ;284
000056  e7e6              B        |L9.38|
;;;286    
                          ENDP

                  |L9.88|
000058  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
00005c  44726976
000060  6572735c
000064  66736c5f
000068  7370692e
00006c  6300    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L9.112|
000070  2128284e          DCB      "!((NULL == base) || (0 == baudrate_Bps) || (0 == srcClo"
000074  554c4c20
000078  3d3d2062
00007c  61736529
000080  207c7c20
000084  2830203d
000088  3d206261
00008c  75647261
000090  74655f42
000094  70732920
000098  7c7c2028
00009c  30203d3d
0000a0  20737263
0000a4  436c6f  
0000a7  636b5f48          DCB      "ck_Hz))",0
0000ab  7a292900
0000af  00                DCB      0

                          AREA ||i.SPI_MasterTransferAbort||, CODE, READONLY, ALIGN=2

                  SPI_MasterTransferAbort PROC
;;;535    
;;;536    void SPI_MasterTransferAbort(SPI_Type *base, spi_master_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;537    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;538        assert(NULL != handle);
000006  b104              CBZ      r4,|L10.10|
000008  e005              B        |L10.22|
                  |L10.10|
00000a  f240221a          MOV      r2,#0x21a
00000e  a10b              ADR      r1,|L10.60|
000010  a010              ADR      r0,|L10.84|
000012  f7fffffe          BL       __aeabi_assert
                  |L10.22|
;;;539    
;;;540        /* Disable interrupt requests*/
;;;541        base->FIFOINTENSET &= ~(SPI_FIFOINTENSET_TXLVL_MASK | SPI_FIFOINTENSET_RXLVL_MASK);
000016  f8d50e10          LDR      r0,[r5,#0xe10]
00001a  f020000c          BIC      r0,r0,#0xc
00001e  f8c50e10          STR      r0,[r5,#0xe10]
;;;542        /* Empty FIFOs */
;;;543        base->FIFOCFG |= SPI_FIFOCFG_EMPTYTX_MASK | SPI_FIFOCFG_EMPTYRX_MASK;
000022  f8d50e00          LDR      r0,[r5,#0xe00]
000026  f4403040          ORR      r0,r0,#0x30000
00002a  f8c50e00          STR      r0,[r5,#0xe00]
;;;544    
;;;545        handle->state = kStatus_SPI_Idle;
00002e  f24150e1          MOV      r0,#0x15e1
000032  61a0              STR      r0,[r4,#0x18]
;;;546        handle->txRemainingBytes = 0;
000034  2000              MOVS     r0,#0
000036  60a0              STR      r0,[r4,#8]
;;;547        handle->rxRemainingBytes = 0;
000038  60e0              STR      r0,[r4,#0xc]
;;;548    }
00003a  bd70              POP      {r4-r6,pc}
;;;549    
                          ENDP

                  |L10.60|
00003c  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000040  44726976
000044  6572735c
000048  66736c5f
00004c  7370692e
000050  6300    
000052  00                DCB      0
000053  00                DCB      0
                  |L10.84|
000054  4e554c4c          DCB      "NULL != handle",0
000058  20213d20
00005c  68616e64
000060  6c6500  
000063  00                DCB      0

                          AREA ||i.SPI_MasterTransferBlocking||, CODE, READONLY, ALIGN=2

                  SPI_MasterTransferBlocking PROC
;;;364    
;;;365    status_t SPI_MasterTransferBlocking(SPI_Type *base, spi_transfer_t *xfer)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;366    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;367        int32_t instance;
;;;368        uint32_t tx_ctrl = 0, last_ctrl = 0;
00000a  2000              MOVS     r0,#0
00000c  9003              STR      r0,[sp,#0xc]
00000e  9002              STR      r0,[sp,#8]
;;;369        uint32_t tmp32, rxRemainingBytes, txRemainingBytes, dataWidth;
;;;370        uint32_t toReceiveCount = 0;
000010  4681              MOV      r9,r0
;;;371        uint8_t *txData, *rxData;
;;;372        uint32_t fifoDepth;
;;;373    
;;;374        /* check params */
;;;375        assert(!((NULL == base) || (NULL == xfer) || ((NULL == xfer->txData) && (NULL == xfer->rxData))));
000012  b12d              CBZ      r5,|L11.32|
000014  b124              CBZ      r4,|L11.32|
000016  6820              LDR      r0,[r4,#0]
000018  b908              CBNZ     r0,|L11.30|
00001a  6860              LDR      r0,[r4,#4]
00001c  b100              CBZ      r0,|L11.32|
                  |L11.30|
00001e  e005              B        |L11.44|
                  |L11.32|
000020  f2401277          MOV      r2,#0x177
000024  a176              ADR      r1,|L11.512|
000026  487c              LDR      r0,|L11.536|
000028  f7fffffe          BL       __aeabi_assert
                  |L11.44|
;;;376        if ((NULL == base) || (NULL == xfer) || ((NULL == xfer->txData) && (NULL == xfer->rxData)))
00002c  b125              CBZ      r5,|L11.56|
00002e  b11c              CBZ      r4,|L11.56|
000030  6820              LDR      r0,[r4,#0]
000032  b928              CBNZ     r0,|L11.64|
000034  6860              LDR      r0,[r4,#4]
000036  b918              CBNZ     r0,|L11.64|
                  |L11.56|
;;;377        {
;;;378            return kStatus_InvalidArgument;
000038  2004              MOVS     r0,#4
                  |L11.58|
;;;379        }
;;;380    
;;;381        fifoDepth = SPI_FIFO_DEPTH(base);
;;;382        txData = xfer->txData;
;;;383        rxData = xfer->rxData;
;;;384        txRemainingBytes = txData ? xfer->dataSize : 0;
;;;385        rxRemainingBytes = rxData ? xfer->dataSize : 0;
;;;386    
;;;387        instance = SPI_GetInstance(base);
;;;388        assert(instance >= 0);
;;;389        dataWidth = g_configs[instance].dataWidth;
;;;390    
;;;391        /* dataSize (in bytes) is not aligned to 16bit (2B) transfer */
;;;392        assert(!((dataWidth > kSPI_Data8Bits) && (xfer->dataSize & 0x1)));
;;;393        if ((dataWidth > kSPI_Data8Bits) && (xfer->dataSize & 0x1))
;;;394        {
;;;395            return kStatus_InvalidArgument;
;;;396        }
;;;397    
;;;398        /* clear tx/rx errors and empty FIFOs */
;;;399        base->FIFOCFG |= SPI_FIFOCFG_EMPTYTX_MASK | SPI_FIFOCFG_EMPTYRX_MASK;
;;;400        base->FIFOSTAT |= SPI_FIFOSTAT_TXERR_MASK | SPI_FIFOSTAT_RXERR_MASK;
;;;401        /* select slave to talk with */
;;;402        tx_ctrl |= (SPI_DEASSERT_ALL & (~SPI_DEASSERTNUM_SSEL(g_configs[instance].sselNum)));
;;;403        /* set width of data - range asserted at entry */
;;;404        tx_ctrl |= SPI_FIFOWR_LEN(dataWidth);
;;;405        /* end of transfer */
;;;406        last_ctrl |= (xfer->configFlags & (uint32_t)kSPI_FrameAssert) ? (uint32_t)kSPI_FrameAssert : 0;
;;;407        /* delay end of transfer */
;;;408        last_ctrl |= (xfer->configFlags & (uint32_t)kSPI_FrameDelay) ? (uint32_t)kSPI_FrameDelay : 0;
;;;409        /* last index of loop */
;;;410        while (txRemainingBytes || rxRemainingBytes || toReceiveCount)
;;;411        {
;;;412            /* if rxFIFO is not empty */
;;;413            if (base->FIFOSTAT & SPI_FIFOSTAT_RXNOTEMPTY_MASK)
;;;414            {
;;;415                tmp32 = base->FIFORD;
;;;416                /* rxBuffer is not empty */
;;;417                if (rxRemainingBytes)
;;;418                {
;;;419                    *(rxData++) = tmp32;
;;;420                    rxRemainingBytes--;
;;;421                    /* read 16 bits at once */
;;;422                    if (dataWidth > 8)
;;;423                    {
;;;424                        *(rxData++) = tmp32 >> 8;
;;;425                        rxRemainingBytes--;
;;;426                    }
;;;427                }
;;;428                /* decrease number of data expected to receive */
;;;429                toReceiveCount -= 1;
;;;430            }
;;;431            /* transmit if txFIFO is not full and data to receive does not exceed FIFO depth */
;;;432            if ((base->FIFOSTAT & SPI_FIFOSTAT_TXNOTFULL_MASK) && (toReceiveCount < fifoDepth) &&
;;;433                ((txRemainingBytes) || (rxRemainingBytes >= SPI_COUNT_TO_BYTES(dataWidth, toReceiveCount + 1))))
;;;434            {
;;;435                /* txBuffer is not empty */
;;;436                if (txRemainingBytes)
;;;437                {
;;;438                    tmp32 = *(txData++);
;;;439                    txRemainingBytes--;
;;;440                    /* write 16 bit at once */
;;;441                    if (dataWidth > 8)
;;;442                    {
;;;443                        tmp32 |= ((uint32_t)(*(txData++))) << 8U;
;;;444                        txRemainingBytes--;
;;;445                    }
;;;446                    if (!txRemainingBytes)
;;;447                    {
;;;448                        tx_ctrl |= last_ctrl;
;;;449                    }
;;;450                }
;;;451                else
;;;452                {
;;;453                    tmp32 = SPI_DUMMYDATA;
;;;454                    /* last transfer */
;;;455                    if (rxRemainingBytes == SPI_COUNT_TO_BYTES(dataWidth, toReceiveCount + 1))
;;;456                    {
;;;457                        tx_ctrl |= last_ctrl;
;;;458                    }
;;;459                }
;;;460                /* send data */
;;;461                tmp32 = tx_ctrl | tmp32;
;;;462                base->FIFOWR = tmp32;
;;;463                toReceiveCount += 1;
;;;464            }
;;;465        }
;;;466        /* wait if TX FIFO of previous transfer is not empty */
;;;467        while (!(base->FIFOSTAT & SPI_FIFOSTAT_TXEMPTY_MASK))
;;;468        {
;;;469        }
;;;470        return kStatus_Success;
;;;471    }
00003a  b005              ADD      sp,sp,#0x14
00003c  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.64|
000040  f8d50e00          LDR      r0,[r5,#0xe00]        ;381
000044  f3c01001          UBFX     r0,r0,#4,#2           ;381
000048  00c0              LSLS     r0,r0,#3              ;381
00004a  9000              STR      r0,[sp,#0]            ;381
00004c  f8d4a000          LDR      r10,[r4,#0]           ;382
000050  f8d4b004          LDR      r11,[r4,#4]           ;383
000054  f1ba0f00          CMP      r10,#0                ;384
000058  d001              BEQ      |L11.94|
00005a  68e0              LDR      r0,[r4,#0xc]          ;384
00005c  e000              B        |L11.96|
                  |L11.94|
00005e  2000              MOVS     r0,#0                 ;384
                  |L11.96|
000060  4680              MOV      r8,r0                 ;384
000062  f1bb0f00          CMP      r11,#0                ;385
000066  d001              BEQ      |L11.108|
000068  68e0              LDR      r0,[r4,#0xc]          ;385
00006a  e000              B        |L11.110|
                  |L11.108|
00006c  2000              MOVS     r0,#0                 ;385
                  |L11.110|
00006e  4607              MOV      r7,r0                 ;385
000070  4628              MOV      r0,r5                 ;387
000072  f7fffffe          BL       SPI_GetInstance
000076  9004              STR      r0,[sp,#0x10]         ;387
000078  9804              LDR      r0,[sp,#0x10]         ;388
00007a  2800              CMP      r0,#0                 ;388
00007c  db00              BLT      |L11.128|
00007e  e005              B        |L11.140|
                  |L11.128|
000080  f44f72c2          MOV      r2,#0x184             ;388
000084  a15e              ADR      r1,|L11.512|
000086  a065              ADR      r0,|L11.540|
000088  f7fffffe          BL       __aeabi_assert
                  |L11.140|
00008c  4967              LDR      r1,|L11.556|
00008e  9804              LDR      r0,[sp,#0x10]         ;389
000090  f8116010          LDRB     r6,[r1,r0,LSL #1]     ;389
000094  2e07              CMP      r6,#7                 ;392
000096  d903              BLS      |L11.160|
000098  7b20              LDRB     r0,[r4,#0xc]          ;392
00009a  f0000001          AND      r0,r0,#1              ;392
00009e  b900              CBNZ     r0,|L11.162|
                  |L11.160|
0000a0  e005              B        |L11.174|
                  |L11.162|
0000a2  f44f72c4          MOV      r2,#0x188             ;392
0000a6  a156              ADR      r1,|L11.512|
0000a8  a061              ADR      r0,|L11.560|
0000aa  f7fffffe          BL       __aeabi_assert
                  |L11.174|
0000ae  2e07              CMP      r6,#7                 ;393
0000b0  d905              BLS      |L11.190|
0000b2  7b20              LDRB     r0,[r4,#0xc]          ;393
0000b4  f0000001          AND      r0,r0,#1              ;393
0000b8  b108              CBZ      r0,|L11.190|
0000ba  2004              MOVS     r0,#4                 ;395
0000bc  e7bd              B        |L11.58|
                  |L11.190|
0000be  f8d50e00          LDR      r0,[r5,#0xe00]        ;399
0000c2  f4403040          ORR      r0,r0,#0x30000        ;399
0000c6  f8c50e00          STR      r0,[r5,#0xe00]        ;399
0000ca  f8d50e04          LDR      r0,[r5,#0xe04]        ;400
0000ce  f0400003          ORR      r0,r0,#3              ;400
0000d2  f8c50e04          STR      r0,[r5,#0xe04]        ;400
0000d6  4955              LDR      r1,|L11.556|
0000d8  9804              LDR      r0,[sp,#0x10]         ;402
0000da  eb010040          ADD      r0,r1,r0,LSL #1       ;402
0000de  7840              LDRB     r0,[r0,#1]            ;402
0000e0  3010              ADDS     r0,r0,#0x10           ;402
0000e2  2101              MOVS     r1,#1                 ;402
0000e4  4081              LSLS     r1,r1,r0              ;402
0000e6  f44f2070          MOV      r0,#0xf0000           ;402
0000ea  4388              BICS     r0,r0,r1              ;402
0000ec  9903              LDR      r1,[sp,#0xc]          ;402
0000ee  4308              ORRS     r0,r0,r1              ;402
0000f0  9003              STR      r0,[sp,#0xc]          ;402
0000f2  f04f6070          MOV      r0,#0xf000000         ;404
0000f6  ea006006          AND      r0,r0,r6,LSL #24      ;404
0000fa  9903              LDR      r1,[sp,#0xc]          ;404
0000fc  4308              ORRS     r0,r0,r1              ;404
0000fe  9003              STR      r0,[sp,#0xc]          ;404
000100  68a0              LDR      r0,[r4,#8]            ;406
000102  f4001080          AND      r0,r0,#0x100000       ;406
000106  b110              CBZ      r0,|L11.270|
000108  f44f1080          MOV      r0,#0x100000          ;406
00010c  e000              B        |L11.272|
                  |L11.270|
00010e  2000              MOVS     r0,#0                 ;406
                  |L11.272|
000110  9902              LDR      r1,[sp,#8]            ;406
000112  4308              ORRS     r0,r0,r1              ;406
000114  9002              STR      r0,[sp,#8]            ;406
000116  68a0              LDR      r0,[r4,#8]            ;408
000118  f4001000          AND      r0,r0,#0x200000       ;408
00011c  b110              CBZ      r0,|L11.292|
00011e  f44f1000          MOV      r0,#0x200000          ;408
000122  e000              B        |L11.294|
                  |L11.292|
000124  2000              MOVS     r0,#0                 ;408
                  |L11.294|
000126  9902              LDR      r1,[sp,#8]            ;408
000128  4308              ORRS     r0,r0,r1              ;408
00012a  9002              STR      r0,[sp,#8]            ;408
00012c  e056              B        |L11.476|
                  |L11.302|
00012e  f8d50e04          LDR      r0,[r5,#0xe04]        ;413
000132  f0000040          AND      r0,r0,#0x40           ;413
000136  b180              CBZ      r0,|L11.346|
000138  f8d50e30          LDR      r0,[r5,#0xe30]        ;415
00013c  9001              STR      r0,[sp,#4]            ;415
00013e  b157              CBZ      r7,|L11.342|
000140  9801              LDR      r0,[sp,#4]            ;419
000142  f80b0b01          STRB     r0,[r11],#1           ;419
000146  1e7f              SUBS     r7,r7,#1              ;420
000148  2e08              CMP      r6,#8                 ;422
00014a  d904              BLS      |L11.342|
00014c  9801              LDR      r0,[sp,#4]            ;424
00014e  0a00              LSRS     r0,r0,#8              ;424
000150  f80b0b01          STRB     r0,[r11],#1           ;424
000154  1e7f              SUBS     r7,r7,#1              ;425
                  |L11.342|
000156  f1a90901          SUB      r9,r9,#1              ;429
                  |L11.346|
00015a  f8d50e04          LDR      r0,[r5,#0xe04]        ;432
00015e  f0000020          AND      r0,r0,#0x20           ;432
000162  b3d8              CBZ      r0,|L11.476|
000164  9800              LDR      r0,[sp,#0]            ;432
000166  4581              CMP      r9,r0                 ;432
000168  d238              BCS      |L11.476|
00016a  f1b80f00          CMP      r8,#0                 ;433
00016e  d105              BNE      |L11.380|
000170  08f1              LSRS     r1,r6,#3              ;433
000172  f1090001          ADD      r0,r9,#1              ;433
000176  4088              LSLS     r0,r0,r1              ;433
000178  42b8              CMP      r0,r7                 ;433
00017a  d82f              BHI      |L11.476|
                  |L11.380|
00017c  f1b80f00          CMP      r8,#0                 ;436
000180  d016              BEQ      |L11.432|
000182  f81a0b01          LDRB     r0,[r10],#1           ;438
000186  9001              STR      r0,[sp,#4]            ;438
000188  f1a80801          SUB      r8,r8,#1              ;439
00018c  2e08              CMP      r6,#8                 ;441
00018e  d907              BLS      |L11.416|
000190  f81a1b01          LDRB     r1,[r10],#1           ;443
000194  9801              LDR      r0,[sp,#4]            ;443
000196  ea402001          ORR      r0,r0,r1,LSL #8       ;443
00019a  9001              STR      r0,[sp,#4]            ;443
00019c  f1a80801          SUB      r8,r8,#1              ;444
                  |L11.416|
0001a0  f1b80f00          CMP      r8,#0                 ;446
0001a4  d111              BNE      |L11.458|
0001a6  e9dd1002          LDRD     r1,r0,[sp,#8]         ;448
0001aa  4308              ORRS     r0,r0,r1              ;448
0001ac  9003              STR      r0,[sp,#0xc]          ;448
0001ae  e00c              B        |L11.458|
                  |L11.432|
0001b0  f64f70ff          MOV      r0,#0xffff            ;453
0001b4  9001              STR      r0,[sp,#4]            ;453
0001b6  08f1              LSRS     r1,r6,#3              ;455
0001b8  f1090001          ADD      r0,r9,#1              ;455
0001bc  4088              LSLS     r0,r0,r1              ;455
0001be  42b8              CMP      r0,r7                 ;455
0001c0  d103              BNE      |L11.458|
0001c2  e9dd1002          LDRD     r1,r0,[sp,#8]         ;457
0001c6  4308              ORRS     r0,r0,r1              ;457
0001c8  9003              STR      r0,[sp,#0xc]          ;457
                  |L11.458|
0001ca  9901              LDR      r1,[sp,#4]            ;461
0001cc  9803              LDR      r0,[sp,#0xc]          ;461
0001ce  4308              ORRS     r0,r0,r1              ;461
0001d0  9001              STR      r0,[sp,#4]            ;461
0001d2  9801              LDR      r0,[sp,#4]            ;462
0001d4  f8c50e20          STR      r0,[r5,#0xe20]        ;462
0001d8  f1090901          ADD      r9,r9,#1              ;463
                  |L11.476|
0001dc  f1b80f00          CMP      r8,#0                 ;410
0001e0  d1a5              BNE      |L11.302|
0001e2  2f00              CMP      r7,#0                 ;410
0001e4  d1a3              BNE      |L11.302|
0001e6  f1b90f00          CMP      r9,#0                 ;410
0001ea  d1a0              BNE      |L11.302|
0001ec  bf00              NOP                            ;467
                  |L11.494|
0001ee  f8d50e04          LDR      r0,[r5,#0xe04]        ;467
0001f2  f0000010          AND      r0,r0,#0x10           ;467
0001f6  2800              CMP      r0,#0                 ;467
0001f8  d0f9              BEQ      |L11.494|
0001fa  2000              MOVS     r0,#0                 ;470
0001fc  e71d              B        |L11.58|
;;;472    
                          ENDP

0001fe  0000              DCW      0x0000
                  |L11.512|
000200  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000204  44726976
000208  6572735c
00020c  66736c5f
000210  7370692e
000214  6300    
000216  00                DCB      0
000217  00                DCB      0
                  |L11.536|
                          DCD      ||.conststring||+0x60
                  |L11.540|
00021c  696e7374          DCB      "instance >= 0",0
000220  616e6365
000224  203e3d20
000228  3000    
00022a  00                DCB      0
00022b  00                DCB      0
                  |L11.556|
                          DCD      g_configs
                  |L11.560|
000230  21282864          DCB      "!((dataWidth > kSPI_Data8Bits) && (xfer->dataSize & 0x1"
000234  61746157
000238  69647468
00023c  203e206b
000240  5350495f
000244  44617461
000248  38426974
00024c  73292026
000250  26202878
000254  6665722d
000258  3e646174
00025c  6153697a
000260  65202620
000264  307831  
000267  292900            DCB      "))",0
00026a  00                DCB      0
00026b  00                DCB      0

                          AREA ||i.SPI_MasterTransferCreateHandle||, CODE, READONLY, ALIGN=2

                  SPI_MasterTransferCreateHandle PROC
;;;312    
;;;313    status_t SPI_MasterTransferCreateHandle(SPI_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;314                                            spi_master_handle_t *handle,
;;;315                                            spi_master_callback_t callback,
;;;316                                            void *userData)
;;;317    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;318        int32_t instance = 0;
00000c  2600              MOVS     r6,#0
;;;319    
;;;320        /* check 'base' */
;;;321        assert(!(NULL == base));
00000e  b105              CBZ      r5,|L12.18|
000010  e005              B        |L12.30|
                  |L12.18|
000012  f2401241          MOV      r2,#0x141
000016  a132              ADR      r1,|L12.224|
000018  a037              ADR      r0,|L12.248|
00001a  f7fffffe          BL       __aeabi_assert
                  |L12.30|
;;;322        if (NULL == base)
00001e  b915              CBNZ     r5,|L12.38|
;;;323        {
;;;324            return kStatus_InvalidArgument;
000020  2004              MOVS     r0,#4
                  |L12.34|
;;;325        }
;;;326        /* check 'handle' */
;;;327        assert(!(NULL == handle));
;;;328        if (NULL == handle)
;;;329        {
;;;330            return kStatus_InvalidArgument;
;;;331        }
;;;332        /* get flexcomm instance by 'base' param */
;;;333        instance = SPI_GetInstance(base);
;;;334        assert(!(instance < 0));
;;;335        if (instance < 0)
;;;336        {
;;;337            return kStatus_InvalidArgument;
;;;338        }
;;;339    
;;;340        memset(handle, 0, sizeof(*handle));
;;;341        /* Initialize the handle */
;;;342        if (base->CFG & SPI_CFG_MASTER_MASK)
;;;343        {
;;;344            FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)SPI_MasterTransferHandleIRQ, handle);
;;;345        }
;;;346        else
;;;347        {
;;;348            FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)SPI_SlaveTransferHandleIRQ, handle);
;;;349        }
;;;350    
;;;351        handle->dataWidth = g_configs[instance].dataWidth;
;;;352        /* in slave mode, the sselNum is not important */
;;;353        handle->sselNum = g_configs[instance].sselNum;
;;;354        handle->txWatermark = (spi_txfifo_watermark_t)SPI_FIFOTRIG_TXLVL_GET(base);
;;;355        handle->rxWatermark = (spi_rxfifo_watermark_t)SPI_FIFOTRIG_RXLVL_GET(base);
;;;356        handle->callback = callback;
;;;357        handle->userData = userData;
;;;358    
;;;359        /* Enable SPI NVIC */
;;;360        EnableIRQ(s_spiIRQ[instance]);
;;;361    
;;;362        return kStatus_Success;
;;;363    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L12.38|
000026  b104              CBZ      r4,|L12.42|
000028  e005              B        |L12.54|
                  |L12.42|
00002a  f2401247          MOV      r2,#0x147             ;327
00002e  a12c              ADR      r1,|L12.224|
000030  a035              ADR      r0,|L12.264|
000032  f7fffffe          BL       __aeabi_assert
                  |L12.54|
000036  b90c              CBNZ     r4,|L12.60|
000038  2004              MOVS     r0,#4                 ;330
00003a  e7f2              B        |L12.34|
                  |L12.60|
00003c  4628              MOV      r0,r5                 ;333
00003e  f7fffffe          BL       SPI_GetInstance
000042  4606              MOV      r6,r0                 ;333
000044  2e00              CMP      r6,#0                 ;334
000046  db00              BLT      |L12.74|
000048  e005              B        |L12.86|
                  |L12.74|
00004a  f44f72a7          MOV      r2,#0x14e             ;334
00004e  a124              ADR      r1,|L12.224|
000050  a032              ADR      r0,|L12.284|
000052  f7fffffe          BL       __aeabi_assert
                  |L12.86|
000056  2e00              CMP      r6,#0                 ;335
000058  da01              BGE      |L12.94|
00005a  2004              MOVS     r0,#4                 ;337
00005c  e7e1              B        |L12.34|
                  |L12.94|
00005e  2130              MOVS     r1,#0x30              ;340
000060  4620              MOV      r0,r4                 ;340
000062  f7fffffe          BL       __aeabi_memclr4
000066  f8d50400          LDR      r0,[r5,#0x400]        ;342
00006a  f0000004          AND      r0,r0,#4              ;342
00006e  b128              CBZ      r0,|L12.124|
000070  4622              MOV      r2,r4                 ;344
000072  492e              LDR      r1,|L12.300|
000074  4628              MOV      r0,r5                 ;344
000076  f7fffffe          BL       FLEXCOMM_SetIRQHandler
00007a  e004              B        |L12.134|
                  |L12.124|
00007c  4622              MOV      r2,r4                 ;348
00007e  492c              LDR      r1,|L12.304|
000080  4628              MOV      r0,r5                 ;348
000082  f7fffffe          BL       FLEXCOMM_SetIRQHandler
                  |L12.134|
000086  482b              LDR      r0,|L12.308|
000088  f8100016          LDRB     r0,[r0,r6,LSL #1]     ;351
00008c  341c              ADDS     r4,r4,#0x1c           ;351
00008e  7220              STRB     r0,[r4,#8]            ;351
000090  4828              LDR      r0,|L12.308|
000092  eb000046          ADD      r0,r0,r6,LSL #1       ;353
000096  7840              LDRB     r0,[r0,#1]            ;353
000098  7260              STRB     r0,[r4,#9]            ;353
00009a  f8d50e08          LDR      r0,[r5,#0xe08]        ;354
00009e  f3c02003          UBFX     r0,r0,#8,#4           ;354
0000a2  7420              STRB     r0,[r4,#0x10]         ;354
0000a4  f8d50e08          LDR      r0,[r5,#0xe08]        ;355
0000a8  f3c04003          UBFX     r0,r0,#16,#4          ;355
0000ac  7460              STRB     r0,[r4,#0x11]         ;355
0000ae  6027              STR      r7,[r4,#0]            ;356
0000b0  f8c48004          STR      r8,[r4,#4]            ;357
0000b4  3c1c              SUBS     r4,r4,#0x1c           ;357
0000b6  4920              LDR      r1,|L12.312|
0000b8  5788              LDRSB    r0,[r1,r6]            ;360
0000ba  f1100f80          CMN      r0,#0x80              ;360
0000be  d100              BNE      |L12.194|
0000c0  e00c              B        |L12.220|
                  |L12.194|
0000c2  bf00              NOP                            ;360
0000c4  f000021f          AND      r2,r0,#0x1f           ;360
0000c8  2101              MOVS     r1,#1                 ;360
0000ca  4091              LSLS     r1,r1,r2              ;360
0000cc  0942              LSRS     r2,r0,#5              ;360
0000ce  0092              LSLS     r2,r2,#2              ;360
0000d0  f10222e0          ADD      r2,r2,#0xe000e000     ;360
0000d4  f8c21100          STR      r1,[r2,#0x100]        ;360
0000d8  bf00              NOP                            ;360
0000da  bf00              NOP                            ;360
                  |L12.220|
0000dc  2000              MOVS     r0,#0                 ;362
0000de  e7a0              B        |L12.34|
;;;364    
                          ENDP

                  |L12.224|
0000e0  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
0000e4  44726976
0000e8  6572735c
0000ec  66736c5f
0000f0  7370692e
0000f4  6300    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L12.248|
0000f8  21284e55          DCB      "!(NULL == base)",0
0000fc  4c4c203d
000100  3d206261
000104  73652900
                  |L12.264|
000108  21284e55          DCB      "!(NULL == handle)",0
00010c  4c4c203d
000110  3d206861
000114  6e646c65
000118  2900    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L12.284|
00011c  2128696e          DCB      "!(instance < 0)",0
000120  7374616e
000124  6365203c
000128  20302900
                  |L12.300|
                          DCD      SPI_MasterTransferHandleIRQ
                  |L12.304|
                          DCD      SPI_SlaveTransferHandleIRQ
                  |L12.308|
                          DCD      g_configs
                  |L12.312|
                          DCD      s_spiIRQ

                          AREA ||i.SPI_MasterTransferGetCount||, CODE, READONLY, ALIGN=2

                  SPI_MasterTransferGetCount PROC
;;;515    
;;;516    status_t SPI_MasterTransferGetCount(SPI_Type *base, spi_master_handle_t *handle, size_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;517    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;518        assert(NULL != handle);
000008  b104              CBZ      r4,|L13.12|
00000a  e005              B        |L13.24|
                  |L13.12|
00000c  f2402206          MOV      r2,#0x206
000010  a10a              ADR      r1,|L13.60|
000012  a010              ADR      r0,|L13.84|
000014  f7fffffe          BL       __aeabi_assert
                  |L13.24|
;;;519    
;;;520        if (!count)
000018  b90d              CBNZ     r5,|L13.30|
;;;521        {
;;;522            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L13.28|
;;;523        }
;;;524    
;;;525        /* Catch when there is not an active transfer. */
;;;526        if (handle->state != kStatus_SPI_Busy)
;;;527        {
;;;528            *count = 0;
;;;529            return kStatus_NoTransferInProgress;
;;;530        }
;;;531    
;;;532        *count = handle->totalByteCount - handle->rxRemainingBytes;
;;;533        return kStatus_Success;
;;;534    }
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  69a0              LDR      r0,[r4,#0x18]         ;526
000020  f5b05faf          CMP      r0,#0x15e0            ;526
000024  d003              BEQ      |L13.46|
000026  2000              MOVS     r0,#0                 ;528
000028  6028              STR      r0,[r5,#0]            ;528
00002a  2006              MOVS     r0,#6                 ;529
00002c  e7f6              B        |L13.28|
                  |L13.46|
00002e  68e1              LDR      r1,[r4,#0xc]          ;532
000030  6960              LDR      r0,[r4,#0x14]         ;532
000032  1a40              SUBS     r0,r0,r1              ;532
000034  6028              STR      r0,[r5,#0]            ;532
000036  2000              MOVS     r0,#0                 ;533
000038  e7f0              B        |L13.28|
;;;535    
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
00003c  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000040  44726976
000044  6572735c
000048  66736c5f
00004c  7370692e
000050  6300    
000052  00                DCB      0
000053  00                DCB      0
                  |L13.84|
000054  4e554c4c          DCB      "NULL != handle",0
000058  20213d20
00005c  68616e64
000060  6c6500  
000063  00                DCB      0

                          AREA ||i.SPI_MasterTransferHandleIRQ||, CODE, READONLY, ALIGN=2

                  SPI_MasterTransferHandleIRQ PROC
;;;638    
;;;639    void SPI_MasterTransferHandleIRQ(SPI_Type *base, spi_master_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;640    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;641        assert((NULL != base) && (NULL != handle));
000006  b10d              CBZ      r5,|L14.12|
000008  b104              CBZ      r4,|L14.12|
00000a  e005              B        |L14.24|
                  |L14.12|
00000c  f2402281          MOV      r2,#0x281
000010  a139              ADR      r1,|L14.248|
000012  a03f              ADR      r0,|L14.272|
000014  f7fffffe          BL       __aeabi_assert
                  |L14.24|
;;;642    
;;;643        /* IRQ behaviour:
;;;644         * - first interrupt is triggered by empty txFIFO. The transfer function
;;;645         *   then tries empty rxFIFO and fill txFIFO interleaved that results to
;;;646         *   strategy to process as many items as possible.
;;;647         * - the next IRQs can be:
;;;648         *      rxIRQ from nonempty rxFIFO which requires to empty rxFIFO.
;;;649         *      txIRQ from empty txFIFO which requires to refill txFIFO.
;;;650         * - last interrupt is triggered by empty txFIFO. The last state is
;;;651         *   known by empty rxBuffer and txBuffer. If there is nothing to receive
;;;652         *   or send - both operations have been finished and interrupts can be
;;;653         *   disabled.
;;;654         */
;;;655    
;;;656        /* Data to send or read or expected to receive */
;;;657        if ((handle->txRemainingBytes) || (handle->rxRemainingBytes) || (handle->toReceiveCount))
000018  68a0              LDR      r0,[r4,#8]
00001a  b920              CBNZ     r0,|L14.38|
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  b910              CBNZ     r0,|L14.38|
000020  6920              LDR      r0,[r4,#0x10]
000022  2800              CMP      r0,#0
000024  d049              BEQ      |L14.186|
                  |L14.38|
;;;658        {
;;;659            /* Transmit or receive data */
;;;660            SPI_TransferHandleIRQInternal(base, handle);
000026  4621              MOV      r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       SPI_TransferHandleIRQInternal
;;;661            /* No data to send or read or receive. Transfer ends. Set txTrigger to 0 level and
;;;662             * enable txIRQ to confirm when txFIFO becomes empty */
;;;663            if ((!handle->txRemainingBytes) && (!handle->rxRemainingBytes) && (!handle->toReceiveCount))
00002e  68a0              LDR      r0,[r4,#8]
000030  b980              CBNZ     r0,|L14.84|
000032  68e0              LDR      r0,[r4,#0xc]
000034  b970              CBNZ     r0,|L14.84|
000036  6920              LDR      r0,[r4,#0x10]
000038  b960              CBNZ     r0,|L14.84|
;;;664            {
;;;665                base->FIFOTRIG = base->FIFOTRIG & (~SPI_FIFOTRIG_TXLVL_MASK);
00003a  f8d50e08          LDR      r0,[r5,#0xe08]
00003e  f4206070          BIC      r0,r0,#0xf00
000042  f8c50e08          STR      r0,[r5,#0xe08]
;;;666                base->FIFOINTENSET |= SPI_FIFOINTENSET_TXLVL_MASK;
000046  f8d50e10          LDR      r0,[r5,#0xe10]
00004a  f0400004          ORR      r0,r0,#4
00004e  f8c50e10          STR      r0,[r5,#0xe10]
000052  e04f              B        |L14.244|
                  |L14.84|
;;;667            }
;;;668            else
;;;669            {
;;;670                uint32_t rxRemainingCount = SPI_BYTES_TO_COUNT(handle->dataWidth, handle->rxRemainingBytes);
000054  68e1              LDR      r1,[r4,#0xc]
000056  f8942024          LDRB     r2,[r4,#0x24]
00005a  10d2              ASRS     r2,r2,#3
00005c  fa21f002          LSR      r0,r1,r2
;;;671                /* If, there are no data to send or rxFIFO is already filled with necessary number of dummy data,
;;;672                 * disable txIRQ. From this point only rxIRQ is used to receive data without any transmission */
;;;673                if ((!handle->txRemainingBytes) && (rxRemainingCount <= handle->toReceiveCount))
000060  68a1              LDR      r1,[r4,#8]
000062  b929              CBNZ     r1,|L14.112|
000064  6921              LDR      r1,[r4,#0x10]
000066  4281              CMP      r1,r0
000068  d302              BCC      |L14.112|
;;;674                {
;;;675                    base->FIFOINTENCLR = SPI_FIFOINTENCLR_TXLVL_MASK;
00006a  2104              MOVS     r1,#4
00006c  f8c51e14          STR      r1,[r5,#0xe14]
                  |L14.112|
;;;676                }
;;;677                /* Nothing to receive or transmit, but we still have pending data which are bellow rxLevel.
;;;678                 * Cannot clear rxFIFO, txFIFO might be still active */
;;;679                if (rxRemainingCount == 0)
000070  b9a0              CBNZ     r0,|L14.156|
;;;680                {
;;;681                    if ((handle->txRemainingBytes == 0) && (handle->toReceiveCount != 0) &&
000072  68a1              LDR      r1,[r4,#8]
000074  bb01              CBNZ     r1,|L14.184|
000076  6921              LDR      r1,[r4,#0x10]
000078  b1f1              CBZ      r1,|L14.184|
;;;682                        (handle->toReceiveCount < SPI_FIFOTRIG_RXLVL_GET(base) + 1))
00007a  6922              LDR      r2,[r4,#0x10]
00007c  f8d51e08          LDR      r1,[r5,#0xe08]
000080  f3c14103          UBFX     r1,r1,#16,#4
000084  1c49              ADDS     r1,r1,#1
000086  428a              CMP      r2,r1
000088  d216              BCS      |L14.184|
;;;683                    {
;;;684                        base->FIFOTRIG =
00008a  6921              LDR      r1,[r4,#0x10]
00008c  1e49              SUBS     r1,r1,#1
00008e  f8d52e08          LDR      r2,[r5,#0xe08]
000092  f3614213          BFI      r2,r1,#16,#4
000096  f8c52e08          STR      r2,[r5,#0xe08]
00009a  e00d              B        |L14.184|
                  |L14.156|
;;;685                            (base->FIFOTRIG & (~SPI_FIFOTRIG_RXLVL_MASK)) | SPI_FIFOTRIG_RXLVL(handle->toReceiveCount - 1);
;;;686                    }
;;;687                }
;;;688                /* Expected to receive less data than rxLevel value, we have to update rxLevel */
;;;689                else
;;;690                {
;;;691                    if (rxRemainingCount < (SPI_FIFOTRIG_RXLVL_GET(base) + 1))
00009c  f8d51e08          LDR      r1,[r5,#0xe08]
0000a0  f3c14103          UBFX     r1,r1,#16,#4
0000a4  1c49              ADDS     r1,r1,#1
0000a6  4281              CMP      r1,r0
0000a8  d906              BLS      |L14.184|
;;;692                    {
;;;693                        base->FIFOTRIG =
0000aa  1e41              SUBS     r1,r0,#1
0000ac  f8d52e08          LDR      r2,[r5,#0xe08]
0000b0  f3614213          BFI      r2,r1,#16,#4
0000b4  f8c52e08          STR      r2,[r5,#0xe08]
                  |L14.184|
;;;694                            (base->FIFOTRIG & (~SPI_FIFOTRIG_RXLVL_MASK)) | SPI_FIFOTRIG_RXLVL(rxRemainingCount - 1);
;;;695                    }
;;;696                }
;;;697            }
0000b8  e01c              B        |L14.244|
                  |L14.186|
;;;698        }
;;;699        else
;;;700        {
;;;701            /* Empty txFIFO is confirmed. Disable IRQs and restore triggers values */
;;;702            base->FIFOINTENCLR = SPI_FIFOINTENCLR_RXLVL_MASK | SPI_FIFOINTENCLR_TXLVL_MASK;
0000ba  200c              MOVS     r0,#0xc
0000bc  f8c50e14          STR      r0,[r5,#0xe14]
;;;703            base->FIFOTRIG = (base->FIFOTRIG & (~(SPI_FIFOTRIG_RXLVL_MASK | SPI_FIFOTRIG_RXLVL_MASK))) |
0000c0  f894102d          LDRB     r1,[r4,#0x2d]
0000c4  f8d50e08          LDR      r0,[r5,#0xe08]
0000c8  f3614013          BFI      r0,r1,#16,#4
0000cc  f894102c          LDRB     r1,[r4,#0x2c]
0000d0  f44f6270          MOV      r2,#0xf00
0000d4  ea022101          AND      r1,r2,r1,LSL #8
0000d8  4308              ORRS     r0,r0,r1
0000da  f8c50e08          STR      r0,[r5,#0xe08]
;;;704                             SPI_FIFOTRIG_RXLVL(handle->rxWatermark) | SPI_FIFOTRIG_TXLVL(handle->txWatermark);
;;;705            /* set idle state and call user callback */
;;;706            handle->state = kStatus_SPI_Idle;
0000de  f24150e1          MOV      r0,#0x15e1
0000e2  61a0              STR      r0,[r4,#0x18]
;;;707            if (handle->callback)
0000e4  69e0              LDR      r0,[r4,#0x1c]
0000e6  b128              CBZ      r0,|L14.244|
;;;708            {
;;;709                (handle->callback)(base, handle, handle->state, handle->userData);
0000e8  6a23              LDR      r3,[r4,#0x20]
0000ea  69a2              LDR      r2,[r4,#0x18]
0000ec  4621              MOV      r1,r4
0000ee  4628              MOV      r0,r5
0000f0  69e6              LDR      r6,[r4,#0x1c]
0000f2  47b0              BLX      r6
                  |L14.244|
;;;710            }
;;;711        }
;;;712    }
0000f4  bd70              POP      {r4-r6,pc}
                          ENDP

0000f6  0000              DCW      0x0000
                  |L14.248|
0000f8  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
0000fc  44726976
000100  6572735c
000104  66736c5f
000108  7370692e
00010c  6300    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L14.272|
000110  284e554c          DCB      "(NULL != base) && (NULL != handle)",0
000114  4c20213d
000118  20626173
00011c  65292026
000120  2620284e
000124  554c4c20
000128  213d2068
00012c  616e646c
000130  652900  
000133  00                DCB      0

                          AREA ||i.SPI_MasterTransferNonBlocking||, CODE, READONLY, ALIGN=2

                  SPI_MasterTransferNonBlocking PROC
;;;472    
;;;473    status_t SPI_MasterTransferNonBlocking(SPI_Type *base, spi_master_handle_t *handle, spi_transfer_t *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;474    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;475        /* check params */
;;;476        assert(
000008  b136              CBZ      r6,|L15.24|
00000a  b12d              CBZ      r5,|L15.24|
00000c  b124              CBZ      r4,|L15.24|
00000e  6820              LDR      r0,[r4,#0]
000010  b908              CBNZ     r0,|L15.22|
000012  6860              LDR      r0,[r4,#4]
000014  b100              CBZ      r0,|L15.24|
                  |L15.22|
000016  e005              B        |L15.36|
                  |L15.24|
000018  f44f72ee          MOV      r2,#0x1dc
00001c  a12b              ADR      r1,|L15.204|
00001e  4831              LDR      r0,|L15.228|
000020  f7fffffe          BL       __aeabi_assert
                  |L15.36|
;;;477            !((NULL == base) || (NULL == handle) || (NULL == xfer) || ((NULL == xfer->txData) && (NULL == xfer->rxData))));
;;;478        if ((NULL == base) || (NULL == handle) || (NULL == xfer) || ((NULL == xfer->txData) && (NULL == xfer->rxData)))
000024  b12e              CBZ      r6,|L15.50|
000026  b125              CBZ      r5,|L15.50|
000028  b11c              CBZ      r4,|L15.50|
00002a  6820              LDR      r0,[r4,#0]
00002c  b918              CBNZ     r0,|L15.54|
00002e  6860              LDR      r0,[r4,#4]
000030  b908              CBNZ     r0,|L15.54|
                  |L15.50|
;;;479        {
;;;480            return kStatus_InvalidArgument;
000032  2004              MOVS     r0,#4
                  |L15.52|
;;;481        }
;;;482    
;;;483        /* dataSize (in bytes) is not aligned to 16bit (2B) transfer */
;;;484        assert(!((handle->dataWidth > kSPI_Data8Bits) && (xfer->dataSize & 0x1)));
;;;485        if ((handle->dataWidth > kSPI_Data8Bits) && (xfer->dataSize & 0x1))
;;;486        {
;;;487            return kStatus_InvalidArgument;
;;;488        }
;;;489    
;;;490        /* Check if SPI is busy */
;;;491        if (handle->state == kStatus_SPI_Busy)
;;;492        {
;;;493            return kStatus_SPI_Busy;
;;;494        }
;;;495    
;;;496        /* Set the handle information */
;;;497        handle->txData = xfer->txData;
;;;498        handle->rxData = xfer->rxData;
;;;499        /* set count */
;;;500        handle->txRemainingBytes = xfer->txData ? xfer->dataSize : 0;
;;;501        handle->rxRemainingBytes = xfer->rxData ? xfer->dataSize : 0;
;;;502        handle->totalByteCount = xfer->dataSize;
;;;503        /* other options */
;;;504        handle->toReceiveCount = 0;
;;;505        handle->configFlags = xfer->configFlags;
;;;506        /* Set the SPI state to busy */
;;;507        handle->state = kStatus_SPI_Busy;
;;;508        /* clear FIFOs when transfer starts */
;;;509        base->FIFOCFG |= SPI_FIFOCFG_EMPTYTX_MASK | SPI_FIFOCFG_EMPTYRX_MASK;
;;;510        base->FIFOSTAT |= SPI_FIFOSTAT_TXERR_MASK | SPI_FIFOSTAT_RXERR_MASK;
;;;511        /* enable generating txIRQ and rxIRQ, first transfer is fired by empty txFIFO */
;;;512        base->FIFOINTENSET |= SPI_FIFOINTENSET_TXLVL_MASK | SPI_FIFOINTENSET_RXLVL_MASK;
;;;513        return kStatus_Success;
;;;514    }
000034  bd70              POP      {r4-r6,pc}
                  |L15.54|
000036  f8950024          LDRB     r0,[r5,#0x24]         ;484
00003a  2807              CMP      r0,#7                 ;484
00003c  dd03              BLE      |L15.70|
00003e  7b20              LDRB     r0,[r4,#0xc]          ;484
000040  f0000001          AND      r0,r0,#1              ;484
000044  b900              CBNZ     r0,|L15.72|
                  |L15.70|
000046  e005              B        |L15.84|
                  |L15.72|
000048  f44f72f2          MOV      r2,#0x1e4             ;484
00004c  a11f              ADR      r1,|L15.204|
00004e  4826              LDR      r0,|L15.232|
000050  f7fffffe          BL       __aeabi_assert
                  |L15.84|
000054  f8950024          LDRB     r0,[r5,#0x24]         ;485
000058  2807              CMP      r0,#7                 ;485
00005a  dd05              BLE      |L15.104|
00005c  7b20              LDRB     r0,[r4,#0xc]          ;485
00005e  f0000001          AND      r0,r0,#1              ;485
000062  b108              CBZ      r0,|L15.104|
000064  2004              MOVS     r0,#4                 ;487
000066  e7e5              B        |L15.52|
                  |L15.104|
000068  69a8              LDR      r0,[r5,#0x18]         ;491
00006a  f5b05faf          CMP      r0,#0x15e0            ;491
00006e  d102              BNE      |L15.118|
000070  f44f50af          MOV      r0,#0x15e0            ;493
000074  e7de              B        |L15.52|
                  |L15.118|
000076  6820              LDR      r0,[r4,#0]            ;497
000078  6028              STR      r0,[r5,#0]            ;497
00007a  6860              LDR      r0,[r4,#4]            ;498
00007c  6068              STR      r0,[r5,#4]            ;498
00007e  6820              LDR      r0,[r4,#0]            ;500
000080  b108              CBZ      r0,|L15.134|
000082  68e0              LDR      r0,[r4,#0xc]          ;500
000084  e000              B        |L15.136|
                  |L15.134|
000086  2000              MOVS     r0,#0                 ;500
                  |L15.136|
000088  60a8              STR      r0,[r5,#8]            ;500
00008a  6860              LDR      r0,[r4,#4]            ;501
00008c  b108              CBZ      r0,|L15.146|
00008e  68e0              LDR      r0,[r4,#0xc]          ;501
000090  e000              B        |L15.148|
                  |L15.146|
000092  2000              MOVS     r0,#0                 ;501
                  |L15.148|
000094  60e8              STR      r0,[r5,#0xc]          ;501
000096  68e0              LDR      r0,[r4,#0xc]          ;502
000098  6168              STR      r0,[r5,#0x14]         ;502
00009a  2000              MOVS     r0,#0                 ;504
00009c  6128              STR      r0,[r5,#0x10]         ;504
00009e  68a0              LDR      r0,[r4,#8]            ;505
0000a0  62a8              STR      r0,[r5,#0x28]         ;505
0000a2  f44f50af          MOV      r0,#0x15e0            ;507
0000a6  61a8              STR      r0,[r5,#0x18]         ;507
0000a8  f5066660          ADD      r6,r6,#0xe00          ;509
0000ac  6830              LDR      r0,[r6,#0]            ;509
0000ae  f4403040          ORR      r0,r0,#0x30000        ;509
0000b2  6030              STR      r0,[r6,#0]            ;509
0000b4  6870              LDR      r0,[r6,#4]            ;510
0000b6  f0400003          ORR      r0,r0,#3              ;510
0000ba  6070              STR      r0,[r6,#4]            ;510
0000bc  6930              LDR      r0,[r6,#0x10]         ;512
0000be  f040000c          ORR      r0,r0,#0xc            ;512
0000c2  6130              STR      r0,[r6,#0x10]         ;512
0000c4  f5a66660          SUB      r6,r6,#0xe00          ;512
0000c8  2000              MOVS     r0,#0                 ;513
0000ca  e7b3              B        |L15.52|
;;;515    
                          ENDP

                  |L15.204|
0000cc  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
0000d0  44726976
0000d4  6572735c
0000d8  66736c5f
0000dc  7370692e
0000e0  6300    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L15.228|
                          DCD      ||.conststring||+0xbc
                  |L15.232|
                          DCD      ||.conststring||+0x12c

                          AREA ||i.SPI_SlaveGetDefaultConfig||, CODE, READONLY, ALIGN=2

                  SPI_SlaveGetDefaultConfig PROC
;;;167    
;;;168    void SPI_SlaveGetDefaultConfig(spi_slave_config_t *config)
000000  b510              PUSH     {r4,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170        assert(NULL != config);
000004  b104              CBZ      r4,|L16.8|
000006  e004              B        |L16.18|
                  |L16.8|
000008  22aa              MOVS     r2,#0xaa
00000a  a108              ADR      r1,|L16.44|
00000c  a00d              ADR      r0,|L16.68|
00000e  f7fffffe          BL       __aeabi_assert
                  |L16.18|
;;;171    
;;;172        config->enableSlave = true;
000012  2001              MOVS     r0,#1
000014  7020              STRB     r0,[r4,#0]
;;;173        config->polarity = kSPI_ClockPolarityActiveHigh;
000016  2000              MOVS     r0,#0
000018  7060              STRB     r0,[r4,#1]
;;;174        config->phase = kSPI_ClockPhaseFirstEdge;
00001a  70a0              STRB     r0,[r4,#2]
;;;175        config->direction = kSPI_MsbFirst;
00001c  70e0              STRB     r0,[r4,#3]
;;;176        config->dataWidth = kSPI_Data8Bits;
00001e  2007              MOVS     r0,#7
000020  7120              STRB     r0,[r4,#4]
;;;177        config->txWatermark = kSPI_TxFifo0;
000022  2000              MOVS     r0,#0
000024  7160              STRB     r0,[r4,#5]
;;;178        config->rxWatermark = kSPI_RxFifo1;
000026  71a0              STRB     r0,[r4,#6]
;;;179    }
000028  bd10              POP      {r4,pc}
;;;180    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  7370692e
000040  6300    
000042  00                DCB      0
000043  00                DCB      0
                  |L16.68|
000044  4e554c4c          DCB      "NULL != config",0
000048  20213d20
00004c  636f6e66
000050  696700  
000053  00                DCB      0

                          AREA ||i.SPI_SlaveInit||, CODE, READONLY, ALIGN=2

                  SPI_SlaveInit PROC
;;;180    
;;;181    status_t SPI_SlaveInit(SPI_Type *base, const spi_slave_config_t *config)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;182    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;183        int32_t result = 0, instance;
000008  2700              MOVS     r7,#0
;;;184        uint32_t tmp;
;;;185    
;;;186        /* assert params */
;;;187        assert(!((NULL == base) || (NULL == config)));
00000a  b10c              CBZ      r4,|L17.16|
00000c  b105              CBZ      r5,|L17.16|
00000e  e004              B        |L17.26|
                  |L17.16|
000010  22bb              MOVS     r2,#0xbb
000012  a12e              ADR      r1,|L17.204|
000014  a033              ADR      r0,|L17.228|
000016  f7fffffe          BL       __aeabi_assert
                  |L17.26|
;;;188        if ((NULL == base) || (NULL == config))
00001a  b104              CBZ      r4,|L17.30|
00001c  b915              CBNZ     r5,|L17.36|
                  |L17.30|
;;;189        {
;;;190            return kStatus_InvalidArgument;
00001e  2004              MOVS     r0,#4
                  |L17.32|
;;;191        }
;;;192        /* configure flexcomm to SPI, enable clock gate */
;;;193        result = FLEXCOMM_Init(base, FLEXCOMM_PERIPH_SPI);
;;;194        assert(kStatus_Success == result);
;;;195        if (kStatus_Success != result)
;;;196        {
;;;197            return result;
;;;198        }
;;;199    
;;;200        instance = SPI_GetInstance(base);
;;;201    
;;;202        /* configure SPI mode */
;;;203        tmp = base->CFG;
;;;204        tmp &= ~(SPI_CFG_MASTER_MASK | SPI_CFG_LSBF_MASK | SPI_CFG_CPHA_MASK | SPI_CFG_CPOL_MASK | SPI_CFG_ENABLE_MASK);
;;;205        /* phase */
;;;206        tmp |= SPI_CFG_CPHA(config->phase);
;;;207        /* polarity */
;;;208        tmp |= SPI_CFG_CPOL(config->polarity);
;;;209        /* direction */
;;;210        tmp |= SPI_CFG_LSBF(config->direction);
;;;211        base->CFG = tmp;
;;;212    
;;;213        /* store configuration */
;;;214        g_configs[instance].dataWidth = config->dataWidth;
;;;215        /* empty and enable FIFOs */
;;;216        base->FIFOCFG |= SPI_FIFOCFG_EMPTYTX_MASK | SPI_FIFOCFG_EMPTYRX_MASK;
;;;217        base->FIFOCFG |= SPI_FIFOCFG_ENABLETX_MASK | SPI_FIFOCFG_ENABLERX_MASK;
;;;218        /* trigger level - empty txFIFO, one item in rxFIFO */
;;;219        tmp = base->FIFOTRIG & (~(SPI_FIFOTRIG_RXLVL_MASK | SPI_FIFOTRIG_TXLVL_MASK));
;;;220        tmp |= SPI_FIFOTRIG_TXLVL(config->txWatermark) | SPI_FIFOTRIG_RXLVL(config->rxWatermark);
;;;221        /* enable generating interrupts for FIFOTRIG levels */
;;;222        tmp |= SPI_FIFOTRIG_TXLVLENA_MASK | SPI_FIFOTRIG_RXLVLENA_MASK;
;;;223        /* set FIFOTRIG */
;;;224        base->FIFOTRIG = tmp;
;;;225    
;;;226        SPI_Enable(base, config->enableSlave);
;;;227        return kStatus_Success;
;;;228    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L17.36|
000024  2102              MOVS     r1,#2                 ;193
000026  4620              MOV      r0,r4                 ;193
000028  f7fffffe          BL       FLEXCOMM_Init
00002c  4607              MOV      r7,r0                 ;193
00002e  b907              CBNZ     r7,|L17.50|
000030  e004              B        |L17.60|
                  |L17.50|
000032  22c2              MOVS     r2,#0xc2              ;194
000034  a125              ADR      r1,|L17.204|
000036  a035              ADR      r0,|L17.268|
000038  f7fffffe          BL       __aeabi_assert
                  |L17.60|
00003c  b10f              CBZ      r7,|L17.66|
00003e  4638              MOV      r0,r7                 ;197
000040  e7ee              B        |L17.32|
                  |L17.66|
000042  4620              MOV      r0,r4                 ;200
000044  f7fffffe          BL       SPI_GetInstance
000048  4680              MOV      r8,r0                 ;200
00004a  f8d46400          LDR      r6,[r4,#0x400]        ;203
00004e  f026063d          BIC      r6,r6,#0x3d           ;204
000052  78a8              LDRB     r0,[r5,#2]            ;206
000054  2110              MOVS     r1,#0x10              ;206
000056  ea011000          AND      r0,r1,r0,LSL #4       ;206
00005a  4306              ORRS     r6,r6,r0              ;206
00005c  7868              LDRB     r0,[r5,#1]            ;208
00005e  2120              MOVS     r1,#0x20              ;208
000060  ea011040          AND      r0,r1,r0,LSL #5       ;208
000064  4306              ORRS     r6,r6,r0              ;208
000066  78e8              LDRB     r0,[r5,#3]            ;210
000068  2108              MOVS     r1,#8                 ;210
00006a  ea0100c0          AND      r0,r1,r0,LSL #3       ;210
00006e  4306              ORRS     r6,r6,r0              ;210
000070  f8c46400          STR      r6,[r4,#0x400]        ;211
000074  7928              LDRB     r0,[r5,#4]            ;214
000076  492c              LDR      r1,|L17.296|
000078  f8010018          STRB     r0,[r1,r8,LSL #1]     ;214
00007c  f8d40e00          LDR      r0,[r4,#0xe00]        ;216
000080  f4403040          ORR      r0,r0,#0x30000        ;216
000084  f8c40e00          STR      r0,[r4,#0xe00]        ;216
000088  f8d40e00          LDR      r0,[r4,#0xe00]        ;217
00008c  f0400003          ORR      r0,r0,#3              ;217
000090  f8c40e00          STR      r0,[r4,#0xe00]        ;217
000094  f8d40e08          LDR      r0,[r4,#0xe08]        ;219
000098  4924              LDR      r1,|L17.300|
00009a  ea000601          AND      r6,r0,r1              ;219
00009e  7968              LDRB     r0,[r5,#5]            ;220
0000a0  f44f6170          MOV      r1,#0xf00             ;220
0000a4  ea012000          AND      r0,r1,r0,LSL #8       ;220
0000a8  79a9              LDRB     r1,[r5,#6]            ;220
0000aa  f44f2270          MOV      r2,#0xf0000           ;220
0000ae  ea024101          AND      r1,r2,r1,LSL #16      ;220
0000b2  4308              ORRS     r0,r0,r1              ;220
0000b4  4306              ORRS     r6,r6,r0              ;220
0000b6  f0460603          ORR      r6,r6,#3              ;222
0000ba  f8c46e08          STR      r6,[r4,#0xe08]        ;224
0000be  7829              LDRB     r1,[r5,#0]            ;226
0000c0  4620              MOV      r0,r4                 ;226
0000c2  f7fffffe          BL       SPI_Enable
0000c6  2000              MOVS     r0,#0                 ;227
0000c8  e7aa              B        |L17.32|
;;;229    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L17.204|
0000cc  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
0000d0  44726976
0000d4  6572735c
0000d8  66736c5f
0000dc  7370692e
0000e0  6300    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L17.228|
0000e4  2128284e          DCB      "!((NULL == base) || (NULL == config))",0
0000e8  554c4c20
0000ec  3d3d2062
0000f0  61736529
0000f4  207c7c20
0000f8  284e554c
0000fc  4c203d3d
000100  20636f6e
000104  66696729
000108  2900    
00010a  00                DCB      0
00010b  00                DCB      0
                  |L17.268|
00010c  6b537461          DCB      "kStatus_Success == result",0
000110  7475735f
000114  53756363
000118  65737320
00011c  3d3d2072
000120  6573756c
000124  7400    
000126  00                DCB      0
000127  00                DCB      0
                  |L17.296|
                          DCD      g_configs
                  |L17.300|
                          DCD      0xfff0f0ff

                          AREA ||i.SPI_SlaveTransferHandleIRQ||, CODE, READONLY, ALIGN=1

                  SPI_SlaveTransferHandleIRQ PROC
;;;615     */
;;;616    static inline void SPI_SlaveTransferHandleIRQ(SPI_Type *base, spi_slave_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;617    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;618        SPI_MasterTransferHandleIRQ(base, handle);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_MasterTransferHandleIRQ
;;;619    }
00000e  bd70              POP      {r4-r6,pc}
;;;620    
                          ENDP


                          AREA ||i.SPI_TransferHandleIRQInternal||, CODE, READONLY, ALIGN=2

                  SPI_TransferHandleIRQInternal PROC
;;;549    
;;;550    static void SPI_TransferHandleIRQInternal(SPI_Type *base, spi_master_handle_t *handle)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;551    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;552        uint32_t tx_ctrl = 0, last_ctrl = 0, tmp32;
000008  2600              MOVS     r6,#0
00000a  46b0              MOV      r8,r6
;;;553        bool loopContinue;
;;;554        uint32_t fifoDepth;
;;;555    
;;;556        /* check params */
;;;557        assert((NULL != base) && (NULL != handle) && ((NULL != handle->txData) || (NULL != handle->rxData)));
00000c  b12d              CBZ      r5,|L19.26|
00000e  b124              CBZ      r4,|L19.26|
000010  6820              LDR      r0,[r4,#0]
000012  b908              CBNZ     r0,|L19.24|
000014  6860              LDR      r0,[r4,#4]
000016  b100              CBZ      r0,|L19.26|
                  |L19.24|
000018  e005              B        |L19.38|
                  |L19.26|
00001a  f240222d          MOV      r2,#0x22d
00001e  a14e              ADR      r1,|L19.344|
000020  4853              LDR      r0,|L19.368|
000022  f7fffffe          BL       __aeabi_assert
                  |L19.38|
;;;558    
;;;559        fifoDepth = SPI_FIFO_DEPTH(base);
000026  f8d50e00          LDR      r0,[r5,#0xe00]
00002a  f3c01001          UBFX     r0,r0,#4,#2
00002e  ea4f09c0          LSL      r9,r0,#3
;;;560        /* select slave to talk with */
;;;561        tx_ctrl |= (SPI_DEASSERT_ALL & SPI_ASSERTNUM_SSEL(handle->sselNum));
000032  f8940025          LDRB     r0,[r4,#0x25]
000036  3010              ADDS     r0,r0,#0x10
000038  2101              MOVS     r1,#1
00003a  4081              LSLS     r1,r1,r0
00003c  f44f2070          MOV      r0,#0xf0000
000040  4388              BICS     r0,r0,r1
000042  f4002070          AND      r0,r0,#0xf0000
000046  4306              ORRS     r6,r6,r0
;;;562        /* set width of data */
;;;563        tx_ctrl |= SPI_FIFOWR_LEN(handle->dataWidth);
000048  f8940024          LDRB     r0,[r4,#0x24]
00004c  f04f6170          MOV      r1,#0xf000000
000050  ea016000          AND      r0,r1,r0,LSL #24
000054  4306              ORRS     r6,r6,r0
;;;564        /* end of transfer */
;;;565        last_ctrl |= (handle->configFlags & (uint32_t)kSPI_FrameAssert) ? (uint32_t)kSPI_FrameAssert : 0;
000056  6aa0              LDR      r0,[r4,#0x28]
000058  f4001080          AND      r0,r0,#0x100000
00005c  b110              CBZ      r0,|L19.100|
00005e  f44f1080          MOV      r0,#0x100000
000062  e000              B        |L19.102|
                  |L19.100|
000064  2000              MOVS     r0,#0
                  |L19.102|
000066  ea400808          ORR      r8,r0,r8
;;;566        /* delay end of transfer */
;;;567        last_ctrl |= (handle->configFlags & (uint32_t)kSPI_FrameDelay) ? (uint32_t)kSPI_FrameDelay : 0;
00006a  6aa0              LDR      r0,[r4,#0x28]
00006c  f4001000          AND      r0,r0,#0x200000
000070  b110              CBZ      r0,|L19.120|
000072  f44f1000          MOV      r0,#0x200000
000076  e000              B        |L19.122|
                  |L19.120|
000078  2000              MOVS     r0,#0
                  |L19.122|
00007a  ea400808          ORR      r8,r0,r8
;;;568        do
00007e  bf00              NOP      
                  |L19.128|
;;;569        {
;;;570            loopContinue = false;
000080  f04f0a00          MOV      r10,#0
;;;571    
;;;572            /* rxFIFO is not empty */
;;;573            if (base->FIFOSTAT & SPI_FIFOSTAT_RXNOTEMPTY_MASK)
000084  f8d50e04          LDR      r0,[r5,#0xe04]
000088  f0000040          AND      r0,r0,#0x40
00008c  b1d8              CBZ      r0,|L19.198|
;;;574            {
;;;575                tmp32 = base->FIFORD;
00008e  f8d57e30          LDR      r7,[r5,#0xe30]
;;;576                /* rxBuffer is not empty */
;;;577                if (handle->rxRemainingBytes)
000092  68e0              LDR      r0,[r4,#0xc]
000094  b190              CBZ      r0,|L19.188|
;;;578                {
;;;579                    /* low byte must go first */
;;;580                    *(handle->rxData++) = tmp32;
000096  6860              LDR      r0,[r4,#4]
000098  1c41              ADDS     r1,r0,#1
00009a  6061              STR      r1,[r4,#4]
00009c  7007              STRB     r7,[r0,#0]
;;;581                    handle->rxRemainingBytes--;
00009e  68e0              LDR      r0,[r4,#0xc]
0000a0  1e40              SUBS     r0,r0,#1
0000a2  60e0              STR      r0,[r4,#0xc]
;;;582                    /* read 16 bits at once */
;;;583                    if (handle->dataWidth > kSPI_Data8Bits)
0000a4  f8940024          LDRB     r0,[r4,#0x24]
0000a8  2807              CMP      r0,#7
0000aa  dd07              BLE      |L19.188|
;;;584                    {
;;;585                        *(handle->rxData++) = tmp32 >> 8;
0000ac  0a3a              LSRS     r2,r7,#8
0000ae  6860              LDR      r0,[r4,#4]
0000b0  1c41              ADDS     r1,r0,#1
0000b2  6061              STR      r1,[r4,#4]
0000b4  7002              STRB     r2,[r0,#0]
;;;586                        handle->rxRemainingBytes--;
0000b6  68e0              LDR      r0,[r4,#0xc]
0000b8  1e40              SUBS     r0,r0,#1
0000ba  60e0              STR      r0,[r4,#0xc]
                  |L19.188|
;;;587                    }
;;;588                }
;;;589                /* decrease number of data expected to receive */
;;;590                handle->toReceiveCount -= 1;
0000bc  6920              LDR      r0,[r4,#0x10]
0000be  1e40              SUBS     r0,r0,#1
0000c0  6120              STR      r0,[r4,#0x10]
;;;591                loopContinue = true;
0000c2  f04f0a01          MOV      r10,#1
                  |L19.198|
;;;592            }
;;;593    
;;;594            /* - txFIFO is not full
;;;595             * - we cannot cause rxFIFO overflow by sending more data than is the depth of FIFO
;;;596             * - txBuffer is not empty or the next 'toReceiveCount' data can fit into rxBuffer
;;;597             */
;;;598            if ((base->FIFOSTAT & SPI_FIFOSTAT_TXNOTFULL_MASK) && (handle->toReceiveCount < fifoDepth) &&
0000c6  f8d50e04          LDR      r0,[r5,#0xe04]
0000ca  f0000020          AND      r0,r0,#0x20
0000ce  2800              CMP      r0,#0
0000d0  d03d              BEQ      |L19.334|
0000d2  6920              LDR      r0,[r4,#0x10]
0000d4  4548              CMP      r0,r9
0000d6  d23a              BCS      |L19.334|
;;;599                ((handle->txRemainingBytes) ||
0000d8  68a0              LDR      r0,[r4,#8]
0000da  b940              CBNZ     r0,|L19.238|
;;;600                 (handle->rxRemainingBytes >= SPI_COUNT_TO_BYTES(handle->dataWidth, handle->toReceiveCount + 1))))
0000dc  6920              LDR      r0,[r4,#0x10]
0000de  1c40              ADDS     r0,r0,#1
0000e0  f8941024          LDRB     r1,[r4,#0x24]
0000e4  10c9              ASRS     r1,r1,#3
0000e6  4088              LSLS     r0,r0,r1
0000e8  68e1              LDR      r1,[r4,#0xc]
0000ea  4288              CMP      r0,r1
0000ec  d82f              BHI      |L19.334|
                  |L19.238|
;;;601            {
;;;602                /* txBuffer is not empty */
;;;603                if (handle->txRemainingBytes)
0000ee  68a0              LDR      r0,[r4,#8]
0000f0  b1c0              CBZ      r0,|L19.292|
;;;604                {
;;;605                    /* low byte must go first */
;;;606                    tmp32 = *(handle->txData++);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  1c41              ADDS     r1,r0,#1
0000f6  6021              STR      r1,[r4,#0]
0000f8  7807              LDRB     r7,[r0,#0]
;;;607                    handle->txRemainingBytes--;
0000fa  68a0              LDR      r0,[r4,#8]
0000fc  1e40              SUBS     r0,r0,#1
0000fe  60a0              STR      r0,[r4,#8]
;;;608                    /* write 16 bit at once */
;;;609                    if (handle->dataWidth > kSPI_Data8Bits)
000100  f8940024          LDRB     r0,[r4,#0x24]
000104  2807              CMP      r0,#7
000106  dd08              BLE      |L19.282|
;;;610                    {
;;;611                        tmp32 |= ((uint32_t)(*(handle->txData++))) << 8U;
000108  6820              LDR      r0,[r4,#0]
00010a  1c41              ADDS     r1,r0,#1
00010c  6021              STR      r1,[r4,#0]
00010e  7801              LDRB     r1,[r0,#0]
000110  ea472701          ORR      r7,r7,r1,LSL #8
;;;612                        handle->txRemainingBytes--;
000114  68a0              LDR      r0,[r4,#8]
000116  1e40              SUBS     r0,r0,#1
000118  60a0              STR      r0,[r4,#8]
                  |L19.282|
;;;613                    }
;;;614                    /* last transfer */
;;;615                    if (!handle->txRemainingBytes)
00011a  68a0              LDR      r0,[r4,#8]
00011c  b978              CBNZ     r0,|L19.318|
;;;616                    {
;;;617                        tx_ctrl |= last_ctrl;
00011e  ea460608          ORR      r6,r6,r8
000122  e00c              B        |L19.318|
                  |L19.292|
;;;618                    }
;;;619                }
;;;620                else
;;;621                {
;;;622                    tmp32 = SPI_DUMMYDATA;
000124  f64f77ff          MOV      r7,#0xffff
;;;623                    /* last transfer */
;;;624                    if (handle->rxRemainingBytes == SPI_COUNT_TO_BYTES(handle->dataWidth, handle->toReceiveCount + 1))
000128  6920              LDR      r0,[r4,#0x10]
00012a  1c40              ADDS     r0,r0,#1
00012c  f8941024          LDRB     r1,[r4,#0x24]
000130  10c9              ASRS     r1,r1,#3
000132  4088              LSLS     r0,r0,r1
000134  68e1              LDR      r1,[r4,#0xc]
000136  4288              CMP      r0,r1
000138  d101              BNE      |L19.318|
;;;625                    {
;;;626                        tx_ctrl |= last_ctrl;
00013a  ea460608          ORR      r6,r6,r8
                  |L19.318|
;;;627                    }
;;;628                }
;;;629                /* send data */
;;;630                tmp32 = tx_ctrl | tmp32;
00013e  4337              ORRS     r7,r7,r6
;;;631                base->FIFOWR = tmp32;
000140  f8c57e20          STR      r7,[r5,#0xe20]
;;;632                /* increase number of expected data to receive */
;;;633                handle->toReceiveCount += 1;
000144  6920              LDR      r0,[r4,#0x10]
000146  1c40              ADDS     r0,r0,#1
000148  6120              STR      r0,[r4,#0x10]
;;;634                loopContinue = true;
00014a  f04f0a01          MOV      r10,#1
                  |L19.334|
;;;635            }
;;;636        } while (loopContinue);
00014e  f1ba0f00          CMP      r10,#0
000152  d195              BNE      |L19.128|
;;;637    }
000154  e8bd87f0          POP      {r4-r10,pc}
;;;638    
                          ENDP

                  |L19.344|
000158  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
00015c  44726976
000160  6572735c
000164  66736c5f
000168  7370692e
00016c  6300    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L19.368|
                          DCD      ||.conststring||

                          AREA ||i.SPI_WriteData||, CODE, READONLY, ALIGN=2

                  SPI_WriteData PROC
;;;286    
;;;287    void SPI_WriteData(SPI_Type *base, uint16_t data, uint32_t configFlags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;288    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;289        uint32_t control = 0;
00000a  2500              MOVS     r5,#0
;;;290        int32_t instance;
;;;291    
;;;292        /* check params */
;;;293        assert(NULL != base);
00000c  b106              CBZ      r6,|L20.16|
00000e  e005              B        |L20.28|
                  |L20.16|
000010  f2401225          MOV      r2,#0x125
000014  a11d              ADR      r1,|L20.140|
000016  a023              ADR      r0,|L20.164|
000018  f7fffffe          BL       __aeabi_assert
                  |L20.28|
;;;294        /* get and check instance */
;;;295        instance = SPI_GetInstance(base);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       SPI_GetInstance
000022  4604              MOV      r4,r0
;;;296        assert(!(instance < 0));
000024  2c00              CMP      r4,#0
000026  db00              BLT      |L20.42|
000028  e005              B        |L20.54|
                  |L20.42|
00002a  f44f7294          MOV      r2,#0x128
00002e  a117              ADR      r1,|L20.140|
000030  a020              ADR      r0,|L20.180|
000032  f7fffffe          BL       __aeabi_assert
                  |L20.54|
;;;297        if (instance < 0)
000036  2c00              CMP      r4,#0
000038  da01              BGE      |L20.62|
                  |L20.58|
;;;298        {
;;;299            return;
;;;300        }
;;;301    
;;;302        /* set data width */
;;;303        control |= SPI_FIFOWR_LEN(g_configs[instance].dataWidth);
;;;304        /* set sssel */
;;;305        control |= (SPI_DEASSERT_ALL & (~SPI_DEASSERTNUM_SSEL(g_configs[instance].sselNum)));
;;;306        /* mask configFlags */
;;;307        control |= (configFlags & SPI_FIFOWR_FLAGS_MASK);
;;;308        /* control should not affect lower 16 bits */
;;;309        assert(!(control & 0xFFFF));
;;;310        base->FIFOWR = data | control;
;;;311    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L20.62|
00003e  4821              LDR      r0,|L20.196|
000040  f8100014          LDRB     r0,[r0,r4,LSL #1]     ;303
000044  f04f6170          MOV      r1,#0xf000000         ;303
000048  ea016000          AND      r0,r1,r0,LSL #24      ;303
00004c  4305              ORRS     r5,r5,r0              ;303
00004e  481d              LDR      r0,|L20.196|
000050  eb000044          ADD      r0,r0,r4,LSL #1       ;305
000054  7840              LDRB     r0,[r0,#1]            ;305
000056  3010              ADDS     r0,r0,#0x10           ;305
000058  2101              MOVS     r1,#1                 ;305
00005a  4081              LSLS     r1,r1,r0              ;305
00005c  f44f2070          MOV      r0,#0xf0000           ;305
000060  4388              BICS     r0,r0,r1              ;305
000062  4305              ORRS     r5,r5,r0              ;305
000064  4918              LDR      r1,|L20.200|
000066  ea080001          AND      r0,r8,r1              ;307
00006a  4305              ORRS     r5,r5,r0              ;307
00006c  b2a8              UXTH     r0,r5                 ;309
00006e  b900              CBNZ     r0,|L20.114|
000070  e005              B        |L20.126|
                  |L20.114|
000072  f2401235          MOV      r2,#0x135             ;309
000076  a105              ADR      r1,|L20.140|
000078  a014              ADR      r0,|L20.204|
00007a  f7fffffe          BL       __aeabi_assert
                  |L20.126|
00007e  ea470005          ORR      r0,r7,r5              ;310
000082  f8c60e20          STR      r0,[r6,#0xe20]        ;310
000086  bf00              NOP      
000088  e7d7              B        |L20.58|
;;;312    
                          ENDP

00008a  0000              DCW      0x0000
                  |L20.140|
00008c  5352435c          DCB      "SRC\\Drivers\\fsl_spi.c",0
000090  44726976
000094  6572735c
000098  66736c5f
00009c  7370692e
0000a0  6300    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L20.164|
0000a4  4e554c4c          DCB      "NULL != base",0
0000a8  20213d20
0000ac  62617365
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L20.180|
0000b4  2128696e          DCB      "!(instance < 0)",0
0000b8  7374616e
0000bc  6365203c
0000c0  20302900
                  |L20.196|
                          DCD      g_configs
                  |L20.200|
                          DCD      0xf0f00000
                  |L20.204|
0000cc  2128636f          DCB      "!(control & 0xFFFF)",0
0000d0  6e74726f
0000d4  6c202620
0000d8  30784646
0000dc  46462900

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_configs
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_spiBaseAddrs
                          DCD      0x40086000
                          DCD      0x40087000
                          DCD      0x40088000
                          DCD      0x40089000
                          DCD      0x4008a000
                          DCD      0x40096000
                          DCD      0x40097000
                          DCD      0x40098000
                          DCD      0x40099000
                          DCD      0x4009a000
                  s_spiIRQ
000028  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
00002c  12131415          DCB      0x12,0x13,0x14,0x15
000030  2829              DCB      0x28,0x29

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  284e554c          DCB      "(NULL != base) && (NULL != handle) && ((NULL != handle-"
000004  4c20213d
000008  20626173
00000c  65292026
000010  2620284e
000014  554c4c20
000018  213d2068
00001c  616e646c
000020  65292026
000024  26202828
000028  4e554c4c
00002c  20213d20
000030  68616e64
000034  6c652d  
000037  3e747844          DCB      ">txData) || (NULL != handle->rxData))",0
00003b  61746129
00003f  207c7c20
000043  284e554c
000047  4c20213d
00004b  2068616e
00004f  646c652d
000053  3e727844
000057  61746129
00005b  2900    
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
000060  2128284e          DCB      "!((NULL == base) || (NULL == xfer) || ((NULL == xfer->t"
000064  554c4c20
000068  3d3d2062
00006c  61736529
000070  207c7c20
000074  284e554c
000078  4c203d3d
00007c  20786665
000080  7229207c
000084  7c202828
000088  4e554c4c
00008c  203d3d20
000090  78666572
000094  2d3e74  
000097  78446174          DCB      "xData) && (NULL == xfer->rxData)))",0
00009b  61292026
00009f  2620284e
0000a3  554c4c20
0000a7  3d3d2078
0000ab  6665722d
0000af  3e727844
0000b3  61746129
0000b7  292900  
0000ba  00                DCB      0
0000bb  00                DCB      0
0000bc  2128284e          DCB      "!((NULL == base) || (NULL == handle) || (NULL == xfer) "
0000c0  554c4c20
0000c4  3d3d2062
0000c8  61736529
0000cc  207c7c20
0000d0  284e554c
0000d4  4c203d3d
0000d8  2068616e
0000dc  646c6529
0000e0  207c7c20
0000e4  284e554c
0000e8  4c203d3d
0000ec  20786665
0000f0  722920  
0000f3  7c7c2028          DCB      "|| ((NULL == xfer->txData) && (NULL == xfer->rxData)))",0
0000f7  284e554c
0000fb  4c203d3d
0000ff  20786665
000103  722d3e74
000107  78446174
00010b  61292026
00010f  2620284e
000113  554c4c20
000117  3d3d2078
00011b  6665722d
00011f  3e727844
000123  61746129
000127  292900  
00012a  00                DCB      0
00012b  00                DCB      0
00012c  21282868          DCB      "!((handle->dataWidth > kSPI_Data8Bits) && (xfer->dataSi"
000130  616e646c
000134  652d3e64
000138  61746157
00013c  69647468
000140  203e206b
000144  5350495f
000148  44617461
00014c  38426974
000150  73292026
000154  26202878
000158  6665722d
00015c  3e646174
000160  615369  
000163  7a652026          DCB      "ze & 0x1))",0
000167  20307831
00016b  292900  

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_spi_c_a05d456f____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_spi_c_a05d456f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_spi_c_a05d456f____REVSH|
#line 402
|__asm___9_fsl_spi_c_a05d456f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_spi_c_a05d456f____RRX|
#line 587
|__asm___9_fsl_spi_c_a05d456f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
