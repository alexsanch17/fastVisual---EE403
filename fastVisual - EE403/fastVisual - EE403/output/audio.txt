; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\audio.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\audio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\audio.crf SRC\Audio\Audio.c]
                          THUMB

                          AREA ||i.I2S_Enable||, CODE, READONLY, ALIGN=1

                  I2S_Enable PROC
;;;399     */
;;;400    static inline void I2S_Enable(I2S_Type *base)
000000  f8d01c00          LDR      r1,[r0,#0xc00]
;;;401    {
;;;402        base->CFG1 |= I2S_CFG1_MAINENABLE(1U);
000004  f0410101          ORR      r1,r1,#1
000008  f8c01c00          STR      r1,[r0,#0xc00]
;;;403    }
00000c  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.I2S_EnableInterrupts||, CODE, READONLY, ALIGN=1

                  I2S_EnableInterrupts PROC
;;;428     */
;;;429    static inline void I2S_EnableInterrupts(I2S_Type *base, uint32_t interruptMask)
000000  f8c01e10          STR      r1,[r0,#0xe10]
;;;430    {
;;;431        base->FIFOINTENSET = interruptMask;
;;;432    }
000004  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.InitAudio_CODEC||, CODE, READONLY, ALIGN=2

                  InitAudio_CODEC PROC
;;;28     /*This function hides the complicated initialization of the onboard CODEC*/
;;;29     void InitAudio_CODEC(void)
000000  b500              PUSH     {lr}
;;;30     {
000002  b093              SUB      sp,sp,#0x4c
;;;31     
;;;32        /*
;;;33     			Before we set the Flexcom channels for I2S,  we have to set up the
;;;34     		external WM8904 CODEC.  It has many configuration settings.   Get the datasheet for the WM8904 and you can see 
;;;35     	  all of the different options.  Page 6 of the WM8904 has a block diagram of the internal functions of the CODEC.
;;;36     	
;;;37     		To configure the WM8904,  we have to use an I2C interface.  I2C is a two-wire serial bus
;;;38     	  that is  common used for inter chip communication.  The WM8904 has an I2C interface which is used
;;;39     	  to configure the CODEC.   There are registers exposed over this interface.    This init fuction will
;;;40     	  take care of this intialization. 
;;;41     	
;;;42     	  To talk I2C,  we are going to use the NXP SDK drivers and an NXP driver for the WM8904.  The structures below
;;;43     	   are used by the drivers to configure the I2C interface and the WM8904
;;;44     	 */
;;;45     	
;;;46        	i2c_master_config_t i2cConfig;
;;;47     
;;;48         wm8904_config_t codecConfig;
;;;49       
;;;50         wm8904_handle_t codecHandle;
;;;51     	
;;;52     	 /*
;;;53     				The external CODEC requires a master clock.  This is used by the sigma-delta converters in the CODEC.
;;;54     				The LPC54608 has a phased locked loop (PLL) clock synthesizer dedicated for generating audio
;;;55     				clocks.   The structures below are used by the NXP drivers for the Audio PLL
;;;56     	 */
;;;57     	 
;;;58     	  pll_config_t audio_pll_config = 
000004  221c              MOVS     r2,#0x1c
000006  4947              LDR      r1,|L3.292|
000008  a806              ADD      r0,sp,#0x18
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;59     		{
;;;60             .desiredRate = 24576000U, .inputRate = 12000000U,
;;;61         };
;;;62     		
;;;63     		pll_setup_t audio_pll_setup;
;;;64     		
;;;65     		/*
;;;66     				The I2C signal that are connected to the WM8902 is from FlexComm 2. (See the schematic for the LPCXpresso54608 to see this connection.
;;;67     			  Enable the clock for the I2C
;;;68     	  */
;;;69         
;;;70     		CLOCK_AttachClk(kFRO12M_to_FLEXCOMM2);
00000e  f44f7087          MOV      r0,#0x10e
000012  f7fffffe          BL       CLOCK_AttachClk
;;;71     		
;;;72         /* reset FLEXCOMM for I2C */
;;;73         RESET_PeripheralReset(kFC2_RST_SHIFT_RSTn);
000016  4844              LDR      r0,|L3.296|
000018  f7fffffe          BL       RESET_PeripheralReset
;;;74     		
;;;75         /* Initialize AUDIO PLL clock */
;;;76         CLOCK_SetupAudioPLLData(&audio_pll_config, &audio_pll_setup);
00001c  4669              MOV      r1,sp
00001e  a806              ADD      r0,sp,#0x18
000020  f7fffffe          BL       CLOCK_SetupAudioPLLData
;;;77         audio_pll_setup.flags = PLL_SETUPFLAG_POWERUP | PLL_SETUPFLAG_WAITLOCK;
000024  2003              MOVS     r0,#3
000026  9005              STR      r0,[sp,#0x14]
;;;78         CLOCK_SetupAudioPLLPrec(&audio_pll_setup, audio_pll_setup.flags);
000028  4668              MOV      r0,sp
00002a  9905              LDR      r1,[sp,#0x14]
00002c  f7fffffe          BL       CLOCK_SetupAudioPLLPrec
;;;79     
;;;80         /*
;;;81     			Flexcomm 6 and 7 are used the I2S channels (one for transmit and one for recieve)
;;;82        		I2S clocks will be derived from the Audio PLL.
;;;83     		*/
;;;84         CLOCK_AttachClk(kAUDIO_PLL_to_FLEXCOMM6);
000030  f2403012          MOV      r0,#0x312
000034  f7fffffe          BL       CLOCK_AttachClk
;;;85         CLOCK_AttachClk(kAUDIO_PLL_to_FLEXCOMM7);
000038  f2403013          MOV      r0,#0x313
00003c  f7fffffe          BL       CLOCK_AttachClk
;;;86     		
;;;87     		/* Attach PLL clock to MCLK for I2S, no divider */
;;;88         CLOCK_AttachClk(kAUDIO_PLL_to_MCLK);
000040  f44f7006          MOV      r0,#0x218
000044  f7fffffe          BL       CLOCK_AttachClk
;;;89         SYSCON->MCLKDIV = SYSCON_MCLKDIV_DIV(0U);
000048  2000              MOVS     r0,#0
00004a  4938              LDR      r1,|L3.300|
00004c  6008              STR      r0,[r1,#0]
;;;90     		
;;;91         /*
;;;92     		 *  Initialize the I2C to talk to the WM8904
;;;93     		 *
;;;94          * enableMaster = true;
;;;95          * baudRate_Bps = 100000U;
;;;96          * enableTimeout = false;
;;;97          */
;;;98         I2C_MasterGetDefaultConfig(&i2cConfig);
00004e  a810              ADD      r0,sp,#0x40
000050  f7fffffe          BL       I2C_MasterGetDefaultConfig
;;;99         i2cConfig.baudRate_Bps = WM8904_I2C_BITRATE;
000054  4836              LDR      r0,|L3.304|
000056  9011              STR      r0,[sp,#0x44]
;;;100        I2C_MasterInit(I2C2, &i2cConfig, I2C2_MASTER_CLOCK_FREQUENCY);
000058  4a36              LDR      r2,|L3.308|
00005a  a910              ADD      r1,sp,#0x40
00005c  4836              LDR      r0,|L3.312|
00005e  f7fffffe          BL       I2C_MasterInit
;;;101    
;;;102    
;;;103        /*
;;;104    			Now that the I2C is setup, we can talk to the WM8904
;;;105    			We are using the NXP provided provided drivers
;;;106         */
;;;107        WM8904_GetDefaultConfig(&codecConfig);
000062  a80e              ADD      r0,sp,#0x38
000064  f7fffffe          BL       WM8904_GetDefaultConfig
;;;108    		codecConfig.format.fsRatio = OVERSAMPLE_RATE;     //These Macros are set at the top of the file.
000068  2006              MOVS     r0,#6
00006a  f88d003a          STRB     r0,[sp,#0x3a]
;;;109    		codecConfig.format.sampleRate = SAMPLE_RATE_REG;
00006e  2104              MOVS     r1,#4
000070  a80e              ADD      r0,sp,#0x38
000072  70c1              STRB     r1,[r0,#3]
;;;110    		
;;;111    		/*
;;;112    		Tell the driver what I2C Channel we are use and then initialize the CODEC
;;;113    		*/
;;;114        
;;;115    		codecHandle.i2c = I2C2;
000074  4830              LDR      r0,|L3.312|
000076  900d              STR      r0,[sp,#0x34]
;;;116        if (WM8904_Init(&codecHandle, &codecConfig) != kStatus_Success)
000078  a90e              ADD      r1,sp,#0x38
00007a  a80d              ADD      r0,sp,#0x34
00007c  f7fffffe          BL       WM8904_Init
000080  b110              CBZ      r0,|L3.136|
;;;117        {
;;;118            PRINTF("WM8904_Init failed!\r\n");
000082  a02e              ADR      r0,|L3.316|
000084  f7fffffe          BL       DbgConsole_Printf
                  |L3.136|
;;;119        }
;;;120    		
;;;121        /* Adjust output volume it to your needs, 0x0006 for -51 dB, 0x0039 for 0 dB etc. */
;;;122        /* Page 154 of the WM8904 data sheet has the volume settings*/
;;;123    		WM8904_SetVolume(&codecHandle, 0x0039, 0x0039);
000088  2239              MOVS     r2,#0x39
00008a  4611              MOV      r1,r2
00008c  a80d              ADD      r0,sp,#0x34
00008e  f7fffffe          BL       WM8904_SetVolume
;;;124      
;;;125        /*
;;;126    			The WM8904 is now configured.   We have to set the I2S channels
;;;127    		  to transmit and recieve audio data
;;;128    		
;;;129    		*/
;;;130    		
;;;131        /* Reset FLEXCOMM for I2S.  Flexcomm 6 is the transmit interface and FlexComm7 is the receive*/
;;;132        RESET_PeripheralReset(kFC6_RST_SHIFT_RSTn);
000092  4825              LDR      r0,|L3.296|
000094  1d00              ADDS     r0,r0,#4
000096  f7fffffe          BL       RESET_PeripheralReset
;;;133        RESET_PeripheralReset(kFC7_RST_SHIFT_RSTn);
00009a  4823              LDR      r0,|L3.296|
00009c  1d40              ADDS     r0,r0,#5
00009e  f7fffffe          BL       RESET_PeripheralReset
;;;134    		
;;;135    		
;;;136    		/*
;;;137    			We are using the NXP Driver to setup the I2S.   We must populate
;;;138    		  the configuration structures and their drivers will hit the registers for us.
;;;139    		
;;;140    		  The Transmitter is setup to by an I2S master and the receiver as an I2S slave
;;;141    			
;;;142    		*/
;;;143    		/*
;;;144         * masterSlave = kI2S_MasterSlaveNormalMaster;
;;;145         * mode = kI2S_ModeI2sClassic;
;;;146         * rightLow = false;
;;;147         * leftJust = false;
;;;148         * pdmData = false;
;;;149         * sckPol = false;
;;;150         * wsPol = false;
;;;151         * divider = 1;
;;;152         * oneChannel = false;
;;;153         * dataLength = 16;
;;;154         * frameLength = 32;
;;;155         * position = 0;
;;;156         * watermark = 4;
;;;157         * txEmptyZero = true;
;;;158         * pack48 = false;
;;;159         */
;;;160        I2S_TxGetDefaultConfig(&s_TxConfig);
0000a2  482c              LDR      r0,|L3.340|
0000a4  f7fffffe          BL       I2S_TxGetDefaultConfig
;;;161        s_TxConfig.divider = I2S_CLOCK_DIVIDER;  //This macro is set at the top of the file.  It is a divder to generate the bit clock
0000a8  f7fffffe          BL       CLOCK_GetAudioPllOutFreq
0000ac  f44f41fa          MOV      r1,#0x7d00
0000b0  fbb0f0f1          UDIV     r0,r0,r1
0000b4  0900              LSRS     r0,r0,#4
0000b6  f3c0004f          UBFX     r0,r0,#1,#16
0000ba  4926              LDR      r1,|L3.340|
0000bc  8108              STRH     r0,[r1,#8]
;;;162    
;;;163        /*
;;;164         * masterSlave = kI2S_MasterSlaveNormalSlave;
;;;165         * mode = kI2S_ModeI2sClassic;
;;;166         * rightLow = false;
;;;167         * leftJust = false;
;;;168         * pdmData = false;
;;;169         * sckPol = false;
;;;170         * wsPol = false;
;;;171         * divider = 1;
;;;172         * oneChannel = false;
;;;173         * dataLength = 16;
;;;174         * frameLength = 32;
;;;175         * position = 0;
;;;176         * watermark = 4;
;;;177         * txEmptyZero = false;
;;;178         * pack48 = false;
;;;179         */
;;;180    
;;;181        I2S_RxGetDefaultConfig(&s_RxConfig);
0000be  4826              LDR      r0,|L3.344|
0000c0  f7fffffe          BL       I2S_RxGetDefaultConfig
;;;182    		
;;;183    		
;;;184    		/*
;;;185    			The only setting we will change is the FIFO Watermark.
;;;186    			The incoming and outgoing I2S data go through a set of FIFO buffers.
;;;187    			The watermark level is the point at which the I2S will generate an interrupt.
;;;188    			
;;;189    			We are are going to interrupt when there are at least 2 samples available or less than 2 to transmit.
;;;190    		  This will give us some to to prep a new sample while another is being transmitted or recieved.
;;;191    		*/
;;;192    		
;;;193    		s_RxConfig.watermark = 2;
0000c4  2002              MOVS     r0,#2
0000c6  4924              LDR      r1,|L3.344|
0000c8  7408              STRB     r0,[r1,#0x10]
;;;194    		s_TxConfig.watermark = 2;
0000ca  4922              LDR      r1,|L3.340|
0000cc  7408              STRB     r0,[r1,#0x10]
;;;195    		
;;;196    		/*
;;;197    			Pass our configuration structures to the driver
;;;198    		*/
;;;199        I2S_TxInit(I2S0, &s_TxConfig);
0000ce  4823              LDR      r0,|L3.348|
0000d0  f7fffffe          BL       I2S_TxInit
;;;200        I2S_RxInit(I2S1, &s_RxConfig);
0000d4  4920              LDR      r1,|L3.344|
0000d6  4822              LDR      r0,|L3.352|
0000d8  f7fffffe          BL       I2S_RxInit
;;;201    		
;;;202    		/*
;;;203    			Enable Interrupts to the Flexcomms and set to the highest priority
;;;204    			We are going to trigger interrupts on the FIFO level (watermark) flags 
;;;205    		*/
;;;206    		NVIC_SetPriority(FLEXCOMM6_IRQn,0);
0000dc  2100              MOVS     r1,#0
0000de  2014              MOVS     r0,#0x14
0000e0  f7fffffe          BL       NVIC_SetPriority
;;;207    		NVIC_SetPriority(FLEXCOMM7_IRQn,0);
0000e4  2100              MOVS     r1,#0
0000e6  2015              MOVS     r0,#0x15
0000e8  f7fffffe          BL       NVIC_SetPriority
;;;208    				
;;;209    		NVIC_EnableIRQ(FLEXCOMM6_IRQn);
0000ec  2014              MOVS     r0,#0x14
0000ee  f7fffffe          BL       NVIC_EnableIRQ
;;;210    		NVIC_EnableIRQ(FLEXCOMM7_IRQn);
0000f2  2015              MOVS     r0,#0x15
0000f4  f7fffffe          BL       NVIC_EnableIRQ
;;;211    		
;;;212    		/*
;;;213    			  We are going to put in some data to transmit FIFO to get it Started!
;;;214    				THis will ensure there is always some data to be sent out.   Out Rx IRQ will be putting a sample into the output
;;;215    				queue	everytime it gets a sample in from the input queue
;;;216    		*/
;;;217    		I2S0->FIFOWR = 0xFFFFFFFF;
0000f8  f04f30ff          MOV      r0,#0xffffffff
0000fc  4919              LDR      r1,|L3.356|
0000fe  6008              STR      r0,[r1,#0]
;;;218    		I2S0->FIFOWR = 0xFFFFFFFF;
000100  6008              STR      r0,[r1,#0]
;;;219    	
;;;220        I2S_EnableInterrupts(I2S0, kI2S_TxLevelFlag);
000102  2104              MOVS     r1,#4
000104  4815              LDR      r0,|L3.348|
000106  f7fffffe          BL       I2S_EnableInterrupts
;;;221        I2S_EnableInterrupts(I2S1, kI2S_RxLevelFlag);
00010a  2108              MOVS     r1,#8
00010c  4814              LDR      r0,|L3.352|
00010e  f7fffffe          BL       I2S_EnableInterrupts
;;;222        
;;;223        I2S_Enable(I2S0);
000112  4812              LDR      r0,|L3.348|
000114  f7fffffe          BL       I2S_Enable
;;;224    		I2S_Enable(I2S1);
000118  4811              LDR      r0,|L3.352|
00011a  f7fffffe          BL       I2S_Enable
;;;225    
;;;226    
;;;227    	  /* At this point, the interrupts will start firing*/
;;;228    
;;;229    }
00011e  b013              ADD      sp,sp,#0x4c
000120  bd00              POP      {pc}
;;;230    
                          ENDP

000122  0000              DCW      0x0000
                  |L3.292|
                          DCD      ||.constdata||
                  |L3.296|
                          DCD      0x0001000d
                  |L3.300|
                          DCD      0x400003ac
                  |L3.304|
                          DCD      0x00061a80
                  |L3.308|
                          DCD      0x00b71b00
                  |L3.312|
                          DCD      0x40088000
                  |L3.316|
00013c  574d3839          DCB      "WM8904_Init failed!\r\n",0
000140  30345f49
000144  6e697420
000148  6661696c
00014c  6564210d
000150  0a00    
000152  00                DCB      0
000153  00                DCB      0
                  |L3.340|
                          DCD      s_TxConfig
                  |L3.344|
                          DCD      s_RxConfig
                  |L3.348|
                          DCD      0x40097000
                  |L3.352|
                          DCD      0x40098000
                  |L3.356|
                          DCD      0x40097e20

                          AREA ||i.Init_DMIC||, CODE, READONLY, ALIGN=2

                  Init_DMIC PROC
;;;252    
;;;253    void Init_DMIC(void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255    		
;;;256    	/*
;;;257    	Setting up a peripheral is generally always the same.
;;;258    	a.)  Set up and enable a clocks to the peripheral.    By default,  peripherals may not be clocked at boot to save power
;;;259    	b.)  If the peripheral is wired to the outside world, you must set up the pin multiplexers.   Because there
;;;260    		    are many peripherals they must share IO pins.  There is a multiplexor at each IO pin to select the function.
;;;261    	       See Chapter 7 (IOCON) of the the LPC54608 User manual (page 137).   Each pin has peripherals that can be routed to it.
;;;262    	       Table 173 shows you how to select what is routed to each pin.
;;;263    	c.)  Setup the core peripheral registers to configure its operation
;;;264    	d.)  Enable interrupts (if used) in the NVIC.  There also may be interrupt masks in the pheriphal registers that need set
;;;265    	e.)  Go!
;;;266    	*/
;;;267    	
;;;268    	
;;;269    	
;;;270    	
;;;271    	/*
;;;272    		   Ok Let's set up the clock for the DMIC
;;;273    			
;;;274    				We start in the "SYSCON" registers. (chapter 4 in the user manual).
;;;275    	
;;;276    				The System Configuration peripheral is where start when configuring the clocks.
;;;277    	*/
;;;278    		
;;;279      /*		There is a a register for the DMIC clock. (page 61 in chapter 3).   
;;;280    				Here we can select what sources our DMIC.    
;;;281    				
;;;282    				In the line below,  notice that the register is mapped to a struct.   If you look in "fsl_device_registers.h"
;;;283    				you can see another #include file "LPC54608.h".  This file has register definitions.    Instead of having
;;;284    				a macro (#define) for every register,   there is a data structure for each periphal that has the same layout
;;;285    				as the pheripheral block in memory.   Pointers are created to these structure types that point the BASE ADDRESS of the peripheral.
;;;286    				This makes accessing the registers a bit easier as we can use structure notation.
;;;287    				
;;;288    				We use the -> notation when getting to a register as the #define for the base address are pointers to a struct.
;;;289    		
;;;290    			  1st we will select the clock source for the DMIC.    We will select the 12MHZ FRO clock.   There is a 12MHz internal oscillator in the chip that
;;;291    				can be used clocking peripherals.  Clocking can be complicated but it is all described inthe SYSCON chapter.   
;;;292    				Section 4.4.1 describes all the different clocking options.
;;;293    	*/
;;;294    	
;;;295    	  SYSCON->DMICCLKSEL = 0; //Select 12MHZ FRO for clock source
000002  2000              MOVS     r0,#0
000004  491f              LDR      r1,|L4.132|
000006  6008              STR      r0,[r1,#0]
;;;296    	
;;;297    	/* Each peripheral clock can also be  divided down.    Section 4.5.58 of the user manual describes the DMIC clock divider.  
;;;298    	We sometimes want to divide clocks to get other application timings just right. (In our case the same rate of the microphone).*/
;;;299    	
;;;300    	SYSCON->DMICCLKDIV = 2; //Divide by 3.   Note that divide by one is a zero,   divide by 2 is a 1, etc.
000008  2002              MOVS     r0,#2
00000a  0741              LSLS     r1,r0,#29
00000c  f8c103a8          STR      r0,[r1,#0x3a8]
;;;301    	
;;;302    	//The clock source is selected.   Now we have to enable the "gate"
;;;303    
;;;304    	/*Page 54 of the user manual shows the bits in AHB clock control register 1.  This is where the bit for gating the DMIC
;;;305    	peripheral is at.  Also notice that I am not using a logical OR operationto set the bit.   There are registers that
;;;306    	allow you to set bits just by writing a 1 to a bit in the register. (see 4.5.22 on page 55)
;;;307    	*/
;;;308    
;;;309      SYSCON->AHBCLKCTRLSET[1] = SYSCON_AHBCLKCTRL_DMIC_MASK; 
000010  0481              LSLS     r1,r0,#18
000012  481c              LDR      r0,|L4.132|
000014  38c8              SUBS     r0,r0,#0xc8
000016  6001              STR      r1,[r0,#0]
;;;310    
;;;311    	
;;;312    	/*For good measure we can reset a periperiphal through peripheral set and reset registers.   See Section 4.5.10 for DMIC reset
;;;313    	Notice the usage of "set" and "clear" registers!   These are special registers that allow you to directly set or clear bits by writing ones to the registers.
;;;314    	*/
;;;315    	
;;;316    	 SYSCON->PRESETCTRLSET[1] = SYSCON_AHBCLKCTRL_DMIC_MASK; //assert the reset
000018  481b              LDR      r0,|L4.136|
00001a  6001              STR      r1,[r0,#0]
;;;317    	 SYSCON->PRESETCTRLCLR[1] = SYSCON_AHBCLKCTRL_DMIC_MASK; //deassert the reset
00001c  481a              LDR      r0,|L4.136|
00001e  3020              ADDS     r0,r0,#0x20
000020  6001              STR      r1,[r0,#0]
;;;318    
;;;319      /*We need the DMIC function routed to the physical IO pins.   
;;;320    	  Open the schematic for the LPCXPresso54608 board.   You will see digital mic on page 9.  It has 2 IO signals CLK and Data
;;;321    		that are connected to microcontroller IO pins P1_2 and P1_3
;;;322    		
;;;323    		Because there  are many peripherals they must share IO pins.  There is a MUX at each IO pin to select the function.
;;;324    	   See Change 7 (IOCON) of the the LPC54608 User manual (page 137).   each pin has certain functions that can be enabled.
;;;325    	   Table 173 shows you how to select the different peripherals for each IO pin.
;;;326    		 
;;;327    		 Notice the array notation below.   The struct that represents the IOCON was organized such that the arrays map
;;;328    		 to the IO ports and pins.  pretty cool huh?   Besides selecting the pin function  with the multiplexer,  there are some other bits that
;;;329    		 configure an IO pin properties.  See Section 7.4.2
;;;330    		 
;;;331    	*/
;;;332    	IOCON->PIO[1][2] = IOCON_PIO_DIGIMODE(1)  | IOCON_PIO_FILTEROFF(1) | IOCON_PIO_FUNC(5);
000022  f2403105          MOV      r1,#0x305
000026  4819              LDR      r0,|L4.140|
000028  6001              STR      r1,[r0,#0]
;;;333    	IOCON->PIO[1][3] = IOCON_PIO_DIGIMODE(1)  | IOCON_PIO_FILTEROFF(1) | IOCON_PIO_FUNC(5);
00002a  1d00              ADDS     r0,r0,#4
00002c  6001              STR      r1,[r0,#0]
;;;334    
;;;335       
;;;336    	 /*At this point the clock is set up and the peripheral is routed to the IO pins,  we now setup the core peripheral registers.
;;;337    	 
;;;338    	 At this point,  there are details about the DMIC we will cover later (like how it actually works) but you can see below that we
;;;339    	 just need to set and clear bits in the control registers*/
;;;340    
;;;341    	DMIC0->CHANEN  = 0x02;  //Enable Channel 1
00002e  2002              MOVS     r0,#2
000030  4917              LDR      r1,|L4.144|
000032  6008              STR      r0,[r1,#0]
;;;342    	DMIC0->IOCFG = 0;			  //Each Channel is independent
000034  2000              MOVS     r0,#0
000036  4916              LDR      r1,|L4.144|
000038  310c              ADDS     r1,r1,#0xc
00003a  6008              STR      r0,[r1,#0]
;;;343    
;;;344    	DMIC0->CHANNEL[1].PHY_CTRL = 1 ; // Sample on the rising Edge and use standard sampling
00003c  2101              MOVS     r1,#1
00003e  4815              LDR      r0,|L4.148|
000040  6001              STR      r1,[r0,#0]
;;;345    	
;;;346    	//Set up the DC blocking filter,  limit to 16-bits and apply some gain.
;;;347    	DMIC0->CHANNEL[1].DC_CTRL = DMIC_CHANNEL_DC_CTRL_DCPOLE(3)            | 
000042  f2401123          MOV      r1,#0x123
000046  1d00              ADDS     r0,r0,#4
000048  6001              STR      r1,[r0,#0]
;;;348    															DMIC_CHANNEL_DC_CTRL_SATURATEAT16BIT_MASK | 
;;;349    															DMIC_CHANNEL_DC_CTRL_DCGAIN(2);
;;;350    	
;;;351    								
;;;352    	DMIC0->CHANNEL[1].PREAC4FSCOEF = 0 ;// No Compenstation
00004a  2100              MOVS     r1,#0
00004c  4811              LDR      r0,|L4.148|
00004e  3880              SUBS     r0,r0,#0x80
000050  6001              STR      r1,[r0,#0]
;;;353    	DMIC0->CHANNEL[1].GAINSHIFT = 0; //No Shift in gain (twos complement 16 bit)
000052  1d00              ADDS     r0,r0,#4
000054  6001              STR      r1,[r0,#0]
;;;354    		
;;;355    		
;;;356    	/*See 26.7.2.2. (Page 461) of the user manual.   The sample rate
;;;357    	is controlled by the 2FS register, the OSR register and the DMIC clock rate.
;;;358    	Knowing how we set up the clock to the DMIC at the beginning of this function, 
;;;359    	can you calculate the sample rate we are now using?
;;;360    	*/
;;;361    	
;;;362    	DMIC0->USE2FS = 1; 		         	// use 1 FS for PCM data
000056  2001              MOVS     r0,#1
000058  490d              LDR      r1,|L4.144|
00005a  3110              ADDS     r1,r1,#0x10
00005c  6008              STR      r0,[r1,#0]
;;;363    	DMIC0->CHANNEL[1].OSR = 125;    //Oversample by 125
00005e  207d              MOVS     r0,#0x7d
000060  490c              LDR      r1,|L4.148|
000062  398c              SUBS     r1,r1,#0x8c
000064  6008              STR      r0,[r1,#0]
;;;364    	DMIC0->CHANNEL[1].DIVHFCLK = 0; // Divide DMIC input clock by 1 ( no divide)
000066  2100              MOVS     r1,#0
000068  480b              LDR      r0,|L4.152|
00006a  f8c01104          STR      r1,[r0,#0x104]
;;;365    	
;;;366    	/*In the register below, we will enable the DMIC AND also enable interrupts *inside* the module.  
;;;367    	this means that an interrupt will be generated when the FIFO gets to a certain level.   This means that the peripheral will
;;;368    	generate an interrupt signal the ARM Cortex NVIC*/
;;;369    	
;;;370    	DMIC0->CHANNEL[1].FIFO_CTRL = DMIC_CHANNEL_FIFO_CTRL_ENABLE_MASK | 
00006e  490b              LDR      r1,|L4.156|
000070  f8c01180          STR      r1,[r0,#0x180]
;;;371    																DMIC_CHANNEL_FIFO_CTRL_INTEN_MASK  | 
;;;372    																DMIC_CHANNEL_FIFO_CTRL_TRIGLVL(2)  |
;;;373    																DMIC_CHANNEL_FIFO_CTRL_RESETN_MASK;
;;;374    
;;;375      /*The line above enables an interrupt to be generated from within the DMIC peripheral. 
;;;376      	We also have to enable the interrupt in the ARM Cortex NVIC (the nested vectored interrupt controller)
;;;377    		
;;;378    		There are 256 slots in the table. Each peripheral has one or more "slots" in the table.   
;;;379    		Chapter 3 (page 21) of the user manual document these slots.  The DMIC is slot 25.
;;;380    		*/
;;;381    
;;;382    	NVIC_EnableIRQ(DMIC0_IRQn);
000074  2019              MOVS     r0,#0x19
000076  f7fffffe          BL       NVIC_EnableIRQ
;;;383    
;;;384       /* This sets the priority to the highest level. 
;;;385    			the NVIC is documented in the ARM technical reference manual for the M4,  not in the user manual for the LPC54608
;;;386       */
;;;387      NVIC_SetPriority(DMIC0_IRQn,0);
00007a  2100              MOVS     r1,#0
00007c  2019              MOVS     r0,#0x19
00007e  f7fffffe          BL       NVIC_SetPriority
;;;388    
;;;389      /*
;;;390    	
;;;391    	All done!!
;;;392    	
;;;393    	Once this function is called the DMIC peripheral will start getting samples and will generate interrupts!
;;;394    	
;;;395    	*/
;;;396    }
000082  bd10              POP      {r4,pc}
;;;397    
                          ENDP

                  |L4.132|
                          DCD      0x400002ec
                  |L4.136|
                          DCD      0x40000124
                  |L4.140|
                          DCD      0x40001088
                  |L4.144|
                          DCD      0x40090f00
                  |L4.148|
                          DCD      0x4009018c
                  |L4.152|
                          DCD      0x40090000
                  |L4.156|
                          DCD      0x00020007

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L6.22|
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  074a              LSLS     r2,r1,#29
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L6.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L6.30|
                  |L6.22|
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  074a              LSLS     r2,r1,#29
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L6.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L6.30|
;;;1707     }
;;;1708   }
00001e  bd10              POP      {r4,pc}
;;;1709   
                          ENDP

                  |L6.32|
                          DCD      0xe000ed18
                  |L6.36|
                          DCD      0xe000e400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_TxConfig
                          %        20
                  s_RxConfig
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x01770000
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
000018  00000000          DCB      0x00,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "SRC\\Audio\\Audio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_Audio_c_02f15e00____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_Audio_c_02f15e00____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_Audio_c_02f15e00____REVSH|
#line 402
|__asm___7_Audio_c_02f15e00____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_Audio_c_02f15e00____RRX|
#line 587
|__asm___7_Audio_c_02f15e00____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
