; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --library_type=standardlib -odebug\fsl_i2c.o --asm_dir=.\output\ --list_dir=.\output\ --depend=debug\fsl_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,66,1296,186 -I.\SRC\eGFX -I.\SRC\eGFX\Drivers -I.\SRC\eGFX\Fonts -I.\SRC\Board -I.\SRC\System\CMSIS\Include -I.\SRC\System\utilities -I.\SRC\Drivers -I.\SRC\System -I.\SRC\eGFX\Fonts\OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP -I.\SRC\Audio -I.\SRC\eGFX\Sprites -I.\SRC\eGFX\Fonts\Consolas__26px__Regular__AntiAliasGridFit_1BPP -I.\SRC\eGFX\Fonts\Magneto__26px__Regular__AntiAliasGridFit_16BPP_565 -I.\SRC\eGFX\Fonts\Arial__23px__Regular__SystemDefault_1BPP -I.\RTE\_Lab6 -IC:\Keil_v5\ARM\PACK\Keil\LPC54000_DFP\2.2.0\LPCOpen\lpc5460x\chip_5460x\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DCHIP_LPC5460X -DDEBUG -DCPU_LPC54608 -DCPU_LPC54608J512ET180=1 -DARM_MATH_CM4 -D__FPU_PRESENT -DCORE_M4 --omf_browse=debug\fsl_i2c.crf SRC\Drivers\fsl_i2c.c]
                          THUMB

                          AREA ||i.EnableIRQ||, CODE, READONLY, ALIGN=1

                  EnableIRQ PROC
;;;198     */
;;;199    static inline void EnableIRQ(IRQn_Type interrupt)
000000  f1100f80          CMN      r0,#0x80
;;;200    {
;;;201        if (NotAvail_IRQn == interrupt)
000004  d100              BNE      |L1.8|
                  |L1.6|
;;;202        {
;;;203            return;
;;;204        }
;;;205    
;;;206    #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
;;;207        if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
;;;208    #endif
;;;209        {
;;;210            NVIC_EnableIRQ(interrupt);
;;;211        }
;;;212    }
000006  4770              BX       lr
                  |L1.8|
000008  bf00              NOP                            ;210
00000a  f000021f          AND      r2,r0,#0x1f           ;210
00000e  2101              MOVS     r1,#1                 ;210
000010  4091              LSLS     r1,r1,r2              ;210
000012  0942              LSRS     r2,r0,#5              ;210
000014  0092              LSLS     r2,r2,#2              ;210
000016  f10222e0          ADD      r2,r2,#0xe000e000     ;210
00001a  f8c21100          STR      r1,[r2,#0x100]        ;210
00001e  bf00              NOP                            ;210
000020  bf00              NOP      
000022  e7f0              B        |L1.6|
;;;213    
                          ENDP


                          AREA ||i.I2C_DisableInterrupts||, CODE, READONLY, ALIGN=1

                  I2C_DisableInterrupts PROC
;;;527     */
;;;528    static inline void I2C_DisableInterrupts(I2C_Type *base, uint32_t interruptMask)
000000  f8c0180c          STR      r1,[r0,#0x80c]
;;;529    {
;;;530        base->INTENCLR = interruptMask;
;;;531    }
000004  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.I2C_EnableInterrupts||, CODE, READONLY, ALIGN=1

                  I2C_EnableInterrupts PROC
;;;515     */
;;;516    static inline void I2C_EnableInterrupts(I2C_Type *base, uint32_t interruptMask)
000000  f8c01808          STR      r1,[r0,#0x808]
;;;517    {
;;;518        base->INTENSET = interruptMask;
;;;519    }
000004  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.I2C_GetInstance||, CODE, READONLY, ALIGN=2

                  I2C_GetInstance PROC
;;;86      */
;;;87     uint32_t I2C_GetInstance(I2C_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;88     {
000002  4605              MOV      r5,r0
;;;89         int i;
;;;90         for (i = 0; i < FSL_FEATURE_SOC_I2C_COUNT; i++)
000004  2400              MOVS     r4,#0
000006  e007              B        |L4.24|
                  |L4.8|
;;;91         {
;;;92             if ((uint32_t)base == s_i2cBaseAddrs[i])
000008  4807              LDR      r0,|L4.40|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  42a8              CMP      r0,r5
000010  d101              BNE      |L4.22|
;;;93             {
;;;94                 return i;
000012  4620              MOV      r0,r4
;;;95             }
;;;96         }
;;;97         assert(false);
;;;98         return 0;
;;;99     }
000014  bd70              POP      {r4-r6,pc}
                  |L4.22|
000016  1c64              ADDS     r4,r4,#1              ;90
                  |L4.24|
000018  2c0a              CMP      r4,#0xa               ;90
00001a  dbf5              BLT      |L4.8|
00001c  2261              MOVS     r2,#0x61              ;97
00001e  a103              ADR      r1,|L4.44|
000020  a008              ADR      r0,|L4.68|
000022  f7fffffe          BL       __aeabi_assert
;;;100    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      s_i2cBaseAddrs
                  |L4.44|
00002c  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
000030  44726976
000034  6572735c
000038  66736c5f
00003c  6932632e
000040  6300    
000042  00                DCB      0
000043  00                DCB      0
                  |L4.68|
000044  66616c73          DCB      "false",0
000048  6500    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.I2C_InitTransferStateMachine||, CODE, READONLY, ALIGN=1

                  I2C_InitTransferStateMachine PROC
;;;518     */
;;;519    static status_t I2C_InitTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;520    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;521        struct _i2c_master_transfer *transfer;
;;;522    
;;;523        handle->transfer = *xfer;
00000a  2218              MOVS     r2,#0x18
00000c  4631              MOV      r1,r6
00000e  f1040018          ADD      r0,r4,#0x18
000012  f7fffffe          BL       __aeabi_memcpy4
;;;524        transfer = &(handle->transfer);
000016  f1040518          ADD      r5,r4,#0x18
;;;525    
;;;526        handle->transferCount = 0;
00001a  2000              MOVS     r0,#0
00001c  6060              STR      r0,[r4,#4]
;;;527        handle->remainingBytes = transfer->dataSize;
00001e  6968              LDR      r0,[r5,#0x14]
000020  60a0              STR      r0,[r4,#8]
;;;528        handle->buf = (uint8_t *)transfer->data;
000022  6928              LDR      r0,[r5,#0x10]
000024  60e0              STR      r0,[r4,#0xc]
;;;529        handle->remainingSubaddr = 0;
000026  2000              MOVS     r0,#0
000028  6120              STR      r0,[r4,#0x10]
;;;530    
;;;531        if (transfer->flags & kI2C_TransferNoStartFlag)
00002a  7828              LDRB     r0,[r5,#0]
00002c  f0000001          AND      r0,r0,#1
000030  b198              CBZ      r0,|L5.90|
;;;532        {
;;;533            /* Start condition shall be ommited, switch directly to next phase */
;;;534            if (transfer->dataSize == 0)
000032  6968              LDR      r0,[r5,#0x14]
000034  b910              CBNZ     r0,|L5.60|
;;;535            {
;;;536                handle->state = kStopState;
000036  2006              MOVS     r0,#6
000038  7020              STRB     r0,[r4,#0]
00003a  e026              B        |L5.138|
                  |L5.60|
;;;537            }
;;;538            else if (handle->transfer.direction == kI2C_Write)
00003c  7fa0              LDRB     r0,[r4,#0x1e]
00003e  b910              CBNZ     r0,|L5.70|
;;;539            {
;;;540                handle->state = kTransmitDataState;
000040  2002              MOVS     r0,#2
000042  7020              STRB     r0,[r4,#0]
000044  e021              B        |L5.138|
                  |L5.70|
;;;541            }
;;;542            else if (handle->transfer.direction == kI2C_Read)
000046  7fa0              LDRB     r0,[r4,#0x1e]
000048  2801              CMP      r0,#1
00004a  d102              BNE      |L5.82|
;;;543            {
;;;544                handle->state = kReceiveDataState;
00004c  2003              MOVS     r0,#3
00004e  7020              STRB     r0,[r4,#0]
000050  e01b              B        |L5.138|
                  |L5.82|
;;;545            }
;;;546            else
;;;547            {
;;;548                return kStatus_I2C_InvalidParameter;
000052  f640202b          MOV      r0,#0xa2b
                  |L5.86|
;;;549            }
;;;550        }
;;;551        else
;;;552        {
;;;553            if (transfer->subaddressSize != 0)
;;;554            {
;;;555                int i;
;;;556                uint32_t subaddress;
;;;557    
;;;558                if (transfer->subaddressSize > sizeof(handle->subaddrBuf))
;;;559                {
;;;560                    return kStatus_I2C_InvalidParameter;
;;;561                }
;;;562    
;;;563                /* Prepare subaddress transmit buffer, most significant byte is stored at the lowest address */
;;;564                subaddress = xfer->subaddress;
;;;565                for (i = xfer->subaddressSize - 1; i >= 0; i--)
;;;566                {
;;;567                    handle->subaddrBuf[i] = subaddress & 0xff;
;;;568                    subaddress >>= 8;
;;;569                }
;;;570                handle->remainingSubaddr = transfer->subaddressSize;
;;;571            }
;;;572            handle->state = kStartState;
;;;573        }
;;;574    
;;;575        return kStatus_Success;
;;;576    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L5.90|
00005a  68e8              LDR      r0,[r5,#0xc]          ;553
00005c  b198              CBZ      r0,|L5.134|
00005e  68e8              LDR      r0,[r5,#0xc]          ;558
000060  2804              CMP      r0,#4                 ;558
000062  d902              BLS      |L5.106|
000064  f640202b          MOV      r0,#0xa2b             ;560
000068  e7f5              B        |L5.86|
                  |L5.106|
00006a  68b2              LDR      r2,[r6,#8]            ;564
00006c  68f0              LDR      r0,[r6,#0xc]          ;565
00006e  1e41              SUBS     r1,r0,#1              ;565
000070  e004              B        |L5.124|
                  |L5.114|
000072  f1040014          ADD      r0,r4,#0x14           ;567
000076  5442              STRB     r2,[r0,r1]            ;567
000078  0a12              LSRS     r2,r2,#8              ;568
00007a  1e49              SUBS     r1,r1,#1              ;565
                  |L5.124|
00007c  2900              CMP      r1,#0                 ;565
00007e  daf8              BGE      |L5.114|
000080  68e8              LDR      r0,[r5,#0xc]          ;570
000082  6120              STR      r0,[r4,#0x10]         ;570
000084  bf00              NOP                            ;571
                  |L5.134|
000086  2005              MOVS     r0,#5                 ;572
000088  7020              STRB     r0,[r4,#0]            ;572
                  |L5.138|
00008a  2000              MOVS     r0,#0                 ;575
00008c  e7e3              B        |L5.86|
;;;577    
                          ENDP


                          AREA ||i.I2C_MasterClearStatusFlags||, CODE, READONLY, ALIGN=1

                  I2C_MasterClearStatusFlags PROC
;;;497     */
;;;498    static inline void I2C_MasterClearStatusFlags(I2C_Type *base, uint32_t statusMask)
000000  f0010250          AND      r2,r1,#0x50
;;;499    {
;;;500        /* Allow clearing just master status flags */
;;;501        base->STAT = statusMask & (I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
000004  f8c02804          STR      r2,[r0,#0x804]
;;;502    }
000008  4770              BX       lr
;;;503    
                          ENDP


                          AREA ||i.I2C_MasterDeinit||, CODE, READONLY, ALIGN=1

                  I2C_MasterDeinit PROC
;;;114    
;;;115    void I2C_MasterDeinit(I2C_Type *base)
000000  b510              PUSH     {r4,lr}
;;;116    {
000002  4604              MOV      r4,r0
;;;117        I2C_MasterEnable(base, false);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_MasterEnable
;;;118    }
00000c  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.I2C_MasterEnable||, CODE, READONLY, ALIGN=1

                  I2C_MasterEnable PROC
;;;448     */
;;;449    static inline void I2C_MasterEnable(I2C_Type *base, bool enable)
000000  b141              CBZ      r1,|L8.20|
;;;450    {
;;;451        if (enable)
;;;452        {
;;;453            base->CFG = (base->CFG & I2C_CFG_MASK) | I2C_CFG_MSTEN_MASK;
000002  f8d02800          LDR      r2,[r0,#0x800]
000006  f002021f          AND      r2,r2,#0x1f
00000a  f0420201          ORR      r2,r2,#1
00000e  f8c02800          STR      r2,[r0,#0x800]
000012  e005              B        |L8.32|
                  |L8.20|
;;;454        }
;;;455        else
;;;456        {
;;;457            base->CFG = (base->CFG & I2C_CFG_MASK) & ~I2C_CFG_MSTEN_MASK;
000014  f8d02800          LDR      r2,[r0,#0x800]
000018  f002021e          AND      r2,r2,#0x1e
00001c  f8c02800          STR      r2,[r0,#0x800]
                  |L8.32|
;;;458        }
;;;459    }
000020  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.I2C_MasterGetDefaultConfig||, CODE, READONLY, ALIGN=2

                  I2C_MasterGetDefaultConfig PROC
;;;100    
;;;101    void I2C_MasterGetDefaultConfig(i2c_master_config_t *masterConfig)
000000  2101              MOVS     r1,#1
;;;102    {
;;;103        masterConfig->enableMaster = true;
000002  7001              STRB     r1,[r0,#0]
;;;104        masterConfig->baudRate_Bps = 100000U;
000004  4902              LDR      r1,|L9.16|
000006  6041              STR      r1,[r0,#4]
;;;105        masterConfig->enableTimeout = false;
000008  2100              MOVS     r1,#0
00000a  7201              STRB     r1,[r0,#8]
;;;106    }
00000c  4770              BX       lr
;;;107    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x000186a0

                          AREA ||i.I2C_MasterInit||, CODE, READONLY, ALIGN=1

                  I2C_MasterInit PROC
;;;107    
;;;108    void I2C_MasterInit(I2C_Type *base, const i2c_master_config_t *masterConfig, uint32_t srcClock_Hz)
000000  b570              PUSH     {r4-r6,lr}
;;;109    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;110        FLEXCOMM_Init(base, FLEXCOMM_PERIPH_I2C);
000008  2103              MOVS     r1,#3
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       FLEXCOMM_Init
;;;111        I2C_MasterEnable(base, masterConfig->enableMaster);
000010  7821              LDRB     r1,[r4,#0]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       I2C_MasterEnable
;;;112        I2C_MasterSetBaudRate(base, masterConfig->baudRate_Bps, srcClock_Hz);
000018  4632              MOV      r2,r6
00001a  4628              MOV      r0,r5
00001c  6861              LDR      r1,[r4,#4]
00001e  f7fffffe          BL       I2C_MasterSetBaudRate
;;;113    }
000022  bd70              POP      {r4-r6,pc}
;;;114    
                          ENDP


                          AREA ||i.I2C_MasterReadBlocking||, CODE, READONLY, ALIGN=2

                  I2C_MasterReadBlocking PROC
;;;269    
;;;270    status_t I2C_MasterReadBlocking(I2C_Type *base, void *rxBuff, size_t rxSize, uint32_t flags)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;271    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  469a              MOV      r10,r3
;;;272        uint32_t status = 0;
00000c  2500              MOVS     r5,#0
;;;273        uint32_t master_state;
;;;274        status_t err;
;;;275    
;;;276        uint8_t *buf = (uint8_t *)(rxBuff);
00000e  46b1              MOV      r9,r6
;;;277    
;;;278        assert(rxBuff);
000010  b106              CBZ      r6,|L11.20|
000012  e005              B        |L11.32|
                  |L11.20|
000014  f44f728b          MOV      r2,#0x116
000018  a127              ADR      r1,|L11.184|
00001a  a02d              ADR      r0,|L11.208|
00001c  f7fffffe          BL       __aeabi_assert
                  |L11.32|
;;;279    
;;;280        err = kStatus_Success;
000020  f04f0800          MOV      r8,#0
;;;281        while (rxSize)
000024  e037              B        |L11.150|
                  |L11.38|
;;;282        {
;;;283            status = I2C_PendingStatusWait(base);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       I2C_PendingStatusWait
00002c  4605              MOV      r5,r0
;;;284    
;;;285            if (status & (I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK))
00002e  f0050050          AND      r0,r5,#0x50
000032  b100              CBZ      r0,|L11.54|
;;;286            {
;;;287                break;
000034  e031              B        |L11.154|
                  |L11.54|
;;;288            }
;;;289    
;;;290            master_state = (status & I2C_STAT_MSTSTATE_MASK) >> I2C_STAT_MSTSTATE_SHIFT;
000036  f3c50b42          UBFX     r11,r5,#1,#3
;;;291            switch (master_state)
00003a  f1bb0f01          CMP      r11,#1
00003e  d006              BEQ      |L11.78|
000040  f1bb0f03          CMP      r11,#3
000044  d019              BEQ      |L11.122|
000046  f1bb0f04          CMP      r11,#4
00004a  d11a              BNE      |L11.130|
00004c  e016              B        |L11.124|
                  |L11.78|
;;;292            {
;;;293                case I2C_STAT_MSTCODE_RXREADY:
;;;294                    /* ready to send next byte */
;;;295                    *(buf++) = base->MSTDAT;
00004e  f8d40828          LDR      r0,[r4,#0x828]
000052  f8090b01          STRB     r0,[r9],#1
;;;296                    if (--rxSize)
000056  1e78              SUBS     r0,r7,#1
000058  1e07              SUBS     r7,r0,#0
00005a  d003              BEQ      |L11.100|
;;;297                    {
;;;298                        base->MSTCTL = I2C_MSTCTL_MSTCONTINUE_MASK;
00005c  2001              MOVS     r0,#1
00005e  f8c40820          STR      r0,[r4,#0x820]
000062  e009              B        |L11.120|
                  |L11.100|
;;;299                    }
;;;300                    else
;;;301                    {
;;;302                        if ((flags & kI2C_TransferNoStopFlag) == 0)
000064  f00a0004          AND      r0,r10,#4
000068  b930              CBNZ     r0,|L11.120|
;;;303                        {
;;;304                            /* initiate NAK and stop */
;;;305                            base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
00006a  2004              MOVS     r0,#4
00006c  f8c40820          STR      r0,[r4,#0x820]
;;;306                            status = I2C_PendingStatusWait(base);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       I2C_PendingStatusWait
000076  4605              MOV      r5,r0
                  |L11.120|
;;;307                        }
;;;308                    }
;;;309                    break;
000078  e006              B        |L11.136|
                  |L11.122|
;;;310    
;;;311                case I2C_STAT_MSTCODE_NACKADR:
;;;312                case I2C_STAT_MSTCODE_NACKDAT:
00007a  bf00              NOP      
                  |L11.124|
;;;313                    /* slave nacked the last byte */
;;;314                    err = kStatus_I2C_Nak;
00007c  f640282a          MOV      r8,#0xa2a
;;;315                    break;
000080  e002              B        |L11.136|
                  |L11.130|
;;;316    
;;;317                default:
;;;318                    /* unexpected state */
;;;319                    err = kStatus_I2C_UnexpectedState;
000082  f6402831          MOV      r8,#0xa31
;;;320                    break;
000086  bf00              NOP      
                  |L11.136|
000088  bf00              NOP                            ;309
;;;321            }
;;;322    
;;;323            if (err != kStatus_Success)
00008a  f1b80f00          CMP      r8,#0
00008e  d002              BEQ      |L11.150|
;;;324            {
;;;325                return err;
000090  4640              MOV      r0,r8
                  |L11.146|
;;;326            }
;;;327        }
;;;328    
;;;329        if (status & I2C_STAT_MSTARBLOSS_MASK)
;;;330        {
;;;331            return kStatus_I2C_ArbitrationLost;
;;;332        }
;;;333    
;;;334        if (status & I2C_STAT_MSTSTSTPERR_MASK)
;;;335        {
;;;336            return kStatus_I2C_StartStopError;
;;;337        }
;;;338    
;;;339        return kStatus_Success;
;;;340    }
000092  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.150|
000096  2f00              CMP      r7,#0                 ;281
000098  d1c5              BNE      |L11.38|
                  |L11.154|
00009a  bf00              NOP                            ;287
00009c  f0050010          AND      r0,r5,#0x10           ;329
0000a0  b110              CBZ      r0,|L11.168|
0000a2  f640202d          MOV      r0,#0xa2d             ;331
0000a6  e7f4              B        |L11.146|
                  |L11.168|
0000a8  f0050040          AND      r0,r5,#0x40           ;334
0000ac  b110              CBZ      r0,|L11.180|
0000ae  f44f6023          MOV      r0,#0xa30             ;336
0000b2  e7ee              B        |L11.146|
                  |L11.180|
0000b4  2000              MOVS     r0,#0                 ;339
0000b6  e7ec              B        |L11.146|
;;;341    
                          ENDP

                  |L11.184|
0000b8  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
0000bc  44726976
0000c0  6572735c
0000c4  66736c5f
0000c8  6932632e
0000cc  6300    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L11.208|
0000d0  72784275          DCB      "rxBuff",0
0000d4  666600  
0000d7  00                DCB      0

                          AREA ||i.I2C_MasterRepeatedStart||, CODE, READONLY, ALIGN=1

                  I2C_MasterRepeatedStart PROC
;;;607     */
;;;608    static inline status_t I2C_MasterRepeatedStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
000000  b570              PUSH     {r4-r6,lr}
;;;609    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;610        return I2C_MasterStart(base, address, direction);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_MasterStart
;;;611    }
000012  bd70              POP      {r4-r6,pc}
;;;612    
                          ENDP


                          AREA ||i.I2C_MasterSetBaudRate||, CODE, READONLY, ALIGN=1

                  I2C_MasterSetBaudRate PROC
;;;119    
;;;120    void I2C_MasterSetBaudRate(I2C_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;121    {
000004  4603              MOV      r3,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;122        uint32_t scl, divider;
;;;123        uint32_t best_scl, best_div;
;;;124        uint32_t err, best_err;
;;;125    
;;;126        best_err = 0;
00000a  f04f0c00          MOV      r12,#0
;;;127    
;;;128        for (scl = 9; scl >= 2; scl--)
00000e  2009              MOVS     r0,#9
000010  e021              B        |L13.86|
                  |L13.18|
;;;129        {
;;;130            /* calculated ideal divider value for given scl */
;;;131            divider = srcClock_Hz / (baudRate_Bps * scl * 2u);
000012  fb04f800          MUL      r8,r4,r0
000016  ea4f0848          LSL      r8,r8,#1
00001a  fbb5f1f8          UDIV     r1,r5,r8
;;;132    
;;;133            /* adjust it if it is out of range */
;;;134            divider = (divider > 0x10000u) ? 0x10000 : divider;
00001e  f5b13f80          CMP      r1,#0x10000
000022  d902              BLS      |L13.42|
000024  f44f3880          MOV      r8,#0x10000
000028  e000              B        |L13.44|
                  |L13.42|
00002a  4688              MOV      r8,r1
                  |L13.44|
00002c  4641              MOV      r1,r8
;;;135    
;;;136            /* calculate error */
;;;137            err = srcClock_Hz - (baudRate_Bps * scl * 2u * divider);
00002e  fb04f800          MUL      r8,r4,r0
000032  ea4f0848          LSL      r8,r8,#1
000036  fb085211          MLS      r2,r8,r1,r5
;;;138            if ((err < best_err) || (best_err == 0))
00003a  4562              CMP      r2,r12
00003c  d302              BCC      |L13.68|
00003e  f1bc0f00          CMP      r12,#0
000042  d102              BNE      |L13.74|
                  |L13.68|
;;;139            {
;;;140                best_div = divider;
000044  460f              MOV      r7,r1
;;;141                best_scl = scl;
000046  4606              MOV      r6,r0
;;;142                best_err = err;
000048  4694              MOV      r12,r2
                  |L13.74|
;;;143            }
;;;144    
;;;145            if ((err == 0) || (divider >= 0x10000u))
00004a  b112              CBZ      r2,|L13.82|
00004c  f5b13f80          CMP      r1,#0x10000
000050  d300              BCC      |L13.84|
                  |L13.82|
;;;146            {
;;;147                /* either exact value was found
;;;148                   or divider is at its max (it would even greater in the next iteration for sure) */
;;;149                break;
000052  e002              B        |L13.90|
                  |L13.84|
000054  1e40              SUBS     r0,r0,#1              ;128
                  |L13.86|
000056  2802              CMP      r0,#2                 ;128
000058  d2db              BCS      |L13.18|
                  |L13.90|
00005a  bf00              NOP      
;;;150            }
;;;151        }
;;;152    
;;;153        base->CLKDIV = I2C_CLKDIV_DIVVAL(best_div - 1);
00005c  f1a70801          SUB      r8,r7,#1
000060  fa1ff888          UXTH     r8,r8
000064  f8c38814          STR      r8,[r3,#0x814]
;;;154        base->MSTTIME = I2C_MSTTIME_MSTSCLLOW(best_scl - 2u) | I2C_MSTTIME_MSTSCLHIGH(best_scl - 2u);
000068  f1a60802          SUB      r8,r6,#2
00006c  f0080807          AND      r8,r8,#7
000070  f1a60902          SUB      r9,r6,#2
000074  f04f0a70          MOV      r10,#0x70
000078  ea0a1909          AND      r9,r10,r9,LSL #4
00007c  ea480809          ORR      r8,r8,r9
000080  f8c38824          STR      r8,[r3,#0x824]
;;;155    }
000084  e8bd87f0          POP      {r4-r10,pc}
;;;156    
                          ENDP


                          AREA ||i.I2C_MasterStart||, CODE, READONLY, ALIGN=1

                  I2C_MasterStart PROC
;;;171    
;;;172    status_t I2C_MasterStart(I2C_Type *base, uint8_t address, i2c_direction_t direction)
000000  b570              PUSH     {r4-r6,lr}
;;;173    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;174        I2C_PendingStatusWait(base);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       I2C_PendingStatusWait
;;;175    
;;;176        /* Write Address and RW bit to data register */
;;;177        base->MSTDAT = ((uint32_t)address << 1) | ((uint32_t)direction & 1u);
00000e  4630              MOV      r0,r6
000010  f365005f          BFI      r0,r5,#1,#31
000014  f8c40828          STR      r0,[r4,#0x828]
;;;178        /* Start the transfer */
;;;179        base->MSTCTL = I2C_MSTCTL_MSTSTART_MASK;
000018  2002              MOVS     r0,#2
00001a  f8c40820          STR      r0,[r4,#0x820]
;;;180    
;;;181        return kStatus_Success;
00001e  2000              MOVS     r0,#0
;;;182    }
000020  bd70              POP      {r4-r6,pc}
;;;183    
                          ENDP


                          AREA ||i.I2C_MasterStop||, CODE, READONLY, ALIGN=1

                  I2C_MasterStop PROC
;;;183    
;;;184    status_t I2C_MasterStop(I2C_Type *base)
000000  b510              PUSH     {r4,lr}
;;;185    {
000002  4604              MOV      r4,r0
;;;186        I2C_PendingStatusWait(base);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       I2C_PendingStatusWait
;;;187    
;;;188        base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
00000a  2004              MOVS     r0,#4
00000c  f8c40820          STR      r0,[r4,#0x820]
;;;189        return kStatus_Success;
000010  2000              MOVS     r0,#0
;;;190    }
000012  bd10              POP      {r4,pc}
;;;191    
                          ENDP


                          AREA ||i.I2C_MasterTransferAbort||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransferAbort PROC
;;;484    
;;;485    void I2C_MasterTransferAbort(I2C_Type *base, i2c_master_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;486    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;487        uint32_t status;
;;;488        uint32_t master_state;
;;;489    
;;;490        if (handle->state != kIdleState)
000008  7820              LDRB     r0,[r4,#0]
00000a  b190              CBZ      r0,|L16.50|
;;;491        {
;;;492            /* Disable internal IRQ enables. */
;;;493            I2C_DisableInterrupts(base, kI2C_MasterIrqFlags);
00000c  2151              MOVS     r1,#0x51
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       I2C_DisableInterrupts
;;;494    
;;;495            /* Wait until module is ready */
;;;496            status = I2C_PendingStatusWait(base);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       I2C_PendingStatusWait
00001a  4605              MOV      r5,r0
;;;497    
;;;498            /* Get the state of the I2C module */
;;;499            master_state = (status & I2C_STAT_MSTSTATE_MASK) >> I2C_STAT_MSTSTATE_SHIFT;
00001c  f3c50742          UBFX     r7,r5,#1,#3
;;;500    
;;;501            if (master_state != I2C_STAT_MSTCODE_IDLE)
000020  b12f              CBZ      r7,|L16.46|
;;;502            {
;;;503                /* Send a stop command to finalize the transfer. */
;;;504                base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
000022  2004              MOVS     r0,#4
000024  f8c60820          STR      r0,[r6,#0x820]
;;;505    
;;;506                /* Wait until the STOP is completed */
;;;507                I2C_PendingStatusWait(base);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       I2C_PendingStatusWait
                  |L16.46|
;;;508            }
;;;509    
;;;510            /* Reset handle. */
;;;511            handle->state = kIdleState;
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
                  |L16.50|
;;;512        }
;;;513    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;514    
                          ENDP


                          AREA ||i.I2C_MasterTransferBlocking||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferBlocking PROC
;;;341    
;;;342    status_t I2C_MasterTransferBlocking(I2C_Type *base, i2c_master_transfer_t *xfer)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;343    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
;;;344        status_t result = kStatus_Success;
000008  2500              MOVS     r5,#0
;;;345        uint32_t subaddress;
;;;346        uint8_t subaddrBuf[4];
;;;347        int i;
;;;348    
;;;349        assert(xfer);
00000a  b104              CBZ      r4,|L17.14|
00000c  e005              B        |L17.26|
                  |L17.14|
00000e  f240125d          MOV      r2,#0x15d
000012  a132              ADR      r1,|L17.220|
000014  a037              ADR      r0,|L17.244|
000016  f7fffffe          BL       __aeabi_assert
                  |L17.26|
;;;350    
;;;351        /* If repeated start is requested, send repeated start. */
;;;352        if (!(xfer->flags & kI2C_TransferNoStartFlag))
00001a  7820              LDRB     r0,[r4,#0]
00001c  f0000001          AND      r0,r0,#1
000020  2800              CMP      r0,#0
000022  d137              BNE      |L17.148|
;;;353        {
;;;354            if (xfer->subaddressSize)
000024  68e0              LDR      r0,[r4,#0xc]
000026  b320              CBZ      r0,|L17.114|
;;;355            {
;;;356                result = I2C_MasterStart(base, xfer->slaveAddress, kI2C_Write);
000028  7921              LDRB     r1,[r4,#4]
00002a  2200              MOVS     r2,#0
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       I2C_MasterStart
000032  4605              MOV      r5,r0
;;;357                if (result == kStatus_Success)
000034  2d00              CMP      r5,#0
000036  d12d              BNE      |L17.148|
;;;358                {
;;;359                    /* Prepare subaddress transmit buffer, most significant byte is stored at the lowest address */
;;;360                    subaddress = xfer->subaddress;
000038  68a7              LDR      r7,[r4,#8]
;;;361                    for (i = xfer->subaddressSize - 1; i >= 0; i--)
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  1e46              SUBS     r6,r0,#1
00003e  e004              B        |L17.74|
                  |L17.64|
;;;362                    {
;;;363                        subaddrBuf[i] = subaddress & 0xff;
000040  b2f8              UXTB     r0,r7
000042  f80d0006          STRB     r0,[sp,r6]
;;;364                        subaddress >>= 8;
000046  0a3f              LSRS     r7,r7,#8
000048  1e76              SUBS     r6,r6,#1              ;361
                  |L17.74|
00004a  2e00              CMP      r6,#0                 ;361
00004c  daf8              BGE      |L17.64|
;;;365                    }
;;;366                    /* Send subaddress. */
;;;367                    result = I2C_MasterWriteBlocking(base, subaddrBuf, xfer->subaddressSize, kI2C_TransferNoStopFlag);
00004e  2304              MOVS     r3,#4
000050  4669              MOV      r1,sp
000052  4640              MOV      r0,r8
000054  68e2              LDR      r2,[r4,#0xc]
000056  f7fffffe          BL       I2C_MasterWriteBlocking
00005a  4605              MOV      r5,r0
;;;368                    if ((result == kStatus_Success) && (xfer->direction == kI2C_Read))
00005c  b9d5              CBNZ     r5,|L17.148|
00005e  79a0              LDRB     r0,[r4,#6]
000060  2801              CMP      r0,#1
000062  d117              BNE      |L17.148|
;;;369                    {
;;;370                        result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, xfer->direction);
000064  79a2              LDRB     r2,[r4,#6]
000066  7921              LDRB     r1,[r4,#4]
000068  4640              MOV      r0,r8
00006a  f7fffffe          BL       I2C_MasterRepeatedStart
00006e  4605              MOV      r5,r0
000070  e010              B        |L17.148|
                  |L17.114|
;;;371                    }
;;;372                }
;;;373            }
;;;374            else if (xfer->flags & kI2C_TransferRepeatedStartFlag)
000072  7820              LDRB     r0,[r4,#0]
000074  f0000002          AND      r0,r0,#2
000078  b130              CBZ      r0,|L17.136|
;;;375            {
;;;376                result = I2C_MasterRepeatedStart(base, xfer->slaveAddress, xfer->direction);
00007a  79a2              LDRB     r2,[r4,#6]
00007c  7921              LDRB     r1,[r4,#4]
00007e  4640              MOV      r0,r8
000080  f7fffffe          BL       I2C_MasterRepeatedStart
000084  4605              MOV      r5,r0
000086  e005              B        |L17.148|
                  |L17.136|
;;;377            }
;;;378            else
;;;379            {
;;;380                result = I2C_MasterStart(base, xfer->slaveAddress, xfer->direction);
000088  79a2              LDRB     r2,[r4,#6]
00008a  7921              LDRB     r1,[r4,#4]
00008c  4640              MOV      r0,r8
00008e  f7fffffe          BL       I2C_MasterStart
000092  4605              MOV      r5,r0
                  |L17.148|
;;;381            }
;;;382        }
;;;383    
;;;384        if (result == kStatus_Success)
000094  b9bd              CBNZ     r5,|L17.198|
;;;385        {
;;;386            if ((xfer->direction == kI2C_Write) && (xfer->dataSize > 0))
000096  79a0              LDRB     r0,[r4,#6]
000098  b948              CBNZ     r0,|L17.174|
00009a  6960              LDR      r0,[r4,#0x14]
00009c  b138              CBZ      r0,|L17.174|
;;;387            {
;;;388                /* Transmit data. */
;;;389                result = I2C_MasterWriteBlocking(base, xfer->data, xfer->dataSize, xfer->flags);
00009e  4640              MOV      r0,r8
0000a0  6823              LDR      r3,[r4,#0]
0000a2  e9d41204          LDRD     r1,r2,[r4,#0x10]
0000a6  f7fffffe          BL       I2C_MasterWriteBlocking
0000aa  4605              MOV      r5,r0
0000ac  e00b              B        |L17.198|
                  |L17.174|
;;;390            }
;;;391            else
;;;392            {
;;;393                if ((xfer->direction == kI2C_Read) && (xfer->dataSize > 0))
0000ae  79a0              LDRB     r0,[r4,#6]
0000b0  2801              CMP      r0,#1
0000b2  d108              BNE      |L17.198|
0000b4  6960              LDR      r0,[r4,#0x14]
0000b6  b130              CBZ      r0,|L17.198|
;;;394                {
;;;395                    /* Receive Data. */
;;;396                    result = I2C_MasterReadBlocking(base, xfer->data, xfer->dataSize, xfer->flags);
0000b8  4640              MOV      r0,r8
0000ba  6823              LDR      r3,[r4,#0]
0000bc  e9d41204          LDRD     r1,r2,[r4,#0x10]
0000c0  f7fffffe          BL       I2C_MasterReadBlocking
0000c4  4605              MOV      r5,r0
                  |L17.198|
;;;397                }
;;;398            }
;;;399        }
;;;400    
;;;401        if (result == kStatus_I2C_Nak)
0000c6  f640202a          MOV      r0,#0xa2a
0000ca  4285              CMP      r5,r0
0000cc  d102              BNE      |L17.212|
;;;402        {
;;;403            I2C_MasterStop(base);
0000ce  4640              MOV      r0,r8
0000d0  f7fffffe          BL       I2C_MasterStop
                  |L17.212|
;;;404        }
;;;405    
;;;406        return result;
0000d4  4628              MOV      r0,r5
;;;407    }
0000d6  e8bd83f8          POP      {r3-r9,pc}
;;;408    
                          ENDP

0000da  0000              DCW      0x0000
                  |L17.220|
0000dc  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
0000e0  44726976
0000e4  6572735c
0000e8  66736c5f
0000ec  6932632e
0000f0  6300    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L17.244|
0000f4  78666572          DCB      "xfer",0
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0

                          AREA ||i.I2C_MasterTransferCreateHandle||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferCreateHandle PROC
;;;408    
;;;409    void I2C_MasterTransferCreateHandle(I2C_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;410                                        i2c_master_handle_t *handle,
;;;411                                        i2c_master_transfer_callback_t callback,
;;;412                                        void *userData)
;;;413    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;414        uint32_t instance;
;;;415    
;;;416        assert(handle);
00000c  b104              CBZ      r4,|L18.16|
00000e  e005              B        |L18.28|
                  |L18.16|
000010  f44f72d0          MOV      r2,#0x1a0
000014  a10e              ADR      r1,|L18.80|
000016  a014              ADR      r0,|L18.104|
000018  f7fffffe          BL       __aeabi_assert
                  |L18.28|
;;;417    
;;;418        /* Clear out the handle. */
;;;419        memset(handle, 0, sizeof(*handle));
00001c  2138              MOVS     r1,#0x38
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memclr4
;;;420    
;;;421        /* Look up instance number */
;;;422        instance = I2C_GetInstance(base);
000024  4640              MOV      r0,r8
000026  f7fffffe          BL       I2C_GetInstance
00002a  4607              MOV      r7,r0
;;;423    
;;;424        /* Save base and instance. */
;;;425        handle->completionCallback = callback;
00002c  6325              STR      r5,[r4,#0x30]
;;;426        handle->userData = userData;
00002e  6366              STR      r6,[r4,#0x34]
;;;427    
;;;428        FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)I2C_MasterTransferHandleIRQ, handle);
000030  4622              MOV      r2,r4
000032  490f              LDR      r1,|L18.112|
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       FLEXCOMM_SetIRQHandler
;;;429    
;;;430        /* Clear internal IRQ enables and enable NVIC IRQ. */
;;;431        I2C_DisableInterrupts(base, kI2C_MasterIrqFlags);
00003a  2151              MOVS     r1,#0x51
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       I2C_DisableInterrupts
;;;432        EnableIRQ(s_i2cIRQ[instance]);
000042  490c              LDR      r1,|L18.116|
000044  57c8              LDRSB    r0,[r1,r7]
000046  f7fffffe          BL       EnableIRQ
;;;433    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;434    
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
000050  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
000054  44726976
000058  6572735c
00005c  66736c5f
000060  6932632e
000064  6300    
000066  00                DCB      0
000067  00                DCB      0
                  |L18.104|
000068  68616e64          DCB      "handle",0
00006c  6c6500  
00006f  00                DCB      0
                  |L18.112|
                          DCD      I2C_MasterTransferHandleIRQ
                  |L18.116|
                          DCD      s_i2cIRQ

                          AREA ||i.I2C_MasterTransferGetCount||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferGetCount PROC
;;;463    
;;;464    status_t I2C_MasterTransferGetCount(I2C_Type *base, i2c_master_handle_t *handle, size_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;465    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;466        assert(handle);
000008  b104              CBZ      r4,|L19.12|
00000a  e005              B        |L19.24|
                  |L19.12|
00000c  f44f72e9          MOV      r2,#0x1d2
000010  a108              ADR      r1,|L19.52|
000012  a00e              ADR      r0,|L19.76|
000014  f7fffffe          BL       __aeabi_assert
                  |L19.24|
;;;467    
;;;468        if (!count)
000018  b90d              CBNZ     r5,|L19.30|
;;;469        {
;;;470            return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L19.28|
;;;471        }
;;;472    
;;;473        /* Catch when there is not an active transfer. */
;;;474        if (handle->state == kIdleState)
;;;475        {
;;;476            *count = 0;
;;;477            return kStatus_NoTransferInProgress;
;;;478        }
;;;479    
;;;480        /* There is no necessity to disable interrupts as we read a single integer value */
;;;481        *count = handle->transferCount;
;;;482        return kStatus_Success;
;;;483    }
00001c  bd70              POP      {r4-r6,pc}
                  |L19.30|
00001e  7820              LDRB     r0,[r4,#0]            ;474
000020  b918              CBNZ     r0,|L19.42|
000022  2000              MOVS     r0,#0                 ;476
000024  6028              STR      r0,[r5,#0]            ;476
000026  2006              MOVS     r0,#6                 ;477
000028  e7f8              B        |L19.28|
                  |L19.42|
00002a  6860              LDR      r0,[r4,#4]            ;481
00002c  6028              STR      r0,[r5,#0]            ;481
00002e  2000              MOVS     r0,#0                 ;482
000030  e7f4              B        |L19.28|
;;;484    
                          ENDP

000032  0000              DCW      0x0000
                  |L19.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  6932632e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L19.76|
00004c  68616e64          DCB      "handle",0
000050  6c6500  
000053  00                DCB      0

                          AREA ||i.I2C_MasterTransferHandleIRQ||, CODE, READONLY, ALIGN=1

                  I2C_MasterTransferHandleIRQ PROC
;;;739    
;;;740    void I2C_MasterTransferHandleIRQ(I2C_Type *base, i2c_master_handle_t *handle)
000000  b5f8              PUSH     {r3-r7,lr}
;;;741    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;742        bool isDone;
;;;743        status_t result;
;;;744    
;;;745        /* Don't do anything if we don't have a valid handle. */
;;;746        if (!handle)
000006  b904              CBNZ     r4,|L20.10|
                  |L20.8|
;;;747        {
;;;748            return;
;;;749        }
;;;750    
;;;751        result = I2C_RunTransferStateMachine(base, handle, &isDone);
;;;752    
;;;753        if (isDone || (result != kStatus_Success))
;;;754        {
;;;755            /* Disable internal IRQ enables. */
;;;756            I2C_DisableInterrupts(base, kI2C_MasterIrqFlags);
;;;757    
;;;758            /* Invoke callback. */
;;;759            if (handle->completionCallback)
;;;760            {
;;;761                handle->completionCallback(base, handle, result, handle->userData);
;;;762            }
;;;763        }
;;;764    }
000008  bdf8              POP      {r3-r7,pc}
                  |L20.10|
00000a  466a              MOV      r2,sp                 ;751
00000c  4621              MOV      r1,r4                 ;751
00000e  4630              MOV      r0,r6                 ;751
000010  f7fffffe          BL       I2C_RunTransferStateMachine
000014  4605              MOV      r5,r0                 ;751
000016  f89d0000          LDRB     r0,[sp,#0]            ;753
00001a  b900              CBNZ     r0,|L20.30|
00001c  b15d              CBZ      r5,|L20.54|
                  |L20.30|
00001e  2151              MOVS     r1,#0x51              ;756
000020  4630              MOV      r0,r6                 ;756
000022  f7fffffe          BL       I2C_DisableInterrupts
000026  6b20              LDR      r0,[r4,#0x30]         ;759
000028  b128              CBZ      r0,|L20.54|
00002a  462a              MOV      r2,r5                 ;761
00002c  4621              MOV      r1,r4                 ;761
00002e  4630              MOV      r0,r6                 ;761
000030  e9d4730c          LDRD     r7,r3,[r4,#0x30]      ;761
000034  47b8              BLX      r7                    ;761
                  |L20.54|
000036  bf00              NOP      
000038  e7e6              B        |L20.8|
;;;765    
                          ENDP


                          AREA ||i.I2C_MasterTransferNonBlocking||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferNonBlocking PROC
;;;434    
;;;435    status_t I2C_MasterTransferNonBlocking(I2C_Type *base, i2c_master_handle_t *handle, i2c_master_transfer_t *xfer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;436    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;437        status_t result;
;;;438    
;;;439        assert(handle);
00000a  b104              CBZ      r4,|L21.14|
00000c  e005              B        |L21.26|
                  |L21.14|
00000e  f24012b7          MOV      r2,#0x1b7
000012  a118              ADR      r1,|L21.116|
000014  a01d              ADR      r0,|L21.140|
000016  f7fffffe          BL       __aeabi_assert
                  |L21.26|
;;;440        assert(xfer);
00001a  b105              CBZ      r5,|L21.30|
00001c  e005              B        |L21.42|
                  |L21.30|
00001e  f44f72dc          MOV      r2,#0x1b8
000022  a114              ADR      r1,|L21.116|
000024  a01b              ADR      r0,|L21.148|
000026  f7fffffe          BL       __aeabi_assert
                  |L21.42|
;;;441        assert(xfer->subaddressSize <= sizeof(xfer->subaddress));
00002a  68e8              LDR      r0,[r5,#0xc]
00002c  2804              CMP      r0,#4
00002e  d800              BHI      |L21.50|
000030  e005              B        |L21.62|
                  |L21.50|
000032  f24012b9          MOV      r2,#0x1b9
000036  a10f              ADR      r1,|L21.116|
000038  a018              ADR      r0,|L21.156|
00003a  f7fffffe          BL       __aeabi_assert
                  |L21.62|
;;;442    
;;;443        /* Return busy if another transaction is in progress. */
;;;444        if (handle->state != kIdleState)
00003e  7820              LDRB     r0,[r4,#0]
000040  b118              CBZ      r0,|L21.74|
;;;445        {
;;;446            return kStatus_I2C_Busy;
000042  f6402028          MOV      r0,#0xa28
                  |L21.70|
;;;447        }
;;;448    
;;;449        /* Disable I2C IRQ sources while we configure stuff. */
;;;450        I2C_DisableInterrupts(base, kI2C_MasterIrqFlags);
;;;451    
;;;452        /* Prepare transfer state machine. */
;;;453        result = I2C_InitTransferStateMachine(base, handle, xfer);
;;;454    
;;;455        /* Clear error flags. */
;;;456        I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
;;;457    
;;;458        /* Enable I2C internal IRQ sources. */
;;;459        I2C_EnableInterrupts(base, kI2C_MasterIrqFlags);
;;;460    
;;;461        return result;
;;;462    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L21.74|
00004a  2151              MOVS     r1,#0x51              ;450
00004c  4630              MOV      r0,r6                 ;450
00004e  f7fffffe          BL       I2C_DisableInterrupts
000052  462a              MOV      r2,r5                 ;453
000054  4621              MOV      r1,r4                 ;453
000056  4630              MOV      r0,r6                 ;453
000058  f7fffffe          BL       I2C_InitTransferStateMachine
00005c  4607              MOV      r7,r0                 ;453
00005e  2150              MOVS     r1,#0x50              ;456
000060  4630              MOV      r0,r6                 ;456
000062  f7fffffe          BL       I2C_MasterClearStatusFlags
000066  2151              MOVS     r1,#0x51              ;459
000068  4630              MOV      r0,r6                 ;459
00006a  f7fffffe          BL       I2C_EnableInterrupts
00006e  4638              MOV      r0,r7                 ;461
000070  e7e9              B        |L21.70|
;;;463    
                          ENDP

000072  0000              DCW      0x0000
                  |L21.116|
000074  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
000078  44726976
00007c  6572735c
000080  66736c5f
000084  6932632e
000088  6300    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L21.140|
00008c  68616e64          DCB      "handle",0
000090  6c6500  
000093  00                DCB      0
                  |L21.148|
000094  78666572          DCB      "xfer",0
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L21.156|
00009c  78666572          DCB      "xfer->subaddressSize <= sizeof(xfer->subaddress)",0
0000a0  2d3e7375
0000a4  62616464
0000a8  72657373
0000ac  53697a65
0000b0  203c3d20
0000b4  73697a65
0000b8  6f662878
0000bc  6665722d
0000c0  3e737562
0000c4  61646472
0000c8  65737329
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.I2C_MasterWriteBlocking||, CODE, READONLY, ALIGN=2

                  I2C_MasterWriteBlocking PROC
;;;191    
;;;192    status_t I2C_MasterWriteBlocking(I2C_Type *base, const void *txBuff, size_t txSize, uint32_t flags)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;193    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  469a              MOV      r10,r3
;;;194        uint32_t status;
;;;195        uint32_t master_state;
;;;196        status_t err;
;;;197    
;;;198        const uint8_t *buf = (const uint8_t *)(uintptr_t)txBuff;
00000c  46b1              MOV      r9,r6
;;;199    
;;;200        assert(txBuff);
00000e  b106              CBZ      r6,|L22.18|
000010  e004              B        |L22.28|
                  |L22.18|
000012  22c8              MOVS     r2,#0xc8
000014  a12d              ADR      r1,|L22.204|
000016  a033              ADR      r0,|L22.228|
000018  f7fffffe          BL       __aeabi_assert
                  |L22.28|
;;;201    
;;;202        err = kStatus_Success;
00001c  f04f0800          MOV      r8,#0
;;;203        while (txSize)
000020  e032              B        |L22.136|
                  |L22.34|
;;;204        {
;;;205            status = I2C_PendingStatusWait(base);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       I2C_PendingStatusWait
000028  4604              MOV      r4,r0
;;;206    
;;;207            if (status & I2C_STAT_MSTARBLOSS_MASK)
00002a  f0040010          AND      r0,r4,#0x10
00002e  b118              CBZ      r0,|L22.56|
;;;208            {
;;;209                return kStatus_I2C_ArbitrationLost;
000030  f640202d          MOV      r0,#0xa2d
                  |L22.52|
;;;210            }
;;;211    
;;;212            if (status & I2C_STAT_MSTSTSTPERR_MASK)
;;;213            {
;;;214                return kStatus_I2C_StartStopError;
;;;215            }
;;;216    
;;;217            master_state = (status & I2C_STAT_MSTSTATE_MASK) >> I2C_STAT_MSTSTATE_SHIFT;
;;;218            switch (master_state)
;;;219            {
;;;220                case I2C_STAT_MSTCODE_TXREADY:
;;;221                    /* ready to send next byte */
;;;222                    base->MSTDAT = *buf++;
;;;223                    txSize--;
;;;224                    base->MSTCTL = I2C_MSTCTL_MSTCONTINUE_MASK;
;;;225                    break;
;;;226    
;;;227                case I2C_STAT_MSTCODE_NACKADR:
;;;228                case I2C_STAT_MSTCODE_NACKDAT:
;;;229                    /* slave nacked the last byte */
;;;230                    err = kStatus_I2C_Nak;
;;;231                    break;
;;;232    
;;;233                default:
;;;234                    /* unexpected state */
;;;235                    err = kStatus_I2C_UnexpectedState;
;;;236                    break;
;;;237            }
;;;238    
;;;239            if (err != kStatus_Success)
;;;240            {
;;;241                return err;
;;;242            }
;;;243        }
;;;244    
;;;245        status = I2C_PendingStatusWait(base);
;;;246    
;;;247        if ((status & (I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK)) == 0)
;;;248        {
;;;249            if (!(flags & kI2C_TransferNoStopFlag))
;;;250            {
;;;251                /* Initiate stop */
;;;252                base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;253                status = I2C_PendingStatusWait(base);
;;;254            }
;;;255        }
;;;256    
;;;257        if (status & I2C_STAT_MSTARBLOSS_MASK)
;;;258        {
;;;259            return kStatus_I2C_ArbitrationLost;
;;;260        }
;;;261    
;;;262        if (status & I2C_STAT_MSTSTSTPERR_MASK)
;;;263        {
;;;264            return kStatus_I2C_StartStopError;
;;;265        }
;;;266    
;;;267        return kStatus_Success;
;;;268    }
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L22.56|
000038  f0040040          AND      r0,r4,#0x40           ;212
00003c  b110              CBZ      r0,|L22.68|
00003e  f44f6023          MOV      r0,#0xa30             ;214
000042  e7f7              B        |L22.52|
                  |L22.68|
000044  f3c40b42          UBFX     r11,r4,#1,#3          ;217
000048  f1bb0f02          CMP      r11,#2                ;218
00004c  d006              BEQ      |L22.92|
00004e  f1bb0f03          CMP      r11,#3                ;218
000052  d00c              BEQ      |L22.110|
000054  f1bb0f04          CMP      r11,#4                ;218
000058  d10d              BNE      |L22.118|
00005a  e009              B        |L22.112|
                  |L22.92|
00005c  f8190b01          LDRB     r0,[r9],#1            ;222
000060  f8c50828          STR      r0,[r5,#0x828]        ;222
000064  1e7f              SUBS     r7,r7,#1              ;223
000066  2001              MOVS     r0,#1                 ;224
000068  f8c50820          STR      r0,[r5,#0x820]        ;224
00006c  e006              B        |L22.124|
                  |L22.110|
00006e  bf00              NOP                            ;228
                  |L22.112|
000070  f640282a          MOV      r8,#0xa2a             ;230
000074  e002              B        |L22.124|
                  |L22.118|
000076  f6402831          MOV      r8,#0xa31             ;235
00007a  bf00              NOP                            ;236
                  |L22.124|
00007c  bf00              NOP                            ;225
00007e  f1b80f00          CMP      r8,#0                 ;239
000082  d001              BEQ      |L22.136|
000084  4640              MOV      r0,r8                 ;241
000086  e7d5              B        |L22.52|
                  |L22.136|
000088  2f00              CMP      r7,#0                 ;203
00008a  d1ca              BNE      |L22.34|
00008c  4628              MOV      r0,r5                 ;245
00008e  f7fffffe          BL       I2C_PendingStatusWait
000092  4604              MOV      r4,r0                 ;245
000094  f0040050          AND      r0,r4,#0x50           ;247
000098  b948              CBNZ     r0,|L22.174|
00009a  f00a0004          AND      r0,r10,#4             ;249
00009e  b930              CBNZ     r0,|L22.174|
0000a0  2004              MOVS     r0,#4                 ;252
0000a2  f8c50820          STR      r0,[r5,#0x820]        ;252
0000a6  4628              MOV      r0,r5                 ;253
0000a8  f7fffffe          BL       I2C_PendingStatusWait
0000ac  4604              MOV      r4,r0                 ;253
                  |L22.174|
0000ae  f0040010          AND      r0,r4,#0x10           ;257
0000b2  b110              CBZ      r0,|L22.186|
0000b4  f640202d          MOV      r0,#0xa2d             ;259
0000b8  e7bc              B        |L22.52|
                  |L22.186|
0000ba  f0040040          AND      r0,r4,#0x40           ;262
0000be  b110              CBZ      r0,|L22.198|
0000c0  f44f6023          MOV      r0,#0xa30             ;264
0000c4  e7b6              B        |L22.52|
                  |L22.198|
0000c6  2000              MOVS     r0,#0                 ;267
0000c8  e7b4              B        |L22.52|
;;;269    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L22.204|
0000cc  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
0000d0  44726976
0000d4  6572735c
0000d8  66736c5f
0000dc  6932632e
0000e0  6300    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L22.228|
0000e4  74784275          DCB      "txBuff",0
0000e8  666600  
0000eb  00                DCB      0

                          AREA ||i.I2C_PendingStatusWait||, CODE, READONLY, ALIGN=1

                  I2C_PendingStatusWait PROC
;;;156    
;;;157    static uint32_t I2C_PendingStatusWait(I2C_Type *base)
000000  b570              PUSH     {r4-r6,lr}
;;;158    {
000002  4605              MOV      r5,r0
;;;159        uint32_t status;
;;;160    
;;;161        do
000004  bf00              NOP      
                  |L23.6|
;;;162        {
;;;163            status = I2C_GetStatusFlags(base);
000006  bf00              NOP      
000008  f8d54804          LDR      r4,[r5,#0x804]
00000c  bf00              NOP      
;;;164        } while ((status & I2C_STAT_MSTPENDING_MASK) == 0);
00000e  f0040001          AND      r0,r4,#1
000012  2800              CMP      r0,#0
000014  d0f7              BEQ      |L23.6|
;;;165    
;;;166        /* Clear controller state. */
;;;167        I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK | I2C_STAT_MSTSTSTPERR_MASK);
000016  2150              MOVS     r1,#0x50
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       I2C_MasterClearStatusFlags
;;;168    
;;;169        return status;
00001e  4620              MOV      r0,r4
;;;170    }
000020  bd70              POP      {r4-r6,pc}
;;;171    
                          ENDP


                          AREA ||i.I2C_RunTransferStateMachine||, CODE, READONLY, ALIGN=1

                  I2C_RunTransferStateMachine PROC
;;;585     */
;;;586    static status_t I2C_RunTransferStateMachine(I2C_Type *base, i2c_master_handle_t *handle, bool *isDone)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;587    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;588        uint32_t status;
;;;589        uint32_t master_state;
;;;590        struct _i2c_master_transfer *transfer;
;;;591        status_t err;
;;;592    
;;;593        transfer = &(handle->transfer);
00000a  f1040718          ADD      r7,r4,#0x18
;;;594    
;;;595        *isDone = false;
00000e  2000              MOVS     r0,#0
000010  f8880000          STRB     r0,[r8,#0]
;;;596    
;;;597        status = I2C_GetStatusFlags(base);
000014  bf00              NOP      
000016  f8d50804          LDR      r0,[r5,#0x804]
00001a  4681              MOV      r9,r0
;;;598    
;;;599        if (status & I2C_STAT_MSTARBLOSS_MASK)
00001c  f0090010          AND      r0,r9,#0x10
000020  b138              CBZ      r0,|L24.50|
;;;600        {
;;;601            I2C_MasterClearStatusFlags(base, I2C_STAT_MSTARBLOSS_MASK);
000022  2110              MOVS     r1,#0x10
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       I2C_MasterClearStatusFlags
;;;602            return kStatus_I2C_ArbitrationLost;
00002a  f640202d          MOV      r0,#0xa2d
                  |L24.46|
;;;603        }
;;;604    
;;;605        if (status & I2C_STAT_MSTSTSTPERR_MASK)
;;;606        {
;;;607            I2C_MasterClearStatusFlags(base, I2C_STAT_MSTSTSTPERR_MASK);
;;;608            return kStatus_I2C_StartStopError;
;;;609        }
;;;610    
;;;611        if ((status & I2C_STAT_MSTPENDING_MASK) == 0)
;;;612        {
;;;613            return kStatus_I2C_Busy;
;;;614        }
;;;615    
;;;616        /* Get the state of the I2C module */
;;;617        master_state = (status & I2C_STAT_MSTSTATE_MASK) >> I2C_STAT_MSTSTATE_SHIFT;
;;;618    
;;;619        if ((master_state == I2C_STAT_MSTCODE_NACKADR) || (master_state == I2C_STAT_MSTCODE_NACKDAT))
;;;620        {
;;;621            /* Slave NACKed last byte, issue stop and return error */
;;;622            base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;623            handle->state = kWaitForCompletionState;
;;;624            return kStatus_I2C_Nak;
;;;625        }
;;;626    
;;;627        err = kStatus_Success;
;;;628        switch (handle->state)
;;;629        {
;;;630            case kStartState:
;;;631                if (handle->remainingSubaddr)
;;;632                {
;;;633                    /* Subaddress takes precedence over the data transfer, direction is always "write" in this case */
;;;634                    base->MSTDAT = (uint32_t)transfer->slaveAddress << 1;
;;;635                    handle->state = kTransmitSubaddrState;
;;;636                }
;;;637                else if (transfer->direction == kI2C_Write)
;;;638                {
;;;639                    base->MSTDAT = (uint32_t)transfer->slaveAddress << 1;
;;;640                    handle->state = handle->remainingBytes ? kTransmitDataState : kStopState;
;;;641                }
;;;642                else
;;;643                {
;;;644                    base->MSTDAT = ((uint32_t)transfer->slaveAddress << 1) | 1u;
;;;645                    handle->state = handle->remainingBytes ? kReceiveDataState : kStopState;
;;;646                }
;;;647                /* Send start condition */
;;;648                base->MSTCTL = I2C_MSTCTL_MSTSTART_MASK;
;;;649                break;
;;;650    
;;;651            case kTransmitSubaddrState:
;;;652                if (master_state != I2C_STAT_MSTCODE_TXREADY)
;;;653                {
;;;654                    return kStatus_I2C_UnexpectedState;
;;;655                }
;;;656    
;;;657                /* Most significant subaddress byte comes first */
;;;658                base->MSTDAT = handle->subaddrBuf[handle->transfer.subaddressSize - handle->remainingSubaddr];
;;;659                base->MSTCTL = I2C_MSTCTL_MSTCONTINUE_MASK;
;;;660                if (--(handle->remainingSubaddr))
;;;661                {
;;;662                    /* There are still subaddress bytes to be transmitted */
;;;663                    break;
;;;664                }
;;;665                if (handle->remainingBytes)
;;;666                {
;;;667                    /* There is data to be transferred, if there is write to read turnaround it is necessary to perform
;;;668                     * repeated start */
;;;669                    handle->state = (transfer->direction == kI2C_Read) ? kStartState : kTransmitDataState;
;;;670                }
;;;671                else
;;;672                {
;;;673                    /* No more data, schedule stop condition */
;;;674                    handle->state = kStopState;
;;;675                }
;;;676                break;
;;;677    
;;;678            case kTransmitDataState:
;;;679                if (master_state != I2C_STAT_MSTCODE_TXREADY)
;;;680                {
;;;681                    return kStatus_I2C_UnexpectedState;
;;;682                }
;;;683                base->MSTDAT = *(handle->buf)++;
;;;684                base->MSTCTL = I2C_MSTCTL_MSTCONTINUE_MASK;
;;;685                if (--handle->remainingBytes == 0)
;;;686                {
;;;687                    /* No more data, schedule stop condition */
;;;688                    handle->state = kStopState;
;;;689                }
;;;690                handle->transferCount++;
;;;691                break;
;;;692    
;;;693            case kReceiveDataState:
;;;694                if (master_state != I2C_STAT_MSTCODE_RXREADY)
;;;695                {
;;;696                    return kStatus_I2C_UnexpectedState;
;;;697                }
;;;698                *(handle->buf)++ = base->MSTDAT;
;;;699                if (--handle->remainingBytes)
;;;700                {
;;;701                    base->MSTCTL = I2C_MSTCTL_MSTCONTINUE_MASK;
;;;702                }
;;;703                else
;;;704                {
;;;705                    /* No more data expected, issue NACK and STOP right away */
;;;706                    base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;707                    handle->state = kWaitForCompletionState;
;;;708                }
;;;709                handle->transferCount++;
;;;710                break;
;;;711    
;;;712            case kStopState:
;;;713                if (transfer->flags & kI2C_TransferNoStopFlag)
;;;714                {
;;;715                    /* Stop condition is omitted, we are done */
;;;716                    *isDone = true;
;;;717                    handle->state = kIdleState;
;;;718                    break;
;;;719                }
;;;720                /* Send stop condition */
;;;721                base->MSTCTL = I2C_MSTCTL_MSTSTOP_MASK;
;;;722                handle->state = kWaitForCompletionState;
;;;723                break;
;;;724    
;;;725            case kWaitForCompletionState:
;;;726                *isDone = true;
;;;727                handle->state = kIdleState;
;;;728                break;
;;;729    
;;;730            case kIdleState:
;;;731            default:
;;;732                /* State machine shall not be invoked again once it enters the idle state */
;;;733                err = kStatus_I2C_UnexpectedState;
;;;734                break;
;;;735        }
;;;736    
;;;737        return err;
;;;738    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L24.50|
000032  f0090040          AND      r0,r9,#0x40           ;605
000036  b130              CBZ      r0,|L24.70|
000038  2140              MOVS     r1,#0x40              ;607
00003a  4628              MOV      r0,r5                 ;607
00003c  f7fffffe          BL       I2C_MasterClearStatusFlags
000040  f44f6023          MOV      r0,#0xa30             ;608
000044  e7f3              B        |L24.46|
                  |L24.70|
000046  f0090001          AND      r0,r9,#1              ;611
00004a  b910              CBNZ     r0,|L24.82|
00004c  f6402028          MOV      r0,#0xa28             ;613
000050  e7ed              B        |L24.46|
                  |L24.82|
000052  f3c90642          UBFX     r6,r9,#1,#3           ;617
000056  2e03              CMP      r6,#3                 ;619
000058  d001              BEQ      |L24.94|
00005a  2e04              CMP      r6,#4                 ;619
00005c  d107              BNE      |L24.110|
                  |L24.94|
00005e  2004              MOVS     r0,#4                 ;622
000060  f8c50820          STR      r0,[r5,#0x820]        ;622
000064  2007              MOVS     r0,#7                 ;623
000066  7020              STRB     r0,[r4,#0]            ;623
000068  f640202a          MOV      r0,#0xa2a             ;624
00006c  e7df              B        |L24.46|
                  |L24.110|
00006e  f04f0a00          MOV      r10,#0                ;627
000072  7820              LDRB     r0,[r4,#0]            ;628
000074  2808              CMP      r0,#8                 ;628
000076  d279              BCS      |L24.364|
000078  e8dff000          TBB      [pc,r0]               ;628
00007c  992a4c64          DCB      0x99,0x2a,0x4c,0x64
000080  98048292          DCB      0x98,0x04,0x82,0x92
000084  6920              LDR      r0,[r4,#0x10]         ;631
000086  b130              CBZ      r0,|L24.150|
000088  88b8              LDRH     r0,[r7,#4]            ;634
00008a  0040              LSLS     r0,r0,#1              ;634
00008c  f8c50828          STR      r0,[r5,#0x828]        ;634
000090  2001              MOVS     r0,#1                 ;635
000092  7020              STRB     r0,[r4,#0]            ;635
000094  e018              B        |L24.200|
                  |L24.150|
000096  79b8              LDRB     r0,[r7,#6]            ;637
000098  b950              CBNZ     r0,|L24.176|
00009a  88b8              LDRH     r0,[r7,#4]            ;639
00009c  0040              LSLS     r0,r0,#1              ;639
00009e  f8c50828          STR      r0,[r5,#0x828]        ;639
0000a2  68a0              LDR      r0,[r4,#8]            ;640
0000a4  b108              CBZ      r0,|L24.170|
0000a6  2002              MOVS     r0,#2                 ;640
0000a8  e000              B        |L24.172|
                  |L24.170|
0000aa  2006              MOVS     r0,#6                 ;640
                  |L24.172|
0000ac  7020              STRB     r0,[r4,#0]            ;640
0000ae  e00b              B        |L24.200|
                  |L24.176|
0000b0  88b8              LDRH     r0,[r7,#4]            ;644
0000b2  2101              MOVS     r1,#1                 ;644
0000b4  eb010040          ADD      r0,r1,r0,LSL #1       ;644
0000b8  f8c50828          STR      r0,[r5,#0x828]        ;644
0000bc  68a0              LDR      r0,[r4,#8]            ;645
0000be  b108              CBZ      r0,|L24.196|
0000c0  2003              MOVS     r0,#3                 ;645
0000c2  e000              B        |L24.198|
                  |L24.196|
0000c4  2006              MOVS     r0,#6                 ;645
                  |L24.198|
0000c6  7020              STRB     r0,[r4,#0]            ;645
                  |L24.200|
0000c8  2002              MOVS     r0,#2                 ;648
0000ca  f8c50820          STR      r0,[r5,#0x820]        ;648
0000ce  e071              B        |L24.436|
0000d0  2e02              CMP      r6,#2                 ;652
0000d2  d002              BEQ      |L24.218|
0000d4  f6402031          MOV      r0,#0xa31             ;654
0000d8  e7a9              B        |L24.46|
                  |L24.218|
0000da  6921              LDR      r1,[r4,#0x10]         ;658
0000dc  6a60              LDR      r0,[r4,#0x24]         ;658
0000de  1a41              SUBS     r1,r0,r1              ;658
0000e0  f1040014          ADD      r0,r4,#0x14           ;658
0000e4  5c40              LDRB     r0,[r0,r1]            ;658
0000e6  f8c50828          STR      r0,[r5,#0x828]        ;658
0000ea  2001              MOVS     r0,#1                 ;659
0000ec  f8c50820          STR      r0,[r5,#0x820]        ;659
0000f0  6920              LDR      r0,[r4,#0x10]         ;660
0000f2  1e40              SUBS     r0,r0,#1              ;660
0000f4  6120              STR      r0,[r4,#0x10]         ;660
0000f6  b100              CBZ      r0,|L24.250|
0000f8  e05c              B        |L24.436|
                  |L24.250|
0000fa  68a0              LDR      r0,[r4,#8]            ;665
0000fc  b138              CBZ      r0,|L24.270|
0000fe  79b8              LDRB     r0,[r7,#6]            ;669
000100  2801              CMP      r0,#1                 ;669
000102  d101              BNE      |L24.264|
000104  2005              MOVS     r0,#5                 ;669
000106  e000              B        |L24.266|
                  |L24.264|
000108  2002              MOVS     r0,#2                 ;669
                  |L24.266|
00010a  7020              STRB     r0,[r4,#0]            ;669
00010c  e001              B        |L24.274|
                  |L24.270|
00010e  2006              MOVS     r0,#6                 ;674
000110  7020              STRB     r0,[r4,#0]            ;674
                  |L24.274|
000112  e04f              B        |L24.436|
000114  2e02              CMP      r6,#2                 ;679
000116  d002              BEQ      |L24.286|
000118  f6402031          MOV      r0,#0xa31             ;681
00011c  e787              B        |L24.46|
                  |L24.286|
00011e  68e1              LDR      r1,[r4,#0xc]          ;683
000120  1c48              ADDS     r0,r1,#1              ;683
000122  60e0              STR      r0,[r4,#0xc]          ;683
000124  7808              LDRB     r0,[r1,#0]            ;683
000126  f8c50828          STR      r0,[r5,#0x828]        ;683
00012a  2001              MOVS     r0,#1                 ;684
00012c  f8c50820          STR      r0,[r5,#0x820]        ;684
000130  68a0              LDR      r0,[r4,#8]            ;685
000132  1e40              SUBS     r0,r0,#1              ;685
000134  60a0              STR      r0,[r4,#8]            ;685
000136  b908              CBNZ     r0,|L24.316|
000138  2006              MOVS     r0,#6                 ;688
00013a  7020              STRB     r0,[r4,#0]            ;688
                  |L24.316|
00013c  6860              LDR      r0,[r4,#4]            ;690
00013e  1c40              ADDS     r0,r0,#1              ;690
000140  6060              STR      r0,[r4,#4]            ;690
000142  e037              B        |L24.436|
000144  2e01              CMP      r6,#1                 ;694
000146  d002              BEQ      |L24.334|
000148  f6402031          MOV      r0,#0xa31             ;696
00014c  e76f              B        |L24.46|
                  |L24.334|
00014e  f8d50828          LDR      r0,[r5,#0x828]        ;698
000152  b2c1              UXTB     r1,r0                 ;698
000154  68e2              LDR      r2,[r4,#0xc]          ;698
000156  1c50              ADDS     r0,r2,#1              ;698
000158  60e0              STR      r0,[r4,#0xc]          ;698
00015a  7011              STRB     r1,[r2,#0]            ;698
00015c  68a0              LDR      r0,[r4,#8]            ;699
00015e  1e40              SUBS     r0,r0,#1              ;699
000160  60a0              STR      r0,[r4,#8]            ;699
000162  b120              CBZ      r0,|L24.366|
000164  2001              MOVS     r0,#1                 ;701
000166  f8c50820          STR      r0,[r5,#0x820]        ;701
00016a  e005              B        |L24.376|
                  |L24.364|
00016c  e01e              B        |L24.428|
                  |L24.366|
00016e  2004              MOVS     r0,#4                 ;706
000170  f8c50820          STR      r0,[r5,#0x820]        ;706
000174  2007              MOVS     r0,#7                 ;707
000176  7020              STRB     r0,[r4,#0]            ;707
                  |L24.376|
000178  6860              LDR      r0,[r4,#4]            ;709
00017a  1c40              ADDS     r0,r0,#1              ;709
00017c  6060              STR      r0,[r4,#4]            ;709
00017e  e019              B        |L24.436|
000180  7838              LDRB     r0,[r7,#0]            ;713
000182  f0000004          AND      r0,r0,#4              ;713
000186  b128              CBZ      r0,|L24.404|
000188  2001              MOVS     r0,#1                 ;716
00018a  f8880000          STRB     r0,[r8,#0]            ;716
00018e  2000              MOVS     r0,#0                 ;717
000190  7020              STRB     r0,[r4,#0]            ;717
000192  e00f              B        |L24.436|
                  |L24.404|
000194  2004              MOVS     r0,#4                 ;721
000196  f8c50820          STR      r0,[r5,#0x820]        ;721
00019a  2007              MOVS     r0,#7                 ;722
00019c  7020              STRB     r0,[r4,#0]            ;722
00019e  e009              B        |L24.436|
0001a0  2001              MOVS     r0,#1                 ;726
0001a2  f8880000          STRB     r0,[r8,#0]            ;726
0001a6  2000              MOVS     r0,#0                 ;727
0001a8  7020              STRB     r0,[r4,#0]            ;727
0001aa  e003              B        |L24.436|
                  |L24.428|
0001ac  bf00              NOP                            ;730
0001ae  f6402a31          MOV      r10,#0xa31            ;733
0001b2  bf00              NOP                            ;734
                  |L24.436|
0001b4  bf00              NOP                            ;649
0001b6  4650              MOV      r0,r10                ;737
0001b8  e739              B        |L24.46|
;;;739    
                          ENDP


                          AREA ||i.I2C_SlaveAddressIRQ||, CODE, READONLY, ALIGN=1

                  I2C_SlaveAddressIRQ PROC
;;;896     */
;;;897    static bool I2C_SlaveAddressIRQ(I2C_Type *base, i2c_slave_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;898    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;899        uint8_t addressByte0;
;;;900    
;;;901        addressByte0 = (uint8_t)base->SLVDAT;
000006  f8d50844          LDR      r0,[r5,#0x844]
00000a  b2c6              UXTB     r6,r0
;;;902    
;;;903        /* store the matched address */
;;;904        handle->transfer.receivedAddress = addressByte0;
00000c  7166              STRB     r6,[r4,#5]
;;;905    
;;;906        /* R/nW */
;;;907        if (addressByte0 & 1u)
00000e  f0060001          AND      r0,r6,#1
000012  b1a8              CBZ      r0,|L25.64|
;;;908        {
;;;909            /* if we have no data in this transfer, call callback to get new */
;;;910            if ((handle->transfer.txData == NULL) || (handle->transfer.txSize == 0))
000014  6920              LDR      r0,[r4,#0x10]
000016  b108              CBZ      r0,|L25.28|
000018  6960              LDR      r0,[r4,#0x14]
00001a  b920              CBNZ     r0,|L25.38|
                  |L25.28|
;;;911            {
;;;912                I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveTransmitEvent);
00001c  2202              MOVS     r2,#2
00001e  4621              MOV      r1,r4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       I2C_SlaveInvokeEvent
                  |L25.38|
;;;913            }
;;;914    
;;;915            /* NACK if we have no data in this transfer. */
;;;916            if ((handle->transfer.txData == NULL) || (handle->transfer.txSize == 0))
000026  6920              LDR      r0,[r4,#0x10]
000028  b108              CBZ      r0,|L25.46|
00002a  6960              LDR      r0,[r4,#0x14]
00002c  b920              CBNZ     r0,|L25.56|
                  |L25.46|
;;;917            {
;;;918                base->SLVCTL = I2C_SLVCTL_SLVNACK_MASK;
00002e  2002              MOVS     r0,#2
000030  f8c50840          STR      r0,[r5,#0x840]
;;;919                return false;
000034  2000              MOVS     r0,#0
                  |L25.54|
;;;920            }
;;;921    
;;;922            /* master wants to read, so slave transmit is next state */
;;;923            handle->slaveFsm = kI2C_SlaveFsmTransmit;
;;;924        }
;;;925        else
;;;926        {
;;;927            /* if we have no receive buffer in this transfer, call callback to get new */
;;;928            if ((handle->transfer.rxData == NULL) || (handle->transfer.rxSize == 0))
;;;929            {
;;;930                I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveReceiveEvent);
;;;931            }
;;;932    
;;;933            /* NACK if we have no data in this transfer */
;;;934            if ((handle->transfer.rxData == NULL) || (handle->transfer.rxSize == 0))
;;;935            {
;;;936                base->SLVCTL = I2C_SLVCTL_SLVNACK_MASK;
;;;937                return false;
;;;938            }
;;;939    
;;;940            /* master wants write, so slave receive is next state */
;;;941            handle->slaveFsm = kI2C_SlaveFsmReceive;
;;;942        }
;;;943    
;;;944        /* continue transaction */
;;;945        base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
;;;946    
;;;947        return true;
;;;948    }
000036  bd70              POP      {r4-r6,pc}
                  |L25.56|
000038  2003              MOVS     r0,#3                 ;923
00003a  f8840025          STRB     r0,[r4,#0x25]         ;923
00003e  e014              B        |L25.106|
                  |L25.64|
000040  68e0              LDR      r0,[r4,#0xc]          ;928
000042  b108              CBZ      r0,|L25.72|
000044  69a0              LDR      r0,[r4,#0x18]         ;928
000046  b920              CBNZ     r0,|L25.82|
                  |L25.72|
000048  2204              MOVS     r2,#4                 ;930
00004a  4621              MOV      r1,r4                 ;930
00004c  4628              MOV      r0,r5                 ;930
00004e  f7fffffe          BL       I2C_SlaveInvokeEvent
                  |L25.82|
000052  68e0              LDR      r0,[r4,#0xc]          ;934
000054  b108              CBZ      r0,|L25.90|
000056  69a0              LDR      r0,[r4,#0x18]         ;934
000058  b920              CBNZ     r0,|L25.100|
                  |L25.90|
00005a  2002              MOVS     r0,#2                 ;936
00005c  f8c50840          STR      r0,[r5,#0x840]        ;936
000060  2000              MOVS     r0,#0                 ;937
000062  e7e8              B        |L25.54|
                  |L25.100|
000064  2002              MOVS     r0,#2                 ;941
000066  f8840025          STRB     r0,[r4,#0x25]         ;941
                  |L25.106|
00006a  2001              MOVS     r0,#1                 ;945
00006c  f8c50840          STR      r0,[r5,#0x840]        ;945
000070  bf00              NOP                            ;947
000072  e7e0              B        |L25.54|
;;;949    
                          ENDP


                          AREA ||i.I2C_SlaveDeinit||, CODE, READONLY, ALIGN=1

                  I2C_SlaveDeinit PROC
;;;1083   
;;;1084   void I2C_SlaveDeinit(I2C_Type *base)
000000  b510              PUSH     {r4,lr}
;;;1085   {
000002  4604              MOV      r4,r0
;;;1086       I2C_SlaveEnable(base, false);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_SlaveEnable
;;;1087   }
00000c  bd10              POP      {r4,pc}
;;;1088   
                          ENDP


                          AREA ||i.I2C_SlaveDivVal||, CODE, READONLY, ALIGN=2

                  I2C_SlaveDivVal PROC
;;;786     */
;;;787    static status_t I2C_SlaveDivVal(uint32_t srcClock_Hz, i2c_slave_bus_speed_t busSpeed, uint32_t *divVal)
000000  b530              PUSH     {r4,r5,lr}
;;;788    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;789        uint32_t dataSetupTime_ns;
;;;790    
;;;791        switch (busSpeed)
000006  b134              CBZ      r4,|L27.22|
000008  2c01              CMP      r4,#1
00000a  d006              BEQ      |L27.26|
00000c  2c02              CMP      r4,#2
00000e  d006              BEQ      |L27.30|
000010  2c03              CMP      r4,#3
000012  d108              BNE      |L27.38|
000014  e005              B        |L27.34|
                  |L27.22|
;;;792        {
;;;793            case kI2C_SlaveStandardMode:
;;;794                dataSetupTime_ns = 250u;
000016  21fa              MOVS     r1,#0xfa
;;;795                break;
000018  e007              B        |L27.42|
                  |L27.26|
;;;796    
;;;797            case kI2C_SlaveFastMode:
;;;798                dataSetupTime_ns = 100u;
00001a  2164              MOVS     r1,#0x64
;;;799                break;
00001c  e005              B        |L27.42|
                  |L27.30|
;;;800    
;;;801            case kI2C_SlaveFastModePlus:
;;;802                dataSetupTime_ns = 50u;
00001e  2132              MOVS     r1,#0x32
;;;803                break;
000020  e003              B        |L27.42|
                  |L27.34|
;;;804    
;;;805            case kI2C_SlaveHsMode:
;;;806                dataSetupTime_ns = 10u;
000022  210a              MOVS     r1,#0xa
;;;807                break;
000024  e001              B        |L27.42|
                  |L27.38|
;;;808    
;;;809            default:
;;;810                dataSetupTime_ns = 0;
000026  2100              MOVS     r1,#0
;;;811                break;
000028  bf00              NOP      
                  |L27.42|
00002a  bf00              NOP                            ;795
;;;812        }
;;;813    
;;;814        if (0 == dataSetupTime_ns)
00002c  b909              CBNZ     r1,|L27.50|
;;;815        {
;;;816            return kStatus_InvalidArgument;
00002e  2004              MOVS     r0,#4
                  |L27.48|
;;;817        }
;;;818    
;;;819        /* divVal = (sourceClock_Hz / 1000000) * (dataSetupTime_ns / 1000) */
;;;820        *divVal = srcClock_Hz / 1000u;
;;;821        *divVal = (*divVal) * dataSetupTime_ns;
;;;822        *divVal = (*divVal) / 1000000u;
;;;823    
;;;824        if ((*divVal) > I2C_CLKDIV_DIVVAL_MASK)
;;;825        {
;;;826            *divVal = I2C_CLKDIV_DIVVAL_MASK;
;;;827        }
;;;828    
;;;829        return kStatus_Success;
;;;830    }
000030  bd30              POP      {r4,r5,pc}
                  |L27.50|
000032  f44f707a          MOV      r0,#0x3e8             ;820
000036  fbb3f0f0          UDIV     r0,r3,r0              ;820
00003a  6010              STR      r0,[r2,#0]            ;820
00003c  6810              LDR      r0,[r2,#0]            ;821
00003e  4348              MULS     r0,r1,r0              ;821
000040  6010              STR      r0,[r2,#0]            ;821
000042  4d07              LDR      r5,|L27.96|
000044  6810              LDR      r0,[r2,#0]            ;822
000046  fbb0f0f5          UDIV     r0,r0,r5              ;822
00004a  6010              STR      r0,[r2,#0]            ;822
00004c  6810              LDR      r0,[r2,#0]            ;824
00004e  f5b03f80          CMP      r0,#0x10000           ;824
000052  d302              BCC      |L27.90|
000054  f64f70ff          MOV      r0,#0xffff            ;826
000058  6010              STR      r0,[r2,#0]            ;826
                  |L27.90|
00005a  2000              MOVS     r0,#0                 ;829
00005c  e7e8              B        |L27.48|
;;;831    
                          ENDP

00005e  0000              DCW      0x0000
                  |L27.96|
                          DCD      0x000f4240

                          AREA ||i.I2C_SlaveEnable||, CODE, READONLY, ALIGN=1

                  I2C_SlaveEnable PROC
;;;812     */
;;;813    static inline void I2C_SlaveEnable(I2C_Type *base, bool enable)
000000  2202              MOVS     r2,#2
;;;814    {
;;;815        /* Set or clear the SLVEN bit in the CFG register. */
;;;816        base->CFG = I2C_CFG_SLVEN(enable);
000002  ea020241          AND      r2,r2,r1,LSL #1
000006  f8c02800          STR      r2,[r0,#0x800]
;;;817    }
00000a  4770              BX       lr
;;;818    
                          ENDP


                          AREA ||i.I2C_SlaveGetDefaultConfig||, CODE, READONLY, ALIGN=2

                  I2C_SlaveGetDefaultConfig PROC
;;;1032   
;;;1033   void I2C_SlaveGetDefaultConfig(i2c_slave_config_t *slaveConfig)
000000  b53e              PUSH     {r1-r5,lr}
;;;1034   {
000002  4604              MOV      r4,r0
;;;1035       assert(slaveConfig);
000004  b104              CBZ      r4,|L29.8|
000006  e005              B        |L29.20|
                  |L29.8|
000008  f240420b          MOV      r2,#0x40b
00000c  a10c              ADR      r1,|L29.64|
00000e  a012              ADR      r0,|L29.88|
000010  f7fffffe          BL       __aeabi_assert
                  |L29.20|
;;;1036   
;;;1037       i2c_slave_config_t mySlaveConfig = {0};
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
000018  9001              STR      r0,[sp,#4]
00001a  9002              STR      r0,[sp,#8]
;;;1038   
;;;1039       /* default config enables slave address 0 match to general I2C call address zero */
;;;1040       mySlaveConfig.enableSlave = true;
00001c  2001              MOVS     r0,#1
00001e  f88d000b          STRB     r0,[sp,#0xb]
;;;1041       mySlaveConfig.address1.addressDisable = true;
000022  2101              MOVS     r1,#1
000024  f88d1003          STRB     r1,[sp,#3]
;;;1042       mySlaveConfig.address2.addressDisable = true;
000028  f88d1005          STRB     r1,[sp,#5]
;;;1043       mySlaveConfig.address3.addressDisable = true;
00002c  f88d1007          STRB     r1,[sp,#7]
;;;1044   
;;;1045       *slaveConfig = mySlaveConfig;
000030  9800              LDR      r0,[sp,#0]
000032  6020              STR      r0,[r4,#0]
000034  9801              LDR      r0,[sp,#4]
000036  6060              STR      r0,[r4,#4]
000038  9802              LDR      r0,[sp,#8]
00003a  60a0              STR      r0,[r4,#8]
;;;1046   }
00003c  bd3e              POP      {r1-r5,pc}
;;;1047   
                          ENDP

00003e  0000              DCW      0x0000
                  |L29.64|
000040  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
000044  44726976
000048  6572735c
00004c  66736c5f
000050  6932632e
000054  6300    
000056  00                DCB      0
000057  00                DCB      0
                  |L29.88|
000058  736c6176          DCB      "slaveConfig",0
00005c  65436f6e
000060  66696700

                          AREA ||i.I2C_SlaveInit||, CODE, READONLY, ALIGN=1

                  I2C_SlaveInit PROC
;;;1047   
;;;1048   status_t I2C_SlaveInit(I2C_Type *base, const i2c_slave_config_t *slaveConfig, uint32_t srcClock_Hz)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1049   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;1050       status_t status;
;;;1051       uint32_t divVal = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1052   
;;;1053       /* configure data setup time used when slave stretches clock */
;;;1054       status = I2C_SlaveDivVal(srcClock_Hz, slaveConfig->busSpeed, &divVal);
00000c  7aa1              LDRB     r1,[r4,#0xa]
00000e  466a              MOV      r2,sp
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       I2C_SlaveDivVal
000016  4607              MOV      r7,r0
;;;1055       if (kStatus_Success != status)
000018  b10f              CBZ      r7,|L30.30|
;;;1056       {
;;;1057           return status;
00001a  4638              MOV      r0,r7
                  |L30.28|
;;;1058       }
;;;1059   
;;;1060       FLEXCOMM_Init(base, FLEXCOMM_PERIPH_I2C);
;;;1061   
;;;1062       /* I2C Clock Divider register */
;;;1063       base->CLKDIV = divVal;
;;;1064   
;;;1065       /* set Slave address */
;;;1066       I2C_SlaveSetAddress(base, kI2C_SlaveAddressRegister0, slaveConfig->address0.address,
;;;1067                           slaveConfig->address0.addressDisable);
;;;1068       I2C_SlaveSetAddress(base, kI2C_SlaveAddressRegister1, slaveConfig->address1.address,
;;;1069                           slaveConfig->address1.addressDisable);
;;;1070       I2C_SlaveSetAddress(base, kI2C_SlaveAddressRegister2, slaveConfig->address2.address,
;;;1071                           slaveConfig->address2.addressDisable);
;;;1072       I2C_SlaveSetAddress(base, kI2C_SlaveAddressRegister3, slaveConfig->address3.address,
;;;1073                           slaveConfig->address3.addressDisable);
;;;1074   
;;;1075       /* set Slave address 0 qual */
;;;1076       base->SLVQUAL0 = I2C_SLVQUAL0_QUALMODE0(slaveConfig->qualMode) | I2C_SLVQUAL0_SLVQUAL0(slaveConfig->qualAddress);
;;;1077   
;;;1078       /* set Slave enable */
;;;1079       base->CFG = I2C_CFG_SLVEN(slaveConfig->enableSlave);
;;;1080   
;;;1081       return status;
;;;1082   }
00001c  bdf8              POP      {r3-r7,pc}
                  |L30.30|
00001e  2103              MOVS     r1,#3                 ;1060
000020  4628              MOV      r0,r5                 ;1060
000022  f7fffffe          BL       FLEXCOMM_Init
000026  9800              LDR      r0,[sp,#0]            ;1063
000028  f8c50814          STR      r0,[r5,#0x814]        ;1063
00002c  7863              LDRB     r3,[r4,#1]            ;1066
00002e  7822              LDRB     r2,[r4,#0]            ;1066
000030  2100              MOVS     r1,#0                 ;1066
000032  4628              MOV      r0,r5                 ;1066
000034  f7fffffe          BL       I2C_SlaveSetAddress
000038  78e3              LDRB     r3,[r4,#3]            ;1068
00003a  78a2              LDRB     r2,[r4,#2]            ;1068
00003c  2101              MOVS     r1,#1                 ;1068
00003e  4628              MOV      r0,r5                 ;1068
000040  f7fffffe          BL       I2C_SlaveSetAddress
000044  7963              LDRB     r3,[r4,#5]            ;1070
000046  7922              LDRB     r2,[r4,#4]            ;1070
000048  2102              MOVS     r1,#2                 ;1070
00004a  4628              MOV      r0,r5                 ;1070
00004c  f7fffffe          BL       I2C_SlaveSetAddress
000050  79e3              LDRB     r3,[r4,#7]            ;1072
000052  79a2              LDRB     r2,[r4,#6]            ;1072
000054  2103              MOVS     r1,#3                 ;1072
000056  4628              MOV      r0,r5                 ;1072
000058  f7fffffe          BL       I2C_SlaveSetAddress
00005c  7a20              LDRB     r0,[r4,#8]            ;1076
00005e  f0000001          AND      r0,r0,#1              ;1076
000062  7a61              LDRB     r1,[r4,#9]            ;1076
000064  22fe              MOVS     r2,#0xfe              ;1076
000066  ea020141          AND      r1,r2,r1,LSL #1       ;1076
00006a  4308              ORRS     r0,r0,r1              ;1076
00006c  f8c50858          STR      r0,[r5,#0x858]        ;1076
000070  7ae0              LDRB     r0,[r4,#0xb]          ;1079
000072  2102              MOVS     r1,#2                 ;1079
000074  ea010040          AND      r0,r1,r0,LSL #1       ;1079
000078  f8c50800          STR      r0,[r5,#0x800]        ;1079
00007c  4638              MOV      r0,r7                 ;1081
00007e  e7cd              B        |L30.28|
;;;1083   
                          ENDP


                          AREA ||i.I2C_SlaveInternalStateMachineReset||, CODE, READONLY, ALIGN=1

                  I2C_SlaveInternalStateMachineReset PROC
;;;772     */
;;;773    static void I2C_SlaveInternalStateMachineReset(I2C_Type *base)
000000  b510              PUSH     {r4,lr}
;;;774    {
000002  4604              MOV      r4,r0
;;;775        I2C_SlaveEnable(base, false); /* clear SLVEN Slave enable bit */
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_SlaveEnable
;;;776    }
00000c  bd10              POP      {r4,pc}
;;;777    
                          ENDP


                          AREA ||i.I2C_SlaveInvokeEvent||, CODE, READONLY, ALIGN=1

                  I2C_SlaveInvokeEvent PROC
;;;861     */
;;;862    static void I2C_SlaveInvokeEvent(I2C_Type *base, i2c_slave_handle_t *handle, i2c_slave_transfer_event_t event)
000000  b570              PUSH     {r4-r6,lr}
;;;863    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;864        handle->transfer.event = event;
000008  7125              STRB     r5,[r4,#4]
;;;865        if ((handle->callback) && (handle->transfer.eventMask & event))
00000a  6aa0              LDR      r0,[r4,#0x28]
00000c  b1d8              CBZ      r0,|L32.70|
00000e  68a0              LDR      r0,[r4,#8]
000010  4028              ANDS     r0,r0,r5
000012  b1c0              CBZ      r0,|L32.70|
;;;866        {
;;;867            handle->callback(base, &handle->transfer, handle->userData);
000014  4621              MOV      r1,r4
000016  4630              MOV      r0,r6
000018  e9d4320a          LDRD     r3,r2,[r4,#0x28]
00001c  4798              BLX      r3
;;;868    
;;;869            /* if after event callback we have data buffer (callback func has added new data), keep transfer busy */
;;;870            if (false == handle->isBusy)
00001e  f8940024          LDRB     r0,[r4,#0x24]
000022  b950              CBNZ     r0,|L32.58|
;;;871            {
;;;872                if (((handle->transfer.txData) && (handle->transfer.txSize)) ||
000024  6920              LDR      r0,[r4,#0x10]
000026  b108              CBZ      r0,|L32.44|
000028  6960              LDR      r0,[r4,#0x14]
00002a  b918              CBNZ     r0,|L32.52|
                  |L32.44|
;;;873                    ((handle->transfer.rxData) && (handle->transfer.rxSize)))
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  b120              CBZ      r0,|L32.58|
000030  69a0              LDR      r0,[r4,#0x18]
000032  b110              CBZ      r0,|L32.58|
                  |L32.52|
;;;874                {
;;;875                    handle->isBusy = true;
000034  2001              MOVS     r0,#1
000036  f8840024          STRB     r0,[r4,#0x24]
                  |L32.58|
;;;876                }
;;;877            }
;;;878    
;;;879            /* Clear the transferred count now that we have a new buffer. */
;;;880            if ((event == kI2C_SlaveReceiveEvent) || (event == kI2C_SlaveTransmitEvent))
00003a  2d04              CMP      r5,#4
00003c  d001              BEQ      |L32.66|
00003e  2d02              CMP      r5,#2
000040  d101              BNE      |L32.70|
                  |L32.66|
;;;881            {
;;;882                handle->transfer.transferredCount = 0;
000042  2000              MOVS     r0,#0
000044  61e0              STR      r0,[r4,#0x1c]
                  |L32.70|
;;;883            }
;;;884        }
;;;885    }
000046  bd70              POP      {r4-r6,pc}
;;;886    
                          ENDP


                          AREA ||i.I2C_SlavePollPending||, CODE, READONLY, ALIGN=1

                  I2C_SlavePollPending PROC
;;;839     */
;;;840    static uint32_t I2C_SlavePollPending(I2C_Type *base)
000000  4601              MOV      r1,r0
;;;841    {
;;;842        uint32_t stat;
;;;843    
;;;844        do
000002  bf00              NOP      
                  |L33.4|
;;;845        {
;;;846            stat = base->STAT;
000004  f8d10804          LDR      r0,[r1,#0x804]
;;;847        } while (0u == (stat & I2C_STAT_SLVPENDING_MASK));
000008  f4007280          AND      r2,r0,#0x100
00000c  2a00              CMP      r2,#0
00000e  d0f9              BEQ      |L33.4|
;;;848    
;;;849        return stat;
;;;850    }
000010  4770              BX       lr
;;;851    
                          ENDP


                          AREA ||i.I2C_SlaveReadBlocking||, CODE, READONLY, ALIGN=1

                  I2C_SlaveReadBlocking PROC
;;;1152   
;;;1153   status_t I2C_SlaveReadBlocking(I2C_Type *base, uint8_t *rxBuff, size_t rxSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1154   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1155       uint8_t *buf = rxBuff;
00000a  46ba              MOV      r10,r7
;;;1156       uint32_t stat;
;;;1157       bool slaveAddress;
;;;1158       bool slaveReceive;
;;;1159   
;;;1160       /* Set the SLVEN bit to 1 in the CFG register. */
;;;1161       I2C_SlaveEnable(base, true);
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_SlaveEnable
;;;1162   
;;;1163       /* wait for SLVPENDING */
;;;1164       stat = I2C_SlavePollPending(base);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       I2C_SlavePollPending
00001a  4606              MOV      r6,r0
;;;1165   
;;;1166       /* Get slave machine state */
;;;1167       slaveAddress = (((stat & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_ADDR);
00001c  f3c62041          UBFX     r0,r6,#9,#2
000020  b908              CBNZ     r0,|L34.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L34.40|
                  |L34.38|
000026  2000              MOVS     r0,#0
                  |L34.40|
000028  4680              MOV      r8,r0
;;;1168       slaveReceive = (((stat & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_RX);
00002a  f3c62041          UBFX     r0,r6,#9,#2
00002e  2801              CMP      r0,#1
000030  d100              BNE      |L34.52|
000032  e000              B        |L34.54|
                  |L34.52|
000034  2000              MOVS     r0,#0
                  |L34.54|
000036  4681              MOV      r9,r0
;;;1169   
;;;1170       /* in I2C_SlaveReceive() it shall be either slaveAddress or slaveReceive */
;;;1171       if (!(slaveAddress || slaveReceive))
000038  f1b80f00          CMP      r8,#0
00003c  d108              BNE      |L34.80|
00003e  f1b90f00          CMP      r9,#0
000042  d105              BNE      |L34.80|
;;;1172       {
;;;1173           I2C_SlaveInternalStateMachineReset(base);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       I2C_SlaveInternalStateMachineReset
;;;1174           return kStatus_Fail;
00004a  2001              MOVS     r0,#1
                  |L34.76|
;;;1175       }
;;;1176   
;;;1177       if (slaveAddress)
;;;1178       {
;;;1179           /* Acknowledge (ack) the address by setting SLVCONTINUE = 1 in the slave control register */
;;;1180           base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
;;;1181   
;;;1182           /* wait for SLVPENDING */
;;;1183           stat = I2C_SlavePollPending(base);
;;;1184       }
;;;1185   
;;;1186       /* receive bytes up to rxSize */
;;;1187       while (rxSize)
;;;1188       {
;;;1189           slaveReceive = (((stat & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_RX);
;;;1190   
;;;1191           if (!slaveReceive)
;;;1192           {
;;;1193               I2C_SlaveInternalStateMachineReset(base);
;;;1194               return kStatus_Fail;
;;;1195           }
;;;1196   
;;;1197           /* Read 8 bits of data from the SLVDAT register */
;;;1198           *buf = (uint8_t)base->SLVDAT;
;;;1199   
;;;1200           /* continue transaction */
;;;1201           base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
;;;1202   
;;;1203           /* advance counters and pointers for next data */
;;;1204           buf++;
;;;1205           rxSize--;
;;;1206   
;;;1207           if (rxSize)
;;;1208           {
;;;1209               /* wait for SLVPENDING */
;;;1210               stat = I2C_SlavePollPending(base);
;;;1211           }
;;;1212       }
;;;1213   
;;;1214       return kStatus_Success;
;;;1215   }
00004c  e8bd87f0          POP      {r4-r10,pc}
                  |L34.80|
000050  f1b80f00          CMP      r8,#0                 ;1177
000054  d006              BEQ      |L34.100|
000056  2001              MOVS     r0,#1                 ;1180
000058  f8c40840          STR      r0,[r4,#0x840]        ;1180
00005c  4620              MOV      r0,r4                 ;1183
00005e  f7fffffe          BL       I2C_SlavePollPending
000062  4606              MOV      r6,r0                 ;1183
                  |L34.100|
000064  e01d              B        |L34.162|
                  |L34.102|
000066  f3c62041          UBFX     r0,r6,#9,#2           ;1189
00006a  2801              CMP      r0,#1                 ;1189
00006c  d100              BNE      |L34.112|
00006e  e000              B        |L34.114|
                  |L34.112|
000070  2000              MOVS     r0,#0                 ;1189
                  |L34.114|
000072  4681              MOV      r9,r0                 ;1189
000074  f1b90f00          CMP      r9,#0                 ;1191
000078  d104              BNE      |L34.132|
00007a  4620              MOV      r0,r4                 ;1193
00007c  f7fffffe          BL       I2C_SlaveInternalStateMachineReset
000080  2001              MOVS     r0,#1                 ;1194
000082  e7e3              B        |L34.76|
                  |L34.132|
000084  f8d40844          LDR      r0,[r4,#0x844]        ;1198
000088  f88a0000          STRB     r0,[r10,#0]           ;1198
00008c  2001              MOVS     r0,#1                 ;1201
00008e  f8c40840          STR      r0,[r4,#0x840]        ;1201
000092  f10a0a01          ADD      r10,r10,#1            ;1204
000096  1e6d              SUBS     r5,r5,#1              ;1205
000098  b11d              CBZ      r5,|L34.162|
00009a  4620              MOV      r0,r4                 ;1210
00009c  f7fffffe          BL       I2C_SlavePollPending
0000a0  4606              MOV      r6,r0                 ;1210
                  |L34.162|
0000a2  2d00              CMP      r5,#0                 ;1187
0000a4  d1df              BNE      |L34.102|
0000a6  2000              MOVS     r0,#0                 ;1214
0000a8  e7d0              B        |L34.76|
;;;1216   
                          ENDP


                          AREA ||i.I2C_SlaveSetAddress||, CODE, READONLY, ALIGN=1

                  I2C_SlaveSetAddress PROC
;;;1024   
;;;1025   void I2C_SlaveSetAddress(I2C_Type *base,
000000  b530              PUSH     {r4,r5,lr}
;;;1026                            i2c_slave_address_register_t addressRegister,
;;;1027                            uint8_t address,
;;;1028                            bool addressDisable)
;;;1029   {
;;;1030       base->SLVADR[addressRegister] = I2C_SLVADR_SLVADR(address) | I2C_SLVADR_SADISABLE(addressDisable);
000002  24fe              MOVS     r4,#0xfe
000004  ea040442          AND      r4,r4,r2,LSL #1
000008  f0030501          AND      r5,r3,#1
00000c  432c              ORRS     r4,r4,r5
00000e  f6000548          ADD      r5,r0,#0x848
000012  f8454021          STR      r4,[r5,r1,LSL #2]
;;;1031   }
000016  bd30              POP      {r4,r5,pc}
;;;1032   
                          ENDP


                          AREA ||i.I2C_SlaveSetReceiveBuffer||, CODE, READONLY, ALIGN=1

                  I2C_SlaveSetReceiveBuffer PROC
;;;1018   
;;;1019   status_t I2C_SlaveSetReceiveBuffer(
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1020       I2C_Type *base, volatile i2c_slave_transfer_t *transfer, void *rxData, size_t rxSize, uint32_t eventMask)
;;;1021   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;1022       return I2C_SlaveTransferNonBlockingInternal(base, transfer->handle, NULL, 0u, rxData, rxSize, eventMask);
000010  e88d0160          STM      sp,{r5,r6,r8}
000014  6821              LDR      r1,[r4,#0]
000016  2300              MOVS     r3,#0
000018  461a              MOV      r2,r3
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       I2C_SlaveTransferNonBlockingInternal
;;;1023   }
000020  e8bd83fe          POP      {r1-r9,pc}
;;;1024   
                          ENDP


                          AREA ||i.I2C_SlaveSetSendBuffer||, CODE, READONLY, ALIGN=1

                  I2C_SlaveSetSendBuffer PROC
;;;1012   
;;;1013   status_t I2C_SlaveSetSendBuffer(
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1014       I2C_Type *base, volatile i2c_slave_transfer_t *transfer, const void *txData, size_t txSize, uint32_t eventMask)
;;;1015   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;1016       return I2C_SlaveTransferNonBlockingInternal(base, transfer->handle, txData, txSize, NULL, 0u, eventMask);
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  e9cd0801          STRD     r0,r8,[sp,#4]
000018  6821              LDR      r1,[r4,#0]
00001a  463b              MOV      r3,r7
00001c  4632              MOV      r2,r6
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       I2C_SlaveTransferNonBlockingInternal
;;;1017   }
000024  e8bd83fe          POP      {r1-r9,pc}
;;;1018   
                          ENDP


                          AREA ||i.I2C_SlaveTransferAbort||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransferAbort PROC
;;;1275   
;;;1276   void I2C_SlaveTransferAbort(I2C_Type *base, i2c_slave_handle_t *handle)
000000  b570              PUSH     {r4-r6,lr}
;;;1277   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1278       /* Disable I2C IRQ sources while we configure stuff. */
;;;1279       I2C_DisableInterrupts(base, kI2C_SlaveIrqFlags);
000006  f44f4101          MOV      r1,#0x8100
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       I2C_DisableInterrupts
;;;1280   
;;;1281       /* Set the SLVEN bit to 0 in the CFG register. */
;;;1282       I2C_SlaveEnable(base, false);
000010  2100              MOVS     r1,#0
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       I2C_SlaveEnable
;;;1283   
;;;1284       handle->isBusy = false;
000018  2000              MOVS     r0,#0
00001a  f8840024          STRB     r0,[r4,#0x24]
;;;1285       handle->transfer.txSize = 0;
00001e  6160              STR      r0,[r4,#0x14]
;;;1286       handle->transfer.rxSize = 0;
000020  61a0              STR      r0,[r4,#0x18]
;;;1287   }
000022  bd70              POP      {r4-r6,pc}
;;;1288   
                          ENDP


                          AREA ||i.I2C_SlaveTransferCreateHandle||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferCreateHandle PROC
;;;1216   
;;;1217   void I2C_SlaveTransferCreateHandle(I2C_Type *base,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1218                                      i2c_slave_handle_t *handle,
;;;1219                                      i2c_slave_transfer_callback_t callback,
;;;1220                                      void *userData)
;;;1221   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;1222       uint32_t instance;
;;;1223   
;;;1224       assert(handle);
00000c  b104              CBZ      r4,|L39.16|
00000e  e005              B        |L39.28|
                  |L39.16|
000010  f44f6299          MOV      r2,#0x4c8
000014  a110              ADR      r1,|L39.88|
000016  a016              ADR      r0,|L39.112|
000018  f7fffffe          BL       __aeabi_assert
                  |L39.28|
;;;1225   
;;;1226       /* Clear out the handle. */
;;;1227       memset(handle, 0, sizeof(*handle));
00001c  2130              MOVS     r1,#0x30
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memclr4
;;;1228   
;;;1229       /* Look up instance number */
;;;1230       instance = I2C_GetInstance(base);
000024  4640              MOV      r0,r8
000026  f7fffffe          BL       I2C_GetInstance
00002a  4607              MOV      r7,r0
;;;1231   
;;;1232       /* Save base and instance. */
;;;1233       handle->callback = callback;
00002c  62a5              STR      r5,[r4,#0x28]
;;;1234       handle->userData = userData;
00002e  62e6              STR      r6,[r4,#0x2c]
;;;1235   
;;;1236       /* initialize fsm */
;;;1237       handle->slaveFsm = kI2C_SlaveFsmAddressMatch;
000030  2000              MOVS     r0,#0
000032  f8840025          STRB     r0,[r4,#0x25]
;;;1238   
;;;1239       /* store pointer to handle into transfer struct */
;;;1240       handle->transfer.handle = handle;
000036  6024              STR      r4,[r4,#0]
;;;1241   
;;;1242       FLEXCOMM_SetIRQHandler(base, (flexcomm_irq_handler_t)(uintptr_t)I2C_SlaveTransferHandleIRQ, handle);
000038  4622              MOV      r2,r4
00003a  490f              LDR      r1,|L39.120|
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       FLEXCOMM_SetIRQHandler
;;;1243   
;;;1244       /* Clear internal IRQ enables and enable NVIC IRQ. */
;;;1245       I2C_DisableInterrupts(base, kI2C_SlaveIrqFlags);
000042  f44f4101          MOV      r1,#0x8100
000046  4640              MOV      r0,r8
000048  f7fffffe          BL       I2C_DisableInterrupts
;;;1246       EnableIRQ(s_i2cIRQ[instance]);
00004c  490b              LDR      r1,|L39.124|
00004e  57c8              LDRSB    r0,[r1,r7]
000050  f7fffffe          BL       EnableIRQ
;;;1247   }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;1248   
                          ENDP

                  |L39.88|
000058  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
00005c  44726976
000060  6572735c
000064  66736c5f
000068  6932632e
00006c  6300    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L39.112|
000070  68616e64          DCB      "handle",0
000074  6c6500  
000077  00                DCB      0
                  |L39.120|
                          DCD      I2C_SlaveTransferHandleIRQ
                  |L39.124|
                          DCD      s_i2cIRQ

                          AREA ||i.I2C_SlaveTransferGetCount||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferGetCount PROC
;;;1253   
;;;1254   status_t I2C_SlaveTransferGetCount(I2C_Type *base, i2c_slave_handle_t *handle, size_t *count)
000000  b570              PUSH     {r4-r6,lr}
;;;1255   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1256       assert(handle);
000008  b104              CBZ      r4,|L40.12|
00000a  e005              B        |L40.24|
                  |L40.12|
00000c  f44f629d          MOV      r2,#0x4e8
000010  a108              ADR      r1,|L40.52|
000012  a00e              ADR      r0,|L40.76|
000014  f7fffffe          BL       __aeabi_assert
                  |L40.24|
;;;1257   
;;;1258       if (!count)
000018  b90d              CBNZ     r5,|L40.30|
;;;1259       {
;;;1260           return kStatus_InvalidArgument;
00001a  2004              MOVS     r0,#4
                  |L40.28|
;;;1261       }
;;;1262   
;;;1263       /* Catch when there is not an active transfer. */
;;;1264       if (!handle->isBusy)
;;;1265       {
;;;1266           *count = 0;
;;;1267           return kStatus_NoTransferInProgress;
;;;1268       }
;;;1269   
;;;1270       /* For an active transfer, just return the count from the handle. */
;;;1271       *count = handle->transfer.transferredCount;
;;;1272   
;;;1273       return kStatus_Success;
;;;1274   }
00001c  bd70              POP      {r4-r6,pc}
                  |L40.30|
00001e  f8940024          LDRB     r0,[r4,#0x24]         ;1264
000022  b918              CBNZ     r0,|L40.44|
000024  2000              MOVS     r0,#0                 ;1266
000026  6028              STR      r0,[r5,#0]            ;1266
000028  2006              MOVS     r0,#6                 ;1267
00002a  e7f7              B        |L40.28|
                  |L40.44|
00002c  69e0              LDR      r0,[r4,#0x1c]         ;1271
00002e  6028              STR      r0,[r5,#0]            ;1271
000030  2000              MOVS     r0,#0                 ;1273
000032  e7f3              B        |L40.28|
;;;1275   
                          ENDP

                  |L40.52|
000034  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
000038  44726976
00003c  6572735c
000040  66736c5f
000044  6932632e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L40.76|
00004c  68616e64          DCB      "handle",0
000050  6c6500  
000053  00                DCB      0

                          AREA ||i.I2C_SlaveTransferHandleIRQ||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransferHandleIRQ PROC
;;;1288   
;;;1289   void I2C_SlaveTransferHandleIRQ(I2C_Type *base, i2c_slave_handle_t *handle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1290   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1291       uint32_t i2cStatus = base->STAT;
000008  f8d56804          LDR      r6,[r5,#0x804]
;;;1292   
;;;1293       if (i2cStatus & I2C_STAT_SLVDESEL_MASK)
00000c  f4064000          AND      r0,r6,#0x8000
000010  b160              CBZ      r0,|L41.44|
;;;1294       {
;;;1295           I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveDeselectedEvent);
000012  2240              MOVS     r2,#0x40
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       I2C_SlaveInvokeEvent
;;;1296           I2C_SlaveClearStatusFlags(base, I2C_STAT_SLVDESEL_MASK);
00001c  f44f4000          MOV      r0,#0x8000
000020  f4004100          AND      r1,r0,#0x8000
000024  f8c51804          STR      r1,[r5,#0x804]
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L41.44|
;;;1297       }
;;;1298   
;;;1299       /* SLVPENDING flag is cleared by writing I2C_SLVCTL_SLVCONTINUE_MASK to SLVCTL register */
;;;1300       if (i2cStatus & I2C_STAT_SLVPENDING_MASK)
00002c  f4067080          AND      r0,r6,#0x100
000030  2800              CMP      r0,#0
000032  d07d              BEQ      |L41.304|
;;;1301       {
;;;1302           bool slaveAddress = (((i2cStatus & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_ADDR);
000034  f3c62041          UBFX     r0,r6,#9,#2
000038  b908              CBNZ     r0,|L41.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L41.64|
                  |L41.62|
00003e  2000              MOVS     r0,#0
                  |L41.64|
000040  4607              MOV      r7,r0
;;;1303   
;;;1304           if (slaveAddress)
000042  b14f              CBZ      r7,|L41.88|
;;;1305           {
;;;1306               I2C_SlaveAddressIRQ(base, handle);
000044  4621              MOV      r1,r4
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       I2C_SlaveAddressIRQ
;;;1307               I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveAddressMatchEvent);
00004c  2201              MOVS     r2,#1
00004e  4621              MOV      r1,r4
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       I2C_SlaveInvokeEvent
000056  e07c              B        |L41.338|
                  |L41.88|
;;;1308           }
;;;1309           else
;;;1310           {
;;;1311               switch (handle->slaveFsm)
000058  f8940025          LDRB     r0,[r4,#0x25]
00005c  2802              CMP      r0,#2
00005e  d002              BEQ      |L41.102|
000060  2803              CMP      r0,#3
000062  d174              BNE      |L41.334|
000064  e037              B        |L41.214|
                  |L41.102|
;;;1312               {
;;;1313                   case kI2C_SlaveFsmReceive:
;;;1314                   {
;;;1315                       bool slaveReceive =
000066  f3c62041          UBFX     r0,r6,#9,#2
00006a  2801              CMP      r0,#1
00006c  d100              BNE      |L41.112|
00006e  e000              B        |L41.114|
                  |L41.112|
000070  2000              MOVS     r0,#0
                  |L41.114|
000072  4680              MOV      r8,r0
;;;1316                           (((i2cStatus & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_RX);
;;;1317   
;;;1318                       if (slaveReceive)
000074  f1b80f00          CMP      r8,#0
000078  d029              BEQ      |L41.206|
;;;1319                       {
;;;1320                           /* if we have no receive buffer in this transfer, call callback to get new */
;;;1321                           if ((handle->transfer.rxData == NULL) || (handle->transfer.rxSize == 0))
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  b108              CBZ      r0,|L41.130|
00007e  69a0              LDR      r0,[r4,#0x18]
000080  b920              CBNZ     r0,|L41.140|
                  |L41.130|
;;;1322                           {
;;;1323                               I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveReceiveEvent);
000082  2204              MOVS     r2,#4
000084  4621              MOV      r1,r4
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       I2C_SlaveInvokeEvent
                  |L41.140|
;;;1324                           }
;;;1325   
;;;1326                           /* receive a byte */
;;;1327                           if ((handle->transfer.rxData) && (handle->transfer.rxSize))
00008c  68e0              LDR      r0,[r4,#0xc]
00008e  b188              CBZ      r0,|L41.180|
000090  69a0              LDR      r0,[r4,#0x18]
000092  b178              CBZ      r0,|L41.180|
;;;1328                           {
;;;1329                               *(handle->transfer.rxData) = (uint8_t)base->SLVDAT;
000094  f8d50844          LDR      r0,[r5,#0x844]
000098  68e1              LDR      r1,[r4,#0xc]
00009a  7008              STRB     r0,[r1,#0]
;;;1330                               (handle->transfer.rxSize)--;
00009c  69a0              LDR      r0,[r4,#0x18]
00009e  1e40              SUBS     r0,r0,#1
0000a0  61a0              STR      r0,[r4,#0x18]
;;;1331                               (handle->transfer.rxData)++;
0000a2  68e0              LDR      r0,[r4,#0xc]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  60e0              STR      r0,[r4,#0xc]
;;;1332                               (handle->transfer.transferredCount)++;
0000a8  69e0              LDR      r0,[r4,#0x1c]
0000aa  1c40              ADDS     r0,r0,#1
0000ac  61e0              STR      r0,[r4,#0x1c]
;;;1333   
;;;1334                               /* continue transaction */
;;;1335                               base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
0000ae  2001              MOVS     r0,#1
0000b0  f8c50840          STR      r0,[r5,#0x840]
                  |L41.180|
;;;1336                           }
;;;1337   
;;;1338                           /* is this last transaction for this transfer? allow next transaction */
;;;1339                           if ((0 == handle->transfer.rxSize) && (0 == handle->transfer.txSize))
0000b4  69a0              LDR      r0,[r4,#0x18]
0000b6  b968              CBNZ     r0,|L41.212|
0000b8  6960              LDR      r0,[r4,#0x14]
0000ba  b958              CBNZ     r0,|L41.212|
;;;1340                           {
;;;1341                               handle->isBusy = false;
0000bc  2000              MOVS     r0,#0
0000be  f8840024          STRB     r0,[r4,#0x24]
;;;1342                               I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveCompletionEvent);
0000c2  2220              MOVS     r2,#0x20
0000c4  4621              MOV      r1,r4
0000c6  4628              MOV      r0,r5
0000c8  f7fffffe          BL       I2C_SlaveInvokeEvent
0000cc  e002              B        |L41.212|
                  |L41.206|
;;;1343                           }
;;;1344                       }
;;;1345                       else
;;;1346                       {
;;;1347                           base->SLVCTL = I2C_SLVCTL_SLVNACK_MASK;
0000ce  2002              MOVS     r0,#2
0000d0  f8c50840          STR      r0,[r5,#0x840]
                  |L41.212|
;;;1348                       }
;;;1349                   }
;;;1350                   break;
0000d4  e03c              B        |L41.336|
                  |L41.214|
;;;1351   
;;;1352                   case kI2C_SlaveFsmTransmit:
;;;1353                   {
;;;1354                       bool slaveTransmit =
0000d6  f3c62041          UBFX     r0,r6,#9,#2
0000da  2802              CMP      r0,#2
0000dc  d101              BNE      |L41.226|
0000de  2001              MOVS     r0,#1
0000e0  e000              B        |L41.228|
                  |L41.226|
0000e2  2000              MOVS     r0,#0
                  |L41.228|
0000e4  4680              MOV      r8,r0
;;;1355                           (((i2cStatus & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_TX);
;;;1356   
;;;1357                       if (slaveTransmit)
0000e6  f1b80f00          CMP      r8,#0
0000ea  d02c              BEQ      |L41.326|
;;;1358                       {
;;;1359                           /* if we have no data in this transfer, call callback to get new */
;;;1360                           if ((handle->transfer.txData == NULL) || (handle->transfer.txSize == 0))
0000ec  6920              LDR      r0,[r4,#0x10]
0000ee  b108              CBZ      r0,|L41.244|
0000f0  6960              LDR      r0,[r4,#0x14]
0000f2  b920              CBNZ     r0,|L41.254|
                  |L41.244|
;;;1361                           {
;;;1362                               I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveTransmitEvent);
0000f4  2202              MOVS     r2,#2
0000f6  4621              MOV      r1,r4
0000f8  4628              MOV      r0,r5
0000fa  f7fffffe          BL       I2C_SlaveInvokeEvent
                  |L41.254|
;;;1363                           }
;;;1364   
;;;1365                           /* transmit a byte */
;;;1366                           if ((handle->transfer.txData) && (handle->transfer.txSize))
0000fe  6920              LDR      r0,[r4,#0x10]
000100  b188              CBZ      r0,|L41.294|
000102  6960              LDR      r0,[r4,#0x14]
000104  b178              CBZ      r0,|L41.294|
;;;1367                           {
;;;1368                               base->SLVDAT = *(handle->transfer.txData);
000106  6920              LDR      r0,[r4,#0x10]
000108  7800              LDRB     r0,[r0,#0]
00010a  f8c50844          STR      r0,[r5,#0x844]
;;;1369                               (handle->transfer.txSize)--;
00010e  6960              LDR      r0,[r4,#0x14]
000110  1e40              SUBS     r0,r0,#1
000112  6160              STR      r0,[r4,#0x14]
;;;1370                               (handle->transfer.txData)++;
000114  6920              LDR      r0,[r4,#0x10]
000116  1c40              ADDS     r0,r0,#1
000118  6120              STR      r0,[r4,#0x10]
;;;1371                               (handle->transfer.transferredCount)++;
00011a  69e0              LDR      r0,[r4,#0x1c]
00011c  1c40              ADDS     r0,r0,#1
00011e  61e0              STR      r0,[r4,#0x1c]
;;;1372   
;;;1373                               /* continue transaction */
;;;1374                               base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
000120  2001              MOVS     r0,#1
000122  f8c50840          STR      r0,[r5,#0x840]
                  |L41.294|
;;;1375                           }
;;;1376   
;;;1377                           /* is this last transaction for this transfer? allow next transaction */
;;;1378                           if ((0 == handle->transfer.rxSize) && (0 == handle->transfer.txSize))
000126  69a0              LDR      r0,[r4,#0x18]
000128  b980              CBNZ     r0,|L41.332|
00012a  6960              LDR      r0,[r4,#0x14]
00012c  b970              CBNZ     r0,|L41.332|
;;;1379                           {
;;;1380                               handle->isBusy = false;
00012e  e001              B        |L41.308|
                  |L41.304|
000130  e010              B        |L41.340|
000132  e00c              B        |L41.334|
                  |L41.308|
000134  2000              MOVS     r0,#0
000136  f8840024          STRB     r0,[r4,#0x24]
;;;1381                               I2C_SlaveInvokeEvent(base, handle, kI2C_SlaveCompletionEvent);
00013a  2220              MOVS     r2,#0x20
00013c  4621              MOV      r1,r4
00013e  4628              MOV      r0,r5
000140  f7fffffe          BL       I2C_SlaveInvokeEvent
000144  e002              B        |L41.332|
                  |L41.326|
;;;1382                           }
;;;1383                       }
;;;1384                       else
;;;1385                       {
;;;1386                           base->SLVCTL = I2C_SLVCTL_SLVNACK_MASK;
000146  2002              MOVS     r0,#2
000148  f8c50840          STR      r0,[r5,#0x840]
                  |L41.332|
;;;1387                       }
;;;1388                   }
;;;1389                   break;
00014c  e000              B        |L41.336|
                  |L41.334|
;;;1390   
;;;1391                   default:
;;;1392                       /* incorrect state, slv_abort()? */
;;;1393                       break;
00014e  bf00              NOP      
                  |L41.336|
000150  bf00              NOP                            ;1350
                  |L41.338|
;;;1394               }
;;;1395           }
;;;1396       }
000152  bf00              NOP      
                  |L41.340|
;;;1397   }
000154  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.I2C_SlaveTransferNonBlocking||, CODE, READONLY, ALIGN=1

                  I2C_SlaveTransferNonBlocking PROC
;;;1248   
;;;1249   status_t I2C_SlaveTransferNonBlocking(I2C_Type *base, i2c_slave_handle_t *handle, uint32_t eventMask)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1250   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1251       return I2C_SlaveTransferNonBlockingInternal(base, handle, NULL, 0u, NULL, 0u, eventMask);
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4603              MOV      r3,r0
00000e  4602              MOV      r2,r0
000010  4631              MOV      r1,r6
000012  e9cd0401          STRD     r0,r4,[sp,#4]
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       I2C_SlaveTransferNonBlockingInternal
;;;1252   }
00001c  bdfe              POP      {r1-r7,pc}
;;;1253   
                          ENDP


                          AREA ||i.I2C_SlaveTransferNonBlockingInternal||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferNonBlockingInternal PROC
;;;968     */
;;;969    static status_t I2C_SlaveTransferNonBlockingInternal(I2C_Type *base,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;970                                                         i2c_slave_handle_t *handle,
;;;971                                                         const void *txData,
;;;972                                                         size_t txSize,
;;;973                                                         void *rxData,
;;;974                                                         size_t rxSize,
;;;975                                                         uint32_t eventMask)
;;;976    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
;;;977        status_t status;
;;;978    
;;;979        assert(handle);
000014  b104              CBZ      r4,|L43.24|
000016  e005              B        |L43.36|
                  |L43.24|
000018  f24032d3          MOV      r2,#0x3d3
00001c  a116              ADR      r1,|L43.120|
00001e  a01c              ADR      r0,|L43.144|
000020  f7fffffe          BL       __aeabi_assert
                  |L43.36|
;;;980    
;;;981        status = kStatus_Success;
000024  f04f0800          MOV      r8,#0
;;;982    
;;;983        /* Disable I2C IRQ sources while we configure stuff. */
;;;984        I2C_DisableInterrupts(base, kI2C_SlaveIrqFlags);
000028  f44f4101          MOV      r1,#0x8100
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       I2C_DisableInterrupts
;;;985    
;;;986        /* Return busy if another transaction is in progress. */
;;;987        if (handle->isBusy)
000032  f8940024          LDRB     r0,[r4,#0x24]
000036  b108              CBZ      r0,|L43.60|
;;;988        {
;;;989            status = kStatus_I2C_Busy;
000038  f6402828          MOV      r8,#0xa28
                  |L43.60|
;;;990        }
;;;991    
;;;992        /* Save transfer into handle. */
;;;993        handle->transfer.txData = (const uint8_t *)(uintptr_t)txData;
00003c  6126              STR      r6,[r4,#0x10]
;;;994        handle->transfer.txSize = txSize;
00003e  6167              STR      r7,[r4,#0x14]
;;;995        handle->transfer.rxData = (uint8_t *)rxData;
000040  f8c4900c          STR      r9,[r4,#0xc]
;;;996        handle->transfer.rxSize = rxSize;
000044  f8c4a018          STR      r10,[r4,#0x18]
;;;997        handle->transfer.transferredCount = 0;
000048  2000              MOVS     r0,#0
00004a  61e0              STR      r0,[r4,#0x1c]
;;;998        handle->transfer.eventMask = eventMask | kI2C_SlaveTransmitEvent | kI2C_SlaveReceiveEvent;
00004c  f04b0006          ORR      r0,r11,#6
000050  60a0              STR      r0,[r4,#8]
;;;999        handle->isBusy = true;
000052  2001              MOVS     r0,#1
000054  f8840024          STRB     r0,[r4,#0x24]
;;;1000   
;;;1001       /* Set the SLVEN bit to 1 in the CFG register. */
;;;1002       I2C_SlaveEnable(base, true);
000058  2101              MOVS     r1,#1
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       I2C_SlaveEnable
;;;1003   
;;;1004       /* Clear w1c flags. */
;;;1005       base->STAT |= 0u;
000060  f8d50804          LDR      r0,[r5,#0x804]
000064  f8c50804          STR      r0,[r5,#0x804]
;;;1006   
;;;1007       /* Enable I2C internal IRQ sources. */
;;;1008       I2C_EnableInterrupts(base, kI2C_SlaveIrqFlags);
000068  f44f4101          MOV      r1,#0x8100
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       I2C_EnableInterrupts
;;;1009   
;;;1010       return status;
000072  4640              MOV      r0,r8
;;;1011   }
000074  e8bd9ff0          POP      {r4-r12,pc}
;;;1012   
                          ENDP

                  |L43.120|
000078  5352435c          DCB      "SRC\\Drivers\\fsl_i2c.c",0
00007c  44726976
000080  6572735c
000084  66736c5f
000088  6932632e
00008c  6300    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L43.144|
000090  68616e64          DCB      "handle",0
000094  6c6500  
000097  00                DCB      0

                          AREA ||i.I2C_SlaveWriteBlocking||, CODE, READONLY, ALIGN=1

                  I2C_SlaveWriteBlocking PROC
;;;1088   
;;;1089   status_t I2C_SlaveWriteBlocking(I2C_Type *base, const uint8_t *txBuff, size_t txSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1090   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1091       const uint8_t *buf = txBuff;
00000a  46ba              MOV      r10,r7
;;;1092       uint32_t stat;
;;;1093       bool slaveAddress;
;;;1094       bool slaveTransmit;
;;;1095   
;;;1096       /* Set the SLVEN bit to 1 in the CFG register. */
;;;1097       I2C_SlaveEnable(base, true);
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_SlaveEnable
;;;1098   
;;;1099       /* wait for SLVPENDING */
;;;1100       stat = I2C_SlavePollPending(base);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       I2C_SlavePollPending
00001a  4606              MOV      r6,r0
;;;1101   
;;;1102       /* Get slave machine state */
;;;1103       slaveAddress = (((stat & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_ADDR);
00001c  f3c62041          UBFX     r0,r6,#9,#2
000020  b908              CBNZ     r0,|L44.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L44.40|
                  |L44.38|
000026  2000              MOVS     r0,#0
                  |L44.40|
000028  4680              MOV      r8,r0
;;;1104       slaveTransmit = (((stat & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_TX);
00002a  f3c62041          UBFX     r0,r6,#9,#2
00002e  2802              CMP      r0,#2
000030  d101              BNE      |L44.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L44.56|
                  |L44.54|
000036  2000              MOVS     r0,#0
                  |L44.56|
000038  4681              MOV      r9,r0
;;;1105   
;;;1106       /* in I2C_SlaveSend() it shall be either slaveAddress or slaveTransmit */
;;;1107       if (!(slaveAddress || slaveTransmit))
00003a  f1b80f00          CMP      r8,#0
00003e  d108              BNE      |L44.82|
000040  f1b90f00          CMP      r9,#0
000044  d105              BNE      |L44.82|
;;;1108       {
;;;1109           I2C_SlaveInternalStateMachineReset(base);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       I2C_SlaveInternalStateMachineReset
;;;1110           return kStatus_Fail;
00004c  2001              MOVS     r0,#1
                  |L44.78|
;;;1111       }
;;;1112   
;;;1113       if (slaveAddress)
;;;1114       {
;;;1115           /* Acknowledge (ack) the address by setting SLVCONTINUE = 1 in the slave control register */
;;;1116           base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
;;;1117   
;;;1118           /* wait for SLVPENDING */
;;;1119           stat = I2C_SlavePollPending(base);
;;;1120       }
;;;1121   
;;;1122       /* send bytes up to txSize */
;;;1123       while (txSize)
;;;1124       {
;;;1125           slaveTransmit = (((stat & I2C_STAT_SLVSTATE_MASK) >> I2C_STAT_SLVSTATE_SHIFT) == I2C_STAT_SLVST_TX);
;;;1126   
;;;1127           if (!slaveTransmit)
;;;1128           {
;;;1129               I2C_SlaveInternalStateMachineReset(base);
;;;1130               return kStatus_Fail;
;;;1131           }
;;;1132   
;;;1133           /* Write 8 bits of data to the SLVDAT register */
;;;1134           base->SLVDAT = I2C_SLVDAT_DATA(*buf);
;;;1135   
;;;1136           /* continue transaction */
;;;1137           base->SLVCTL = I2C_SLVCTL_SLVCONTINUE_MASK;
;;;1138   
;;;1139           /* advance counters and pointers for next data */
;;;1140           buf++;
;;;1141           txSize--;
;;;1142   
;;;1143           if (txSize)
;;;1144           {
;;;1145               /* wait for SLVPENDING */
;;;1146               stat = I2C_SlavePollPending(base);
;;;1147           }
;;;1148       }
;;;1149   
;;;1150       return kStatus_Success;
;;;1151   }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L44.82|
000052  f1b80f00          CMP      r8,#0                 ;1113
000056  d006              BEQ      |L44.102|
000058  2001              MOVS     r0,#1                 ;1116
00005a  f8c40840          STR      r0,[r4,#0x840]        ;1116
00005e  4620              MOV      r0,r4                 ;1119
000060  f7fffffe          BL       I2C_SlavePollPending
000064  4606              MOV      r6,r0                 ;1119
                  |L44.102|
000066  e01e              B        |L44.166|
                  |L44.104|
000068  f3c62041          UBFX     r0,r6,#9,#2           ;1125
00006c  2802              CMP      r0,#2                 ;1125
00006e  d101              BNE      |L44.116|
000070  2001              MOVS     r0,#1                 ;1125
000072  e000              B        |L44.118|
                  |L44.116|
000074  2000              MOVS     r0,#0                 ;1125
                  |L44.118|
000076  4681              MOV      r9,r0                 ;1125
000078  f1b90f00          CMP      r9,#0                 ;1127
00007c  d104              BNE      |L44.136|
00007e  4620              MOV      r0,r4                 ;1129
000080  f7fffffe          BL       I2C_SlaveInternalStateMachineReset
000084  2001              MOVS     r0,#1                 ;1130
000086  e7e2              B        |L44.78|
                  |L44.136|
000088  f89a0000          LDRB     r0,[r10,#0]           ;1134
00008c  f8c40844          STR      r0,[r4,#0x844]        ;1134
000090  2001              MOVS     r0,#1                 ;1137
000092  f8c40840          STR      r0,[r4,#0x840]        ;1137
000096  f10a0a01          ADD      r10,r10,#1            ;1140
00009a  1e6d              SUBS     r5,r5,#1              ;1141
00009c  b11d              CBZ      r5,|L44.166|
00009e  4620              MOV      r0,r4                 ;1146
0000a0  f7fffffe          BL       I2C_SlavePollPending
0000a4  4606              MOV      r6,r0                 ;1146
                  |L44.166|
0000a6  2d00              CMP      r5,#0                 ;1123
0000a8  d1de              BNE      |L44.104|
0000aa  2000              MOVS     r0,#0                 ;1150
0000ac  e7cf              B        |L44.78|
;;;1152   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  s_i2cBaseAddrs
                          DCD      0x40086000
                          DCD      0x40087000
                          DCD      0x40088000
                          DCD      0x40089000
                          DCD      0x4008a000
                          DCD      0x40096000
                          DCD      0x40097000
                          DCD      0x40098000
                          DCD      0x40099000
                          DCD      0x4009a000
                  s_i2cIRQ
000028  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
00002c  12131415          DCB      0x12,0x13,0x14,0x15
000030  2829              DCB      0x28,0x29

;*** Start embedded assembler ***

#line 1 "SRC\\Drivers\\fsl_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_i2c_c_d4dc8a94____REV16|
#line 388 ".\\SRC\\System\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_fsl_i2c_c_d4dc8a94____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_i2c_c_d4dc8a94____REVSH|
#line 402
|__asm___9_fsl_i2c_c_d4dc8a94____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_fsl_i2c_c_d4dc8a94____RRX|
#line 587
|__asm___9_fsl_i2c_c_d4dc8a94____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
